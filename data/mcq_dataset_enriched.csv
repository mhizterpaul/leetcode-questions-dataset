id,question,a,b,c,d,correct,difficulty,category,tags
1,"Two Sum
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. ",Use a brute-force approach with nested loops to check all possible pairs of numbers.,Sort the array and use binary search to find the complement of each number.,Use recursion to explore all possible combinations of numbers.,Iterate through the array and keep track of the minimum difference from the target.,"Use a hash map to store each number and its index, then check if the complement exists in the map.",Easy,algorithms,"Array,Hash Table"
2,"Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. ","Use a hash map to store the digits and their positions, then perform addition based on position values","Recursively add the digits from the head nodes, returning a new list if the result is less than 10","Convert both lists to strings, concatenate them, and convert the resulting string back to a linked list",Subtract the smaller number from the larger and rebuild the smaller number's linked list,"Traverse both lists node-by-node, adding digits with carry, and build a new list for the result",Medium,algorithms,"Linked List,Math,Recursion"
3,"Longest Substring Without Repeating Characters
Given a string s, find the length of the longest substring without duplicate characters. ","Use a sliding window approach, resetting the window start index whenever a repeated character is encountered but only after calculating current substring length.",Sort the string and then iterate through it to find the longest substring.,Generate all possible substrings and check each for repeating characters; return the length of the longest valid substring.,Employ dynamic programming to store lengths of all substrings ending at each index.,"Use a sliding window approach with a hash map (or set) to track characters in the current window, updating the start index when a duplicate is found.",Medium,algorithms,"Hash Table,String,Sliding Window"
4,"Median of Two Sorted Arrays
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). ","Use a hash table to count the frequency of each number, then iterate from smallest to largest to find the median.","Merge the arrays, then calculate the median directly using the length of the merged array. This has O(m+n) time complexity.","Sort both arrays independently using an O(n log n) algorithm, then find the median of the concatenated result.","Perform a linear scan across both arrays simultaneously, tracking elements until the middle is reached.",Use binary search to find the partition points in both arrays such that all elements to the left are smaller than elements to the right.,Hard,algorithms,"Array,Binary Search,Divide and Conquer"
5,"Longest Palindromic Substring
Given a string s, return the longest palindromic substring in s. ",Use dynamic programming with a 2D table storing palindrome information for all substrings,"Employ a recursive approach, checking all possible substrings for palindrome property.",Sort the string and identify common subsequences as potential palindromes.,Reverse the string and find the longest common substring with the original string.,"Apply the expanding center approach, checking for palindromes around each character and pair of characters.",Medium,algorithms,"String,Dynamic Programming"
6,"Zigzag Conversion
The string ""PAYPALISHIRING"" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) And then read line by line: ""PAHNAPLSIIGYIR"" Write the code that will take a string and make this conversion given a number of rows: ",Hash each character based on its row index in the zigzag pattern and then concatenate the hash values.,Sort the string alphabetically and then redistribute characters based on row indices.,Use a matrix to store the zigzag pattern and read the matrix row by row to form the converted string.,Reverse the input string and apply a standard string reversal algorithm.,"Calculate the row index for each character based on the zigzag pattern and append it to the corresponding row string, then concatenate the row strings.",Medium,algorithms,String
7,"Reverse Integer
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). ","Using strings to represent the numbers allows easy reversal, but doesn't address overflow correctly.",Reversing the number by repeatedly dividing by 10 and multiplying by 10 in each step.,Shifting the integer bits to the left and then using bitwise OR to add the last digit.,Using an array to store the reversed digits and then reconstructing the integer.,Repeatedly popping the last digit using the modulo operator and building the reversed integer while checking for overflow before multiplication.,Medium,algorithms,Math
8,"String to Integer (atoi)
Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer. The algorithm for myAtoi(string s) is as follows: Return the integer as the final result. ",Assume all non-numeric characters are valid and should be converted to their ASCII integer representation.,"Ignore leading and trailing whitespaces, but any whitespace in between digits is significant and ends the conversion.","Only positive integers are supported. Negative signs and '+' signs are ignored, and the conversion begins at the first digit encountered.","If the resulting integer is outside the 32-bit signed integer range, return 0.","Read and ignore leading whitespace, handle optional sign, read digits until a non-digit character or end of string is found, and clamp the result to the 32-bit signed integer range.",Medium,algorithms,String
9,"Palindrome Number
Given an integer x, return true if x is a palindrome, and false otherwise. ",Convert the number to a string and check if the reversed string is equal to the original.,"Iterate through half of the number, comparing digits at corresponding positions from the beginning and end, using string conversion.",Use bitwise operations to reverse the number and compare it with the original.,Recursively divide the number by 10 until a single digit is reached and compare with the original number using a global variable.,Reverse the number without using extra space and compare it to the original number.,Easy,algorithms,Math
10,"Regular Expression Matching
Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: The matching should cover the entire input string (not partial). ","Backtracking: Explore all possible matching combinations recursively, pruning branches that don't lead to a full match.",Brute Force: Generate all possible strings from the pattern and compare them against the input string.,"Greedy Matching: At each step, match the longest possible substring allowed by the pattern.",Memoization: Store results of subproblems involving the pattern and input up to certain indices and reuse the values to avoid redundant computation.,"Dynamic Programming: Build a table to store whether substrings of 's' match substrings of 'p', handling base cases and transitions for '.' and '*'.",Hard,algorithms,"String,Dynamic Programming,Recursion"
11,"Container With Most Water
You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. ",Sort the height array and calculate the area using the two tallest lines.,"Calculate the area for every possible pair of lines, keeping track of the maximum.",Start with the widest container and greedily shrink it by removing the taller of the two lines.,Use binary search to find the optimal width and then search for the corresponding heights.,"Use two pointers, one at each end of the array, and move the pointer with the smaller height towards the center.",Medium,algorithms,"Array,Two Pointers,Greedy"
12,"Integer to Roman
Seven different symbols represent Roman numerals with the following values: Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules: Given an integer, convert it to a Roman numeral. ","Using a greedy algorithm, repeatedly subtract the largest possible Roman numeral value until the integer reaches zero.",Decompose the integer into its prime factors and map the primes to Roman numerals.,Recursively divide the integer by 10 and construct the Roman numeral from right to left.,"Convert the integer to binary, then map the binary digits to Roman numerals.","Decompose the integer into thousands, hundreds, tens, and ones, then convert each place value to its Roman numeral equivalent and concatenate the results.",Medium,algorithms,"Hash Table,Math,String"
13,"Roman to Integer
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: Given a roman numeral, convert it to an integer. ",Subtract the current value from the total if the next value is smaller.,"Add the value of each numeral to a running total, ignoring subtractive cases.",Multiply the value of each numeral by its position in the string and sum the results.,Use a lookup table to directly convert the entire Roman numeral string into its integer equivalent.,"Iterate from right to left, adding the current value and subtracting if it's less than the next value.",Easy,algorithms,"Hash Table,Math,String"
17,"Letter Combinations of a Phone Number
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. ",Breadth-first search (BFS),Dynamic programming,Greedy algorithm,Divide and conquer,Depth-first search (DFS) with backtracking,Medium,algorithms,"Hash Table,String,Backtracking"
18,"4Sum
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: You may return the answer in any order. ",Use brute force: iterate through all possible combinations of four numbers.,Sort the array and use three pointers with binary search for the fourth number.,"Create a hash map to store pairs and their sums, then find pairs that add up to the target.",Recursively divide the array into smaller subproblems and combine the results.,Sort the array and use two pointers to reduce the problem to a 2Sum variant.,Medium,algorithms,"Array,Two Pointers,Sorting"
19,"Remove Nth Node From End of List
Given the head of a linked list, remove the nth node from the end of the list and return its head. ",Use one pointer to traverse to the (L-n)th node and delete the next node,Use recursion to find the nth node from the end and modify the links during backtracking,"Store the linked list in an array, remove the element at index (length - n), and rebuild the list","Reverse the linked list, remove the nth node from the beginning, and reverse it back","Use two pointers, one 'n' nodes ahead, to find the (L-n)th node from the beginning",Medium,algorithms,"Linked List,Two Pointers"
20,"Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: ",Strings with mismatched opening and closing brackets are always valid.,The order of brackets doesn't matter as long as the counts are equal.,Use regular expressions to match bracket pairs and recursively remove them.,A valid string must start with an opening bracket and end with a closing bracket.,Use a stack to track opening brackets and verify matching closing brackets in the correct order.,Easy,algorithms,"String,Stack"
21,"Merge Two Sorted Lists
You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. ",Create a new list and alternately insert elements from both lists based on their index parity.,Append list2 to the end of list1 and then sort the resulting list1 in place.,Use a hash table to store the frequency of each value and then reconstruct the sorted list.,Recursively select the largest element from either list and prepend it to the result of merging the remaining portions.,"Iteratively compare the head nodes of both lists, appending the smaller one to the merged list and advancing its pointer.",Easy,data structures,"Linked List,Recursion"
22,"Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. ",Use dynamic programming to build solutions from smaller subproblems by iteratively adding '()' to valid combinations.,"Employ a greedy approach, always adding '(' unless the number of open parentheses equals n, then add ')'.",Generate all possible combinations of '(' and ')' and then validate each one using a stack.,Start with '()' and recursively add either '(' to the beginning or ')' to the end of the string.,"Use backtracking to explore adding '(' or ')' at each step, ensuring the number of open parentheses is always greater than or equal to the number of closed parentheses.",Medium,algorithms,"String,Dynamic Programming,Backtracking"
23,"Merge k Sorted Lists
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. ",Concatenate all lists and then apply a sorting algorithm.,Repeatedly merge pairs of lists until only one list remains.,Push all list elements onto a stack and then pop them off in sorted order.,Only compare the head nodes of the first two lists.,Use a priority queue to keep track of the smallest head node of all lists.,Hard,algorithms,"Linked List,Divide and Conquer,Heap (Priority Queue),Merge Sort"
24,"Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) ","Recursively swap pairs starting from the head, and link the swapped pairs together",Iteratively swap the 'val' attributes of adjacent nodes,"Reverse the entire linked list, then iterate and swap pairs","Store the list in an array, swap elements in the array, and rebuild the linked list",Iteratively swap the 'next' pointers of adjacent nodes by maintaining previous and current pointers,Medium,data structures,"Linked List,Recursion"
25,"Reverse Nodes in k-Group
Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. ","Recursively reverse each k-group, but without checking for sufficient nodes, leading to errors when the list length isn't a multiple of k",Reverse the entire linked list first and then process it in k-sized chunks.,"Iterate through the linked list and store the node values in an array, reverse the array in k-sized chunks and then update the linked list with the new values.",Reverse only the first k nodes and then terminate the process without considering the rest of the list.,"Iteratively reverse each k-sized group of nodes, maintaining pointers to the previous group and the next group, and handling the case where the remaining list has fewer than k nodes.",Hard,algorithms,"Linked List,Recursion"
26,"Remove Duplicates from Sorted Array
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted. ","Create a new array and only add elements that are different from the previous one, using extra space.",Use a hash set to store unique elements and then copy them back to the original array. This may not preserve original order.,"Sort the array first, then iterate through it, removing elements that are equal to their neighbors.","Recursively call a function that removes the duplicate at the current index if it exists, otherwise move to the next index.","Use two pointers, one for iterating and one for tracking the index to place the next unique element.",Easy,algorithms,"Array,Two Pointers"
27,"Remove Element
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted. ","Create a new array, copying elements that are not equal to val",Use a hash map to count the occurrences of each element and reconstruct the array without val,Sort the array and then remove all occurrences of val using binary search,"Replace all occurrences of val with a placeholder value (e.g., -1) and then sort the array","Use the two-pointer technique, one to iterate and another to track the position for elements not equal to val",Easy,algorithms,"Array,Two Pointers"
32,"Longest Valid Parentheses
Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring. ",Recursively check all possible substrings for balanced parentheses.,Use dynamic programming to store the lengths of valid parentheses ending at each index.,"Employ a greedy approach, always selecting the longest possible sequence.",Maintain a counter to track the depth of nesting and reset when an invalid sequence is encountered.,Utilize a stack to track the indices of unmatched opening parentheses.,Hard,algorithms,"String,Dynamic Programming,Stack"
33,"Search in Rotated Sorted Array
There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. ",Linear search the entire array.,Perform binary search directly without considering rotation.,"Find the minimum element, then perform two binary searches.",Split the array into two unsorted sub-arrays and search them separately.,"Find the pivot, then perform binary search in the appropriate sub-array.",Medium,algorithms,"Array,Binary Search"
34,"Find First and Last Position of Element in Sorted Array
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. ",Linear search from the beginning to find the first and from the end to find the last occurrence.,Perform a single binary search and then expand outwards linearly to find the range.,"Use two separate binary searches, one optimized to find the closest smaller element and another for the closest larger element.",Sort the input array and use binary search to find the first and last occurrence.,"Use two binary searches, one to find the first occurrence and another to find the last occurrence.",Medium,algorithms,"Array,Binary Search"
35,"Search Insert Position
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. ",Linear search from the beginning of the array until a larger element is found.,"Check if the target is smaller than the first element or larger than the last, then perform a linear search in the applicable half.",Recursively divide the array in half until the target is found or the base case (single element) is reached.,Iterate through the array using a standard for loop to find the correct position.,Use binary search to find the target or the appropriate insertion point.,Easy,algorithms,"Array,Binary Search"
36,"Valid Sudoku
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Note: ",Check only the 3x3 subgrids to ensure no repeated numbers,"Verify only the rows have unique digits, ignoring columns and subgrids",Confirm that each digit from 1-9 appears exactly 9 times in the whole board,"The board is valid if the sum of each row, column, and subgrid equals 45","Validate that each row, each column, and each 3x3 subgrid contains unique digits from 1-9",Medium,algorithms,"Array,Hash Table,Matrix"
37,"Sudoku Solver
Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: The '.' character indicates empty cells. ",Backtracking is generally inefficient for constraint satisfaction problems like Sudoku.,Use dynamic programming to memoize the solution for subgrids.,Employ a greedy algorithm by filling in the cell with the smallest possible value at each step.,Transform the Sudoku grid into a linear programming problem and solve it using simplex.,Use backtracking with constraint propagation to explore possible solutions and prune invalid branches early.,Hard,algorithms,"Array,Backtracking,Matrix"
38,"Count and Say
The count-and-say sequence is a sequence of digit strings defined by the recursive formula: Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string ""3322251"" we replace ""33"" with ""23"", replace ""222"" with ""32"", replace ""5"" with ""15"" and replace ""1"" with ""11"". Thus the compressed string becomes ""23321511"". Given a positive integer n, return the nth element of the count-and-say sequence. ",Memoization,Greedy Algorithm,Backtracking,Divide and Conquer,Recursion,Medium,algorithms,String
39,"Combination Sum
Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. ",Use dynamic programming with a table storing the minimum number of candidates to reach each sum.,"Sort the candidates array and use a greedy approach, always choosing the largest candidate less than or equal to the remaining target.",Generate all possible subsets of candidates and filter out those that don't sum to the target.,"Iterate through the candidates array linearly, and for each candidate, subtract it from the target until the target is zero.","Use backtracking to explore all possible combinations, pruning branches when the sum exceeds the target.",Medium,algorithms,"Array,Backtracking"
40,"Combination Sum II
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. ","Use dynamic programming with a 2D array to store intermediate results, indexed by current number and remaining target value, without handling duplicates effectively.","Sort the input and use a backtracking approach, including each candidate multiple times until the target is reached or exceeded.","Iterate through all possible subsets of candidates and filter those that sum to the target, without considering duplicate combinations.","Apply a greedy algorithm, always choosing the largest candidate less than or equal to the remaining target value.",Sort the candidates array and use a backtracking approach with pruning to avoid duplicate combinations by skipping over identical consecutive numbers.,Medium,algorithms,"Array,Backtracking"
41,"First Missing Positive
Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space. ",Use a hash table to store all present numbers and then iterate from 1 to find the missing one,"Sort the array and then iterate through it, checking for the first missing positive integer",Recursively search for each positive integer starting from 1,"Replace negative numbers, zeros, and numbers larger than n by 1s. Iterate and use the index as a hash key and number sign as a presence detector.","Rearrange the array such that nums[i] = i+1, then iterate to find the first mismatch.",Hard,algorithms,"Array,Hash Table"
42,"Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. ",Dynamic Programming: Build two arrays representing the highest bar to the left and right for each position.,Divide and Conquer: Recursively split the array and calculate trapped water in subproblems.,Greedy Approach: Iterate and always fill the minimum possible level with water until it's no longer possible.,"Brute Force: For each index, find the maximum height of the left and right sides by iterating through the entire array each time.","Two Pointers: Maintain left and right pointers, moving the smaller one inwards while tracking maximum heights on each side.",Hard,algorithms,"Array,Two Pointers,Dynamic Programming,Stack,Monotonic Stack"
43,"Multiply Strings
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. ",Convert both strings to integers using `parseInt()` and then multiply them,Use dynamic programming to store intermediate products for optimization,Employ the Karatsuba algorithm for faster multiplication of large numbers,"Iterate through each digit of the first string and multiply it by the entire second string, accumulating the results",Simulate manual multiplication by iterating through each digit of both strings and using an array to store intermediate products and carry-overs.,Medium,algorithms,"Math,String,Simulation"
48,"Rotate Image
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ",Transpose the matrix and then reverse each row.,Reverse the order of the rows and then transpose the matrix.,"Create a new matrix and copy elements from the original in rotated order, then copy back.",Iterate through diagonals and swap elements around the center.,"Iterate through layers, swapping elements in a circular manner within each layer.",Medium,algorithms,"Array,Math,Matrix"
49,"Group Anagrams
Given an array of strings strs, group the anagrams together. You can return the answer in any order. ",Sort each string and use the sorted string as a key in a hash map to group anagrams.,Use a trie data structure to store the strings and retrieve anagrams.,Compare each string with every other string in the array to find anagrams.,Create a frequency count array for each string and compare the arrays to group anagrams.,Create a hash map where the key is a character count tuple and the value is a list of anagrams.,Medium,algorithms,"Hash Table,String,Sorting"
50,"Pow(x, n)
Implement pow(x, n), which calculates x raised to the power n (i.e., xn). ","Iteratively multiply x by itself n times, handling negative n with reciprocal",Use logarithms to calculate n * log(x) and then exponentiate the result,Apply dynamic programming to store intermediate powers of x,Employ a naive loop multiplying x by itself n times,Utilize binary exponentiation to recursively calculate the power in O(log n) time,Medium,algorithms,"Math,Recursion"
51,"N-Queens
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. ","Utilize backtracking, pruning branches when a queen attacks another along rows only.","Employ a greedy algorithm, placing queens row by row in the safest available column.",Randomly place queens and iteratively adjust positions until no conflicts remain; repeat until a solution is found or a timeout is reached.,"Place queens using dynamic programming, building up solutions from smaller board sizes.","Employ backtracking, pruning branches when a queen attacks another along rows, columns, or diagonals.",Hard,algorithms,"Array,Backtracking"
52,"N-Queens II
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. ",Use dynamic programming to store intermediate board states and prune search branches.,"Employ a greedy algorithm, placing queens in the most promising positions based on immediate threats.",Generate all possible board configurations and filter out invalid solutions.,Utilize a backtracking algorithm with pruning based on column conflicts only.,"Use a backtracking algorithm, pruning the search space by checking row, column, and diagonal conflicts efficiently.",Hard,algorithms,Backtracking
53,"Maximum Subarray
Given an integer array nums, find the subarray with the largest sum, and return its sum. ",Divide and Conquer,Greedy Algorithm,Dynamic Programming with O(n^2) space,Backtracking,Dynamic Programming with O(1) space (Kadane's Algorithm),Medium,algorithms,"Array,Divide and Conquer,Dynamic Programming"
54,"Spiral Matrix
Given an m x n matrix, return all elements of the matrix in spiral order. ","Simultaneously traverse rows and columns, incrementing indices linearly until all elements are visited.",Recursively extract the outer layers of the matrix and concatenate them until the matrix is empty.,Sort the matrix elements and then arrange them in spiral order.,"Transpose the matrix repeatedly, extracting the first row in each step.","Iteratively traverse the outer layers of the matrix, updating boundaries after each layer.",Medium,algorithms,"Array,Matrix,Simulation"
55,"Jump Game
You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. ","Use dynamic programming, building a table to store reachability from each index.","Implement a greedy algorithm iterating backward from the end, marking indices as 'good' if they can reach the end.",Perform a depth-first search to explore all possible jump combinations.,Sort the array and check if the sum of the first k elements is greater than or equal to the index of the (k+1)-th element.,"Implement a greedy algorithm iterating forward, tracking the furthest reachable index.",Medium,algorithms,"Array,Dynamic Programming,Greedy"
56,"Merge Intervals
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. ","Use a nested loop to compare each interval with all other intervals for merging, resulting in O(n^2) complexity",Sort the intervals based on their ending times and then merge overlapping intervals iteratively,"Use a hash map to store the frequency of each start and end time, then reconstruct the merged intervals","Recursively divide the intervals into smaller subproblems, merge them, and combine the results",Sort the intervals based on their starting times and then merge overlapping intervals iteratively,Medium,algorithms,"Array,Sorting"
57,"Insert Interval
You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it. ",Append the new interval to the end and sort the entire array.,Replace the first interval with the new interval and leave the rest unchanged.,Only insert the new interval if it doesn't overlap with any existing intervals.,Prepend the new interval to the beginning of the sorted array.,"Iterate through the sorted array, merging the new interval with overlapping intervals and inserting it in the correct position.",Medium,algorithms,Array
58,"Length of Last Word
Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. ",Using dynamic programming to store results of subproblems based on starting index,"Recursively traversing the string from start to end, summing word lengths",Splitting the string into an array and returning the length of the last element,Counting all characters except spaces and subtracting the total word length,"Traversing the string from the end, skipping trailing spaces, and counting characters until the next space",Easy,algorithms,String
59,"Spiral Matrix II
Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. ","Initialize the matrix with zeros and fill it by repeatedly shrinking the boundaries, moving right, down, left, and up.","Create a 1D array of size n*n, sort it, and then map the sorted elements to the matrix in a spiral order.","Use recursion to fill sub-matrices, starting from the center and working outwards.","Allocate a matrix of size (n+2)x(n+2), pad the inner n x n part with 0's, then fill it using a wave propagation method.","Simulate the spiral path by maintaining direction variables (right, down, left, up) and updating them when hitting boundaries or filled cells.",Medium,algorithms,"Array,Matrix,Simulation"
60,"Permutation Sequence
The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: Given n and k, return the kth permutation sequence. ",Depth-First Search (DFS),Greedy Algorithm,Dynamic Programming,Binary Search,Factorial Number System,Hard,algorithms,"Math,Recursion"
61,"Rotate List
Given the head of a linked list, rotate the list to the right by k places. ","Create a new linked list and copy elements from the original, shifting by k","Reverse the linked list, shift elements, then reverse again",Split the linked list into k sublists and concatenate them in reverse order,"Iterate through the linked list k times, moving the tail to the head","Find the length of the list, adjust k, break the list, and reconnect it correctly",Medium,algorithms,"Linked List,Two Pointers"
62,"Unique Paths
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. ",Calculate the product of m and n,Compute m raised to the power of n,Return the minimum of m and n,Return the maximum of m and n,Calculate (m+n-2)! / ((m-1)! * (n-1)!) using dynamic programming or combinatorics,Medium,algorithms,"Math,Dynamic Programming,Combinatorics"
63,"Unique Paths II
You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109. ","Use Dijkstra's algorithm to find the shortest path, then count all paths of that length.","Apply a greedy algorithm, always choosing the path with the fewest obstacles.","Recursively explore all possible paths, pruning branches that lead to obstacles, but without memoization.",Calculate the total number of paths without obstacles and subtract the number of paths that pass through obstacles.,Use dynamic programming to store the number of paths to each cell.,Medium,algorithms,"Array,Dynamic Programming,Matrix"
68,"Text Justification
Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words. Note: ","Prioritize distributing spaces evenly, then add one space at a time to each gap from right to left.",Calculate the average space between words and add extra spaces to the longest words.,Distribute spaces randomly to each gap until the line reaches maxWidth.,"Fill each line with as many words as possible, adding spaces only at the end to reach maxWidth.","Calculate the number of spaces needed and distribute them evenly, adding extra spaces from left to right for uneven distribution.",Hard,algorithms,"Array,String,Simulation"
69,"Sqrt(x)
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator. ",Perform a linear search from 0 to x to find the largest integer whose square is less than or equal to x.,"Calculate x / 2 and return that value, as it is often close to the square root.","Return x - 1, assuming that the square root will always be one less than the input.","Return the integer part of x / 3, which provides a rough approximation of the square root.",Use binary search to efficiently find the largest integer whose square is less than or equal to x.,Easy,algorithms,"Math,Binary Search"
70,"Climbing Stairs
You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? ","Use dynamic programming with a bottom-up approach, storing results in an array of size n-1","Apply a greedy algorithm, always choosing the largest possible step (2) until only 0 or 1 steps remain","Calculate the number of ways to climb n/2 steps, and square the result","Employ recursion without memoization, resulting in repeated calculations for the same subproblems","Use dynamic programming to store the number of ways to reach each step, building up to n",Easy,algorithms,"Math,Dynamic Programming,Memoization"
71,"Simplify Path
You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: The simplified canonical path should follow these rules: Return the simplified canonical path. ","Use a stack to keep track of directory names, popping when encountering '..'",Split the path string into components and rebuild it using only alphanumeric characters,Replace all occurrences of multiple slashes with a single slash and remove leading/trailing slashes,Use regular expressions to filter out invalid path components,"Split the path, use a stack to track directories, handle '.' and '..', and reconstruct the path",Medium,algorithms,"String,Stack"
72,"Edit Distance
Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: ","Recursively explore all possible edit sequences, memoizing results to avoid redundant calculations.","Use dynamic programming with a space-optimized approach, storing only the current and previous row of the DP table.","Apply a greedy algorithm, prioritizing substitutions over insertions and deletions based on character frequency.",Calculate the Levenshtein distance using a divide-and-conquer strategy.,"Employ a dynamic programming approach, building a table representing the minimum edit distance between prefixes of the two strings.",Medium,algorithms,"String,Dynamic Programming"
73,"Set Matrix Zeroes
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. ",Use a boolean matrix of the same size to mark rows and columns containing zeroes in the original matrix.,"Iterate through the matrix, and for each zero found, create copies of the row and column and set them to zero, then replace the originals.",Store the indices of zero elements in a hashmap and then iterate through the hashmap to set corresponding rows and columns to zero.,"Replace all zeroes with a special value, like -1, set rows and columns containing -1 to -1, and finally, replace -1 with 0.","Use the first row and first column of the matrix itself to record rows and columns to be set to zero, using O(1) space.",Medium,algorithms,"Array,Hash Table,Matrix"
74,"Search a 2D Matrix
You are given an m x n integer matrix matrix with the following two properties: Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity. ",Perform a linear search on each row to find the target.,Treat the matrix as a binary search tree and apply tree search.,Iterate through each element of the matrix using nested loops.,Apply a hash table to store elements then find target value.,Treat the matrix as a sorted 1D array and apply binary search.,Medium,algorithms,"Array,Binary Search,Matrix"
75,"Sort Colors
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. ","Use a counting sort algorithm by iterating through the array and counting the occurrences of 0, 1, and 2, then overwriting the array.","Apply a merge sort algorithm by recursively dividing the array, sorting sub-arrays, and merging them back together.","Employ a quicksort algorithm, choosing a pivot and partitioning the array around it recursively.",Utilize an insertion sort algorithm by iterating through the array and inserting elements into their correct positions.,"Apply the Dutch National Flag algorithm, using three pointers to partition the array into three sections: 0s, 1s, and 2s.",Medium,algorithms,"Array,Two Pointers,Sorting"
76,"Minimum Window Substring
Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string """". The testcases will be generated such that the answer is unique. ",Recursively explore all possible substrings of 's' and check if they contain 't',Sort both strings 's' and 't' and then find the common substring,Use dynamic programming to build a table indicating if a substring of 's' contains a prefix of 't',Precompute all substrings of 's' and check each one against 't' for inclusion,Use a sliding window approach with two pointers and a frequency map to track characters in 't',Hard,algorithms,"Hash Table,String,Sliding Window"
77,"Combinations
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order. ","Use dynamic programming to build combinations from smaller subproblems, storing intermediate results in a matrix.","Generate all possible subsets of [1, n] and filter for subsets of size k using bit manipulation.","Recursively choose or don't choose each number, building the combination until it reaches size k.","Sort the numbers from 1 to n, then iterate through all possible k-sized sliding windows.","Iterate through numbers from 1 to n and recursively build combinations, backtracking when a combination reaches size k or exceeds the range.",Medium,algorithms,Backtracking
78,"Subsets
Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. ",Use a greedy approach by always selecting the smallest remaining element.,"Sort the input array first, then iterate and include/exclude each element.","Utilize dynamic programming, storing already calculated subsets to avoid recalculation.","Employ a backtracking algorithm, pruning branches that lead to duplicate subsets.",Use a bit manipulation technique to represent each subset with a unique bitmask.,Medium,algorithms,"Array,Backtracking,Bit Manipulation"
83,"Remove Duplicates from Sorted List
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. ",Use a hash table to keep track of seen values and remove any subsequent occurrences,"Convert the linked list to an array, remove duplicates from the array, and then convert it back to a linked list","Recursively traverse the list, comparing each node with the head node and removing duplicates",Sort the linked list using an efficient sorting algorithm before removing the duplicate nodes,"Iterate through the linked list, comparing each node with the next, and removing the next node if it has the same value",Easy,data structures,Linked List
84,"Largest Rectangle in Histogram
Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. ",Divide the histogram into subproblems recursively and calculate the area in each subproblem using dynamic programming.,Sort the heights array and then calculate the area by multiplying each height with the number of bars taller than it.,"Iterate through the heights array, keeping track of the minimum height seen so far, and calculate the area based on this minimum height.",Use a brute-force approach by calculating the area for every possible rectangle formed by the bars.,Use a stack to keep track of increasing bar heights and calculate area when a smaller bar is encountered.,Hard,algorithms,"Array,Stack,Monotonic Stack"
85,"Maximal Rectangle
Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. ","Treat each row as a histogram and use a stack-based approach to find the largest rectangular area in each histogram, then take the maximum.","Recursively explore all possible submatrices and check if they contain only 1s, keeping track of the largest area.","For each cell (i, j), calculate the area of the largest square with (i, j) as the bottom-right corner and return the maximum square area.",Transpose the matrix and then apply an algorithm for finding the largest square submatrix.,"For each row, compute the left boundary, right boundary, and height for each cell based on the 1s. Then use these to calculate the maximum rectangular area.",Hard,algorithms,"Array,Dynamic Programming,Stack,Matrix,Monotonic Stack"
86,"Partition List
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. ",Create a new linked list with elements rearranged in-place using nested loops.,Sort the linked list and then shift elements less than x to the front.,"Use two arrays to store values less than and greater than or equal to x, then rebuild the list.",Recursively partition sublists until the entire list is partitioned.,"Maintain two separate linked lists: one for elements less than x, and another for elements greater than or equal to x, then concatenate them.",Medium,data structures,"Linked List,Two Pointers"
87,"Scramble String
We can scramble a string s to get a string t using the following algorithm: Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. ","Depth-first search, recursively partitioning and comparing substrings lexicographically","Dynamic programming, building a table of boolean values representing scrambled substrings based on substring length","Breadth-first search, exploring possible partitions and permutations of the string","Greedy algorithm, always selecting the locally optimal partition at each step to minimize comparisons",Recursively check if s2 is a scramble of s1 by partitioning s1 and comparing scrambled versions of its partitions with partitions of s2.,Hard,algorithms,"String,Dynamic Programming"
88,"Merge Sorted Array
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. ",Copy `nums2` into the end of `nums1` and then sort `nums1` using a standard sorting algorithm.,"Create a new array of size `m + n`, iterate through `nums1` and `nums2` inserting elements in sorted order, then copy the result back to `nums1`.","Iterate through `nums1` and `nums2` simultaneously, comparing elements and swapping them in place until both arrays are merged.",Use a hash map to store the elements of both arrays and then reconstruct `nums1` in sorted order based on the hash map.,"Use three pointers: one for `nums1`, one for `nums2`, and one for the end of `nums1`. Iterate backwards, placing the larger element into the correct position in `nums1`.",Easy,algorithms,"Array,Two Pointers,Sorting"
89,"Gray Code
An n-bit gray code sequence is a sequence of 2n integers where: Given an integer n, return any valid n-bit gray code sequence. ",Generate all possible binary numbers and then filter for Gray code properties,Use a recursive function that explores all bit combinations while ensuring only one bit changes at a time,"Start with a list containing only '0', then iteratively append the reversed list with '1' prepended","Apply a brute-force method, permuting all binary numbers and validating against the Gray code condition","Reflect and prefix method: start with [0, 1], then reflect it [1, 0] and prefix the original with 0 and the reflected with 1",Medium,algorithms,"Math,Backtracking,Bit Manipulation"
90,"Subsets II
Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. ","Use a combination of iterative and recursive approaches to explore all possibilities, avoiding duplicates using a `visited` set of indices",Sort the array and use a boolean array to mark visited elements during recursive calls to handle duplicates,Convert the array to a set to remove duplicates and then generate all subsets using bit manipulation,"Generate all subsets without considering duplicates, then apply a post-processing step to remove any duplicate subsets from the result",Sort the array and use backtracking with pruning to avoid generating duplicate subsets during the recursive calls,Medium,algorithms,"Array,Backtracking,Bit Manipulation"
91,"Decode Ways
You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: ""1"" -> 'A'
""2"" -> 'B'
...
""25"" -> 'Y'
""26"" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (""2"" and ""5"" vs ""25""). For example, ""11106"" can be decoded into: Note: there may be strings that are impossible to decode.

Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer. ","Use a greedy algorithm, prioritizing larger two-digit combinations whenever possible.",Apply a depth-first search (DFS) to explore all possible decoding paths and count valid ones.,"Employ dynamic programming with a bottom-up approach, storing the number of ways to decode substrings.","Sort the input string numerically and then iterate, grouping adjacent identical digits for encoding.",Utilize dynamic programming with memoization to avoid redundant calculations of overlapping subproblems.,Medium,algorithms,"String,Dynamic Programming"
92,"Reverse Linked List II
Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. ","Use a stack to store nodes between 'left' and 'right', then pop and re-link","Recursively reverse the entire list, then reverse the reversed portion back to the original order","Create a new linked list containing only nodes from 'left' to 'right' in reverse order, and then splice it back","Iterate from 'left' to 'right', swapping the values of nodes at corresponding positions from the start and end","Identify the nodes preceding 'left' and succeeding 'right', reverse the sublist between 'left' and 'right', and re-link to the surrounding nodes",Medium,algorithms,Linked List
93,"Restore IP Addresses
A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. ","Iterate through all possible combinations of split points and validate each resulting segment to be within the range [0, 256]",Use regular expressions to find all possible patterns matching the IP address format,Employ dynamic programming to store previously computed valid IP segments and reuse them to build complete addresses.,Generate all possible permutations of the digits and filter out the invalid IP addresses based on format and range constraints.,"Use backtracking to explore all possible segmentations of the string, pruning branches that lead to invalid IP addresses.",Medium,algorithms,"String,Backtracking"
97,"Interleaving String
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: Note: a + b is the concatenation of strings a and b. ","Greedy algorithm, prioritizing the longer string",Regular expression matching to find s1 and s2 within s3,"Recursively checking substrings of s1 and s2 against substrings of s3, without memoization",Direct string concatenation and comparison,Dynamic programming to build a table representing possible interleavings,Medium,algorithms,"String,Dynamic Programming"
98,"Validate Binary Search Tree
Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: ","The left subtree must contain nodes with values strictly less than the root node's value, and the right subtree must contain nodes with values strictly greater than the root node's value, but there are no restrictions on nodes in the same level.","The left and right subtrees must both be valid binary trees, and the value of the root node must be between the minimum and maximum values in the entire tree.","Each node's value must be greater than the value of its left child and less than the value of its right child, and no duplicate values are allowed in the tree.","The tree must be complete, and each node's value must be greater than or equal to the value of its left child and less than or equal to the value of its right child.","The left subtree of a node contains only nodes with values strictly less than the node's value, the right subtree contains only nodes with values strictly greater than the node's value, and both the left and right subtrees must also be binary search trees.",Medium,data structures,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
99,"Recover Binary Search Tree
You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. ",Perform an inorder traversal and sort the resulting array to identify and swap the misplaced nodes.,Use a level-order traversal to identify the misplaced nodes and swap their values.,"Create a new BST from the given tree, which will inherently correct the misplaced nodes.",Recursively search for the misplaced nodes by comparing the current node's value with the average of its children's values.,Perform an inorder traversal to identify the two out-of-order nodes and then swap their values to restore the BST property.,Medium,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
100,"Same Tree
Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. ","Check only the root nodes for equality; if equal, the trees are the same.","Compare the number of nodes in both trees; if different, they are not the same, otherwise they are.",Perform a breadth-first search (BFS) on both trees and compare the order of visited nodes.,"Compare the sum of all node values in both trees; if equal, the trees are the same.",Recursively check if the root values are equal and then recursively check the left and right subtrees.,Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
101,"Symmetric Tree
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). ",A tree where the values of all nodes are equal.,"A tree where the left subtree is a mirror image of itself, and the right subtree is also a mirror image of itself.",A tree that has an even number of nodes.,"A tree where for every node, the number of nodes in the left subtree equals the number of nodes in the right subtree.",A tree where the left and right subtrees are mirror images of each other.,Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
102,"Binary Tree Level Order Traversal
Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). ",Depth-First Search (DFS),Reverse Inorder Traversal,Inorder Traversal,Postorder Traversal,Breadth-First Search (BFS),Medium,data structures,"Tree,Breadth-First Search,Binary Tree"
103,"Binary Tree Zigzag Level Order Traversal
Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). ",Use depth-first search (DFS) and reverse the order of nodes at even depths.,Use breadth-first search (BFS) and reverse the order of nodes at odd depths.,"Use recursion to traverse the tree and store nodes in a list, then reverse the list at alternating levels.",Use a stack to store nodes at each level and reverse the stack based on level parity.,Use breadth-first search (BFS) with a deque to add nodes from left or right based on the current level's parity.,Medium,algorithms,"Tree,Breadth-First Search,Binary Tree"
104,"Maximum Depth of Binary Tree
Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. ",Use Breadth-First Search (BFS) and return the number of levels traversed,Recursively traverse the left subtree and return its depth,Store all nodes in an array and return the array's length,Apply Depth-First Search (DFS) iteratively using a stack and track the maximum depth at each node,"Apply Depth-First Search (DFS) recursively, returning the maximum of the depths of the left and right subtrees plus one",Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
105,"Construct Binary Tree from Preorder and Inorder Traversal
Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. ","Recursively build the tree, using preorder to determine the root and inorder to split into left and right subtrees, but always taking the first element of the inorder array as the root.","Iteratively build the tree using a stack to keep track of the path from the root to the current node, and only using the preorder array.","Create a hashmap mapping inorder values to their indices, then traverse the preorder array and create nodes, linking them based only on the hashmap indices without considering the preorder sequence.","Construct a tree using only the preorder array, assuming a complete binary tree structure and ignoring the inorder traversal.","Recursively build the tree, using preorder to determine the root and inorder to split into left and right subtrees, updating the preorder index with each recursive call.",Medium,data structures,"Array,Hash Table,Divide and Conquer,Tree,Binary Tree"
106,"Construct Binary Tree from Inorder and Postorder Traversal
Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. ",The last element in 'inorder' is always the root.,The first element in 'postorder' is always the root.,Use a stack to keep track of visited nodes in the inorder traversal.,The problem cannot be solved if the tree contains duplicate values.,The last element in 'postorder' is the root; find it in 'inorder' to split the arrays recursively.,Medium,algorithms,"Array,Hash Table,Divide and Conquer,Tree,Binary Tree"
107,"Binary Tree Level Order Traversal II
Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root). ",Use Depth-First Search (DFS) and prepend each level's nodes to the result list.,Perform a standard Level Order Traversal and reverse the final result list.,"Utilize a recursive approach, processing nodes from the bottom up.",Employ a stack to temporarily store nodes and then pop them in reverse level order.,Use Breadth-First Search (BFS) and insert each level's nodes at the beginning of the result list.,Medium,algorithms,"Tree,Breadth-First Search,Binary Tree"
112,"Path Sum
Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. ",Use a breadth-first search algorithm to explore all possible paths and check their sums.,Employ dynamic programming to store previously calculated path sums and avoid redundant computations.,Convert the binary tree into a sorted array and check for a target sum within the array.,Prune subtrees whose sum exceeds the target sum at each node to optimize search.,"Recursively traverse the tree, subtracting the current node's value from the targetSum, and check if a leaf node with a remaining sum of 0 is reached.",Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
113,"Path Sum II
Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. ","Use breadth-first search and store all possible paths, then filter for the target sum.","Perform a depth-first search without backtracking to find a single path, which may not be optimal.",Convert the binary tree to an array and then find sub-arrays that sum to the target.,Apply dynamic programming to store the sums of all subtrees and then reconstruct the paths.,Use a recursive depth-first search with backtracking to explore all possible paths and check their sums.,Medium,algorithms,"Backtracking,Tree,Depth-First Search,Binary Tree"
116,"Populating Next Right Pointers in Each Node
You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. ",Use breadth-first search and modify pointers only at the second-to-last level.,"Employ depth-first search, setting next pointers based on node depth.",Utilize a stack to keep track of nodes and set next pointers after popping.,Recursively process the left and right subtrees independently without inter-level connection.,"Employ a level-order traversal, connecting each node to its immediate right sibling within the same level.",Medium,data structures,"Linked List,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
117,"Populating Next Right Pointers in Each Node II
Given a binary tree Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. ","Level order traversal with a queue, connecting nodes at each level after processing",Recursively traverse the tree in-order and use a global variable to track the previous node at the same level,Perform a depth-first search and maintain a hash map to store nodes at each level for linking,"Utilize a modified pre-order traversal, always connecting the right child to the left child if they exist","Employ a level order traversal, using dummy nodes to efficiently track the start of each level and link nodes",Medium,data structures,"Linked List,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
14,"Longest Common Prefix
Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string """". ","Compare all strings to the first string, shortening it if mismatches are found.",Sort the array of strings and compare the first and last strings.,Find the shortest string in the array and check if it's a prefix of all other strings.,Concatenate all strings and find repeated substrings.,"Iterate through characters of the first string and compare with corresponding characters in other strings, stopping when a mismatch is found.",Easy,algorithms,String
15,"3Sum
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. ","Use a brute-force approach with three nested loops to check all possible triplets, resulting in O(n^3) time complexity.","Sort the array first and then use three pointers, skipping duplicate elements, achieving O(n log n) time complexity.","Convert the array into a hash set and iterate through all possible pairs, checking if the negative sum exists in the set, yielding O(n^2) time complexity but possible hash collisions.","Use recursion to find all possible combinations and filter out triplets that sum to zero, leading to potentially high stack usage and time complexity.","Sort the array, then use two pointers starting from opposite ends for each element, skipping duplicates, with O(n^2) time complexity.",Medium,algorithms,"Array,Two Pointers,Sorting"
16,"3Sum Closest
Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. ",Use a hash map to store all possible sums of two numbers and then iterate through the array to find the closest match for the third number.,Calculate the sum of all possible triplets and select the one with the minimum absolute difference from the target.,"Sort the array, then for each element, use two pointers to find the pair that sums closest to the target minus the current element without duplicate checking.",Recursively divide the array into smaller subproblems and find the closest sum in each subproblem.,"Sort the array, then for each element, use two pointers to find the pair that sums closest to the target minus the current element.",Medium,algorithms,"Array,Two Pointers,Sorting"
29,"Divide Two Integers
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. ",Bitwise AND with the divisor until dividend is smaller,Repeatedly add the divisor to itself and count how many times,Use logarithms and exponentiation to approximate the division,Recursively subtract the divisor from the dividend and increment a counter,Repeatedly subtract left-shifted divisor from the dividend,Medium,algorithms,"Math,Bit Manipulation"
30,"Substring with Concatenation of All Words
You are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated. Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order. ","A sliding window approach with a fixed window size equal to the total length of concatenated words, but incorrectly handling word counts.",Generating all permutations of the words array and then searching for each permutation in the string s.,"Using regular expressions to search for the pattern of concatenated words in the string s, which may not handle all cases efficiently.","Implementing a brute-force search, comparing every substring of length equal to the total length of concatenated words against the words array without proper word count management.","Employ a sliding window with a fixed window size, maintaining a frequency map of words and checking if each window contains the exact frequency of words from the input array.",Hard,algorithms,"Hash Table,String,Sliding Window"
31,"Next Permutation
A permutation of an array of integers is an arrangement of its members into a sequence or linear order. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. ","Find the longest non-increasing suffix, then swap the pivot with the smallest element to its right that is still greater than it, finally sort the suffix","Reverse the entire array, then reverse it again to obtain the next permutation",Sort the array in descending order to get the next permutation,Rotate the array to the right by one position to get the next permutation,"Find the largest index i such that nums[i] < nums[i + 1]. Then, find the largest index j > i such that nums[j] > nums[i]. Swap nums[i] and nums[j] and reverse the suffix nums[i + 1:]",Medium,algorithms,"Array,Two Pointers"
44,"Wildcard Matching
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: The matching should cover the entire input string (not partial). ","The '?' matches any single character, and '*' matches zero or more of the preceding character.","The '?' matches zero or more of any character, and '*' matches any single character.","The '?' matches zero or one of the preceding character, and '*' matches any character.","The '?' matches any single digit, and '*' matches any number of digits.","The '?' matches any single character, and '*' matches any sequence of characters.",Hard,algorithms,"String,Dynamic Programming,Greedy,Recursion"
45,"Jump Game II
You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. ","Dynamic programming using a bottom-up approach, storing minimum jumps to each index",Greedily jump to the farthest reachable index in each step,Recursively explore all possible jump combinations and return the minimum,"Use breadth-first search to explore possible paths, level by level","Maintain a 'current reachable' and 'next reachable' range, updating jumps when 'i' reaches 'current reachable'",Medium,algorithms,"Array,Dynamic Programming,Greedy"
46,"Permutations
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. ",Iterative Depth-First Search (DFS),Dynamic Programming with Memoization,Greedy Algorithm with Backtracking,Breadth-First Search (BFS),Recursive Backtracking,Medium,algorithms,"Array,Backtracking"
47,"Permutations II
Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. ","Use a HashMap to store the frequency of each element, then apply backtracking without explicitly swapping elements","Sort the input array and use a Set to store the permutations, avoiding duplicates",Generate all possible permutations using recursion and then filter out duplicates using a Set,"Employ a greedy approach, always picking the smallest available number for the next position",Sort the input array and use backtracking with a 'used' array to skip duplicate elements at the same level of recursion,Medium,algorithms,"Array,Backtracking"
64,"Minimum Path Sum
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.",Use Dijkstra's algorithm to find the shortest path.,Use Depth-First Search (DFS) to explore all possible paths and choose the minimum.,Calculate all possible path sums and select the minimum using brute force.,Use a greedy approach by always choosing the smallest adjacent cell.,Use dynamic programming to build a table of minimum path sums from the top-left to each cell.,Medium,algorithms,"Array,Dynamic Programming,Matrix"
65,"Valid Number
Given a string s, return whether s is a valid number.

For example, all the following are valid numbers: ""2"", ""0089"", ""-0.1"", ""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"", ""-123.456e789"", while the following are not valid numbers: ""abc"", ""1a"", ""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53"". Formally, a valid number is defined using one of the following definitions: An integer number is defined with an optional sign '-' or '+' followed by digits. A decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions: An exponent is defined with an exponent notation 'e' or 'E' followed by an integer number. The digits are defined as one or more digits.","Regular expressions offer precise pattern matching, but crafting a regex for all valid number formats can be complex and inefficient, leading to potential performance bottlenecks.","A finite state machine provides a structured way to validate the string, but handling edge cases and transitions can be cumbersome and increase code complexity.","Converting the string to a double and back to a string using standard library functions can identify some invalid formats, but this approach may introduce inaccuracies due to floating-point representation.","Splitting the string into integer, decimal, and exponent parts, and validating each part separately simplifies the logic and improves readability, leading to faster execution.","Iterating through the string character by character, applying a series of conditional checks based on the current character and state, is the most robust and reliable approach.",Hard,algorithms,String
66,"Plus One
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits.","Convert the array to a string, increment the string representation as an integer, then convert back to an array of digits.","Iterate through the array from left to right, adding 1 to the first digit and propagating carry as needed.","Replace the array with a new array containing only the value 1, representing incrementing to the minimum possible value.",Use recursion to add 1 to the least significant digit and handle carry-over to the more significant digits.,"Iterate through the array from right to left, adding 1 to the least significant digit and handling carry-over to the more significant digits.",Easy,algorithms,"Array,Math"
67,"Add Binary
Given two binary strings a and b, return their sum as a binary string.","Iterate through both strings, converting characters to integers, summing, and then converting back to binary.","Convert each binary string to its decimal equivalent, sum the decimals, and then convert the result back to binary.","Use bitwise XOR and AND operators to simulate binary addition without carry, then handle the carry separately.","Prepend leading zeros to the shorter string to match the length of the longer string, then perform digit-wise addition without carry.","Initialize a carry to 0. Iterate from right to left, adding digits and carry, updating the carry, and building the result string.",Easy,algorithms,"Math,String,Bit Manipulation,Simulation"
79,"Word Search
Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",Use a breadth-first search algorithm to exhaustively explore all possible paths.,Sort the board alphabetically and then check if the sorted word is a substring.,Convert the board into a string and use regular expressions to search for the word.,Employ dynamic programming to store previously visited cells and their corresponding word segments.,Utilize a depth-first search algorithm with backtracking to explore adjacent cells and match the word.,Medium,algorithms,"Array,Backtracking,Matrix"
80,"Remove Duplicates from Sorted Array II
Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted.",Use a hash map to count occurrences and rebuild the array with elements appearing at most twice.,"Sort the array and then iterate, removing any element appearing more than twice.",Iterate through the array and skip over consecutive elements if they are equal.,"Create a new array and copy elements, ensuring each appears at most twice, then copy back to the original.","Maintain a slow pointer to track the modified array and a fast pointer to iterate, only copying elements if they are different from the two preceding elements.",Medium,algorithms,"Array,Two Pointers"
81,"Search in Rotated Sorted Array II
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible.",A linear search through the entire array.,"Apply binary search directly, ignoring the rotation and hoping to find the target.",Perform a modified binary search that only checks one half of the array in each iteration.,Sort the rotated array and then apply standard binary search.,"Use a modified binary search, handling the rotated segments by checking if the current segment is sorted.",Medium,algorithms,"Array,Binary Search"
82,"Remove Duplicates from Sorted List II
Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",Using a hash table to count occurrences and then rebuilding the list with unique elements.,"Iterating through the list and removing adjacent duplicates in-place, but failing to handle consecutive duplicates beyond pairs.","Recursively processing the list, removing the first duplicate found and recursively calling the function on the rest.","Converting the linked list to an array, removing duplicates from the array, and converting the array back to a linked list.","Using two pointers, a 'predecessor' and a 'current', to track and remove consecutive duplicate nodes.",Medium,algorithms,"Linked List,Two Pointers"
94,"Binary Tree Inorder Traversal
Given the root of a binary tree, return the inorder traversal of its nodes' values.","Preorder: Root, Left, Right","Postorder: Left, Right, Root",Level order: Visit nodes by level,"Reverse inorder: Right, Root, Left","Inorder: Left, Root, Right",Easy,data structures,"Stack,Tree,Depth-First Search,Binary Tree"
95,"Unique Binary Search Trees II
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.","Depth-first search with backtracking to generate all possible tree structures, pruning invalid trees early","Dynamic programming to store and reuse previously computed subtrees, combined with memoization to avoid redundant calculations",Greedy algorithm that always selects the smallest available number as the root to minimize tree depth,"Divide and conquer approach, recursively generating left and right subtrees for each number as the potential root","Recursively construct subtrees for each possible root value from 1 to n, combining left and right subtrees to form unique BSTs",Medium,algorithms,"Dynamic Programming,Backtracking,Tree,Binary Search Tree,Binary Tree"
96,"Unique Binary Search Trees
Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",O(n!),O(2^n),O(n log n),O(n),O(4^n / (n^(3/2))),Medium,algorithms,"Math,Dynamic Programming,Tree,Binary Search Tree,Binary Tree"
108,"Convert Sorted Array to Binary Search Tree
Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",Always pick the middle element as the root.,Create a tree where the smallest element is always the root.,Insert elements in the array order into the BST.,Always pick the first element as the root.,"Recursively pick the middle element as the root, and the left and right subarrays for the left and right subtrees, respectively.",Easy,data structures,"Array,Divide and Conquer,Tree,Binary Search Tree,Binary Tree"
109,"Convert Sorted List to Binary Search Tree
Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.",Recursively build the tree by selecting the head of the list as the root,Convert the sorted list to an array and then build the BST from the array in O(n log n) time,"Iteratively insert nodes into the BST, maintaining balance after each insertion",Create a skewed BST by traversing the linked list in order,"Find the middle element of the list to be the root, then recursively build the left and right subtrees from the left and right halves of the list",Medium,data structures,"Linked List,Divide and Conquer,Tree,Binary Search Tree,Binary Tree"
110,"Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.",The difference in height between left and right subtrees is at most 2 for every node.,All leaf nodes must be at the same depth.,The tree must be a complete binary tree in addition to satisfying height balance properties.,The difference in the number of nodes between the left and right subtrees is at most 1 for every node.,The difference in height between the left and right subtrees is at most 1 for every node.,Easy,data structures,"Tree,Depth-First Search,Binary Tree"
111,"Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.",The depth of the leftmost subtree.,The maximum depth of the tree divided by two.,The number of nodes in the longest branch.,The average depth of all leaf nodes.,The minimum number of nodes along any path from the root to a leaf node.,Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
114,"Flatten Binary Tree to Linked List
Given the root of a binary tree, flatten the tree into a ""linked list"":","Use an iterative approach with a stack to store right subtrees, linking them in a post-order traversal.","Recursively flatten the left and right subtrees, then move the right subtree to the leftmost child of the right subtree.","Perform an in-order traversal, storing nodes in an array, then reconstruct a linked list from the array.","Flatten by always moving the left subtree to the right, and setting the left child to null","Recursively flatten the left subtree, then the right subtree, and finally rewire the root to point to the former left subtree (now a list).",Medium,algorithms,"Linked List,Stack,Tree,Depth-First Search,Binary Tree"
115,"Distinct Subsequences
Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.","Greedily match characters from 's' to 't' from left to right, backtracking when a mismatch occurs.",Use regular expressions to find all occurrences of 't' within 's'.,Calculate all possible subsequences of 's' and then count how many are equal to 't'.,Employ a sliding window approach to find all substrings of 's' that are equal to 't'.,"Apply dynamic programming, building a 2D table where dp[i][j] represents the number of distinct subsequences of s[:i] that equal t[:j].",Hard,algorithms,"String,Dynamic Programming"
118,"Pascal's Triangle
Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:","Use dynamic programming, storing only the previous row to optimize space complexity","Employ recursion, calculating each element based on its two parent elements in the triangle",Pre-calculate all factorials up to numRows and apply the combination formula directly,Utilize a matrix representation and perform matrix exponentiation to generate rows,Iteratively build each row by summing the two elements above it in the previous row,Easy,algorithms,"Array,Dynamic Programming"
119,"Pascal's Triangle II
Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",Use dynamic programming to calculate all rows up to rowIndex and return the last row,Employ recursion to calculate each element based on the elements in the previous row,Apply the binomial coefficient formula directly to compute each element in the rowIndex,Store the entire Pascal's triangle in a matrix and then return the desired row,Utilize a single array and iteratively update it from right to left to store the current row,Easy,algorithms,"Array,Dynamic Programming"
120,"Triangle
Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.","Use a greedy approach, always selecting the smallest adjacent number",Calculate the sum of all possible paths and choose the minimum,Sort the triangle array and then sum the first element of each row,Apply Dijkstra's algorithm,Use dynamic programming to store the minimum path sum to each element,Medium,algorithms,"Array,Dynamic Programming"
121,"Best Time to Buy and Sell Stock
You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",Greedily pick the lowest price as the buying day and the highest price after it as the selling day.,Use dynamic programming to build a table of all possible profits and select the maximum.,Calculate the difference between every pair of prices and return the largest difference.,Sort the array and take the difference between the last and first element.,Track the minimum price seen so far and calculate the potential profit at each step.,Easy,algorithms,"Array,Dynamic Programming"
122,"Best Time to Buy and Sell Stock II
You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",Always buy low and sell high regardless of transaction fees,Calculate the difference between the first and last price in the array,"Only buy and sell once at the absolute lowest and highest prices, respectively",Ignore any price drops and only accumulate the increases,Sum up all positive differences between consecutive days' prices,Medium,algorithms,"Array,Dynamic Programming,Greedy"
123,"Best Time to Buy and Sell Stock III
You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","Use a greedy approach, buying at the lowest price and selling at the highest price twice.",Calculate the maximum profit for each day using a single transaction and sum the two largest profits.,Sort the prices array and calculate the profit by subtracting the first element from the last element twice.,Iterate through all possible pairs of buy and sell days and choose the two pairs that maximize the sum of their profits.,"Use dynamic programming to track the maximum profit after 0, 1, and 2 transactions at each day.",Hard,algorithms,"Array,Dynamic Programming"
124,"Binary Tree Maximum Path Sum
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",Only consider paths that include the root node in the calculation.,"Recursively calculate the maximum path sum from each node, ignoring negative node values.",Calculate the sum of all possible paths and then choose the maximum value.,Use a breadth-first search (BFS) approach to explore all possible paths in the tree.,"Recursively calculate the maximum path sum including the current node as a turning point or extending from its children, handling negative values correctly.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Binary Tree"
125,"Valid Palindrome
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.",Using regular expressions to remove non-alphanumeric characters and then checking for equality of the string with its reverse using slicing.,"Converting the string to a list, reversing the list, joining it back into a string, and comparing it to the original string.","Comparing the first and last characters iteratively, moving inwards only if both are alphanumeric and equal in lowercase.",Using a stack to store the first half of the string and then comparing it with the second half.,"Using two pointers, one starting from the beginning and the other from the end, skipping non-alphanumeric characters and comparing characters in lowercase.",Easy,algorithms,"Two Pointers,String"
126,"Word Ladder II
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].",Depth-First Search (DFS) alone will always find the shortest path efficiently.,"Breadth-First Search (BFS) is guaranteed to find a path, but not necessarily the shortest one.",A* search algorithm with a heuristic function is the most appropriate choice for this problem.,Dynamic programming can be used to precompute all possible transformation sequences.,"Breadth-First Search (BFS) is used to find all shortest paths, followed by Depth-First Search (DFS) to enumerate those paths.",Hard,algorithms,"Hash Table,String,Backtracking,Breadth-First Search"
127,"Word Ladder
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",Use Depth-First Search (DFS) to explore all possible transformation sequences until the endWord is found.,Greedily select the next word in the sequence that has the smallest lexicographical difference from the current word.,"Use a recursive approach, checking all possible one-letter mutations at each step until endWord is found, pruning branches exceeding a maximum depth.","Precompute all possible one-letter mutations and store them in a hash table, then perform a lookup for each word.","Use Breadth-First Search (BFS) to explore possible transformations level by level, guaranteeing the shortest path if it exists.",Hard,algorithms,"Hash Table,String,Breadth-First Search"
128,"Longest Consecutive Sequence
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",Use a hash table to store all numbers and iteratively remove adjacent numbers to find sequences,"Sort the array and then iterate through it, keeping track of the current and longest sequence lengths","Use recursion to check for consecutive numbers, memoizing results to avoid redundant calculations",Apply dynamic programming by storing the length of the longest sequence ending at each number,"Insert all numbers into a set, then iterate through the array and extend consecutive sequences from each number",Medium,algorithms,"Array,Hash Table,Union Find"
129,"Sum Root to Leaf Numbers
You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children.","Use a breadth-first search, concatenating node values as strings and converting them to integers at leaf nodes.","Perform a depth-first search, storing paths in a list and summing the integer representation of the paths afterward.","Employ dynamic programming to cache path sums, reducing redundant calculations for overlapping subtrees.","Use a greedy approach, prioritizing paths with larger digits higher in the tree to maximize the sum.","Use recursion with backtracking to explore all root-to-leaf paths, accumulating the numerical value as you traverse each path.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
130,"Surrounded Regions
You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.",Use Depth-First Search (DFS) starting from all 'O's to identify and flip surrounded regions.,"Iterate through the entire board, flipping 'O's to 'X's if they have 'X' neighbors in all directions.",Replace all 'O's with 'X's and then revert back the 'X's that are connected to the border.,"Iterate through the board linearly, flipping 'O's based on a simple parity check of row and column indices.","Use Breadth-First Search (BFS) or DFS starting from border 'O's to mark connected 'O's, then flip remaining 'O's to 'X's and revert marked 'O's.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
131,"Palindrome Partitioning
Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.","Depth-first search, pruning branches that don't start with palindromes","Dynamic programming, storing palindrome status in a table","Greedy algorithm, picking the longest palindrome at each step","Breadth-first search, exploring partitions layer by layer","Backtracking, recursively exploring possible partitions and checking for palindromes",Medium,algorithms,"String,Dynamic Programming,Backtracking"
132,"Palindrome Partitioning II
Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.","Use dynamic programming to store the minimum cuts needed for all substrings, but only consider odd-length palindromes.","Recursively check if the string is a palindrome and if not, make a cut at every possible position and take the minimum.","Use a greedy approach, always making a cut at the longest possible palindrome found from the start of the string.",Iterate through the string and keep track of all possible palindrome starting positions using a hash table.,Use dynamic programming to precompute whether substrings are palindromes and then find the minimum cuts using another DP.,Hard,algorithms,"String,Dynamic Programming"
133,"Clone Graph
Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.  Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.","Perform a breadth-first search (BFS) or depth-first search (DFS) and only copy the node values, not the neighbors.","Use a hash map to store the original nodes' values and then create a new graph based on those values, ignoring the neighbor relationships.",Create a shallow copy of the graph by simply copying the references of the original nodes.,Create a subgraph containing only the nodes reachable within a certain depth from the starting node.,Use a hash map to store cloned nodes and perform a depth-first search (DFS) or breadth-first search (BFS) to clone the graph and its connections.,Medium,algorithms,"Hash Table,Depth-First Search,Breadth-First Search,Graph"
134,"Gas Station
There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",Return -1 if the total cost exceeds the total gas available.,"Start from the first station and keep track of the remaining gas. If the gas becomes negative, reset the starting station to the next one.","Simulate the journey starting from each station. If a complete circle is possible, return the starting index. Otherwise, return -1.",Sort the gas array in descending order and cost array in ascending order and start from the index of the largest gas value.,Calculate the difference between gas and cost for each station. Accumulate the differences and return the index where the cumulative sum becomes non-negative after a negative sum.,Medium,algorithms,"Array,Greedy"
135,"Candy
There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Return the minimum number of candies you need to have to distribute the candies to the children.",Sort the ratings array and assign candies based on the sorted order.,Assign one candy to each child regardless of their ratings.,Distribute candies randomly to the children.,Assign candies proportional to the rating values without considering neighbors.,"Traverse the array twice, once from left to right and once from right to left, ensuring each child has more candies than their neighbors with lower ratings.",Hard,algorithms,"Array,Greedy"
136,"Single Number
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.",Using a hash map to count occurrences of each number.,Sorting the array and comparing adjacent elements.,Recursively dividing the array until the single number is found.,Calculating the sum of all numbers and dividing by two.,Applying the XOR bitwise operation to all elements in the array.,Easy,algorithms,"Array,Bit Manipulation"
137,"Single Number II
Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space.",Use a hash map to store the count of each bit at each position and take the modulus by 3,"Sort the array and iterate, checking for elements that are not equal to their neighbors",Calculate the sum of all elements and divide by 3 to find the single number,Use bitwise XOR operation on all elements to cancel out the numbers appearing three times,Use bit manipulation with two variables to track the count of each bit modulo 3,Medium,algorithms,"Array,Bit Manipulation"
138,"Copy List with Random Pointer
A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: Your code will only be given the head of the original linked list.","Use a hash table to store the mapping between original nodes and their copies, iterating three times: once to create new nodes, once to assign next pointers, and once to assign random pointers.","Employ recursion. For each node, create a copy and recursively copy the next and random pointers, returning the head of the copied list.","Create a new list and directly assign values. For random pointers, iterate the original list to find the target and do the same on the new list.","Clone the list then attempt to correct the random pointers in a subsequent pass. If a random pointer doesn't point to a new node, recursively correct it until all random pointers are valid","Interweave the original and copied lists, then separate them. The copied list has the same structure and random pointer relationships as the original.",Medium,data structures,"Hash Table,Linked List"
139,"Word Break
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.","Depth-first search, backtracking when a path fails to produce a complete segmentation","Greedy approach, always choosing the longest possible word from the beginning of the string",Regular expression matching against concatenated dictionary words,"Divide and conquer, splitting the string into halves and recursively checking segmentation","Dynamic programming, building a table of segmentable prefixes",Medium,algorithms,"Hash Table,String,Dynamic Programming,Trie,Memoization"
140,"Word Break II
Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.",The solution will always find at least one valid sentence if the wordDict is not empty.,Dynamic programming cannot be applied to this problem due to the exponential number of possible solutions.,Breadth-first search is more efficient than depth-first search for this problem.,The order of words in the wordDict significantly impacts the output sentences.,Backtracking can be used to explore all possible segmentations of the input string.,Hard,algorithms,"Hash Table,String,Dynamic Programming,Backtracking,Trie,Memoization"
algorithms,141,"Linked List Cycle
Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false.",Depth-First Search (DFS),Breadth-First Search (BFS),Using a hash table to store visited nodes,Sorting the linked list,,"['linked list', 'cycle detection', 'algorithms']",Floyd's Cycle-Finding Algorithm (Tortoise and Hare)
algorithms,142,"Linked List Cycle II
Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list.",The Floyd-Warshall algorithm,Depth-First Search (DFS),A union-find data structure,Breadth-First Search (BFS),,"['linked list', 'cycle detection', 'algorithm']",Floyd's cycle-finding algorithm (tortoise and hare)
data structures,143,"Reorder List
You are given the head of a singly linked-list. The list can be represented as: Reorder the list to be on the following form: You may not modify the values in the list's nodes. Only nodes themselves may be changed.","Use two pointers, one fast and one slow, to split the list, reverse the second half, and then merge the two halves by alternating nodes.","Reverse the entire list and then iterate through the original list and the reversed list, inserting nodes from the reversed list after each node in the original list.","Store the list nodes in an array, then iterate through the array from both ends, linking the nodes in the desired order.",Recursively reorder the list by moving the last node to the second position in each recursive call.,,"['linked list', 'reversal', 'merge']","Find the middle of the list, reverse the second half, and then merge the first and reversed second halves."
data structures,144,"Binary Tree Preorder Traversal
Given the root of a binary tree, return the preorder traversal of its nodes' values.","Postorder: Left, Right, Root",Level Order: Visit nodes level by level,"Inorder: Left, Root, Right","Reverse Inorder: Right, Root, Left",,"['binary tree', 'traversal', 'recursion']","Preorder: Root, Left, Right"
data structures,145,"Binary Tree Postorder Traversal
Given the root of a binary tree, return the postorder traversal of its nodes' values.","Visit the root node, then the left subtree, then the right subtree.","Visit the right subtree, then the left subtree, then the root node.","Visit the left subtree, then the root node, then the right subtree.","Visit the root node, then apply a breadth-first search.",,"['binary tree', 'tree traversal', 'recursion']","Visit the left subtree, then the right subtree, then the root node."
146,"LRU Cache
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: The functions get and put must each run in O(1) average time complexity.",Use a standard hash map without any eviction strategy,Employ a simple queue to store the keys and evict the least recently added,Utilize a binary search tree to maintain the order of access,Implement a linked list without a hash map for key lookups,Combine a hash map for O(1) key lookups with a doubly linked list to track recency,Medium,data structures,"Hash Table,Linked List,Design,Doubly-Linked List"
147,"Insertion Sort List
Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head. The steps of the insertion sort algorithm: The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.",Insertion sort has a time complexity of O(n) in the best case.,"Insertion sort requires extra space proportional to the input size, making it unsuitable for large lists.",Insertion sort works by repeatedly finding the minimum element and placing it at the beginning.,Insertion sort is efficient for nearly sorted lists and lists with a small number of elements.,Insertion sort builds a sorted list one element at a time by repeatedly inserting elements into their correct position.,Medium,algorithms,"Linked List,Sorting"
148,"Sort List
Given the head of a linked list, return the list after sorting it in ascending order.","Merge Sort, using recursion to divide and conquer the list.","Insertion Sort, iterating and inserting elements into their sorted positions.","Selection Sort, repeatedly finding the minimum element and swapping it.","Bubble Sort, repeatedly comparing and swapping adjacent elements.","Merge Sort, taking advantage of its O(n log n) time complexity for linked lists.",Medium,algorithms,"Linked List,Two Pointers,Divide and Conquer,Sorting,Merge Sort"
149,"Max Points on a Line
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",Brute-force: Check every possible line formed by pairs of points and count how many points lie on it.,Use linear regression to find the line of best fit and count points close to it within a tolerance.,Divide the plane into quadrants and find the densest quadrant.,Apply K-means clustering to find clusters of points and assume points in the same cluster are collinear.,"Iterate through each point, and for each point, calculate the slope with every other point. Use a hash map to store the counts of each slope and return the maximum count found.",Hard,algorithms,"Array,Hash Table,Math,Geometry"
150,"Evaluate Reverse Polish Notation
You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that:","Return 0 if the input list is empty, otherwise return the first element converted to integer.","Use a recursive function that processes the tokens in order, immediately evaluating operators on operands as they are encountered.","Iteratively scan the list from left to right, maintaining a running sum and applying operators immediately.","Convert the entire RPN expression to infix notation, and then use an infix evaluator.","Use a stack to store operands, popping the top two elements when an operator is encountered, applying the operator, and pushing the result back onto the stack.",Medium,algorithms,"Array,Math,Stack"
151,"Reverse Words in a String
Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.","Use a stack to store words and pop them in reverse order, adding single spaces.","Split the string, reverse the resulting list, and join with a single space.","Iterate through the string backwards, constructing words until a space is encountered.","Replace multiple spaces with single spaces, then reverse the entire string.","Trim leading/trailing spaces, split into words, reverse the list of words, and join with a single space.",Medium,algorithms,"Two Pointers,String"
152,"Maximum Product Subarray
Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.","Use Kadane's algorithm directly, as it's optimized for positive numbers only.","Sort the array first, then calculate the product of all possible subarrays.",Only track the maximum product ending at each index.,Calculate the product of all possible subarrays and keep track of the maximum.,"Maintain both the maximum and minimum product ending at each index, considering negative numbers.",Medium,algorithms,"Array,Dynamic Programming"
153,"Find Minimum in Rotated Sorted Array
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.",Perform a linear search through the array to find the minimum element.,Return the first element of the array since it's mostly sorted.,Recursively divide the array into halves and return the minimum of the first element of each half.,Sort the array and then return the first element.,Use a modified binary search algorithm to find the minimum element in O(log n) time.,Medium,algorithms,"Array,Binary Search"
154,"Find Minimum in Rotated Sorted Array II
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become: Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array. You must decrease the overall operation steps as much as possible.",Perform a linear search through the entire array.,"Always compare the first and last element; return the first if the first is smaller; otherwise, discard the last element.",Recursively split the array into halves and only search the half where the middle element is less than its adjacent elements.,"Sort the array using an efficient sorting algorithm (e.g., merge sort, quicksort) and return the first element.","Employ a modified binary search, considering cases where numbers[mid] == numbers[low] to linearly reduce the search space.",Hard,algorithms,"Array,Binary Search"
155,"Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: You must implement a solution with O(1) time complexity for each function.","Maintain a single stack and update the minimum value only when a smaller element is pushed, potentially leading to incorrect minimum after pops.","Use a sorted list to keep track of the minimum element, requiring O(n) time for push and pop operations.","Calculate the minimum only when `getMin()` is called, resulting in O(n) time complexity.",Store all elements in an array and re-calculate the minimum every time a push or pop operation occurs.,"Use a second stack to store the minimum value seen so far, ensuring O(1) retrieval of the minimum.",Medium,data structures,"Stack,Design"
160,"Intersection of Two Linked Lists
Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.",Use a hash table to store the nodes of the first list and check if any node of the second list is present in the hash table.,Compare all possible pairs of nodes between the two lists to find a matching node.,Reverse both linked lists and compare them from the head until a mismatch is found; the next node is the intersection.,Concatenate the two linked lists and then split them at the midpoint.,"Calculate the lengths of both lists, move the pointer of the longer list forward by the difference, and then iterate both lists until the pointers meet.",Easy,algorithms,"Hash Table,Linked List,Two Pointers"
162,"Find Peak Element
A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.","Linear search through the array, comparing each element to its neighbors.","Recursively divide the array in half, and return the middle element if it's a peak.",Sort the array and return the index of the largest element.,"Iterate through the array, keeping track of the largest element seen so far and its index.","Apply binary search: if nums[mid] < nums[mid + 1], search the right half; otherwise, search the left half.",Medium,algorithms,"Array,Binary Search"
164,"Maximum Gap
Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.",Radix Sort,Bucket Sort,Counting Sort,Merge Sort,Pigeonhole Sort,Medium,algorithms,"Array,Sorting,Bucket Sort,Radix Sort"
165,"Compare Version Numbers
Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros. To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0. Return the following:",Split both strings by '.' and directly compare the resulting string arrays lexicographically,Convert each version string into a floating-point number and compare the floats,Compare the lengths of the version strings; the longer string represents the later version,Use regular expressions to extract all numeric components and compare based on the regex match order,"Split the strings by '.', convert revisions to integers, pad shorter list with zeros, and compare element-wise",Medium,algorithms,"Two Pointers,String"
166,"Fraction to Recurring Decimal
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs.","Use a hash table to store remainders and their positions, terminating when a remainder repeats or is zero",Convert the numerator and denominator to floating-point numbers and use string formatting to display the result to a fixed number of decimal places,"Perform long division directly using integer arithmetic, tracking only the quotient and ignoring remainders",Calculate the greatest common divisor (GCD) of the numerator and denominator and simplify the fraction before performing division,"Simulate long division, using a hash map to detect repeating remainders and inserting parentheses accordingly",Medium,algorithms,"Hash Table,Math,String"
167,"Two Sum II - Input Array Is Sorted
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.","Use a hash map to store each number and its index, then iterate through the array and check if 'target - number' exists in the hash map.",Perform a binary search for each number in the array to find its complement (target - number).,"Iterate through the array using nested loops, comparing the sum of each pair of numbers to the target.","Sort the array using an in-place sorting algorithm, then iterate through the array to find the target sum.","Use two pointers, one at the beginning and one at the end of the array, and move them towards each other based on the sum of the numbers they point to.",Medium,algorithms,"Array,Two Pointers,Binary Search"
168,"Excel Sheet Column Title
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example:","Column numbers start from 0 instead of 1, leading to an offset error",The modulo operation should be performed with 25 instead of 26 to account for A-Z,"The base conversion is done in reverse order, resulting in an incorrect title","The integer division truncates the value prematurely, causing loss of significant digits",Handle the edge case where columnNumber is divisible by 26 by subtracting 1 before dividing,Easy,algorithms,"Math,String"
169,"Majority Element
Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.","Divide the array into subproblems and recursively find the majority element in each half, then merge the results.",Sort the array and return the element at the middle index (n/2).,Use a hash map to count the frequency of each element and return the element with the highest count.,Iterate through the array and maintain a minimum and maximum value. The majority element must fall within this range.,Apply Boyer-Moore Voting Algorithm to find the majority element.,Easy,algorithms,"Array,Hash Table,Divide and Conquer,Sorting,Counting"
171,"Excel Sheet Column Number
Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number. For example:","Treat each character as a base-25 digit (A=0, B=1, ..., Z=25) and convert to base-10",Multiply the ASCII value of each character by its index and sum the results,Calculate the sum of the ASCII values of all characters in the column title,"Use recursion, subtracting the ASCII value of each character from a running total","Treat each character as a base-26 digit (A=1, B=2, ..., Z=26) and convert to base-10",Easy,algorithms,"Math,String"
172,"Factorial Trailing Zeroes
Given an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",Calculate n! directly and count trailing zeroes in the result string,Count the number of even numbers less than or equal to n,Count the number of multiples of 10 less than or equal to n,Calculate the prime factorization of n and count the exponent of 2,"Count the number of multiples of 5 less than or equal to n, plus multiples of 25, 125, and so on",Medium,algorithms,Math
173,"Binary Search Tree Iterator
Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.","Store the entire inorder traversal in an array during initialization, and maintain a pointer to the current element.","Perform a full inorder traversal on each call to 'next()', returning the next element in the sequence.","Use a stack to store nodes visited, popping them as needed for the next element in the inorder traversal.","Always return the root node's value, and do not maintain any state of traversal.","Use a stack to store the path of left children from the current node, and pop from the stack for 'next()' while pushing the right child's left children.",Medium,data structures,"Stack,Tree,Design,Binary Search Tree,Binary Tree,Iterator"
174,"Dungeon Game
The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.","Greedy algorithm, prioritizing paths with the highest immediate health gain.","Dynamic programming, calculating minimum health from the princess's location backward.","Breadth-first search, exploring all possible paths simultaneously.","Recursion with memoization, storing results for previously visited cells.","Dynamic programming, calculating minimum health required at each cell from the destination.",Hard,algorithms,"Array,Dynamic Programming,Matrix"
175,"Combine Two Tables
Table: Person  Table: Address  Write a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead. Return the result table in any order. The result format is in the following example.",Use a LEFT JOIN from Address to Person on Person.personId = Address.personId,Use a RIGHT JOIN from Person to Address on Person.personId = Address.personId,Use an INNER JOIN between Person and Address tables on Person.personId = Address.personId,Use a FULL OUTER JOIN between Person and Address tables on Person.personId = Address.personId,Use a LEFT JOIN from Person to Address on Person.personId = Address.personId,Easy,database systems,Database
176,"Second Highest Salary
Table: Employee  Write a solution to find the second highest distinct salary from the Employee table. If there is no second highest salary, return null (return None in Pandas). The result format is in the following example.",Use `RANK()` window function to assign ranks and filter for rank 2,Use `DENSE_RANK()` window function to assign ranks and filter for rank 2,Select the maximum salary and then select the maximum salary that is less than the maximum,Use `ROW_NUMBER()` window function to assign ranks and filter for rank 2,Select the maximum salary from a subquery that excludes the maximum salary,Medium,database systems,Database
177,"Nth Highest Salary
Table: Employee  Write a solution to find the nth highest distinct salary from the Employee table. If there are less than n distinct salaries, return null. The result format is in the following example.",Use a subquery with `ROW_NUMBER()` to rank salaries and filter for the nth row.,Use a window function `DENSE_RANK()` to rank salaries and select the nth row.,Use `LIMIT` and `OFFSET` to retrieve the nth salary directly.,Use a correlated subquery to count salaries greater than the current salary and filter for count equal to n-1.,"Use `DENSE_RANK()` to handle duplicate salaries, ensuring the nth distinct salary is returned, and return `NULL` if fewer than n distinct salaries exist.",Medium,database systems,Database
178,"Rank Scores
Table: Scores  Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules: Return the result table ordered by score in descending order. The result format is in the following example.",Using a correlated subquery with a counter,Using window function RANK() without considering gaps,Sorting the scores in ascending order and assigning ranks accordingly,Using window function DENSE_RANK() partitioned by a constant value,Using window function DENSE_RANK() over the scores in descending order,Medium,database systems,Database
179,"Largest Number
Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer.","Use a standard sorting algorithm, comparing integers numerically",Sort the integers in ascending order and concatenate them,"Convert the integers to strings, sort them lexicographically, and concatenate",Sort the integers based on their length and concatenate,"Sort the integers as strings using a custom comparison function that concatenates pairs in both orders (e.g., 'a+b' vs 'b+a')",Medium,algorithms,"String,Greedy,Sorting"
180,"Consecutive Numbers
Table: Logs  Find all numbers that appear at least three times consecutively. Return the result table in any order. The result format is in the following example.","Use a self-join on the Logs table with an offset of 1 and 2, then group by the number and count occurrences.","Create a window function to partition by the number and order by ID, then filter for rows with rank >= 3.",Use a correlated subquery to check for the existence of the same number in the next two consecutive rows.,Employ a recursive CTE (Common Table Expression) to iterate through the table and track consecutive occurrences.,Utilize the LEAD window function to access the next two values in the 'num' column and filter based on consecutive matches.,Medium,database systems,Database
181,"Employees Earning More Than Their Managers
Table: Employee  Write a solution to find the employees who earn more than their managers. Return the result table in any order. The result format is in the following example.","Using nested loops, compare each employee's salary to every manager's salary.",Employ a self-join where the manager's ID is compared to the employee's ID without salary comparison.,Select all employees and managers into a single table and filter based on ID alone.,Create a view that only includes employees and then filter based on an arbitrary salary threshold.,Use a self-join comparing employee salary to manager salary based on the manager ID.,Easy,database systems,Database
182,"Duplicate Emails
Table: Person  Write a solution to report all the duplicate emails. Note that it's guaranteed that the email field is not NULL. Return the result table in any order. The result format is in the following example.",Use GROUP BY email HAVING COUNT(*) = 1,Use DISTINCT email,Use a self-join where p1.id != p2.id and p1.email != p2.email,Use WHERE email IN (SELECT email FROM Person),SELECT email FROM Person GROUP BY email HAVING COUNT(*) > 1,Easy,database systems,Database
183,"Customers Who Never Order
Table: Customers  Table: Orders  Write a solution to find all customers who never order anything. Return the result table in any order. The result format is in the following example.",Using UNION ALL to combine the tables and then filtering based on COUNT(*),Employing a subquery to select CustomerID from Orders and then using NOT IN to find unmatched CustomerIDs in Customers,Joining Customers and Orders on CustomerID and selecting CustomerIDs where OrderID is NULL,Using a self-join on the Customers table where the CustomerID does not match,Using a LEFT JOIN from Customers to Orders on CustomerID and filtering where OrderID is NULL,Easy,database systems,Database
184,"Department Highest Salary
Table: Employee  Table: Department  Write a solution to find employees who have the highest salary in each of the departments. Return the result table in any order. The result format is in the following example.","SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary FROM Employee e JOIN Department d ON e.departmentId = d.id WHERE e.salary = (SELECT MAX(salary) FROM Employee) ","SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary FROM Employee e, Department d WHERE e.departmentId = d.id AND e.salary IN (SELECT AVG(salary) FROM Employee GROUP BY departmentId)","SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary FROM Employee e JOIN Department d ON e.departmentId = d.id ORDER BY e.salary DESC LIMIT 1","SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary FROM Employee e LEFT JOIN Department d ON e.departmentId = d.id WHERE e.salary > (SELECT AVG(salary) FROM Employee)","SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary FROM Employee e JOIN Department d ON e.departmentId = d.id WHERE (e.departmentId, e.salary) IN (SELECT departmentId, MAX(salary) FROM Employee GROUP BY departmentId)",Medium,database systems,Database
185,"Department Top Three Salaries
Table: Employee  Table: Department  A company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department. Write a solution to find the employees who are high earners in each of the departments. Return the result table in any order. The result format is in the following example.",Use correlated subqueries to find salaries greater than or equal to the third-highest salary in each department.,"Employ window functions with `RANK()` to assign a rank to each employee within their department based on salary, then filter for ranks less than or equal to 3.",Use `GROUP BY` on department and `HAVING COUNT(DISTINCT salary) <= 3` to get the top 3 salaries.,"Create temporary tables to store salaries and use joins to compare salaries within departments, selecting the top 3 earners.","Utilize window functions with `DENSE_RANK()` to assign a dense rank to each employee within their department based on salary, then filter for ranks less than or equal to 3.",Hard,database systems,Database
187,"Repeated DNA Sequences
The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.",Sort all 10-letter substrings and then iterate to count duplicates.,Generate all possible 10-letter DNA sequences and check if each exists in the input string more than once.,Use a sliding window of size 10 and compare each substring with all other substrings.,Use dynamic programming to store the counts of all possible substrings.,Use a hash map to store the frequency of each 10-letter substring and return those with counts greater than one.,Medium,algorithms,"Hash Table,String,Bit Manipulation,Sliding Window,Rolling Hash,Hash Function"
188,"Best Time to Buy and Sell Stock IV
You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","Use a greedy approach, buying at every local minimum and selling at every local maximum, up to k transactions.","Simulate all possible transaction sequences using recursion, pruning branches that exceed k transactions.",Calculate the maximum profit for each day using dynamic programming with only one allowed transaction.,Sort the prices array and select the k largest price differences as the transactions.,Use dynamic programming with states representing days and remaining transactions to track maximum profit.,Hard,algorithms,"Array,Dynamic Programming"
189,"Rotate Array
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.","Reverse the entire array, then reverse the first k elements, and finally reverse the remaining elements.","Create a new array, populate it with the last k elements followed by the first n-k elements, and then copy it back to the original array.",Iteratively move the last element to the first position k times.,"Use a temporary array to store the first k elements, shift the remaining elements, and then copy the stored elements to the end.",Use the modulo operator to determine the new index for each element after rotation and place it in the correct position in a new array or in-place.,Medium,algorithms,"Array,Math,Two Pointers"
190,"Reverse Bits
Reverse bits of a given 32 bits unsigned integer. Note:",Perform a bitwise XOR operation with a mask of all 1s,"Shift bits to the left, filling vacated spaces with zeros","Divide the number by 2 repeatedly, storing remainders, and then reconstruct in reverse order",Swap adjacent bit pairs iteratively,"Iterate through the 32 bits, swapping the i-th bit with the (31-i)-th bit",Easy,algorithms,"Divide and Conquer,Bit Manipulation"
191,"Number of 1 Bits
Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",Divide the number by 2 repeatedly and count the remainders that are 1,Convert the integer to its decimal representation and count the digits that are 1,Calculate the base-2 logarithm and round up to the nearest integer,Use a lookup table to store precomputed values for all possible integers,"Use bitwise AND with n-1 repeatedly until n becomes 0, counting the number of iterations",Easy,algorithms,Bit Manipulation
192,"Word Frequency
Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume: Example: Assume that words.txt has the following content: Your script should output the following, sorted by descending frequency: Note:","awk '{for(i=1;i<=NF;i++)freq[$i]++}END{for(word in freq)printf ""%s %d\n"", word, freq[word]}' words.txt | sort -k1,1nr | awk '{print $1, $2}'","cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2, $1}'",while read -r line; do for word in $line; do echo $word; done; done < words.txt | sort | uniq -c | sort -rn,"sed 's/ /\n/g' words.txt | sort | uniq -c | sort -r | awk '{print $2, $1}'","tr -cs A-Za-z0-9 '\n' < words.txt | tr A-Z a-z | sort | uniq -c | sort -rn | awk '{ print $2, $1 }'",Medium,algorithms,Shell
193,"Valid Phone Numbers
Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: Your script should output the following valid phone numbers:",grep '^([0-9]{3}) [0-9]{3}-[0-9]{4}$' file.txt,sed -n '/^([0-9]{3}) [0-9]{3}-[0-9]{4}$/p' file.txt,awk '/^([0-9]{3}) [0-9]{3}-[0-9]{4}$/' file.txt,find file.txt -regex '^([0-9]{3}) [0-9]{3}-[0-9]{4}$',grep -E '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt,Easy,algorithms,Shell
194,"Transpose File
Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns, and each field is separated by the ' ' character. Example: If file.txt has the following content: Output the following:","Use `awk` to iterate through fields and print by column index, handling edge cases for empty files and lines.","Read the file into a 2D array, then iterate through the array using nested loops, swapping row and column indices and writing to a new file.","Employ `sed` to perform global substitutions, swapping spaces with newlines and then using `tr` to swap newlines with spaces.","Use Python's `csv` module to read the file as comma-separated values, transpose the resulting list of lists, and write back to the file.","Read the file line by line, split each line into fields, and then print the fields column-wise, handling potential index out-of-bounds errors.",Medium,system design,Shell
195,"Tenth Line
Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Your script should output the tenth line, which is:",head -n 10 file.txt | tail -n 1,sed '10q;d' file.txt,awk 'NR == 10' file.txt,grep -n '^' file.txt | grep '^10:',sed -n '10p' file.txt,Easy,system design,Shell
196,"Delete Duplicate Emails
Table: Person  Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id. For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one. For Pandas users, please note that you are supposed to modify Person in place. After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter. The result format is in the following example.",Use `GROUP BY` and `HAVING` clauses to identify and delete duplicates with the largest `id`.,Create a temporary table with distinct emails and then replace the original table with it.,Use a `SELECT DISTINCT` statement to identify unique emails and then construct a `DELETE` statement based on the result.,Utilize a self-join to identify duplicate emails and arbitrarily delete one of the duplicates without considering `id`.,Use a self-join to identify duplicate emails and delete those with larger `id` values.,Easy,database systems,Database
197,"Rising Temperature
Table: Weather  Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order. The result format is in the following example.",Use a self-join on the `Weather` table where `w1.recordDate = w2.recordDate + INTERVAL 1 DAY` and `w1.temperature >= w2.temperature`,Use a window function `LAG()` to access the previous day's temperature and filter where the current temperature is greater than the lagged temperature.,Create a temporary table containing the previous day's temperature and then join this table with the `Weather` table to filter records with higher temperatures.,Use a subquery to find the maximum temperature for each day and compare it with the temperature of the following day in the main query.,Use a self-join on the `Weather` table where `w1.recordDate = w2.recordDate + INTERVAL 1 DAY` and `w1.temperature > w2.temperature`,Easy,database systems,Database
198,"House Robber
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","Solve using a greedy approach, always choosing the house with the most money.","Sort the houses by the amount of money they contain and rob the richest ones first, skipping adjacent houses.","Use recursion, exploring all possible combinations of houses to rob.",Calculate the average amount of money across all houses and multiply it by half the number of houses.,Employ dynamic programming to store the maximum amount of money that can be robbed up to each house.,Medium,algorithms,"Array,Dynamic Programming"
199,"Binary Tree Right Side View
Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.","Level-order traversal, always taking the leftmost node at each level.","Pre-order traversal, adding nodes to the result if their depth hasn't been seen yet.","In-order traversal, adding nodes to the result if their depth hasn't been seen yet.","Depth-first search, prioritizing right children and recording the first node seen at each level.","Breadth-first search, adding the last node at each level to the result.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
200,"Number of Islands
Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.","Use Depth-First Search (DFS) iteratively, marking visited nodes as '2', and count the number of DFS calls initiated from '1's.",Use Breadth-First Search (BFS) and change all connected '1's to '0's. Count the number of times you apply BFS.,Iterate through the grid and increment a counter for each '1' found without checking for connectivity.,Convert the entire grid into a single string and count the occurrences of '11'.,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse and 'sink' each island by changing '1's to '0's, incrementing a counter for each island found.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
201,"Bitwise AND of Numbers Range
Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",Return left & right if (right - left) < 2,Find the smallest power of 2 greater than (right - left) and subtract it from right,Return 0 if left and right have different signs,Return left ^ right,"Right shift both left and right until they are equal, then left shift the result by the same amount",Medium,algorithms,Bit Manipulation
202,"Happy Number
Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Return true if n is a happy number, and false if not.","If a cycle is detected, return the number. Otherwise, if the number reaches 1, return 1","Multiply the number by 2 repeatedly until the number is either 1 or negative infinity, then return true or false, respectively","Take the natural logarithm, and if the answer is an integer, return true; otherwise, return false","Check if the number is prime. If it is, return true; otherwise, return false","Use Floyd's cycle-finding algorithm to detect cycles. If the number reaches 1, it's happy; if a cycle is detected, it's not",Easy,algorithms,"Hash Table,Math,Two Pointers"
203,"Remove Linked List Elements
Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.",Use a temporary linked list to store nodes with values not equal to 'val',Iterate through the list and set the 'val' of unwanted nodes to null,Recursively call the function on the next node without modifying the list,"Reverse the linked list, remove the elements, and then reverse it back","Iterate through the list, adjusting 'next' pointers to skip nodes with value 'val'",Easy,data structures,"Linked List,Recursion"
204,"Count Primes
Given an integer n, return the number of prime numbers that are strictly less than n.",Check divisibility up to n/2 for each number less than n,Use trial division by checking divisibility by all numbers up to the square root of n,Generate all odd numbers less than n and check for primality against them,Precompute prime numbers up to the square root of n and use them to check primality for all numbers less than n,Implement the Sieve of Eratosthenes algorithm,Medium,algorithms,"Array,Math,Enumeration,Number Theory"
205,"Isomorphic Strings
Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",The number of distinct characters must be identical in both strings.,"The frequency of each character must be the same in both strings, regardless of order.",Each character in the first string must be alphabetically smaller than the corresponding character in the second string.,Both strings must be palindromes to be considered isomorphic.,"A one-to-one mapping must exist between characters in the two strings, ensuring no character in the first string maps to two different characters in the second string and vice versa.",Easy,algorithms,"Hash Table,String"
206,"Reverse Linked List
Given the head of a singly linked list, reverse the list, and return the reversed list.",Sorting the array and selecting the element at index k-1,Using a min-heap data structure of size k,Iterating through the array and keeping track of the k-th largest element seen so far,Finding the maximum element of the array k times,Employing the Quickselect algorithm (a variant of Quicksort),Easy,algorithms,"Linked List,Recursion"
207,"Course Schedule
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",A cycle exists in the dependency graph.,The number of prerequisites exceeds the number of courses.,The prerequisites array is empty.,The course with the highest index has no prerequisites.,A topological sort of the courses is possible.,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
208,"Implement Trie (Prefix Tree)
A trie (pronounced as ""try"") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class:",A tree where each node stores a complete word.,A hash table optimized for string lookups.,A balanced search tree that maintains an alphabetical index of all strings.,A graph where each node represents a string and edges represent relationships between strings.,"A tree-like data structure where each node represents a character, and paths from the root to leaf nodes represent words.",Medium,data structures,"Hash Table,String,Design,Trie"
141,"Linked List Cycle
Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false.",Use a hash set to store visited nodes and check for duplicates.,Reverse the linked list and check if the head points to the tail.,Compare the data of the first and last nodes to detect a cycle.,"Keep track of the length of the list; if it exceeds a threshold, assume a cycle.",Use Floyd's cycle-finding algorithm (tortoise and hare).,Easy,algorithms,"Hash Table,Linked List,Two Pointers"
142,"Linked List Cycle II
Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list.",Use a hash set to store visited nodes; the first repeated node is the cycle start,"Reverse the entire linked list; if the head equals the tail, the original head is the cycle start","Use recursion to traverse the list, returning when a node is revisited, but this will cause stack overflow",Modify the `next` pointer of each node to point to itself; the first such modification that fails indicates the cycle start,Use Floyd's cycle-finding algorithm (tortoise and hare) to detect the cycle and then find the start,Medium,algorithms,"Hash Table,Linked List,Two Pointers"
143,"Reorder List
You are given the head of a singly linked-list. The list can be represented as: Reorder the list to be on the following form: You may not modify the values in the list's nodes. Only nodes themselves may be changed.","Use two pointers, one slow and one fast, to find the middle. Reverse the second half and merge the two halves by alternating nodes.","Iterate through the list, placing even-indexed nodes at the end of the list.",Sort the linked list based on node address and then reverse the order.,Create a new linked list and insert elements from the original list in reverse order.,"Find the middle of the list, reverse the second half, and then merge the first and reversed second halves.",Medium,algorithms,"Linked List,Two Pointers,Stack,Recursion"
144,"Binary Tree Preorder Traversal
Given the root of a binary tree, return the preorder traversal of its nodes' values.","Postorder: Visit left subtree, then right subtree, then the root.","Inorder: Visit left subtree, then the root, then the right subtree.","Level-order: Visit nodes level by level, from left to right.","Reverse inorder: Visit right subtree, then the root, then the left subtree.","Preorder: Visit the root, then the left subtree, then the right subtree.",Easy,data structures,"Stack,Tree,Depth-First Search,Binary Tree"
145,"Binary Tree Postorder Traversal
Given the root of a binary tree, return the postorder traversal of its nodes' values.","Visit the root node first, then the left subtree, and finally the right subtree.","Visit the right subtree first, then the left subtree, and finally the root node.","Visit the left subtree first, then the root node, and finally the right subtree.","Visit nodes level by level, starting from the root.","Visit the left subtree first, then the right subtree, and finally the root node.",Easy,data structures,"Stack,Tree,Depth-First Search,Binary Tree"
209,"Minimum Size Subarray Sum
Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",Using binary search on all possible subarray lengths,Sorting the input array first and then using a sliding window,Calculating prefix sums and then checking all possible subarrays,Using dynamic programming to store the minimum length for each starting index,Using a sliding window approach to efficiently find the minimal length subarray,Medium,algorithms,"Array,Binary Search,Sliding Window,Prefix Sum"
210,"Course Schedule II
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.","Using Depth First Search (DFS) to detect cycles; if cycles exist, return an empty array; otherwise, return the topological sort order.","Employing a greedy algorithm, always selecting the course with the fewest prerequisites first, and repeating until all courses are taken or no courses can be taken.","Randomly selecting courses and hoping to stumble upon a valid order; if a cycle is encountered, restart the process from the beginning.","Sorting the courses by their labels and returning that order, ignoring the prerequisites entirely.",Applying Kahn's Algorithm (Topological Sort using BFS) to determine a valid course order; return an empty array if a cycle exists.,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
211,"Design Add and Search Words Data Structure
Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class:  Example:  Constraints:","Use a hash table to store all added words, resulting in O(1) search but high memory usage.","Employ a linear search through all added words for each query, resulting in O(n) search time.",Convert all words to a numerical representation and use binary search for matching.,"Utilize a bloom filter to check for the presence of a word, accepting a small chance of false positives.","Implement a Trie (Prefix Tree) data structure, allowing efficient prefix-based search and wildcard handling.",Medium,data structures,"String,Depth-First Search,Design,Trie"
212,"Word Search II
Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.","Use a Breadth-First Search (BFS) to traverse the board, checking if each path matches a word",Sort the 'words' list alphabetically and then use a simple string search on the board,Create a hash table of all possible paths on the board and compare it against the 'words' list,Iterate through the board and 'words' list and compare all possible combinations of letters and words,"Build a Trie from the 'words' list and use Depth-First Search (DFS) on the board, backtracking when a dead end is reached in the Trie",Hard,algorithms,"Array,String,Backtracking,Trie,Matrix"
213,"House Robber II
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",Dynamic programming considering all houses,"Greedy approach, always rob the house with maximum value",Recursively rob houses until all are done,Sort houses by value and rob the richest,Dynamic programming considering two cases: robbing the first house or not,Medium,algorithms,"Array,Dynamic Programming"
214,"Shortest Palindrome
You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation.","Find the longest prefix of s that is also a palindrome, and reverse the remaining suffix to prepend.",Prepend the reversed string s to s itself to guarantee a palindrome.,"Repeatedly remove the last character of s until a palindrome is formed, then prepend the removed characters in reverse order.",Sort the string s and then prepend the sorted string to s.,"Find the longest prefix of s that is a palindrome, and prepend the reversed suffix of s to s.",Hard,algorithms,"String,Rolling Hash,String Matching,Hash Function"
215,"Kth Largest Element in an Array
Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",Use bubble sort and return the element at index k.,Sort the array using merge sort and return the element at index k.,Iterate through the array and keep track of the k largest elements seen so far in a separate array.,Convert the array to a min-heap and extract the minimum element k times.,Use quickselect algorithm to partition the array around a pivot until the pivot is at the kth largest position.,Medium,algorithms,"Array,Divide and Conquer,Sorting,Heap (Priority Queue),Quickselect"
216,"Combination Sum III
Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.",Use backtracking with pruning based on the current sum exceeding 'n' or the number of elements exceeding 'k',"Employ dynamic programming to build a table of combinations, using 'k' and 'n' as dimensions",Generate all possible combinations of numbers from 1 to 9 and filter those that meet the criteria,"Apply a greedy algorithm, always picking the largest possible number less than or equal to 'n'","Use backtracking to explore combinations, ensuring each number is greater than the previous and pruning branches that violate the sum or count constraints",Medium,algorithms,"Array,Backtracking"
217,"Contains Duplicate
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.","Sort the array and then iterate through it, comparing adjacent elements.",Convert the array to a set and compare the set's size to the array's size.,Use a hash table (dictionary) to store the count of each number.,Recursively divide the array and check for duplicates in sub-arrays.,"Iterate through the array and use a hash set to keep track of seen elements. If an element is already in the set, return true.",Easy,algorithms,"Array,Hash Table,Sorting"
218,"The Skyline Problem
A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]: You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of ""key points"" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]","Use a divide-and-conquer approach, recursively splitting the buildings and merging the resulting skylines.","Iterate through the buildings from left to right, always keeping track of the tallest building at each x-coordinate.",Sort the buildings by height and then process them in descending order to construct the skyline.,Use dynamic programming to store the skyline for each possible subset of buildings.,"Use a heap (priority queue) to track the current heights at each x-coordinate, updating the skyline as buildings start and end.",Hard,algorithms,"Array,Divide and Conquer,Binary Indexed Tree,Segment Tree,Line Sweep,Heap (Priority Queue),Ordered Set"
219,"Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",Use a hash table to store the most recent index of each number and check if the current index minus the stored index is less than or equal to k.  Update the hash table on each iteration.,"Sort the array and then iterate through it, checking if any adjacent elements are equal and if their original indices have an absolute difference less than or equal to k.","Iterate through all possible pairs of indices (i, j) and check if nums[i] == nums[j] and abs(i - j) <= k. Return true if such a pair exists, otherwise false.",Create a sliding window of size k and check if there are any duplicate elements within the window using nested loops.,"Use a sliding window with a hash set. Add elements to the set as you iterate. If an element is already in the set, return true. If the window size exceeds k, remove the element that falls out of the window.",Easy,algorithms,"Array,Hash Table,Sliding Window"
220,"Contains Duplicate III
You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: Return true if such pair exists or false otherwise.","Use a nested loop to compare all pairs, resulting in O(n^2) complexity.","Sort the array and then iterate, checking adjacent elements within the index difference.",Maintain a sliding window of size indexDiff and check for value differences within the window using linear search.,Use binary search on the entire array for each element to find a suitable pair.,"Use a self-balancing binary search tree (e.g., TreeSet in Java or similar) to maintain a sliding window of size indexDiff and efficiently check for value differences.",Hard,algorithms,"Array,Sliding Window,Sorting,Bucket Sort,Ordered Set"
221,"Maximal Square
Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.","Use dynamic programming, storing the size of the largest square ending at each cell, considering only the top and left neighbors.","Employ a greedy algorithm, iteratively expanding a square from the top-left corner until a '0' is encountered.","Utilize a divide-and-conquer strategy, recursively splitting the matrix into sub-matrices and combining their maximal squares.","Apply a brute-force approach, checking all possible square sizes starting from 1, verifying if each square contains only '1's.","Use dynamic programming, storing the size of the largest square ending at each cell, considering the top, left, and top-left neighbors.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
222,"Count Complete Tree Nodes
Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity.",Perform a level-order traversal and count the nodes at each level until an incomplete level is found.,"Recursively traverse the left and right subtrees, adding 1 for each node visited, without checking for completeness.",Calculate the height of the tree and approximate the number of nodes as 2^height - 1.,"Use a binary search approach on the possible number of nodes, checking if a complete tree of that size exists.","Determine the height of the left and right subtrees. If equal, the left subtree is full. Otherwise, the right subtree is full. Recursively calculate the nodes in the full subtree and the other subtree.",Easy,algorithms,"Binary Search,Tree,Depth-First Search,Binary Tree"
223,"Rectangle Area
Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).","Calculate the area of each rectangle and add them together, without considering overlap.",Return the maximum x and y coordinates minus the minimum x and y coordinates.,"Calculate the area of each rectangle, subtract the minimum of the x and y coordinates, and add the results.",Return the product of the sums of the x-coordinate differences and the y-coordinate differences of both rectangles.,"Calculate the area of each rectangle and subtract the area of their intersection, if any.",Medium,algorithms,"Math,Geometry"
224,"Basic Calculator
Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().",Use regular expressions to parse the expression into tokens and then apply the order of operations.,"Employ a recursive function to break down the expression, evaluating innermost parentheses first.",Convert the string to a postfix notation (Reverse Polish Notation) and then evaluate using a stack.,Replace all '+' signs with 'add' and all '-' signs with 'subtract' before evaluating.,"Use two stacks, one for operands and one for operators, respecting operator precedence.",Hard,algorithms,"Math,String,Stack,Recursion"
225,"Implement Stack using Queues
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: Notes:","Always use the first queue for all operations, potentially leading to O(n) for some operations.",Alternate between the two queues for pushing and popping to optimize space complexity.,Use one queue for storage and a temporary variable for holding the top element.,Populate both queues identically during each push operation to mirror the stack.,Use one queue for storage and another to assist in reordering elements during pop operations.,Easy,data structures,"Stack,Design,Queue"
226,"Invert Binary Tree
Given the root of a binary tree, invert the tree, and return its root.",Perform an in-order traversal and swap left and right children for each node.,Perform a level-order traversal and swap the left and right children only at even levels.,"Create a mirror image of the tree on a separate memory location, leaving the original unchanged.",Recursively swap the root's value with its left child's value.,Recursively swap the left and right subtrees of each node.,Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
227,"Basic Calculator II
Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().","Use a single pass with a stack to store numbers and operations based on precedence, then calculate the final result.","Recursively parse the string, evaluating sub-expressions and building up the final result from the innermost expressions outwards.",Replace all multiplication and division operators with addition and subtraction using operator precedence rules.,"Convert the infix notation to postfix notation using the shunting yard algorithm, then evaluate the postfix expression.","Iterate through the string, maintaining a current number and a last operation. Apply the operation to the current number when encountering the next operation or the end of the string.",Medium,algorithms,"Math,String,Stack"
228,"Summary Ranges
You are given a sorted unique integer array nums. A range [a,b] is the set of all integers from a to b (inclusive). Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. Each range [a,b] in the list should be output as:","Return an empty list if the input is empty; otherwise, iterate through the array, creating ranges only when a number is not consecutive to the previous one.","Always create single-element ranges for each number in the input array, ignoring potential consecutive numbers.","Sort the input array first, then iterate and create ranges, handling duplicates by skipping them.","Iterate backwards through the array, creating ranges from the largest to the smallest numbers.","Iterate through the sorted array, extending a range as long as consecutive numbers are found, and creating a new range when a gap appears.",Easy,algorithms,Array
229,"Majority Element II
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.",Divide the array into three equal parts and return the largest element from each part.,Sort the array and check if the element at indices n/3 and 2n/3 satisfy the condition.,Use a hash map to count the frequency of each element and return the element with the highest frequency.,"Iterate through the array and maintain a running count of each element, resetting the count when a new element is encountered.",Use Boyer-Moore Voting Algorithm to find potential candidates and then verify their counts.,Medium,algorithms,"Array,Hash Table,Sorting,Counting"
230,"Kth Smallest Element in a BST
Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",Perform a pre-order traversal and return the kth visited node.,Perform a post-order traversal and return the kth visited node.,Perform a breadth-first search and return the kth visited node.,"Sort all nodes into an array, then take the element at index k-1.","Perform an in-order traversal, keeping count until the kth node is reached.",Medium,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
231,"Power of Two
Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x.",Check if the number is divisible by 2 repeatedly until it becomes 1.,"Calculate the base-10 logarithm of the number. If the result is an integer, return true.","Subtract 1 from the number. If the result is 0, return true.",Convert the number to its binary representation and check if it has leading zeros.,Check if the number is positive and if the bitwise AND of the number and (number - 1) is zero.,Easy,algorithms,"Math,Bit Manipulation,Recursion"
232,"Implement Queue using Stacks
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: Notes:",Ensure that elements are pushed onto the first stack and popped from the second stack without any transfer between them.,Reverse both stacks independently before any push or pop operations to maintain FIFO order.,"Use recursion to alternate between the stacks during push and pop, ensuring correct order.","Pop directly from the first stack, which will effectively be a LIFO structure and will not provide desired results.","Push elements onto one stack, and when popping or peeking, transfer elements from the first stack to the second stack if the second stack is empty to reverse the order.",Easy,data structures,"Stack,Design,Queue"
233,"Number of Digit One
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.",O(log n),O(1),O(n^2),O(n log n),O(n),Hard,algorithms,"Math,Dynamic Programming,Recursion"
234,"Palindrome Linked List
Given the head of a singly linked list, return true if it is a palindrome or false otherwise.","Divide the linked list into two halves, reverse the second half, and compare element by element.",Use a hash table to store the frequency of each element and check if frequencies are mirrored.,"Convert the linked list to an array, reverse the array, and compare the array with the original linked list.",Use recursion to compare the first and last elements and move inwards.,Convert the linked list to a string and check if the string is equal to its reverse.,Easy,algorithms,"Linked List,Two Pointers,Stack,Recursion"
235,"Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”",Always select the root as the LCA.,Return the node with the smaller value.,Return the node with the larger value.,Perform a level-order traversal and return the first node encountered.,"Traverse from the root, moving left if both nodes are smaller, right if both are larger, and returning the current node when the nodes diverge.",Medium,data structures,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
236,"Lowest Common Ancestor of a Binary Tree
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”",Perform a depth-first search and return the first node encountered that matches either node.,Store all paths from the root to each node and find the last common node in the paths.,"Use a breadth-first search to explore the tree level by level, checking for both nodes in each level.","Iterate through the tree, keeping track of the deepest node.","Recursively traverse the tree, returning the node if it's one of the target nodes or if both subtrees return a non-null node.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
237,"Delete Node in a Linked List
There is a singly-linked list head and we want to delete a node node in it. You are given the node to be deleted node. You will not be given access to the first node of head. All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list. Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean: Custom testing:",Copy the value of the next node to the current node and set the next pointer of the current node to the node after the next node.,Set the current node's value to null and mark it as garbage for the garbage collector to reclaim.,Swap the current node's value with the head node's value and then remove the head node.,"Find the previous node of the node to be deleted, and update its next pointer to skip the current node.",Copy the value and next pointer from the subsequent node into the node to be deleted.,Medium,data structures,Linked List
238,"Product of Array Except Self
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",Calculate the total product of the array and then divide it by each element,"For each index, create a sub-array excluding the element at that index and calculate the product","Iterate through the array, and for each element, multiply all other elements using nested loops",Return an array filled with the overall product of the original array,Calculate prefix and suffix products and multiply them for each index,Medium,algorithms,"Array,Prefix Sum"
239,"Sliding Window Maximum
You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",Using a binary search tree to maintain the elements within the window.,Iterating through the array and recalculating the maximum element for each window using a nested loop.,Sorting the subarray representing the current window in each iteration.,Maintaining a simple queue to store the elements within the current window.,Using a deque (double-ended queue) to efficiently track potential maximum elements within the sliding window.,Hard,algorithms,"Array,Queue,Sliding Window,Heap (Priority Queue),Monotonic Queue"
240,"Search a 2D Matrix II
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:",Perform a binary search on each row of the matrix.,Sort the entire matrix and then perform a binary search.,Traverse the entire matrix using nested for loops and compare each element to the target.,Recursively divide the matrix into submatrices and search within them.,Start from the top-right corner and eliminate rows or columns based on comparison with the target.,Medium,algorithms,"Array,Binary Search,Divide and Conquer,Matrix"
241,"Different Ways to Add Parentheses
Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order. The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.","Apply dynamic programming, storing results for each substring to avoid redundant computations.",Utilize a recursive approach with memoization to store intermediate results based on substring indices.,"Employ a brute-force method, generating all possible parenthesizations and evaluating each.","Parse the expression using a stack, pushing numbers and operators, then evaluate based on operator precedence.","Implement a divide-and-conquer algorithm, splitting the expression at each operator and recursively evaluating subexpressions.",Medium,algorithms,"Math,String,Dynamic Programming,Recursion,Memoization"
242,"Valid Anagram
Given two strings s and t, return true if t is an anagram of s, and false otherwise.",The process of retrieving data from a database table,A method to remove duplicate rows from a table,A way to permanently alter the structure of a database,The act of inserting new data into a database,A mechanism to combine rows from two or more tables based on a related column,Easy,database systems,"Hash Table,String,Sorting"
257,"Binary Tree Paths
Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.","Use a stack to store nodes and backtrack when a leaf is reached, constructing the path in reverse order.","Perform a breadth-first search, storing paths in a queue and processing nodes level by level.",Serialize the binary tree to a string and use string manipulation to extract paths.,Convert the binary tree to an array and use array indexing to determine parent-child relationships.,"Use recursion with depth-first search to traverse the tree, building path strings as you go.",Easy,algorithms,"String,Backtracking,Tree,Depth-First Search,Binary Tree"
258,"Add Digits
Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.",Compute the digital root using modulo 9: `return num % 9`,"Convert the number to a string, sum the ASCII values of the digits, and subtract 48 times the number of digits",Recursively call the function with `num // 10 + num % 10` as the argument until `num < 10`,Return the number as is without any operations since the prompt is misleading,Calculate `(num - 1) % 9 + 1` to obtain the single-digit result directly,Easy,algorithms,"Math,Simulation,Number Theory"
260,"Single Number III
Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.",Use a hash map to store the frequency of each number and return numbers with frequency 1,"Sort the array and then iterate through it, comparing adjacent elements to find the unique numbers",Calculate the sum of all elements and subtract twice the sum of the set of unique elements,"Iterate through the array, XORing each element with a running total. The final total contains the XOR of the two unique numbers.","XOR all numbers, find the rightmost set bit in the result, divide numbers into two groups based on that bit, and XOR each group.",Medium,algorithms,"Array,Bit Manipulation"
262,"Trips and Users
Table: Trips  Table: Users  The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Write a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between ""2013-10-01"" and ""2013-10-03"" with at least one trip. Round Cancellation Rate to two decimal points. Return the result table in any order. The result format is in the following example.","SELECT request_at, ROUND(SUM(CASE WHEN status LIKE 'cancelled%' THEN 1 ELSE 0 END) / COUNT(*), 2) AS cancellation_rate FROM trips WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03';","SELECT request_at, AVG(CASE WHEN status = 'cancelled_by_client' OR status = 'cancelled_by_driver' THEN 1 ELSE 0 END) AS cancellation_rate FROM trips WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03';","SELECT t.request_at, ROUND(COUNT(CASE WHEN t.status LIKE 'cancelled_%' THEN 1 END) / COUNT(*), 2) FROM trips t JOIN users u1 ON t.client_id = u1.users_id JOIN users u2 ON t.driver_id = u2.users_id WHERE u1.banned = 'No' AND u2.banned = 'No' AND t.request_at BETWEEN '2013-10-01' AND '2013-10-03' GROUP BY t.request_at;","SELECT request_at, SUM(CASE WHEN status LIKE 'cancelled%' THEN 1 ELSE 0 END) / COUNT(*) AS cancellation_rate FROM trips WHERE request_at >= '2013-10-01' AND request_at <= '2013-10-03';","SELECT t.request_at AS Day, ROUND(SUM(CASE WHEN t.status LIKE 'cancelled_%' THEN 1 ELSE 0 END) / COUNT(*), 2) AS 'Cancellation Rate' FROM Trips t JOIN Users u1 ON (t.client_id = u1.users_id AND u1.banned = 'No') JOIN Users u2 ON (t.driver_id = u2.users_id AND u2.banned = 'No') WHERE t.request_at BETWEEN '2013-10-01' AND '2013-10-03' GROUP BY t.request_at;",Hard,database systems,Database
263,"Ugly Number
An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5. Given an integer n, return true if n is an ugly number.","Check if n is divisible by 2, 3, and 5 only once and return true if n becomes 1","Return true if n modulo 2, 3, and 5 equals 0","Iterate from 2 up to n and check for prime factors other than 2, 3, and 5",Use dynamic programming to precompute ugly numbers and check if n exists in the table,"Repeatedly divide n by 2, 3, and 5 until it's no longer divisible by any of them. Return true if n becomes 1.",Easy,algorithms,Math
264,"Ugly Number II
An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number.","Test all numbers from 1 to n and check if they are divisible by 2, 3, or 5","Use dynamic programming with a single array to store ugly numbers, updating it iteratively with prime multiples","Maintain three separate sorted lists for multiples of 2, 3, and 5, then merge them","Recursively generate all possible combinations of 2, 3, and 5 until n numbers are generated","Use three pointers to track multiples of 2, 3, and 5 and update the next ugly number by selecting the minimum",Medium,algorithms,"Hash Table,Math,Dynamic Programming,Heap (Priority Queue)"
268,"Missing Number
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","Calculate the sum of numbers from 0 to n and subtract the sum of elements in the array. If result is negative, the missing number is 0.",Sort the array and iterate through it. The first index where arr[i] != i is the missing number.,"Use a hash set to store all the numbers in the array and then iterate from 0 to n, checking for the presence of each number in the hash set.",Return the element that appears exactly once in the array after applying the bitwise XOR operation on all elements,Calculate n(n+1)/2 and subtract the sum of elements in the array.,Easy,algorithms,"Array,Hash Table,Math,Bit Manipulation,Sorting"
273,"Integer to English Words
Convert a non-negative integer num to its English words representation.",Use a series of if-else statements to handle each digit place value individually,"Convert the integer to a string, reverse it, and then map each digit to its English word equivalent","Recursively divide the integer by 1000, converting each three-digit group separately and appending the appropriate magnitude (thousand, million, billion)",Utilize a pre-defined dictionary mapping all numbers from 0 to 999 to their English word equivalents and perform lookups,"Divide the number into groups of three digits, convert each group to English words, and append the corresponding magnitude (thousand, million, billion) to each group",Hard,algorithms,"Math,String,Recursion"
274,"H-Index
Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.","Sort the array in ascending order and iterate from the beginning, finding the first index where citations[i] >= n - i.",Return the median of the citations array after sorting it in descending order.,Calculate the average citation count and round up to the nearest integer.,"Sort the array in descending order and return the element at index h, where h is the value such that citations[h] > h.",Sort the array in descending order and find the largest index h such that citations[h] >= h.,Medium,algorithms,"Array,Sorting,Counting Sort"
275,"H-Index II
Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. You must write an algorithm that runs in logarithmic time.",Divide the array into subarrays and recursively calculate the H-index for each subarray.,"Linearly scan the array, maintaining a counter for papers with citations greater than or equal to the current index.",Return the median value of the citations array.,Return the largest value in the citations array.,"Use binary search to find the smallest index i such that citations[i] >= n - i, where n is the length of citations.",Medium,algorithms,"Array,Binary Search"
278,"First Bad Version
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.","Linear search from version 1 to n, checking each version with isBadVersion().",Start from the middle version (n/2) and move linearly towards the beginning or end based on isBadVersion().,"Randomly select a version and check with isBadVersion() until a bad version is found, then linearly search backwards.",Recursively check each version until the API limit is reached.,"Apply binary search to find the first bad version, minimizing API calls.",Easy,algorithms,"Binary Search,Interactive"
279,"Perfect Squares
Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.","Dynamic programming with a bottom-up approach, iterating from 1 to n and storing the minimum count for each number.","Recursively try all possible combinations of perfect squares less than or equal to n, memoizing results to avoid redundant computations.","Greedily select the largest perfect square less than or equal to n, subtract it, and repeat until n is zero, summing the number of squares used.",Use a breadth-first search (BFS) where each node represents a remaining sum and edges represent subtracting a perfect square.,Use Lagrange's four-square theorem directly to determine the answer in constant time.,Medium,algorithms,"Math,Dynamic Programming,Breadth-First Search"
282,"Expression Add Operators
Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros.",Use dynamic programming to store intermediate results and build up solutions iteratively.,"Employ a greedy approach, always choosing the operator that minimizes the difference between the current result and the target.","Recursively explore all possible operator combinations, pruning branches that exceed the target early on.",Convert the input string to an integer and then decompose it using modulo operations to find suitable operator placements.,Use backtracking to explore all possible combinations of operators while maintaining the current result and last operand.,Hard,algorithms,"Math,String,Backtracking"
283,"Move Zeroes
Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",Use a separate array to store non-zero elements and then fill the remaining positions with zeroes,Iterate through the array and swap each zero with the last element until all zeroes are at the end,Count the number of zeroes and then shift all non-zero elements forward by that count,Sort the array and then reverse it to move the zeroes to the end,Maintain two pointers: one for iterating and another for tracking the position to place the next non-zero element,Easy,algorithms,"Array,Two Pointers"
284,"Peeking Iterator
Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.",Throw an exception if `hasNext()` is false when `peek()` is called.,"`peek()` should advance the original iterator, and `next()` should return the previously peeked value and re-advance the iterator.",`peek()` should return null without advancing the iterator if `hasNext()` is false.,"`peek()` should advance the original iterator but keep a separate cached value; `next()` should return the cached value if it exists, otherwise advance the original iterator.","`peek()` should store the next value without advancing the original iterator; `next()` returns the stored value (if any) and advances the iterator, or advances the iterator if no value is stored.",Medium,system design,"Array,Design,Iterator"
287,"Find the Duplicate Number
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.",Use a hash table to count the frequency of each number; return the number with a count greater than 1,Sort the array; the duplicate number will be adjacent to itself,Calculate the sum of numbers from 1 to n and subtract it from the sum of the elements in nums,Return the number that appears most frequently in the first half of the array,Treat the array as a linked list and use the 'tortoise and hare' algorithm to find the cycle entry point,Medium,algorithms,"Array,Two Pointers,Binary Search,Bit Manipulation"
289,"Game of Life
According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously. Given the current state of the board, update the board to reflect its next state. Note that you do not need to return anything.",Use a temporary matrix to store the next state and update the original matrix at the end.,"Process the board row by row, immediately updating cells and using the updated values for subsequent calculations.","Only consider live cells and their neighbors, ignoring dead cells to optimize the computation.",Randomly change the state of cells with an equal number of live neighbors to simulate uncertainty.,Use bit manipulation to store the next state in the same cell without affecting neighbor calculations during iteration.,Medium,algorithms,"Array,Matrix,Simulation"
290,"Word Pattern
Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:",Employ a hash map to store character-to-word mappings and check for inconsistencies.,Use regular expressions to extract words from the string and compare them directly against the pattern.,"Split the string into characters and compare them directly with the pattern, ignoring spaces.",Sort the pattern and the string (split into words) alphabetically before comparing them element-wise.,Create two hash maps to maintain bidirectional mappings between pattern characters and string words.,Easy,algorithms,"Hash Table,String"
292,"Nim Game
You are playing the following Nim Game with your friend: Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.",n % 2 == 0,n > 1,n % 3 == 0,n > 4,n % 4 != 0,Easy,algorithms,"Math,Brainteaser,Game Theory"
295,"Find Median from Data Stream
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. Implement the MedianFinder class:",Store all numbers in a sorted array and recalculate the median on each call.,Use a single heap to store all numbers and calculate the median based on the heap's root.,Maintain a running average of all numbers seen so far and return that as the median.,Use a hash table to store the frequency of each number and iterate to find the middle element(s).,"Maintain two heaps, a max-heap for the smaller half and a min-heap for the larger half, to efficiently find the median.",Hard,data structures,"Two Pointers,Design,Sorting,Heap (Priority Queue),Data Stream"
297,"Serialize and Deserialize Binary Tree
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.","Use level-order traversal and store only the node values, omitting null nodes.","Serialize the tree using pre-order traversal, representing null nodes with a special character, and deserialize using a stack.",Serialize the tree into an array where the index represents the node's position in a complete binary tree structure.,Serialize the tree by storing only the leaf nodes and their parent-child relationships.,"Serialize the tree using pre-order traversal, representing null nodes with a special character, and deserialize recursively.",Hard,data structures,"String,Tree,Depth-First Search,Breadth-First Search,Design,Binary Tree"
299,"Bulls and Cows
You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: Given the secret number secret and your friend's guess guess, return the hint for your friend's guess. The hint should be formatted as ""xAyB"", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.",Use dynamic programming to store intermediate results and optimize the guessing strategy,"Employ a brute-force approach, generating all possible secret numbers and comparing them to the guess",Calculate the Levenshtein distance between the secret and the guess,Use a machine learning model trained on previous Bulls and Cows games to predict the hint,"Maintain frequency maps of digits in both strings to efficiently count bulls and cows, handling duplicates correctly",Medium,algorithms,"Hash Table,String,Counting"
300,"Longest Increasing Subsequence
Given an integer array nums, return the length of the longest strictly increasing subsequence.",Recursively explore all possible subsequences and track the longest increasing one.,Sort the array and then find the longest common subsequence with the original array.,"Use a greedy approach, always adding the next largest element to the subsequence.","Apply dynamic programming, storing the length of the longest increasing subsequence ending at each index.",Employ binary search within a dynamic programming approach to optimize subsequence tail tracking.,Medium,algorithms,"Array,Binary Search,Dynamic Programming"
301,"Remove Invalid Parentheses
Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.",Use a stack to track open parentheses and greedily remove matching closing parentheses.,Recursively explore all possible substring combinations and filter for valid ones with minimal removals.,"Employ dynamic programming, building a table of valid substrings based on removal counts.","Prioritize removing opening parentheses until a valid state is reached, then repeat for closing parentheses.","Use breadth-first search to explore possible string states, pruning branches that exceed the minimum removals seen so far.",Hard,algorithms,"String,Backtracking,Breadth-First Search"
303,"Range Sum Query - Immutable
Given an integer array nums, handle multiple queries of the following type: Implement the NumArray class:",Calculate prefix sums during initialization and return the difference for the given range,Store all possible range sums in a hash map during initialization,Iterate through the array for each query to calculate the sum within the given range,Use a binary search tree to store the array elements and efficiently query the range sum,"Precompute and store the cumulative sum of the array elements, enabling constant-time range sum queries",Easy,algorithms,"Array,Design,Prefix Sum"
304,"Range Sum Query 2D - Immutable
Given a 2D matrix matrix, handle multiple queries of the following type: Implement the NumMatrix class: You must design an algorithm where sumRegion works on O(1) time complexity.",Compute the sum of all elements within the submatrix for each query.,Use dynamic programming to store prefix sums of each row.,Maintain a list of all possible submatrices and precompute their sums.,Store the matrix as a sparse matrix and only sum the non-zero elements in the region.,Precompute a 2D prefix sum matrix to calculate the sum of any region in O(1) time.,Medium,algorithms,"Array,Design,Matrix,Prefix Sum"
306,"Additive Number
An additive number is a string whose digits can form an additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits, return true if it is an additive number or false otherwise. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.",Use dynamic programming to store intermediate sums and check for valid sequences,Employ a greedy algorithm to find the largest possible numbers that fit the additive property,"Backtrack by trying all possible starting numbers and verifying the additive sequence recursively, pruning when a condition is violated",Use a sliding window to check every substring of length 3 to see if it follows the additive property,"Recursively explore all possible first and second numbers, verifying if the remaining string forms an additive sequence based on the sum of the previous two numbers",Medium,algorithms,"String,Backtracking"
307,"Range Sum Query - Mutable
Given an integer array nums, handle multiple queries of the following types: Implement the NumArray class:",Rebuild the entire sum array on each update; query the rebuilt array,Store the prefix sums of the array and update all prefix sums after a mutation,Calculate the sum of a range by iterating through the original array on each query,Maintain a separate array containing the cumulative sums and update the array by iterating through it until the index,Use a segment tree or Fenwick tree to efficiently update elements and calculate range sums,Medium,data structures,"Array,Design,Binary Indexed Tree,Segment Tree"
309,"Best Time to Buy and Sell Stock with Cooldown
You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).","Use a greedy approach, buying whenever the price dips and selling whenever it peaks without considering the cooldown.","Implement a single-pass algorithm that only tracks the maximum profit seen so far, ignoring potential future gains.","Employ dynamic programming with only two states: holding stock or not holding stock, neglecting the cooldown state.","Recursively explore all possible buy/sell combinations without memoization, leading to exponential time complexity.","Use dynamic programming with three states: buying, selling, and cooldown, to track the maximum profit at each day.",Medium,algorithms,"Array,Dynamic Programming"
310,"Minimum Height Trees
A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs). Return a list of all MHTs' root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.","A topological sort is guaranteed to produce a single, uniquely defined 'center' node.",The center nodes are always the nodes that were initially leaves in the graph.,"The problem requires finding the diameter of the tree, then returning the middle node(s) of that diameter.",Perform a Depth First Search (DFS) starting from each node to calculate its height and then select the minimum.,Repeatedly prune leaf nodes from the graph until only the center node(s) remain.,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
312,"Burst Balloons
You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely.","Greedy approach, always burst the balloon with the smallest value first","Divide and conquer, split the balloon array into subproblems and solve recursively","Dynamic programming, calculate minimum coins instead of maximum",Sort the balloons in ascending order and then burst them sequentially,"Dynamic programming, build a table representing the maximum coins obtainable by bursting balloons within certain ranges",Hard,algorithms,"Array,Dynamic Programming"
313,"Super Ugly Number
A super ugly number is a positive integer whose prime factors are in the array primes. Given an integer n and an array of integers primes, return the nth super ugly number. The nth super ugly number is guaranteed to fit in a 32-bit signed integer.",Recursively generate all possible multiples using the primes array and find the nth smallest,Use a priority queue containing only the prime numbers and repeatedly multiply by previous ugly numbers.,Sort the prime numbers and repeatedly multiply the smallest prime by each previously generated super ugly number,Precompute all multiples of primes up to n and select the nth largest,"Use a dynamic programming approach maintaining an index for each prime factor, updating the sequence efficiently",Medium,algorithms,"Array,Hash Table,Math,Dynamic Programming,Heap (Priority Queue)"
315,"Count of Smaller Numbers After Self
Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].","Use a bubble sort variation, counting inversions for each element","Utilize a brute-force approach with nested loops, comparing each element with all subsequent elements",Sort the array using quicksort and then perform a binary search for each element to find smaller elements,Create a frequency table of all numbers and iterate the table for each element,Use a modified merge sort algorithm to count smaller elements during the merge process,Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
316,"Remove Duplicate Letters
Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.","Use a greedy approach, always picking the smallest available character and removing larger ones later if needed.","Sort the string, then iterate through it, keeping only the first occurrence of each character.","Recursively process the string, always selecting the first unique character and then processing the rest of the string excluding characters smaller than it.","Build a frequency map, then construct the result by picking the smallest characters first while ensuring all characters are eventually included.","Use a stack to maintain the result, ensuring lexicographical order and that each character appears only once.",Medium,algorithms,"String,Stack,Greedy,Monotonic Stack"
318,"Maximum Product of Word Lengths
Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.",Use a nested loop to compare each word with every other word for common letters.,Sort the array of words by length and then only compare adjacent words.,Convert each word into its ASCII representation and compare the sums of the ASCII values.,Use a sliding window approach to find non-overlapping word pairs.,Use bit manipulation to represent each word as a bitmask and efficiently check for common letters.,Medium,algorithms,"Array,String,Bit Manipulation"
319,"Bulb Switcher
There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds.",n - (number of prime numbers <= n),n / 2 (integer division),"The sum of all integers from 1 to n, divided by 2",The closest prime number to n,floor(sqrt(n)),Medium,algorithms,"Math,Brainteaser"
321,"Create Maximum Number
You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k. Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the k digits representing the answer.",Greedily pick the larger digit from nums1 or nums2 at each step until k digits are selected.,Generate all possible subsequences of length k from the merged array of nums1 and nums2 and select the largest.,Recursively combine the largest digits from nums1 and nums2 until the desired length is reached.,Dynamically program the selection by comparing digits and build the result from the end.,"Extract maximum possible subsequences of lengths i and k-i from nums1 and nums2 respectively for all i from 0 to k, then merge them.",Hard,algorithms,"Stack,Greedy,Monotonic Stack"
322,"Coin Change
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.","Greedy algorithm, picking the largest coin denomination first","Dynamic programming with a bottom-up approach, building solutions for smaller amounts",Recursion with memoization to avoid redundant calculations,"Branch and bound, pruning branches that exceed the target amount",Dynamic programming with a top-down approach and memoization to store results,Medium,algorithms,"Array,Dynamic Programming,Breadth-First Search"
324,"Wiggle Sort II
Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer.",Sort the array and then swap adjacent elements in pairs.,"Create two subarrays, one with elements less than the median and the other with elements greater than the median, then merge them.",Sort the array in descending order and interleave the first and second halves.,Randomly shuffle the array until the wiggle sort condition is met.,"Find the median, then partition the array into three parts (less than, equal to, greater than the median) and rearrange them according to the wiggle sort pattern.",Medium,algorithms,"Array,Divide and Conquer,Sorting,Quickselect"
326,"Power of Three
Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x.",Recursively divide n by 3 until it becomes 1 or less than 1,Check if the base-10 logarithm of n is an integer,Convert n to base-3 and check if it contains only '1' and '0',Check if n is divisible by the largest power of 3 that fits within the integer range,"Repeatedly divide n by 3 as long as it is divisible by 3, then check if the result is 1",Easy,algorithms,"Math,Recursion"
327,"Count of Range Sum
Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.","Use brute force: calculate all possible range sums and count those within the range [lower, upper].","Sort the input array and then use binary search to find the range sums within [lower, upper].","Calculate prefix sums and then iterate through all pairs of prefix sums, counting those with differences within the range [lower, upper].","Use a sliding window approach to calculate range sums and count those within the range [lower, upper].",Use merge sort to sort prefix sums and maintain a count of valid range sums during the merge process.,Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
328,"Odd Even Linked List
Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity.",Use a merge sort algorithm to rearrange the list based on index parity.,"Create two new linked lists, one for odd indices and one for even indices, then concatenate the even list to the tail of the odd list.","Reverse the entire linked list, then reverse the first half and the second half separately.","Store the values of the linked list in an array, rearrange the array based on index parity, and then create a new linked list from the rearranged array.","Maintain two pointers, one for odd nodes and one for even nodes, and rearrange the next pointers to group odd and even nodes separately.",Medium,data structures,Linked List
329,"Longest Increasing Path in a Matrix
Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",Use Dijkstra's algorithm to find the longest path from each cell.,Sort the matrix and then perform a linear search for the longest increasing subsequence.,"Apply a greedy approach, always choosing the neighbor with the highest value.","Use dynamic programming with a bottom-up approach, starting from cells with no smaller neighbors.",Employ depth-first search (DFS) with memoization to avoid recomputation of path lengths.,Hard,algorithms,"Dynamic Programming,Depth-First Search,Breadth-First Search,Graph,Topological Sort,Memoization"
330,"Patching Array
Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.","Iteratively insert necessary values while sum < n, incrementing a counter for each insertion","Binary search for each missing number between 1 and n, adding the number if not found and incrementing the patch count","Calculate the sum of the existing array. If it is less than n, add n - sum to the array and increment the patch count. Return the patch count.","Sort the array in descending order, then greedily select numbers until the range [1, n] is covered. The number of unselected elements is the number of patches.","Maintain a 'missable' range [1, x). If nums[i] <= x, then x can be extended by nums[i] (x += nums[i]). Otherwise, patch x and extend the range (x += x). Repeat until x > n.",Hard,algorithms,"Array,Greedy"
331,"Verify Preorder Serialization of a Binary Tree
One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'. For example, the above binary tree can be serialized to the string ""9,3,4,#,#,1,#,#,2,#,6,#,#"", where '#' represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid. Note: You are not allowed to reconstruct the tree.","Use a stack to keep track of the difference between non-null nodes and null nodes, incrementing for numbers and decrementing for '#'. Return true if the stack is empty at the end.","Count the number of '#' characters. If the number of '#' is one less than the number of other characters, return true.","Recursively check if the left and right subtrees are valid, based on the position of the '#' characters.",Convert the preorder string into an inorder string and then validate.,"Use a 'slots' or 'degree of freedom' approach. Increment the slot for each number and decrement twice for each '#'. The serialization is valid if and only if the slots become zero at the very end, and never negative before that.",Medium,algorithms,"String,Stack,Tree,Binary Tree"
332,"Reconstruct Itinerary
You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary must begin with ""JFK"". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",Use Depth-First Search (DFS) starting from 'JFK' and always pick the lexicographically largest destination first.,"Sort the tickets lexicographically and then perform a simple traversal, adding each destination to the itinerary.",Use Breadth-First Search (BFS) starting from 'JFK' to explore possible itineraries.,Prioritize visiting airports with the most outgoing flights first and then backtracking when necessary.,"Use Depth-First Search (DFS) starting from 'JFK' and always pick the lexicographically smallest destination first. After visiting all destinations from a node, add the node to the itinerary.",Hard,algorithms,"Depth-First Search,Graph,Eulerian Circuit"
334,"Increasing Triplet Subsequence
Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.",Use dynamic programming to store the minimum value encountered so far at each index.,Sort the array and check for three consecutive increasing elements.,Iterate through all possible triplets and check if they satisfy the condition.,Maintain a single variable to track the minimum element and check if the current element is greater.,Maintain two variables to track the smallest and second smallest elements encountered so far.,Medium,algorithms,"Array,Greedy"
335,"Self Crossing
You are given an array of integers distance. You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself or false if it does not.",Check for intersections only between adjacent path segments,Simulate the entire path and store all coordinates visited in a hash set to detect duplicates,"Check for intersections only after the fifth move, as self-crossing is impossible before that",Sort the distance array and then check for overlaps between the sorted segments,Iterate through the distance array and check for crossing conditions based on relative distances of the last few moves,Hard,algorithms,"Array,Math,Geometry"
336,"Palindrome Pairs
You are given a 0-indexed array of unique strings words. A palindrome pair is a pair of integers (i, j) such that: Return an array of all the palindrome pairs of words. You must write an algorithm with O(sum of words[i].length) runtime complexity.","Use a hash table to store the words and their indices, then iterate through the words and check if the reverse of each word or its prefixes/suffixes exists in the hash table to form a palindrome",Compare each word with every other word to check for palindrome pairs in O(n^2) time complexity which is not efficient,Sort the words alphabetically and then iterate through the sorted list to find palindrome pairs using binary search,Concatenate all the words into a single string and then use a palindrome detection algorithm,"Build a Trie of all words and their reverses. Then, for each word, traverse the Trie to efficiently find palindrome pairs",Hard,algorithms,"Array,Hash Table,String,Trie"
337,"House Robber III
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.",Depth-First Search (DFS) without memoization,Breadth-First Search (BFS) with a queue,"Greedy approach, always picking the node with the highest value",Dynamic programming using an array to store maximum values at each level,"Dynamic programming with recursion and memoization, considering two states: including the current node or excluding it",Medium,algorithms,"Dynamic Programming,Tree,Depth-First Search,Binary Tree"
338,"Counting Bits
Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.","Brute force: For each number from 0 to n, convert it to binary and count the set bits.","Use dynamic programming, where dp[i] = dp[i/2] + (i % 2).",Precompute the number of set bits for all numbers up to n using bitwise operations.,Apply a lookup table containing the number of set bits for each number up to n.,"Use dynamic programming, leveraging the property that dp[i] = dp[i & (i-1)] + 1.",Easy,algorithms,"Dynamic Programming,Bit Manipulation"
341,"Flatten Nested List Iterator
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: Your code will be tested with the following pseudocode: If res matches the expected flattened list, then your code will be judged as correct.","Use a depth-first search (DFS) approach, but only explore the first branch of each nested list.",Convert the entire nested list into a string representation and then parse it.,"Use a breadth-first search (BFS) approach, processing elements level by level and only yielding integers on the final level.","Recursively flatten the list into a single list, reversing the order of elements at each level of recursion.","Use a stack to maintain the current state of nested lists, popping elements and pushing sublists as needed.",Medium,data structures,"Stack,Tree,Depth-First Search,Design,Queue,Iterator"
342,"Power of Four
Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x.",Check if the number is a power of 2 and has an odd number of trailing zeros in its binary representation,"Repeatedly divide the number by 4 until it is no longer divisible. If the final result is 1, it's a power of 4","Take the base-4 logarithm of the number. If the result is an integer, it's a power of 4.",Check if the number is a positive integer and its square root is an integer,Check if the number is a power of 2 and its bitwise AND with 0x55555555 is equal to the number,Easy,algorithms,"Math,Bit Manipulation,Recursion"
343,"Integer Break
Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers. Return the maximum product you can get.",Recursively break n into smaller numbers and cache the results,Always break n into as many 2's as possible,"Use dynamic programming, building a table of maximum products for subproblems from 1 to n","Apply the formula (n/e)^e, where e is Euler's number, and round to the nearest integer","Maximize the number of 3's used as factors, using 2's only when the remainder is 2 or 4",Medium,algorithms,"Math,Dynamic Programming"
344,"Reverse String
Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory.",Create a new string by iterating through the original string backward.,Use string slicing with a step of -1 to create a reversed copy.,"Convert the character array to a string, reverse the string using built-in functions, and convert back to a character array.",Recursively swap characters from the beginning and end of the string until the middle is reached.,"Use two pointers, one at the beginning and one at the end, and swap the characters they point to, moving the pointers towards the middle.",Easy,algorithms,"Two Pointers,String,Recursion"
345,"Reverse Vowels of a String
Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",Use regular expressions to identify and replace vowels iteratively from left to right.,"Split the string into an array, reverse the entire array, then replace consonants with their original values.","Convert the string to lowercase, reverse it, then convert it back to its original case.",Iterate through the string and swap each character with its opposite character until the middle is reached.,"Use two pointers, one at the beginning and one at the end, swapping vowels until they meet in the middle.",Easy,algorithms,"Two Pointers,String"
347,"Top K Frequent Elements
Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",Use a binary search tree to store frequencies and then retrieve the top k elements in O(k log n) time.,Sort the input array in ascending order and then select the last k elements as the most frequent.,"Iterate through the array k times, each time finding the most frequent element and removing it.","Maintain a sorted array of the top k elements seen so far, updating it for each element in the input array.",Use a hash map to count frequencies and a min-heap of size k to track the top k frequent elements.,Medium,algorithms,"Array,Hash Table,Divide and Conquer,Sorting,Heap (Priority Queue),Bucket Sort,Counting,Quickselect"
349,"Intersection of Two Arrays
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.","Using nested loops, compare each element of `nums1` with every element of `nums2`, adding matches to the result. This leads to O(n*m) complexity.","Sort both arrays, then iterate through both simultaneously, adding elements to the intersection if equal, and skipping smaller elements. O(n log n + m log m).","Convert both arrays to sets, then iterate through the smaller set and add elements present in the larger set to the result. O(min(n, m)).","Store the frequency of each element in `nums1` in a hash map, then iterate through `nums2`, adding elements found in the map to the result and decrementing their counts.","Convert one array into a set and iterate through the other, adding elements present in the set to the result. O(n+m).",Easy,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Sorting"
350,"Intersection of Two Arrays II
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.","Using nested loops, compare each element of `nums1` with every element of `nums2`, adding matches to the result array.",Convert both arrays into sets and return the set intersection.,"Sort both arrays, then iterate through both simultaneously using two pointers, only adding to the result when a match occurs.","Create a hash table for `nums1` storing counts. Iterate through `nums2`, decrementing counts in the table and adding to the result if the count is positive.","Create a hash table for the smaller array storing element counts. Iterate through the larger array, adding to the result and decrementing counts if they exist.",Easy,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Sorting"
352,"Data Stream as Disjoint Intervals
Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals. Implement the SummaryRanges class:",Use a self-balancing binary search tree to store intervals and merge overlapping intervals on insertion.,Maintain a sorted array of all numbers seen and iterate through it to construct intervals in linear time.,Store all numbers in a hash set and iterate from the minimum to maximum value to create intervals.,Use a bloom filter to quickly check if a number has been seen before adding it to a single interval.,"Employ a sorted list of intervals, using binary search to find the correct position for a new number and merge overlapping intervals.",Hard,algorithms,"Binary Search,Design,Ordered Set"
354,"Russian Doll Envelopes
You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope.",Sort envelopes by width (ascending) then height (ascending) and find the longest increasing subsequence of heights.,Sort envelopes by area (ascending) and count the number of envelopes where both dimensions are greater than the previous envelope.,"Use dynamic programming, where dp[i] stores the maximum envelopes possible ending with envelopes[i], without considering sorting.","Iterate through all possible subsets of envelopes and check if they form a valid Russian doll sequence, returning the length of the longest one.",Sort envelopes by width (ascending) and then height (descending). Find the longest increasing subsequence of heights.,Hard,algorithms,"Array,Binary Search,Dynamic Programming,Sorting"
355,"Design Twitter
Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed. Implement the Twitter class:","Use a single, global timeline and filter based on followers for each user's feed.",Store tweets in a relational database with full-text search capabilities.,Implement a publish-subscribe system where users subscribe to tweets from those they follow.,Use a key-value store where keys are user IDs and values are lists of all tweets.,"Maintain a news feed cache for each user, pre-computing the feed based on followers and using a priority queue to rank tweets by timestamp.",Medium,system design,"Hash Table,Linked List,Design,Heap (Priority Queue)"
357,"Count Numbers with Unique Digits
Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.","Use backtracking to explore all possible digit combinations, pruning branches when a duplicate is found.","Calculate 9^n, since the first digit has 9 possibilities (1-9) and each subsequent digit also has 9 possibilities (0-9 excluding the previous digit).","Compute 10^n - n! because there are 10^n total numbers less than 10^n, and n! numbers with all unique digits.","Apply dynamic programming, where dp[i] stores the count of numbers with unique digits of length i, and sum dp[0] to dp[n].","Apply dynamic programming, where dp[i] stores the count of numbers with unique digits of length i. The recurrence relation is dp[i] = dp[i-1] * (10 - (i - 1)).",Medium,algorithms,"Math,Dynamic Programming,Backtracking"
363,"Max Sum of Rectangle No Larger Than K
Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k. It is guaranteed that there will be a rectangle with a sum no larger than k.","Brute-force: Enumerate all possible rectangles and check their sums, resulting in O(m^3n^3) time complexity.","Use Kadane's algorithm on each row to find the maximum subarray sum, then sum the results across rows, leading to O(m*n) time complexity.","Precompute the prefix sum for each row and binary search on all possible sub-rectangles, yielding O(m^2n log n) time complexity.","Dynamically program the solution where dp[i][j] stores the max sum ending at (i,j), resulting in O(m*n) time complexity.","Iterate through all possible left and right columns. For each pair, compute row sums and use a sorted set to find the max sum no larger than k. O(n^2 m log m)",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Matrix,Ordered Set"
365,"Water and Jug Problem
You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach target using the following operations:",Only target amounts that are multiples of both x and y are reachable,"If x and y are coprime, any amount less than x + y is reachable","The target amount must be either x or y, or a combination of filling one jug completely and then filling the other",Only amounts where target % x == 0 or target % y == 0 are reachable,"The target is reachable if it is a multiple of the greatest common divisor (GCD) of x and y, and is no larger than x + y",Medium,algorithms,"Math,Depth-First Search,Breadth-First Search"
367,"Valid Perfect Square
Given a positive integer num, return true if num is a perfect square or false otherwise. A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself. You must not use any built-in library function, such as sqrt.",Binary search on odd numbers only.,Linear search starting from num/2 down to 1.,Newton's method approximation without convergence checks.,"Using the property that the sum of the first n odd numbers is n^2, iterate adding odd numbers until the sum exceeds num.",Binary search between 1 and num to find the square root.,Easy,algorithms,"Math,Binary Search"
368,"Largest Divisible Subset
Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: If there are multiple solutions, return any of them.","Dynamic programming, storing the largest divisible subset ending at each index",Greedily picking the smallest number and repeatedly multiplying it by a factor until no larger divisible number is found,Recursively checking all possible subsets for divisibility properties,Sorting the numbers and checking all possible pairs for divisibility to determine the subset,"Sort the numbers, then use dynamic programming to find the largest divisible subset ending at each number",Medium,algorithms,"Array,Math,Dynamic Programming,Sorting"
371,"Sum of Two Integers
Given two integers a and b, return the sum of the two integers without using the operators + and -.",Use a lookup table to store precomputed sums for all possible input pairs,Return the bitwise XOR of a and b,Recursively call the function with decremented inputs until one input is zero,"Convert integers to strings, concatenate, and convert back to integer",Use bitwise operators to simulate addition with carry,Medium,algorithms,"Math,Bit Manipulation"
372,"Super Pow
Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.",Calculate a^b directly using the power operator and then apply the modulo operator,Use Euler's totient theorem to reduce the exponent b modulo phi(1337) before exponentiation,"Apply the modulo operator to 'a' first, then calculate a^b and apply the modulo operator again","Decompose 'b' into prime factors, calculate a raised to each prime factor modulo 1337, and then multiply the results",Use the property (a*b) mod m = ((a mod m) * (b mod m)) mod m and the given array to calculate the power iteratively,Medium,algorithms,"Math,Divide and Conquer"
373,"Find K Pairs with Smallest Sums
You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.",Use nested loops to generate all pairs and then sort them to pick the k smallest.,Apply binary search on both arrays to find the k smallest elements independently and pair them.,Merge the two arrays and then find the k smallest sums from the merged array.,Only consider pairs where the indices in `nums1` and `nums2` are less than k.,"Use a min-heap to track the k smallest pairs, updating the heap as we traverse the arrays.",Medium,algorithms,"Array,Heap (Priority Queue)"
374,"Guess Number Higher or Lower
We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: Return the number that I picked.",Hash the data and compare hash values,Use a simple XOR operation,Employ a Bloom filter to probabilistically check for differences,Serialize data into JSON and compare strings,Compare the cryptographic checksum of the files,Easy,security,"Binary Search,Interactive"
375,"Guess Number Higher or Lower II
We are playing the Guessing Game. The game will work as follows: Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.","Use dynamic programming with a top-down memoization approach, exploring all possible guesses and caching intermediate results.","Implement a greedy algorithm, always guessing the middle number between the current lower and upper bounds.","Apply binary search to find the optimal guessing strategy, minimizing the worst-case cost at each step.",Simulate the game using Monte Carlo methods to estimate the minimum cost based on random trials.,"Employ dynamic programming with a bottom-up approach, building a table of minimum costs for all possible ranges.",Medium,algorithms,"Math,Dynamic Programming,Game Theory"
376,"Wiggle Subsequence
A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences. A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order. Given an integer array nums, return the length of the longest wiggle subsequence of nums.","O(n^2) using dynamic programming, comparing each element to all preceding elements.",O(n log n) by sorting the array and then extracting the wiggle subsequence.,O(n) by tracking only the peak and valley indices in the array.,O(n log n) using a binary search approach to find the optimal wiggle subsequence length.,O(n) by maintaining two variables representing the lengths of increasing and decreasing wiggle subsequences ending at the current element.,Medium,algorithms,"Array,Dynamic Programming,Greedy"
377,"Combination Sum IV
Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. The test cases are generated so that the answer can fit in a 32-bit integer.","Depth-First Search (DFS) without memoization, leading to redundant calculations",Breadth-First Search (BFS) to explore all possible combinations level by level,Dynamic programming with a 2D array to store the number of combinations for each sub-target and subset of nums,"Greedy approach, always choosing the largest possible number from nums that is less than or equal to the remaining target",Dynamic programming with a 1D array where dp[i] represents the number of combinations for target i,Medium,algorithms,"Array,Dynamic Programming"
378,"Kth Smallest Element in a Sorted Matrix
Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n2).","Use a max-heap of size k to maintain the k smallest elements seen so far, but replace the root only if a smaller element is encountered.","Perform a binary search on the range of values in the matrix, counting elements less than or equal to the mid value in each iteration using nested loops.",Sort each row individually and then merge the sorted rows using a priority queue of size n to keep track of the smallest element in each row.,"Apply a modified merge sort algorithm to the entire matrix, considering the sorted rows and columns as pre-sorted subarrays.","Use binary search on the range of values in the matrix, optimizing the element counting by starting from the bottom-left corner and moving up or right.",Medium,algorithms,"Array,Binary Search,Sorting,Heap (Priority Queue),Matrix"
380,"Insert Delete GetRandom O(1)
Implement the RandomizedSet class: You must implement the functions of the class such that each function works in average O(1) time complexity.",Use a hash map to store elements and their indices in an array. Delete by swapping with the last element and removing it.,"Maintain a balanced binary search tree. Insertion, deletion, and random selection are all O(log n).","Utilize a sorted array. Insertion and deletion require shifting elements, but getRandom is simple.","Employ a linked list for storage. Insertion is O(1), but deletion and random retrieval are O(n).",Maintain an array for element storage and a hash map for value-index mapping. Delete by swapping with the last element.,Medium,data structures,"Array,Hash Table,Math,Design,Randomized"
381,"Insert Delete GetRandom O(1) - Duplicates allowed
RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element. Implement the RandomizedCollection class: You must implement the functions of the class such that each function works on average O(1) time complexity. Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.",Store elements in a sorted array and use binary search for removal.,"Use a hash table to store element counts and generate a random number within the total count range, then decrement.",Store elements in a linked list and use a separate array to track indices for O(1) random access; removal involves shifting elements in the array.,Implement all operations using a standard binary search tree with rebalancing.,Use a dynamic array to store elements and a hash map to store the indices of each element in the array; removal involves swapping with the last element.,Hard,data structures,"Array,Hash Table,Math,Design,Randomized"
382,"Linked List Random Node
Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class:",Store the linked list elements in an array and return a random element from the array.,"Use a reservoir sampling algorithm, but only keep track of the first two nodes.","Traverse the entire list multiple times, each time narrowing down the possible nodes.","Calculate the length of the list first, then generate a random number between 0 and length-1, and return the value at that index.","Use reservoir sampling with a single pass through the linked list, updating the selected node with probability 1/i at the i-th node.",Medium,algorithms,"Linked List,Math,Reservoir Sampling,Randomized"
383,"Ransom Note
Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote.","Check if every character in ransomNote exists in magazine, removing it from magazine each time, using nested loops.",Convert both strings to character arrays and compare their lengths directly.,Sort both strings alphabetically and then compare them directly using string equality.,Use a regular expression to check if ransomNote is a substring of magazine.,"Use a hash map (or array) to count character frequencies in magazine and then decrement counts for each character in ransomNote, returning false if any count goes negative.",Easy,algorithms,"Hash Table,String,Counting"
384,"Shuffle an Array
Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling. Implement the Solution class:",Use a Fisher-Yates shuffle by iterating from the beginning and swapping each element with a randomly chosen element from the entire array.,Sort the array randomly using a comparison-based sorting algorithm with a random comparator function.,Generate all possible permutations of the array and select one at random.,"Reverse the array, then sort it using a standard sorting algorithm.",Use a Fisher-Yates shuffle by iterating from the end and swapping each element with a randomly chosen element from the remaining unsorted portion.,Medium,algorithms,"Array,Math,Randomized"
385,"Mini Parser
Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger. Each element is either an integer or a list whose elements may also be integers or other lists.","Use a regular expression to extract integers and lists, then recursively parse the lists.",Evaluate the string as a Python expression using `eval()` after sanitizing it.,Tokenize the string using a finite state machine to identify integers and list delimiters.,"Replace all '[' with '(' and ']' with ')', then use Python's `ast.literal_eval()`.",Use a recursive descent parser to handle nested lists and integer conversions.,Medium,algorithms,"String,Stack,Depth-First Search"
386,"Lexicographical Numbers
Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order. You must write an algorithm that runs in O(n) time and uses O(1) extra space.","Implement a depth-first search (DFS) to traverse the potential prefixes in order, pruning branches exceeding 'n'.","Generate all numbers from 1 to n, convert them to strings, and sort the strings lexicographically.",Use a priority queue to maintain the smallest lexicographical number seen so far and iteratively build the sequence.,"Employ a breadth-first search (BFS) starting from 1, adding children 0-9, filtering out numbers greater than n.","Iteratively generate the next lexicographical number by either appending 0 or incrementing the current number, resetting to the next order of magnitude if needed.",Medium,algorithms,"Depth-First Search,Trie"
387,"First Unique Character in a String
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.","Use a sliding window to track character frequencies, updating the window as needed.",Sort the string and then iterate to find the first character that differs from its neighbor.,Use recursion to split the string into smaller substrings and then compare characters within each substring.,Convert the string to a list of ASCII values and perform statistical analysis to find the least frequent value.,Use a hash map to count character frequencies and then iterate through the string to find the first character with a frequency of 1.,Easy,algorithms,"Hash Table,String,Queue,Counting"
388,"Longest Absolute File Path
Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:  Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext. In text form, it looks like this (with ⟶ representing the tab character): If we were to write this representation in code, it will look like this: ""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"". Note that the '\n' and '\t' are the new-line and tab characters. Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is ""dir/subdir2/subsubdir2/file2.ext"". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces. Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0. Note that the testcases are generated such that the file system is valid and no file or directory name has length 0.","Process each line by splitting on '\t' and calculating path lengths incrementally, keeping track of the maximum file path length","Use regular expressions to extract file names and directory depths, then calculate path lengths based on these extracted values","Recursively traverse the string, building the file system tree and calculating path lengths during the traversal, returning the longest file path","Split the input string into lines and use a stack to maintain the current directory depth and path length, updating the maximum length upon encountering a file","Split the input string into lines, use a stack to keep track of directory depths, and update the maximum length when a file is encountered",Medium,algorithms,"String,Stack,Depth-First Search"
389,"Find the Difference
You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.",Sort both strings and compare characters at each index to find the difference.,Calculate the sum of ASCII values of characters in both strings and return the difference.,"Use a hash table to store character counts of string 's', then decrement counts for string 't', and return the character with a non-zero count.",Concatenate both strings and find the most frequent character.,Calculate the XOR of all characters in both strings; the result is the added character.,Easy,algorithms,"Hash Table,String,Bit Manipulation,Sorting"
390,"Elimination Game
You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr: Given the integer n, return the last number that remains in arr.",O(n log n),O(n!),O(n^2),O(log n),O(n),Medium,algorithms,Math
391,"Perfect Rectangle
Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi). Return true if all the rectangles together form an exact cover of a rectangular region.","Check if the area of the union of the rectangles is equal to the sum of the individual rectangle areas, and if the count of each corner point is exactly 4",Sort the rectangles based on their bottom-left x-coordinate and then check for overlaps during iteration.,Use a disjoint set data structure to track connected components of the rectangles and ensure only one component exists.,Create a bitmap of the entire region and 'draw' each rectangle onto it. Then check if the entire bitmap is filled without overlap.,Calculate the total area and the corner points. Verify the area equals the sum of rectangle areas and that only the extreme corner points appear once.,Hard,algorithms,"Array,Line Sweep"
392,"Is Subsequence
Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).","Use a two-pointer approach, advancing the pointer for the subsequence string only when a match is found in the target string.",Sort both strings alphabetically and then compare them for equality.,Reverse both strings and check if the reversed subsequence string is a prefix of the reversed target string.,Calculate the Levenshtein distance between the two strings and check if it equals the difference in their lengths.,"Iterate through the target string, maintaining a pointer for the subsequence string, advancing the subsequence pointer only when a character match is found.",Easy,algorithms,"Two Pointers,String,Dynamic Programming"
393,"UTF-8 Validation
Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters). A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: This is how the UTF-8 encoding would work: x denotes a bit in the binary form of a byte that may be either 0 or 1. Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.","If a byte starts with '10', it's a continuation byte and should be skipped.",Valid UTF-8 sequences must always begin with '0' followed by a continuation byte.,The length of a valid UTF-8 sequence is determined by the total number of '1's at the beginning of the last byte.,"Check if all numbers are less than 128 (0x80); if so, it's valid UTF-8.",Track the number of expected continuation bytes based on the first byte; validate each subsequent byte starts with '10'.,Medium,algorithms,"Array,Bit Manipulation"
394,"Decode String
Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4]. The test cases are generated so that the length of the output will never exceed 105.","Use a regular expression to extract the number and the string to repeat, then multiply the string by the number and concatenate","Recursively decode the string, keeping track of the repetition count using a global variable",Iteratively build the decoded string by maintaining a single index and updating it based on encountered characters,"Use a queue to store the characters and their repetition counts, processing them in FIFO order","Use two stacks, one for numbers and one for strings, to handle nested repetitions",Medium,algorithms,"String,Stack,Recursion"
395,"Longest Substring with At Least K Repeating Characters
Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k. if no such substring exists, return 0.","Recursively divide the string into substrings based on characters with frequency less than k, then return the maximum length of valid substrings.","Iterate through all possible substrings of s and check if each substring satisfies the condition, returning the length of the longest valid substring found.","Use a sliding window approach, expanding the window until a character's frequency drops below k, then shrink it until all characters have frequency at least k.","Sort the string, then iterate through it and check repeating characters until a character appears that does not repeat K times, then restart the process after the character.","Use a divide and conquer strategy; find characters with frequency less than k, split the string by these characters, and recursively find the longest substring in each part.",Medium,algorithms,"Hash Table,String,Divide and Conquer,Sliding Window"
396,"Rotate Function
You are given an integer array nums of length n. Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow: Return the maximum value of F(0), F(1), ..., F(n-1). The test cases are generated so that the answer fits in a 32-bit integer.",Calculate F(0) and iteratively update F(k) = F(k-1) + sum(nums) - n * nums[n-k],Calculate all F(k) independently using nested loops and store them in an array to find the maximum,Sort the input array and calculate F(0) to guarantee the maximum value due to optimal ordering,Compute the prefix sum array and use it to calculate each F(k) efficiently,Calculate F(0) and iteratively update F(k) = F(k-1) + sum(nums) - n * nums[n-k] (mod n),Medium,algorithms,"Array,Math,Dynamic Programming"
397,"Integer Replacement
Given a positive integer n, you can apply one of the following operations: Return the minimum number of operations needed for n to become 1.","Recursively divide by 2 until n becomes 1, incrementing a counter for each division.",Convert the integer to its binary representation and count the number of 1s.,"Repeatedly subtract 1 from n until it becomes 1, tracking the number of subtractions.","Apply a greedy approach, always dividing by 2 if even, otherwise subtracting 1.","Apply dynamic programming or recursion with memoization, choosing between dividing by 2 if even, or adding/subtracting 1 if odd, to minimize operations.",Medium,algorithms,"Dynamic Programming,Greedy,Bit Manipulation,Memoization"
398,"Random Pick Index
Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Implement the Solution class:",Use a hash map to store the indices of each number and then randomly select from the target's indices.,Sort the array and then perform a binary search to find the first and last occurrence of the target. Calculate the range and then choose a random number within that range.,"Iterate through the array and maintain a counter. If the current element is the target, update the potential index with probability 1/counter.","Precompute all possible combinations of indices and store them in a list. Then, randomly select an index from this list.","Iterate through the array, and when encountering the target, update the result index with probability 1/count, where count is the number of times the target has been seen so far.",Medium,algorithms,"Hash Table,Math,Reservoir Sampling,Randomized"
399,"Evaluate Division
You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.",Use Dijkstra's algorithm to find the shortest path between variables in the graph represented by equations and values.,Apply a greedy approach by iteratively selecting the equation with the largest value to estimate the query result.,Solve the system of equations using Gaussian elimination to find the value of each variable and then calculate the query.,Use a brute-force approach by trying all possible combinations of equations to derive the query result.,"Represent the equations as a graph, use Depth-First Search (DFS) or Breadth-First Search (BFS) to find a path between variables in the query, and multiply values along the path.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Graph,Shortest Path"
400,"Nth Digit
Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].","Iterate through numbers until the nth digit is reached, then extract the digit using string conversion.",Calculate the sum of the first n integers and then extract the last digit.,Use a lookup table containing the first million digits to directly retrieve the nth digit.,"Compute the number of digits in each group of numbers (1-9, 10-99, 100-999, etc.) and adjust n accordingly, then find the target number and extract the digit.","Determine the number of digits of the target number, then find the target number, and extract the nth digit from it.",Medium,algorithms,"Math,Binary Search"
401,"Binary Watch
A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  Given an integer turnedOn which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. You may return the answer in any order. The hour must not contain a leading zero. The minute must consist of two digits and may contain a leading zero.",Calculate time complexity for different input sizes and extrapolate,Use a brute-force approach trying every possible combination,Employ dynamic programming to store intermediate results,Implement a backtracking algorithm to systematically explore solutions,Iterate through all possible hour and minute combinations and check if the number of set bits matches the input,Easy,algorithms,"Backtracking,Bit Manipulation"
402,"Remove K Digits
Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",Greedily remove the largest digit from the left until k digits are removed.,Sort the digits of the number in ascending order and remove the last k digits.,Remove k random digits from the number and return the result.,Generate all possible subsequences of length n-k and return the smallest one.,"Use a stack to maintain a monotonically increasing sequence of digits, removing larger digits from the stack when possible.",Medium,algorithms,"String,Stack,Greedy,Monotonic Stack"
403,"Frog Jump
A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.","Dynamic programming, using a boolean array to track reachable stones based on jump size, iterating through stones and jump sizes.","Greedy approach, always jumping the maximum possible distance (k+1) to reach the farthest stone quickly.","Backtracking, recursively exploring all possible jump sequences from each stone, pruning branches if a stone is not reachable.","Breadth-first search, exploring stones reachable from the current stone using a queue, considering all possible jump lengths.","Dynamic programming, using a hash map to store reachable stones and corresponding jump sizes, checking if the last stone is reachable.",Hard,algorithms,"Array,Dynamic Programming"
404,"Sum of Left Leaves
Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.",Use a stack to store right nodes and process them after the left subtree,Perform a breadth-first search and check each node's children,"Recursively traverse the tree, adding the value of any node found where node.left.left and node.left.right are both null",Utilize an iterative inorder traversal to identify left leaves,"Recursively traverse the tree, checking if the left child is a leaf node, and summing their values",Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
405,"Convert a Number to Hexadecimal
Given a 32-bit integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself. Note: You are not allowed to use any built-in library method to directly solve this problem.","Use repeated division by 16, storing remainders directly as decimal strings","Convert the number to its absolute value first, then process as unsigned, and prepend a minus sign if negative","Employ bitwise right shifts and masking to extract 4-bit segments, and map each segment to its hexadecimal equivalent","Represent the number in binary, pad to 32 bits, and directly convert the binary string to hexadecimal",Use bitwise operations (AND and right shift) to extract each 4-bit chunk and map it to its hexadecimal character.,Easy,algorithms,"Math,Bit Manipulation"
406,"Queue Reconstruction by Height
You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi. Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).",Sort the input array in ascending order based on height and then reconstruct the queue.,Create a priority queue based on height and then process elements sequentially.,"Iterate through the array and for each person, find a valid spot by shifting elements.",Recursively place people in the queue based on their height and the number of taller people in front.,Sort the input array in descending order based on height and then insert people at their specified index.,Medium,algorithms,"Array,Greedy,Binary Indexed Tree,Segment Tree,Sorting"
407,"Trapping Rain Water II
Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.","Use dynamic programming to iteratively calculate water levels from the edges inwards, but this approach may lead to stack overflow for large matrices.",Sort the height map and then calculate the trapped water based on the sorted order.,"Apply a greedy algorithm starting from the cell with the minimum height, but it may not find the optimal water level.",Calculate the average height of the entire matrix and then estimate the water trapped based on that average.,"Use a priority queue (min-heap) to process cells from the boundary inwards, tracking the maximum height encountered so far.",Hard,algorithms,"Array,Breadth-First Search,Heap (Priority Queue),Matrix"
409,"Longest Palindrome
Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, ""Aa"" is not considered a palindrome.",Return half the string length multiplied by two.,Return the total count of characters if all characters are distinct.,Return the length of the string.,"Count characters with even frequency, and the character with the highest frequency.",Count character frequencies; add pairs of even frequencies and a single odd frequency if available.,Easy,algorithms,"Hash Table,String,Greedy"
410,"Split Array Largest Sum
Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split. A subarray is a contiguous part of the array.","Dynamic Programming: Build a table storing the minimum largest sum for splitting the first 'i' elements into 'j' subarrays, considering all possible split points.",Greedy Approach: Continuously create subarrays with sums as close to the average as possible until 'k' subarrays are formed.,"Recursion with Memoization: Recursively explore all possible splits, storing intermediate results to avoid redundant computations.",Branch and Bound: Explore the solution space by pruning branches that exceed the current minimum largest sum found.,Binary Search: Use binary search on the possible range of the largest sum to find the minimum value that allows splitting into 'k' or fewer subarrays.,Hard,algorithms,"Array,Binary Search,Dynamic Programming,Greedy"
412,"Fizz Buzz
Given an integer n, return a string array answer (1-indexed) where:",XML (Extensible Markup Language),YAML (YAML Ain't Markup Language),JSON5 (JSON with extensions),"TOML (Tom's Obvious, Minimal Language)",JSON (JavaScript Object Notation),Easy,data structures,"Math,String,Simulation"
413,"Arithmetic Slices
An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array.",O(1),O(n log n),O(n^3),O(n^2 log n),O(n),Medium,algorithms,"Array,Dynamic Programming"
414,"Third Maximum Number
Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.","Use a hash table to track counts, then iterate through the sorted array.",Sort the array and return the element at index `len(nums) - 3`.,Convert the array to a set and sort the set.,"Iterate through the array three times, each time finding the next largest distinct number.",Use a priority queue (min-heap) to keep track of the three largest distinct numbers.,Easy,algorithms,"Array,Sorting"
415,"Add Strings
Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",Use a hash table to store digit frequencies and combine them.,Prepend zeros to the shorter string to equalize lengths before summing.,"Convert the strings to lists of ASCII values, sum the lists, and convert back to a string.",Multiply the two strings by powers of 10 and add the results.,"Iterate through the strings from right to left, adding digits and carrying over values as needed.",Easy,algorithms,"Math,String,Simulation"
416,"Partition Equal Subset Sum
Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",Sort the input array and check if the sum of the first half is equal to the sum of the second half.,Use a greedy approach by always adding the largest number to the subset with the smaller sum.,"Calculate the total sum and, if even, check all possible subsets using recursion.",Calculate the product of all numbers and check if the square root is an integer.,Use dynamic programming with a table to store whether a subset with a given sum is possible.,Medium,algorithms,"Array,Dynamic Programming"
417,"Pacific Atlantic Water Flow
There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",Use Depth-First Search (DFS) starting from each cell and check if both oceans are reachable.,Sort the height matrix and then perform a linear scan to find cells that can reach both oceans.,Apply Dijkstra's algorithm from both oceans to find the shortest path from each cell.,Calculate the average height of each cell's neighbors and check if it is greater than both ocean levels.,"Use Breadth-First Search (BFS) or Depth-First Search (DFS) from both oceans to mark reachable cells, then find the intersection.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
419,"Battleships in a Board
Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board. Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",Return the count of 'X' characters in the board matrix.,Count all 'X' characters and subtract the number of adjacent 'X' characters.,Return the number of rows multiplied by the number of columns containing 'X'.,Use recursion to explore the matrix and count battleships based on connected components.,Count 'X' characters only if they are the top-leftmost part of a battleship.,Medium,algorithms,"Array,Depth-First Search,Matrix"
420,"Strong Password Checker
A password is considered strong if the below conditions are all met: Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0. In one step, you can:","Increase the length until all other conditions are met, then address repeats and character types.","Simultaneously address length, repeats, and character types with independent, greedy adjustments.","Address character types first, then repeats, and finally length using a dynamic programming approach.","First reduce repeating characters to singles, then add characters to satisfy length and type conditions","Prioritize reducing repeating characters, then adjust length, and finally fulfill character type requirements",Hard,algorithms,"String,Greedy,Heap (Priority Queue)"
421,"Maximum XOR of Two Numbers in an Array
Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.","Use a brute-force approach, comparing every pair of numbers in the array with XOR",Sort the array and only XOR adjacent elements to find the maximum XOR,Calculate the average of the array and XOR each number with the average to find the maximum XOR,"Convert each number to binary, pad them to equal length, and compare each bit position to find the maximum XOR",Use a Trie data structure to efficiently search for the number that maximizes the XOR with each element,Medium,algorithms,"Array,Hash Table,Bit Manipulation,Trie"
423,"Reconstruct Original Digits from English
Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.",Use a Bloom filter to quickly check for digit existence and reconstruct based on counts,Employ dynamic programming to memoize digit combinations and minimize redundant calculations,"Sort the input string and then iterate, greedily selecting digits based on character frequency",Apply a neural network trained on English digit representations for direct translation,Count character frequencies and use them to determine the presence and quantity of each digit based on unique character patterns,Medium,algorithms,"Hash Table,Math,String"
424,"Longest Repeating Character Replacement
You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.","Use a sliding window, shrinking it when the maximum frequency of any character exceeds k.",Sort the string and then find the longest contiguous substring.,Replace all characters with the most frequent one until k is exhausted and return the string length.,Iterate through all possible substrings and check if the number of replacements needed is less than or equal to k.,"Use a sliding window, expanding it, and keep track of the maximum frequency of any character within the window. Shrink the window when the window size minus the max frequency exceeds k.",Medium,algorithms,"Hash Table,String,Sliding Window"
772,"Construct Quad Tree
Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree. Return the root of the Quad-Tree representing grid. A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes: We can construct a Quad-Tree from a two-dimensional area using the following steps: If you want to know more about the Quad-Tree, you can refer to the wiki. Quad-Tree format: You don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below. It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val]. If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.","Divide the grid into four subgrids, recursively processing only subgrids containing both 0s and 1s","Traverse the grid row by row, creating a binary tree for each row and then merging the trees","Apply a k-means clustering algorithm to group similar values, then construct a tree based on the clusters","Use a minimum spanning tree algorithm to connect adjacent cells with the same value, then derive the QuadTree","Recursively divide the grid into four quadrants; if a quadrant contains only 0s or only 1s, create a leaf node; otherwise, create an internal node and recursively process its children",Medium,data structures,"Array,Divide and Conquer,Tree,Matrix"
764,"N-ary Tree Level Order Traversal
Given an n-ary tree, return the level order traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",Depth-First Search (DFS) iteratively using a stack,Depth-First Search (DFS) recursively,Reverse level order traversal and then reverse the result,Randomized tree traversal,Breadth-First Search (BFS) iteratively using a queue,Medium,algorithms,"Tree,Breadth-First Search"
766,"Flatten a Multilevel Doubly Linked List
You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below. Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list. Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.",Use a stack to keep track of the next pointers of the current node while traversing the child list,Recursively flatten each child list and then insert the flattened child list between the current node and its next node,Iteratively traverse the list and move child nodes to the end of the list,Convert the entire multilevel list into a tree and then perform a depth-first traversal to flatten it,"Use iterative depth-first search (DFS) to traverse the list, updating next and prev pointers while setting child pointers to null",Medium,algorithms,"Linked List,Depth-First Search,Doubly-Linked List"
432,"All O`one Data Structure
Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts. Implement the AllOne class: Note that each function must run in O(1) average time complexity.","Use a hash map to store strings and their counts, and maintain separate sorted lists for min/max counts, updating them on every operation.","Employ a self-balancing binary search tree to store strings and counts, allowing for efficient retrieval of min/max but slower updates.","Utilize a simple array to store counts, iterating through it linearly to find min/max, which violates the O(1) constraint.","Implement a skiplist to store strings and counts, providing probabilistic O(1) performance for most operations.","Use doubly linked lists of buckets, each bucket containing strings with the same count, and maintain pointers to the min and max count buckets.",Hard,data structures,"Hash Table,Linked List,Design,Doubly-Linked List"
433,"Minimum Genetic Mutation
A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'. Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string. There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string. Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1. Note that the starting point is assumed to be valid, so it might not be included in the bank.",Depth-First Search (DFS),Greedy Algorithm,Divide and Conquer,Dynamic Programming,Breadth-First Search (BFS),Medium,algorithms,"Hash Table,String,Breadth-First Search"
434,"Number of Segments in a String
Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters.",Use regular expressions to find all occurrences of space characters and count the number of segments by incrementing the count each time a space is found,Iterate through the string and increment a counter each time a character is not a space,"Split the string by all characters, including spaces, and count the resulting elements","Use a stack to store each character, popping them off to form words and incrementing the count for each valid word",Split the string by spaces and filter out empty strings to count the number of segments,Easy,algorithms,String
435,"Non-overlapping Intervals
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.","Sort intervals by start time and greedily choose intervals with the earliest end time, maximizing the number of kept intervals",Sort intervals by their length and remove the shortest intervals first until no overlaps exist,Sort intervals by end time and always remove the interval with the latest start time,"Iterate through all possible subsets of intervals and check for non-overlapping conditions, choosing the subset with the maximum size","Sort intervals by end time and greedily choose intervals with the earliest end time, minimizing removed intervals",Medium,algorithms,"Array,Dynamic Programming,Greedy,Sorting"
436,"Find Right Interval
You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique. The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j. Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.",Sort the intervals by their end times and perform a linear search for each interval's right interval.,"Use a hash map to store the intervals and their indices, then iterate through the intervals and search the hash map for the right interval.","Sort the intervals based on their start times, and for each interval, linearly scan for a suitable right interval from the sorted intervals.","For each interval, iterate through all other intervals and select the one with the smallest start time greater than or equal to the current interval's end time, using O(n^2) complexity.",Sort the intervals by start times and use binary search to find the smallest start time that is greater than or equal to the end time of the current interval.,Medium,algorithms,"Array,Binary Search,Sorting"
437,"Path Sum III
Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).",Perform a level-order traversal and check all possible paths from root to leaf.,Use dynamic programming to store path sums for each node and reuse them.,"Apply a greedy algorithm, always choosing the path that gets closest to the target sum.",Convert the binary tree to a sorted array and then search for subarrays summing to the target.,"Use recursion to explore all possible paths starting from each node, tracking the current sum.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
438,"Find All Anagrams in a String
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.",Use a brute-force approach with nested loops to compare all substrings of 's' with 'p',"Sort both strings 's' and 'p', then iterate through 's' comparing substrings with the sorted 'p'",Precompute a hash for string 'p' and compare it with the hash of every substring of 's',Use dynamic programming to store the frequency of characters in 'p' and 's',Use a sliding window technique with character frequency counts to efficiently find anagrams,Medium,algorithms,"Hash Table,String,Sliding Window"
440,"K-th Smallest in Lexicographical Order
Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",Simulate a complete k-ary tree traversal and count nodes.,Perform a binary search between 1 and n to find the kth smallest.,Generate all numbers from 1 to n and sort them lexicographically.,Use a heap data structure to maintain the k smallest elements encountered so far.,"Iteratively explore the lexicographical tree, advancing one step at a time based on k.",Hard,algorithms,Trie
441,"Arranging Coins
You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete. Given the integer n, return the number of complete rows of the staircase you will build.","Use dynamic programming, building a table to store the number of rows for each possible number of coins.","Apply binary search on the range [1, n] to find the largest k such that k*(k+1)/2 <= n, but without handling potential integer overflow.","Iteratively subtract row numbers (1, 2, 3, ...) from n until n becomes negative, then return the number of iterations minus one.",Recursively calculate the number of rows by subtracting the current row number from n and calling the function again with the updated value.,"Apply binary search on the range [1, n] to find the largest k such that k*(k+1)/2 <= n.",Easy,algorithms,"Math,Binary Search"
442,"Find All Duplicates in an Array
Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output",Create a hash map to count the occurrences of each number and return those with a count of 2.,"Sort the array and iterate through it, adding numbers to the result array if a number equals the subsequent one.","For each number, check if it is already present in another array, if so, add it to the duplicates array.","Iterate through the array, and for each number, perform a linear search to find duplicates.","Iterate through the array, using each number as an index (with adjustments) to negate the value at that index; if an index is already negative, the number is a duplicate.",Medium,algorithms,"Array,Hash Table"
443,"String Compression
Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars. After you are done modifying the input array, return the new length of the array. You must write an algorithm that uses only constant extra space.","Use a hash map to count character frequencies, then rebuild the array with the counts as strings.","Create a new string, append each character and its count, and then replace the original array.","Iterate through the array, replacing consecutive characters with the first character and its count.",Sort the array first and then apply run-length encoding using a separate array.,"Use two pointers, one for reading and one for writing, to compress in place, handling counts > 9 correctly.",Medium,algorithms,"Two Pointers,String"
445,"Add Two Numbers II
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","Reverse both lists, add them element-wise, and reverse the result",Pad the shorter list with leading zeros and add the lists element-wise,"Convert both lists to strings, concatenate them, parse as integers, sum them, convert back to a string, and then to a linked list","Use recursion to add the lists from the head, storing the carry in a global variable","Use stacks to store the digits, pop them, add, and create a new linked list from head to tail managing carry",Medium,algorithms,"Linked List,Math,Stack"
446,"Arithmetic Slices II - Subsequence
Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array. The test cases are generated so that the answer fits in 32-bit integer.",Use a hash map to store the index of each number and recursively find arithmetic subsequences.,Sort the array first and then use dynamic programming to find arithmetic subsequences.,Use a two-pointer approach to iterate through the array and check for arithmetic subsequences.,Iterate through all possible combinations of elements and check if they form an arithmetic subsequence.,Use dynamic programming with a hash map to store the counts of arithmetic subsequences ending at each index with different common differences.,Hard,algorithms,"Array,Dynamic Programming"
447,"Number of Boomerangs
You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Return the number of boomerangs.","Use a brute-force approach, calculating all pairwise distances and checking the boomerang condition in O(n^3) time.","Sort the points based on x-coordinates, then use a sliding window to identify potential boomerangs.","Precompute all pairwise distances and store them in a matrix, then iterate through the matrix to count boomerangs.","Use a KD-tree to efficiently find points within a certain radius, optimizing the search for potential boomerangs.","For each point, calculate distances to all other points, store them in a hash map, and then count boomerangs based on pairs with equal distances.",Medium,algorithms,"Array,Hash Table,Math"
448,"Find All Numbers Disappeared in an Array
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",Use a hash map to store the presence of each number in nums and then iterate from 1 to n to find the missing numbers.,"Sort the array nums and then iterate through it, comparing each element with its index to find the missing numbers.","Create a boolean array of size n+1, mark present numbers as true, and then iterate to find indices marked as false.","Use binary search on a sorted version of nums for each number from 1 to n, adding numbers not found to the result.","Iterate through nums. For each num, change the sign of the element at index |num| - 1. Then, iterate to find indices with positive values, which indicate missing numbers.",Easy,algorithms,"Array,Hash Table"
449,"Serialize and Deserialize BST
Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible.","Use level-order traversal and store node values with delimiters, then reconstruct using a queue.","Perform an in-order traversal and store node values, reconstructing by repeatedly inserting into an initially empty BST.","Employ post-order traversal, storing node values; rebuild by iteratively placing elements in the correct BST position.",Serialize only the leaf nodes and reconstruct by creating a perfectly balanced BST from them.,Pre-order traversal serialization with null markers; deserialize by recursively constructing the tree.,Medium,data structures,"String,Tree,Depth-First Search,Breadth-First Search,Design,Binary Search Tree,Binary Tree"
450,"Delete Node in a BST
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:",Replace the node with its inorder successor's left child.,Replace the node with its inorder predecessor's right child.,Replace the node with the largest value in the entire BST.,Replace the node with a randomly selected node from the BST.,Replace the node with its inorder successor or predecessor.,Medium,data structures,"Tree,Binary Search Tree,Binary Tree"
451,"Sort Characters By Frequency
Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.",Use a heap to store character counts and then build the string,Sort the string directly using a comparison function based on character ASCII values,Reverse the string and then count character frequencies to sort,Use a binary search tree to store character counts and then perform an in-order traversal,"Use a hash map to count character frequencies, then sort by frequency and build the string",Medium,algorithms,"Hash Table,String,Sorting,Heap (Priority Queue),Bucket Sort,Counting"
452,"Minimum Number of Arrows to Burst Balloons
There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons.",Sort the balloons by their start points and greedily shoot arrows at the earliest end point.,Use dynamic programming to calculate the minimum arrows for each possible subrange of balloons.,Create a graph where balloons are nodes and overlapping balloons are connected by edges. Find the maximum clique.,"Randomly shoot arrows until all balloons are burst, then repeat and take the minimum number of arrows.","Sort the balloons by their end points and greedily shoot arrows at the earliest end point, skipping overlapping balloons.",Medium,algorithms,"Array,Greedy,Sorting"
453,"Minimum Moves to Equal Array Elements
Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment n - 1 elements of the array by 1.",O(n log n),O(n^2),O(n!),O(1),O(n),Medium,algorithms,"Array,Math"
454,"4Sum II
Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:",Sort all four arrays and use a four-pointer approach to find quadruplets that sum to zero.,"Iterate through all possible combinations of indices i, j, k, and l, and count the tuples where nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0.",Use dynamic programming to store the sums of two arrays and then efficiently search for the remaining sums.,Combine all four arrays into one and use a three-sum approach.,"Use a hash map to store the sums of nums1 and nums2, then iterate through nums3 and nums4, checking if the negative sum exists in the hash map.",Medium,algorithms,"Array,Hash Table"
455,"Assign Cookies
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.","The time complexity is O(n), and the space complexity is O(1)","The time complexity is O(n log n), and the space complexity is O(n)","The time complexity is O(n^2), and the space complexity is O(1)","The time complexity is O(m + n), where m and n are the sizes of g and s respectively, and the space complexity is O(1)","The time complexity is O(mlogm + nlogn), where m and n are the sizes of g and s respectively, and the space complexity is O(1)",Easy,algorithms,"Array,Greedy,Sorting"
456,"132 Pattern
Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false.","Use a nested loop to check every possible triplet combination, resulting in O(n^3) time complexity.",Sort the array and then check for the pattern in the sorted array.,Keep track of the maximum element seen so far and use it to find potential '2' elements.,Use a hash map to store the frequency of each element and then search for the pattern.,Use a stack to track potential '2' elements and efficiently find the '1' and '3' elements.,Medium,algorithms,"Array,Binary Search,Stack,Monotonic Stack,Ordered Set"
457,"Circular Array Loop
You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i: Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element. A cycle in the array consists of a sequence of indices seq of length k where: Return true if there is a cycle in nums, or false otherwise.","Always move forward, regardless of the sign of the numbers",Assume a cycle exists if any two numbers in the array are the same,Terminate the search after a fixed number of iterations to avoid infinite loops,Only consider cycles that start at index 0,Detect cycles by using slow and fast pointers and verifying that all movements within the cycle are in the same direction,Medium,algorithms,"Array,Hash Table,Two Pointers"
458,"Poor Pigs
There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous. You can feed the pigs according to these steps: Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.","Binary search the buckets repeatedly, reducing the search space by half with each round of pig testing.",Use a number of pigs equal to the square root of the number of buckets.,"Test all buckets sequentially with one pig, resetting the timer after each death.",Use one pig to test all buckets simultaneously by mixing equal amounts of liquid from each bucket and observing if the pig dies.,Represent each bucket as a number in base 'number of rounds + 1' and use each pig as a digit in that base.,Hard,algorithms,"Math,Dynamic Programming,Combinatorics"
459,"Repeated Substring Pattern
Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.",Calculate the prefix function (LPS array) and check if `n % (n - lps[n-1]) == 0` where `n` is the length of the string,Iterate through all possible substring lengths from 1 to n/2 and use `string.find()` to check if the substring repeats to form the original string.,"Use dynamic programming to build a table of booleans indicating whether a substring of a certain length can be repeated, and check the final value",Construct a suffix tree for the string and check if any internal node's string depth is a divisor of the string's length.,"Concatenate the string with itself, remove the first and last characters, and check if the original string is a substring of the result.",Easy,algorithms,"String,String Matching"
460,"LFU Cache
Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity.","A doubly linked list sorted by frequency, with a hashmap for key-node access.","A single linked list, where nodes are moved to the front on access.","A hash map storing all keys and their frequencies, with a background thread for eviction.",A tree data structure where nodes are sorted by frequency and insertion order.,"A hash map for key-node access, and multiple doubly linked lists, each representing a frequency level.",Hard,data structures,"Hash Table,Linked List,Design,Doubly-Linked List"
461,"Hamming Distance
The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, return the Hamming distance between them.",The number of trailing zeros in x XOR y.,The number of leading zeros in x AND y.,The sum of set bits in x and y.,The number of bits required to represent the larger of x and y.,The number of set bits in x XOR y.,Easy,algorithms,Bit Manipulation
462,"Minimum Moves to Equal Array Elements II
Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer.",Select the element closest to the mean,Select the maximum element in the array,Select a random element in the array,Select the minimum element in the array,Select the median element of the sorted array,Medium,algorithms,"Array,Math,Sorting"
463,"Island Perimeter
You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.",Count the number of land cells and multiply by 4.,Count the number of water cells and subtract from the total number of cells.,Calculate the area of the island and equate it to the perimeter.,Sum the row and column indices of all land cells.,"Iterate through the grid, and for each land cell, add 1 to the perimeter for each side that is water or at the grid boundary.",Easy,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
464,"Can I Win
In the ""100 game"" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins. What if we change the game so that players cannot re-use integers? For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100. Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.",Brute-force minimax search without memoization leading to exponential time complexity,A greedy approach that always chooses the largest available number,Using dynamic programming with a 2D table to store the win/loss states,A randomized algorithm that simulates multiple games and estimates the win probability,Memoization combined with minimax search to efficiently explore the game tree,Medium,algorithms,"Math,Dynamic Programming,Bit Manipulation,Memoization,Game Theory,Bitmask"
466,"Count The Repetitions
We define str = [s, n] as the string str which consists of the string s concatenated n times. We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2]. Return the maximum integer m such that str = [str2, m] can be obtained from str1.","Employ dynamic programming, storing counts of s2 substrings within s1 repetitions.",Use regular expressions to find occurrences of s2 within s1 and extrapolate for repetitions.,Precompute all possible substrings of s2 and check their presence within concatenated s1.,Decompose s1 and s2 into character frequency maps and compare for divisibility.,Identify repeating patterns in s1's repetitions to efficiently count occurrences of s2.,Hard,algorithms,"String,Dynamic Programming"
algorithms,467,"Unique Substrings in Wraparound String
We define the string base to be the infinite wraparound string of ""abcdefghijklmnopqrstuvwxyz"", so base will look like this: Given a string s, return the number of unique non-empty substrings of s are present in base.",Generate all possible substrings of 's' and use a hash set to check if each is present in the wraparound string.,Construct a very long string consisting of several repetitions of the wraparound string and check for substrings of 's' within this long string.,"Iterate through all possible substring lengths and starting positions in 's', checking if each substring is in alphabetical order.",Use dynamic programming to store all possible substrings of 's' and then iterate the wraparound string comparing for existence.,,"['dynamic programming', 'string manipulation', 'substring']","Use dynamic programming to track the longest consecutive sequence ending at each character of 's', then sum the unique lengths."
algorithms,468,"Validate IP Address
Given a string queryIP, return ""IPv4"" if IP is a valid IPv4 address, ""IPv6"" if IP is a valid IPv6 address or ""Neither"" if IP is not a correct IP of any type. A valid IPv4 address is an IP in the form ""x1.x2.x3.x4"" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, ""192.168.1.1"" and ""192.168.1.0"" are valid IPv4 addresses while ""192.168.01.1"", ""192.168.1.00"", and ""192.168@1.1"" are invalid IPv4 addresses. A valid IPv6 address is an IP in the form ""x1:x2:x3:x4:x5:x6:x7:x8"" where: For example, ""2001:0db8:85a3:0000:0000:8a2e:0370:7334"" and ""2001:db8:85a3:0:0:8A2E:0370:7334"" are valid IPv6 addresses, while ""2001:0db8:85a3::8A2E:037j:7334"" and ""02001:0db8:85a3:0000:0000:8a2e:0370:7334"" are invalid IPv6 addresses.","Split the string by '.' or ':', validate each part is within range, and check for leading zeros or invalid characters",Use regular expressions to match the IPv4 and IPv6 patterns without range validation,Convert the IP address to an integer and check if it falls within the allowed range for IPv4 or IPv6,"Check if the IP address contains only digits, '.', and ':', then apply a fuzzy matching algorithm against known IP address ranges",,"['string parsing', 'validation', 'IP address']","Parse the string by delimiters, validate segments' lengths, range, hexadecimal characters (if IPv6), and leading zeros (if IPv4)"
algorithms,903,"Implement Rand10() Using Rand7()
Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API. Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().","Multiply the result of (rand7() - 1) by 7 and add another rand7() call, returning the value modulo 10","Return the average of two calls to rand7(), rounded to the nearest integer","Return rand7() % 10 + 1, ensuring the result is within the desired range",Square the result of rand7() and take the remainder when divided by 10,,"['random number generation', 'rejection sampling', 'probability']","Repeatedly generate a number between 1 and 49 using (rand7() - 1) * 7 + rand7(), and return the number modulo 10 plus 1 if it's less than or equal to 40, otherwise repeat."
algorithms,472,"Concatenated Words
Given an array of strings words (without duplicates), return all the concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",Use dynamic programming to determine if each word can be formed by concatenating other words in the array.,Sort the array by length and then iterate through the array to check if each word is a concatenation of previous words using string slicing.,"Create a Trie data structure of all the words, and for each word, search the Trie to see if it can be formed by other words.",Recursively check for each word if it is composed of other words by splitting the word and searching in the array.,,"['string', 'dynamic programming', 'concatenation']","Sort the array by length and then use a set to store valid words. Iterate through the array and for each word, check if it can be segmented using the words in the set."
algorithms,473,"Matchsticks to Square
You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Return true if you can make this square and false otherwise.",Greedily assign matchsticks to sides until all are used or a side overflows.,Sort the matchsticks array and then use dynamic programming to find if a subset sums to a side length.,"Recursively explore all possible combinations of matchstick assignments, pruning branches when a side exceeds the target length.",Check if the sum of matchsticks is divisible by 4 and each matchstick is less than or equal to sum/4.,,"['backtracking', 'recursion', 'array']","Use backtracking to try assigning each matchstick to a side, returning true if all sides reach the target length."
474,"Ones and Zeroes
You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset. A set x is a subset of a set y if all elements of x are also elements of y.",Greedily select strings with the fewest ones and zeros until either m or n is exhausted.,Sort the strings by length and then use a sliding window approach to find the largest subset.,"Recursively explore all possible subsets, pruning branches that exceed the limits of m and n.",Use dynamic programming with a 1D array representing the maximum number of strings possible with a fixed number of zeros or ones.,Use dynamic programming with a 2D array where dp[i][j] represents the maximum number of strings with at most i zeros and j ones.,Medium,algorithms,"Array,String,Dynamic Programming"
475,"Heaters
Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater's warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses. Notice that all the heaters follow your radius standard, and the warm radius will the same.","Binary search on houses for nearest heater, then binary search on heaters for nearest house",Sort houses and heaters and use two pointers to find the minimum distance for each house,Calculate the distance between each house and every heater and take the maximum of the minimum distances,Use a hash map to store the positions of heaters and iterate through houses to find the closest heater,Sort houses and heaters and use two pointers to find the minimum radius required to cover each house,Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
476,"Number Complement
The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation. Given an integer num, return its complement.",Return num XOR (num + 1),Return ~num,Return num * -1 - 1,Return num ^ 0xFFFFFFFF,Return (1 << num.bit_length()) - 1 ^ num,Easy,algorithms,Bit Manipulation
477,"Total Hamming Distance
The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.","Calculate the Hamming distance between each pair of numbers using XOR and bit counting within nested loops, resulting in O(n^2) time complexity.","Sort the array first, then iterate through it, calculating the Hamming distance only for adjacent elements to reduce computational cost.","Convert all integers to their binary string representations, pad them to the same length, and then count the differences between characters at each index.","For each bit position (0 to 31), count the number of integers with a '1' in that position and multiply it by the number of integers with a '0' in that position, then sum these products.","Iterate through each bit position (0 to 31), counting the number of integers with a '1' in that position. Multiply this count by the number of integers with a '0' in that position, and sum the results across all bit positions.",Medium,algorithms,"Array,Math,Bit Manipulation"
915,"Generate Random Point in a Circle
Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle. Implement the Solution class:",Generate two random numbers between 0 and 1 and use them as x and y offsets from the center.,"Generate a random angle and a random radius between 0 and the given radius, then convert to Cartesian coordinates.","Divide the circle into quadrants and generate a random point within one of the quadrants, then reflect it.","Use a uniform distribution to pick a point within the square bounding the circle, and reject if it's outside the circle.","Generate a random angle and a random radius scaled by the square root of a uniform random variable, then convert to Cartesian coordinates.",Medium,algorithms,"Math,Geometry,Rejection Sampling,Randomized"
479,"Largest Palindrome Product
Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.","Find the largest and smallest n-digit numbers, then iterate downwards checking for palindromes",Generate all possible products of n-digit numbers and check each for palindromicity.,Start with the largest possible palindrome and check if it can be factored into two n-digit numbers.,Use dynamic programming to store intermediate palindrome values for faster computation,"Construct palindromes from the largest possible n-digit numbers downwards, and check for factorization",Hard,algorithms,Math
480,"Sliding Window Median
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values. You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.","Use a heap to maintain the elements within the window, and extract the median from the heap.",Sort the array at each window position and directly extract the median.,"Use a self-balancing BST (e.g., AVL tree) to store the window elements, and find the median by traversing the BST.","Iterate through the array, keeping track of the window bounds and recalculating the median each time.","Use two heaps (min-heap and max-heap) to maintain the smaller and larger halves of the window, allowing for efficient median calculation.",Hard,algorithms,"Array,Hash Table,Sliding Window,Heap (Priority Queue)"
481,"Magical String
A magical string s consists of only '1' and '2' and obeys the following rules: The first few elements of s is s = ""1221121221221121122……"". If we group the consecutive 1's and 2's in s, it will be ""1 22 11 2 1 22 1 22 11 2 11 22 ......"" and the occurrences of 1's or 2's in each group are ""1 2 2 1 1 2 1 2 2 1 2 2 ......"". You can see that the occurrence sequence is s itself. Given an integer n, return the number of 1's in the first n number in the magical string s.",Iteratively construct the magical string and count 1s up to n using string manipulation.,Use recursion to generate the magical string and count 1s using a global variable.,Precompute the entire magical string up to a large limit and return a substring with the count of 1s.,"Employ dynamic programming, storing the counts of 1s at each index of the magical string.","Simulate the magical string generation process, maintaining a counter for 1s while generating only up to the required length.",Medium,algorithms,"Two Pointers,String"
482,"License Key Formatting
You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k. We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key.","Split the string into substrings of length k, reverse each substring, and join with dashes.","Remove all dashes, convert to lowercase, then insert dashes every k characters from the beginning.","Remove dashes, convert to uppercase, and insert dashes every k characters from the end, without handling the first group's length.","Convert to uppercase, insert dashes every k characters starting from the beginning, and truncate any leading empty groups.","Remove dashes, convert to uppercase, then insert dashes every k characters from the end, ensuring the first group is shorter or equal to k.",Easy,algorithms,String
483,"Smallest Good Base
Given an integer n represented as a string, return the smallest good base of n. We call k >= 2 a good base of n, if all digits of n base k are 1's.","Binary search for the base k within the range [2, n-1]",Check all bases from 2 to sqrt(n) and return the smallest good base found,Factorize n and use the factors to deduce the good base,Use Newton's method to approximate the base k,Iterate through possible lengths of the all-ones representation and binary search for the base,Hard,algorithms,"Math,Binary Search"
485,"Max Consecutive Ones
Given a binary array nums, return the maximum number of consecutive 1's in the array.",O(n log n) due to sorting the array in each iteration,O(n^2) because each '1' requires a nested loop to count consecutive occurrences,O(n!) as it explores all possible sub-arrays to find the maximum consecutive ones,O(log n) by using binary search to find the first and last '1' and calculating the difference,O(n) as it iterates through the array once to count consecutive ones,Easy,algorithms,Array
486,"Predict the Winner
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2. Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array. Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.",Greedy approach: Player 1 always chooses the larger of the two end numbers.,"Dynamic programming: Build a table representing the maximum difference in scores Player 1 can achieve for each subarray, without memoization.",Recursion: Exhaustively explore all possible choices for both players.,Depth-first search: Explore different paths of choices until the end of the array.,"Dynamic programming: Build a table representing the maximum difference in scores Player 1 can achieve for each subarray, using memoization to avoid recomputation.",Medium,algorithms,"Array,Math,Dynamic Programming,Recursion,Game Theory"
488,"Zuma Game
You are playing a variation of the game Zuma. In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand. Your goal is to clear all of the balls from the board. On each turn: Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.","Use dynamic programming to store intermediate results and avoid redundant calculations, considering all possible insertions at each position.","Apply a greedy algorithm, always inserting the ball that immediately eliminates the longest consecutive sequence of the same color.","Recursively try all possible insertion positions and ball colors, pruning the search space when the hand runs out of balls or the board cannot be cleared.","Simulate the game using a breadth-first search, exploring all possible game states and tracking the minimum number of balls used.","Employ a backtracking algorithm combined with run-length encoding to efficiently manage the board and hand, pruning infeasible branches.",Hard,algorithms,"String,Dynamic Programming,Breadth-First Search,Memoization"
492,"Construct the Rectangle
A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.",Find the closest integer square root and use that as both L and W,"Start with L = area and W = 1, then decrement L and increment W until L * W equals area","Iterate through all possible values of L from 1 to area, and check if area is divisible by L",Randomly generate L and W until their product equals the given area,"Iterate from the square root of the area downwards to find a divisor (W), then calculate L as area/W",Easy,algorithms,Math
493,"Reverse Pairs
Given an integer array nums, return the number of reverse pairs in the array. A reverse pair is a pair (i, j) where:","Use a brute-force approach with nested loops to compare every pair of elements, resulting in O(n^2) complexity.","Sort the array and then iterate through it, counting pairs where nums[i] > 2 * nums[j] for i < j, resulting in O(n log n) complexity.",Use a binary search tree to store elements and efficiently find elements satisfying the reverse pair condition for each element.,"Employ a counting sort algorithm, leveraging auxiliary arrays to derive the reverse pair count.","Apply a modified merge sort algorithm where, during the merge step, reverse pairs are counted efficiently, achieving O(n log n) complexity.",Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
494,"Target Sum
You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. Return the number of different expressions that you can build, which evaluates to target.","Use a greedy algorithm, always choosing the sign that gets you closest to the target.",Sort the array and use binary search to find a subset that sums to the target.,"Recursively explore all possible combinations of signs, pruning branches that exceed the target.",Use dynamic programming with a 1D array representing the number of ways to achieve each sum.,Use dynamic programming with a 2D array where dp[i][j] represents the number of ways to achieve sum j using the first i elements.,Medium,algorithms,"Array,Dynamic Programming,Backtracking"
495,"Teemo Attacking
Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned.",The sum of the duration multiplied by the number of attacks.,The length of the timeSeries array multiplied by the duration.,"The difference between the last and first attack time, plus the duration.",The sum of all attack times plus the duration.,"Iterate through the timeSeries, calculating the poisoned duration for each interval, considering overlaps, and summing the non-overlapping durations.",Easy,algorithms,"Array,Simulation"
496,"Next Greater Element I
The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.",Use nested loops to search for each element of `nums1` in `nums2` and find the next greater element.,Sort both `nums1` and `nums2` and then iterate through them simultaneously to find the next greater element.,Employ a hash map to store indices of `nums2` and then linearly search for the next greater element in `nums2` for each element in `nums1`.,"Precompute the maximum element in `nums2` and return it if any element in `nums1` is smaller, otherwise return -1.",Utilize a stack to maintain a decreasing sequence of elements from `nums2` to efficiently find the next greater element for each element.,Easy,algorithms,"Array,Hash Table,Stack,Monotonic Stack"
914,"Random Point in Non-overlapping Rectangles
You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle. Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned. Note that an integer point is a point that has integer coordinates. Implement the Solution class:",Select a rectangle randomly with uniform probability and then pick a random point within it.,"Calculate the area of each rectangle, select a rectangle proportional to its area, and pick a random point.","Divide the space into a grid and randomly select a grid cell. If the cell is within a rectangle, return it; otherwise, repeat.",Randomly select x and y coordinates within the bounding box of all rectangles. Check if the point is within any rectangle and resample until it is.,"Calculate the area of each rectangle and its cumulative sum, use binary search to select a rectangle proportional to its area, and pick a random point within that rectangle.",Medium,algorithms,"Math,Binary Search,Reservoir Sampling,Prefix Sum,Ordered Set,Randomized"
498,"Diagonal Traverse
Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.",Reverse the matrix row by row and then traverse it in column-major order.,Sort all elements of the matrix and then reshape them back into the original dimensions.,"Traverse the matrix in a spiral pattern, appending elements to the result array.","Iterate through the matrix row by row, adding elements to the result array in that order.","Iterate through diagonals, handling boundary conditions to change direction when necessary.",Medium,algorithms,"Array,Matrix,Simulation"
500,"Keyboard Row
Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below. Note that the strings are case-insensitive, both lowercased and uppercased of the same letter are treated as if they are at the same row. In the American keyboard:",Use regular expressions to check if each word matches one of the keyboard rows,"Create a hashmap of characters to row numbers, then iterate through the words and check if all characters belong to the same row",Convert each word to a numerical representation based on ASCII values and check for specific row patterns,Utilize bit manipulation to encode each character's row and perform a bitwise AND operation to check for consistency,Create sets for each keyboard row and check if the set of characters in each word is a subset of any of the row sets,Easy,algorithms,"Array,Hash Table,String"
501,"Find Mode in Binary Search Tree
Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows:","Use a hash map to store the frequency of each element, then iterate through the map to find the mode(s)",Convert the BST to a sorted array and then iterate through the array to find the longest consecutive sequence,"Perform a breadth-first search (BFS) and store all nodes in a queue, then process the queue to find the mode(s)","Recursively traverse the tree, keeping track of the maximum frequency seen so far and the current element's frequency","Perform an in-order traversal, keeping track of the current element, its frequency, the maximum frequency, and the mode(s)",Easy,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
502,"IPO
Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it. Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital. Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital. The answer is guaranteed to fit in a 32-bit signed integer.","Sort projects by capital required, then greedily choose the k projects with the highest profit.",Use dynamic programming to find the optimal subset of projects within the capital limit.,Randomly select k projects and hope for the best outcome.,Always choose the project with the lowest capital requirement first.,Use a priority queue (heap) to keep track of available projects and choose the most profitable ones within the capital constraint.,Hard,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
503,"Next Greater Element II
Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.","Use a nested loop to iterate through the array for each element, resulting in O(n^2) time complexity.","Create a temporary array with double the length of the original, copy the original array twice, and then use a single loop.","Sort the array first and then use a binary search to find the next greater element for each element, resulting in O(n log n) time complexity.","Maintain a minimum heap of size n, storing the elements and their indices. Then, for each element, search for the next greater element in the heap.",Use a stack to keep track of indices of elements and iterate through the array twice to simulate circularity.,Medium,algorithms,"Array,Stack,Monotonic Stack"
504,"Base 7
Given an integer num, return a string of its base 7 representation.","Repeatedly divide the number by 7, taking the remainders as digits and building the base 7 number from left to right.",Directly convert the number to a string using a built-in base conversion function.,"Represent the number in binary, then convert the binary representation to base 7.","Multiply the number by 7 until it becomes smaller than 7, then use the final result as the base 7 representation.","Repeatedly divide the number by 7, taking the remainders as digits and building the base 7 number from right to left, handling negative numbers correctly.",Easy,algorithms,Math
506,"Relative Ranks
You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique. The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank: Return an array answer of size n where answer[i] is the rank of the ith athlete.",Use a hash table to store the scores and then iterate through the sorted scores to assign ranks.,Sort the original array and create a separate array with the rank strings based on index.,Create a min-heap of the scores and iteratively assign ranks based on heap extraction.,Use a binary search tree to keep track of the scores and their ranks during insertion.,Sort the indices based on the scores and then create a result array mapping original indices to their rank strings.,Easy,algorithms,"Array,Sorting,Heap (Priority Queue)"
507,"Perfect Number
A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false.",A number where the product of its digits equals the sum of its digits.,A prime number that is also a palindrome.,A number where all its digits are the same.,A number divisible by all positive integers less than or equal to its square root.,A positive integer equal to the sum of its proper divisors (excluding the number itself).,Easy,algorithms,Math
508,"Most Frequent Subtree Sum
Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).",Return the sum of the root's left and right children's values,Calculate the sum of all node values in the tree and return it,"Return the value of the root node if the tree is not empty, otherwise return 0",Maintain a global variable to track the maximum subtree sum encountered so far,"Recursively calculate subtree sums, store their frequencies in a hash map, and return the sums with the highest frequency",Medium,algorithms,"Hash Table,Tree,Depth-First Search,Binary Tree"
1013,"Fibonacci Number
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, Given n, calculate F(n).","Use a loop and two variables to store the two preceding numbers, calculating the next in each iteration.","Apply recursion without memoization, calculating F(n-1) + F(n-2) repeatedly.",Utilize dynamic programming with a one-dimensional array to store intermediate Fibonacci numbers.,"Employ matrix exponentiation for O(log n) time complexity, raising a transformation matrix to the power of n.","Apply recursion with memoization, storing previously computed Fibonacci numbers to avoid redundant calculations.",Easy,algorithms,"Math,Dynamic Programming,Recursion,Memoization"
1179,"Game Play Analysis I
Table: Activity  Write a solution to find the first login date for each player. Return the result table in any order. The result format is in the following example.",AVG(event_date) OVER (PARTITION BY player_id),MAX(event_date) OVER (PARTITION BY player_id ORDER BY event_date DESC),event_date,RANK() OVER (ORDER BY event_date),MIN(event_date) OVER (PARTITION BY player_id),Easy,database systems,Database
513,"Find Bottom Left Tree Value
Given the root of a binary tree, return the leftmost value in the last row of the tree.","Perform a pre-order traversal, updating the bottom-left value whenever a leaf node is encountered","Calculate the height of the tree and then perform a level-order traversal, stopping at the last level",Perform a depth-first search (DFS) and keep track of the leftmost node at each level visited,Perform a breadth-first search (BFS) and return the first node encountered at the last level,Perform a breadth-first search (BFS) and return the value of the last node enqueued,Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
514,"Freedom Trail
In the video game Fallout 4, the quest ""Road to Freedom"" requires players to reach a metal dial called the ""Freedom Trail Ring"" and use the dial to spell a specific keyword to open the door. Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword. Initially, the first character of the ring is aligned at the ""12:00"" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the ""12:00"" direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]:","Greedy approach, always rotate in the direction that reaches the next character of the key faster.","Dynamic programming with state (index in ring, index in key) to store minimum steps.",Backtracking to explore all possible rotations and find the minimum steps.,Simulate the rotation using a queue and track the total number of rotations until the key is spelled.,Dynamic programming with memoization to avoid redundant calculations of the minimum rotations between ring positions.,Hard,algorithms,"String,Dynamic Programming,Depth-First Search,Breadth-First Search"
515,"Find Largest Value in Each Tree Row
Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).","Depth-first search, updating a map of row to largest value","Level-order traversal, comparing each node's value to the current row's largest value stored in an array",Recursively traverse the tree and maintain a global maximum for each level,"Preorder traversal, storing values in a list and finding the maximum at the end","Breadth-first search, tracking the maximum value seen at each level",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
516,"Longest Palindromic Subsequence
Given a string s, find the longest palindromic subsequence's length in s. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",Greedily expand around each character as the center of a potential palindrome.,Use dynamic programming to build a table of all possible subsequences and their lengths.,Reverse the string and find the longest common subsequence between the original and reversed strings.,"Employ a divide-and-conquer approach, recursively breaking down the string into smaller subproblems.",Use dynamic programming to build a table storing lengths of palindromic subsequences for substrings.,Medium,algorithms,"String,Dynamic Programming"
517,"Super Washing Machines
You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. For each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time. Given an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.",The maximum absolute value of prefix sums of (machines[i] - average),The sum of absolute differences between each machine's load and the average load.,The maximum difference between any two machine loads.,The total number of dresses divided by the number of washing machines.,The maximum of the absolute value of the prefix sum of (machines[i] - average) and the maximum load transfer required at any machine.,Hard,algorithms,"Array,Greedy"
913,"Random Flip Matrix
There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned. Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity. Implement the Solution class:","Use a hash table to track flipped indices, generating random coordinates until an unflipped index is found.",Precompute all possible unflipped indices into an array and randomly select an element from the array.,"Simulate the matrix directly, flipping a random cell until an unflipped cell is found.","Maintain a separate matrix representing the flipped state and generate random coordinates until an unflipped cell is found, updating both matrices.","Use a hash map to map original indices to available indices and a counter to track available slots, generating random numbers within the counter's range.",Medium,algorithms,"Hash Table,Math,Reservoir Sampling,Randomized"
520,"Detect Capital
We define the usage of capitals in a word to be right when one of the following cases holds: Given a string word, return true if the usage of capitals in it is right.",Convert the string to lowercase and check if it's equal to the original,Check if the first letter is uppercase and the rest are lowercase,Use regular expressions to match all possible capitalizations,Count the number of uppercase letters and compare it to the string length,"Check if the word is either all uppercase, all lowercase, or only the first letter is uppercase",Easy,algorithms,String
521,"Longest Uncommon Subsequence I
Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1. An uncommon subsequence between two strings is a string that is a subsequence of exactly one of them.","Return the length of the shorter string if they are different, otherwise -1",Return the maximum length of the two strings regardless of their content,"Return the length of the longer string if one is a subsequence of the other, otherwise -1",Return the difference in length between the two strings,"Return the length of the longer string if they are different, otherwise -1",Easy,algorithms,String
522,"Longest Uncommon Subsequence II
Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1. An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others. A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.",Compare each string with all possible subsequences of other strings using brute force.,Sort the strings by length and then check for uncommon subsequences only in the longer strings.,Return the length of the longest string in the array.,Return the length of the shortest string in the array.,"Iterate through the strings, checking if each string is a subsequence of any other string. The longest string that isn't a subsequence of any other is the answer.",Medium,algorithms,"Array,Hash Table,Two Pointers,String,Sorting"
523,"Continuous Subarray Sum
Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where: Note that:",Check if the sum of all elements is divisible by k,Check if any single element is equal to k,Check if any two consecutive elements sum to k,"Calculate the sum of all possible subarrays and check for divisibility by k, stopping after the first found subarray","Use a hash map to store remainders when dividing prefix sums by k. If a remainder repeats, a good subarray exists.",Medium,algorithms,"Array,Hash Table,Math,Prefix Sum"
524,"Longest Word in Dictionary through Deleting
Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.",Depth-First Search (DFS) to explore all possible substrings.,Dynamic programming to build a table of substring matches.,Regular expression matching to find potential candidates.,Brute-force comparison of all dictionary words with all possible subsequences of the string s.,"Iterate through the dictionary, checking if each word is a subsequence of s, keeping track of the longest word found so far, resolving ties with lexicographical order.",Medium,algorithms,"Array,Two Pointers,String,Sorting"
525,"Contiguous Array
Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.",Dynamic programming with a 2D array to store subarray sums.,Brute-force: Check every possible subarray for an equal count of 0s and 1s.,Sort the array and count the number of 0s and 1s in the smallest half.,Use a greedy approach by always extending the subarray from the beginning.,"Use a hash map to store the running count (0 as -1) and its index, then calculate the maximum length.",Medium,algorithms,"Array,Hash Table,Prefix Sum"
526,"Beautiful Arrangement
Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true: Given an integer n, return the number of the beautiful arrangements that you can construct.",Dynamic programming with bitmasking to track used numbers,Greedy algorithm placing numbers closest to their index first,Backtracking with pruning based on exceeding a pre-calculated average,Using inclusion-exclusion principle to subtract invalid arrangements,Recursive approach with backtracking to explore all valid permutations,Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
912,"Random Pick with Weight
You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).",Use binary search on the prefix sum array to find the index corresponding to the generated random number,Generate a random index directly using a uniform distribution without considering weights,Select an index proportionally to its weight using a roulette wheel selection algorithm based on cumulative probabilities,Divide each weight by the total weight and store the resulting probabilities for direct index lookup,Create a prefix sum array of the weights and use binary search to find the index corresponding to a random number between 1 and the total weight,Medium,algorithms,"Math,Binary Search,Prefix Sum,Randomized"
529,"Minesweeper
Let's play the minesweeper game (Wikipedia, online game)! You are given an m x n char matrix board representing the game board where: You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E'). Return the board after revealing this position according to the following rules:","Use dynamic programming to precompute the number of mines around each cell, then reveal based on click.","Recursively expand revealed cells until a mine or a cell with adjacent mines is found, marking visited cells.","Apply a flood fill algorithm starting from the clicked cell, always revealing adjacent cells.","Check if the clicked cell is a mine. If not, reveal only that cell without expanding.","If the clicked cell is a mine, mark it as 'X'. Otherwise, if it has adjacent mines, reveal the number of adjacent mines. If it has no adjacent mines, reveal it and recursively reveal its neighbors.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
530,"Minimum Absolute Difference in BST
Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",Perform an in-order traversal and compare adjacent node values in the sorted list,Calculate the absolute difference between every pair of nodes and take the minimum,Only compare the root node's value with its immediate children's values,Perform a breadth-first search and compare the values of nodes at the same level,"Use in-order traversal to maintain sorted order, keeping track of the minimum difference between consecutive nodes",Easy,data structures,"Tree,Depth-First Search,Breadth-First Search,Binary Search Tree,Binary Tree"
532,"K-diff Pairs in an Array
Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true: Notice that |val| denotes the absolute value of val.",O(n log n) due to sorting the array,O(n^2) due to nested loops for comparing all pairs,O(k) where k is the target difference,O(1) since the array size is constant,O(n) on average using a hash set or dictionary,Medium,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Sorting"
535,"Encode and Decode TinyURL
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class:",Using MD5 hashing without collision detection or handling,Storing the URL in a database without a unique key,Encoding the URL using Base64 without any shortening,Using a simple incremental integer as the key for the URL in a hashmap and converting it to a base-36 string,"Employing a hash table to store the mapping between shortened URLs and original URLs, along with a collision resolution strategy such as chaining or open addressing",Medium,system design,"Hash Table,String,Design,Hash Function"
537,"Complex Number Multiplication
A complex number can be represented as a string on the form ""real+imaginaryi"" where: Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.","Extract real and imaginary parts, multiply separately, and combine directly without simplification.","Convert complex numbers to polar form, multiply magnitudes, and add angles, then convert back.","Parse as strings, perform string concatenation of all possible products, and then simplify.","Convert to floating-point representation, perform multiplication, and format back to a string.","Extract real and imaginary parts, apply the distributive property (FOIL), and simplify the result.",Medium,algorithms,"Math,String,Simulation"
538,"Convert BST to Greater Tree
Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints:",Perform an inorder traversal and update each node's value by adding the sum of all nodes visited so far.,"Create a sorted array of the BST nodes and then iterate from the end, accumulating sums and updating the BST.","Use a level-order traversal, maintaining a global sum which is added to each node during the traversal.","Apply a standard BST search algorithm, modifying node values during the search based on a global sum.","Perform a reverse inorder traversal, maintaining a running sum which is added to the current node's value.",Medium,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
540,"Single Element in a Sorted Array
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.","Perform a linear search through the array, comparing each element to its neighbors.",Use a hash map to count the frequency of each element and return the one with a count of 1.,"Apply binary search, but if nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1], return nums[mid]; otherwise, discard half the array based on whether mid is even or odd.",Split the array into two halves and recursively search for the single element in each half.,"Apply binary search. If nums[mid] == nums[mid+1], move to the right half if mid is even, else left half. If nums[mid] == nums[mid-1], move to the right half if mid is odd, else left half.",Medium,algorithms,"Array,Binary Search"
541,"Reverse String II
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.","Use `s[::-1]` on the entire string, then correct sections using more slicing.","Split the string into chunks of size `k`, reverse all of them, and join the result.","Iterate through the string, reversing every character using recursion.",Use a regular expression to identify and reverse the desired segments of the string.,"Iterate through the string with a step of 2k, reversing the first k characters of each segment.",Easy,algorithms,"Two Pointers,String"
542,"01 Matrix
Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two cells sharing a common edge is 1.",Use Dijkstra's algorithm treating 1s as nodes with weight 1 and 0s as the target nodes.,"Perform a breadth-first search (BFS) starting from all 1s, updating distances until a 0 is found.",Calculate the Euclidean distance between each cell and every 0 in the matrix and take the minimum.,"Iterate through the matrix, and for each cell, perform a recursive depth-first search (DFS) until a 0 is found.","Perform a breadth-first search (BFS) starting from all 0s, propagating the distance to adjacent cells.",Medium,algorithms,"Array,Dynamic Programming,Breadth-First Search,Matrix"
543,"Diameter of Binary Tree
Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.",Calculate the height of the left and right subtrees separately and return the maximum of the two heights.,Perform a breadth-first search and keep track of the maximum path length encountered.,"Find the longest path from the root to any leaf node, and double its length.",Sum the number of nodes in the left and right subtrees and subtract 1.,"Recursively calculate the height of left and right subtrees for each node, and track the maximum diameter encountered, which is the sum of the two heights plus one.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
546,"Remove Boxes
You are given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points. Return the maximum points you can get.",Greedily remove the longest consecutive sequence of boxes at each step.,Use a dynamic programming approach with a 2D table representing the optimal score for removing boxes from index i to j.,"Apply a divide-and-conquer strategy, splitting the boxes into smaller subproblems and combining the results.",Sort the boxes based on their color and then greedily remove them.,Use dynamic programming with a 3D table to store the maximum points obtainable from a subarray given a number of boxes with the same color appended to the left.,Hard,algorithms,"Array,Dynamic Programming,Memoization"
547,"Number of Provinces
There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces.","Perform Depth-First Search (DFS) on the adjacency matrix, incrementing the province count each time a new unvisited city is encountered, and marking visited cities to avoid cycles.","Iterate through the `isConnected` matrix, incrementing a counter for each cell where `isConnected[i][j] == 1`, then divide the result by 2 to account for duplicate connections.","Use a Union-Find algorithm. Initialize each city as its own province. Iterate through the matrix; if `isConnected[i][j] == 1`, union the provinces of city i and city j. The number of distinct roots represents the number of provinces.",Apply Dijkstra's algorithm to find the shortest path between each pair of cities. The number of disconnected components represents the number of provinces.,"Utilize Depth-First Search (DFS) or Breadth-First Search (BFS) on the implied graph to find connected components. Iterate through each city. If the city hasn't been visited, start a DFS/BFS from that city and increment the province count.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
1182,"Game Play Analysis IV
Table: Activity  Write a solution to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to determine the number of players who logged in on the day immediately following their initial login, and divide it by the number of total players. The result format is in the following example.",Use a correlated subquery to find the minimum login date for each player and then join back to the table to find subsequent logins.,Calculate the difference between consecutive login dates for each player using window functions and filter for a difference of exactly one day.,Use a self-join with a date difference condition and group by player to count the number of players who logged in the next day.,Create a temporary table to store the first login date for each player and then join the temporary table with the original table.,"Find the first login date for each player, then count players whose next login date is exactly one day after their first login date, and divide by the total number of players.",Medium,database systems,Database
551,"Student Attendance Record I
You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: The student is eligible for an attendance award if they meet both of the following criteria: Return true if the student is eligible for an attendance award, or false otherwise.",Check for 'A' more than once using `s.count('A') > 1` and 'LLL' using `s.find('LLL') != -1`.,Use regular expressions to find 'A.*A' and 'LLL' within the string.,"Iterate through the string and increment a counter for consecutive 'L's, resetting if a non-'L' is encountered, and track the number of 'A's using a separate counter.",Split the string into substrings using 'A' as a delimiter and check if any substring contains 'LLL'.,"Iterate through the string; if 'A' is found, increment an absence counter. If 'L' is found, increment a late counter. Reset the late counter if a non-'L' is found. Return false if absence count exceeds 1 or late count reaches 3.",Easy,algorithms,String
552,"Student Attendance Record II
An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: Any student is eligible for an attendance award if they meet both of the following criteria: Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.",Calculate the number of records with at most one 'A' and no more than two consecutive 'L's using combinatorics directly,"Generate all possible attendance records of length n and filter out the invalid ones, then count the remaining ones.","Use dynamic programming, tracking the number of 'A's and consecutive 'L's ending at each position.","Employ recursion with memoization, exploring all possible attendance records while avoiding redundant computations.","Utilize a 3D dynamic programming approach, storing the number of valid records of length i with j absences and k consecutive lates.",Hard,algorithms,Dynamic Programming
553,"Optimal Division
You are given an integer array nums. The adjacent integers in nums will perform the float division. However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum. Return the corresponding expression that has the maximum value in string format. Note: your expression should not contain redundant parenthesis.",nums[0]/(nums[1]/nums[2]/.../nums[n-1]),nums[0]/nums[1]/(nums[2]/.../nums[n-1]),(nums[0]/nums[1])/(nums[2]/.../nums[n-1]),nums[0]/(nums[1]+nums[2]+...+nums[n-1]),nums[0]/(nums[1]/nums[2]/.../nums[n-1]),Medium,algorithms,"Array,Math,Dynamic Programming"
554,"Brick Wall
There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same. Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.",Calculate the mode of brick widths for each row and subtract from the total number of rows.,Compute the variance of brick widths and select the row with the lowest variance to minimize crossings.,Use dynamic programming to find the optimal vertical line that minimizes the cumulative brick crossings.,"For each possible vertical line position, calculate crossings using nested loops, and return the minimum.",Count the frequency of edge positions in each row using a hash map and subtract the maximum frequency from the total number of rows.,Medium,algorithms,"Array,Hash Table"
556,"Next Greater Element III
Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1. Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.",Brute-force: Generate all permutations of the digits and find the smallest one greater than n.,Greedy: Always swap the last two digits to find a larger number.,Sort the digits in ascending order to find the next greater element.,"Convert the integer to a string, reverse it, find the next lexicographically greater permutation, and reverse it back.","Find the first decreasing digit from right to left, then find the smallest digit to its right that is larger than it, swap them, and sort the digits to the right of the first decreasing digit.",Medium,algorithms,"Math,Two Pointers,String"
557,"Reverse Words in a String III
Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.","Split the string into words, reverse the entire string, then split again.",Iterate through the string backwards and rebuild it word by word.,Use a stack to store the entire string and then pop characters to create reversed words.,Replace each word with its reversed form using regular expressions.,"Split the string into words, reverse each word individually, then join them back together.",Easy,algorithms,"Two Pointers,String"
773,"Logical OR of Two Binary Grids Represented as Quad-Trees
A Binary Matrix is a matrix in which all the elements are either 0 or 1. Given quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix. Return a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2. Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer. A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes: We can construct a Quad-Tree from a two-dimensional area using the following steps: If you want to know more about the Quad-Tree, you can refer to the wiki. Quad-Tree format: The input/output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below. It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val]. If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.","Return quadTree1 if quadTree2 is a leaf with value 0, and vice-versa","Convert both quadtrees to their corresponding binary matrices, perform the OR operation, and then construct a new quadtree from the result.",Return a new leaf node with value equal to (quadTree1.val OR quadTree2.val) if both are leaves.,"Always return quadTree1, ignoring quadTree2","If both nodes are leaves, return a leaf with their OR. If one is a leaf, return it if its value is 1, else return the other subtree. Otherwise, recursively OR their children.",Medium,data structures,"Divide and Conquer,Tree"
774,"Maximum Depth of N-ary Tree
Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",Perform a breadth-first search and return the number of levels visited before encountering a leaf node.,"Use a depth-first search, but only consider the leftmost branch of each node to find the depth.","Use a recursive function that returns 1, regardless of the depth of the tree.",Perform a level-order traversal and store the number of nodes at each level; the maximum of these counts is the depth.,"Use a recursive depth-first search, incrementing the depth at each level and returning the maximum depth among all children.",Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search"
560,"Subarray Sum Equals K
Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array.","Use two nested loops to check every possible subarray sum, resulting in O(n^2) time complexity.","Sort the array first, then iterate through it to find subarrays that sum to k, requiring O(n log n) time.","Employ a sliding window approach to adjust the window size until the sum equals k, but only when all numbers are non-negative.","Recursively divide the array into two halves, find subarrays summing to k in each half, and combine the results.","Use a hash map to store prefix sums and their frequencies, enabling efficient lookup for the difference (sum - k).",Medium,algorithms,"Array,Hash Table,Prefix Sum"
563,"Binary Tree Tilt
Given the root of a binary tree, return the sum of every tree node's tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.",The tilt is calculated as the sum of the absolute difference between each node's value and its parent's value.,The tilt of the tree is the difference between the maximum and minimum node values.,The tilt is calculated as the absolute difference between the sum of all node values and the number of nodes.,The tilt is the absolute difference between the total number of left and right child nodes in the tree.,"The tilt of a node is the absolute difference between the sum of its left subtree and the sum of its right subtree, summed across all nodes.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
564,"Find the Closest Palindrome
Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one. The closest is defined as the absolute difference minimized between two integers.","Increment/Decrement the input number until a palindrome is found, always returning the smaller in case of ties.","Generate palindromes of lengths one less, equal to, and one greater than the input number's length and choose the closest.","Reverse the input number and compare it with the original. If different, return the reversed number.","Consider only palindromes formed by mirroring the first half of the input number, and compare against a single decremented version.","Construct candidates by mirroring the first half of the input, and also consider mirroring after incrementing/decrementing the first half. Return the closest.",Hard,algorithms,"Math,String"
565,"Array Nesting
You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1]. You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule: Return the longest length of a set s[k].","Depth-First Search (DFS) on the array, marking visited elements to avoid cycles.",Treat the array as a graph and find the connected components using Breadth-First Search (BFS).,Sort the array and then iterate to find the longest increasing subsequence.,Use dynamic programming to store the lengths of the sets starting from each index.,"Iterate through the array, and for each unvisited element, traverse the cycle until you return to the starting element, counting the length of the cycle.",Medium,algorithms,"Array,Depth-First Search"
566,"Reshape the Matrix
In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.","Return the original matrix if r * c != m * n, otherwise create a new r x c matrix and fill it row by row by column by column of the original matrix.","Return the original matrix if r * c != m * n, otherwise flatten the original matrix into a 1D array, then create a new r x c matrix and fill it with the elements from the 1D array column by column.","Return the original matrix if r * c != m * n, otherwise transpose the original matrix and then reshape it directly using built-in functions if available.","Always create a new r x c matrix irrespective of r * c == m * n, and pad with zeros if the number of elements is fewer, or truncate if more.","Return the original matrix if r * c != m * n, otherwise flatten the original matrix into a 1D array, then create a new r x c matrix and fill it with the elements from the 1D array row by row.",Easy,algorithms,"Array,Matrix,Simulation"
567,"Permutation in String
Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",Use dynamic programming to store previously calculated substring matches and avoid redundant computations,Sort both strings and then check if s1 is a substring of s2,"Compare the lengths of s1 and s2. If len(s1) > len(s2), return false immediately. Otherwise, generate all permutations of s1 and check if any are substrings of s2.",Use regular expressions to search for all possible permutations of s1 within s2.,Use a sliding window of size s1.length() to maintain character counts and compare with the character count of s1 using a hash map or array.,Medium,algorithms,"Hash Table,Two Pointers,String,Sliding Window"
570,"Managers with at Least 5 Direct Reports
Table: Employee  Write a solution to find managers with at least five direct reports. Return the result table in any order. The result format is in the following example.",Using a self-join where the manager's ID equals the employee's manager ID and counting distinct employee IDs.,"Employing a window function to partition by manager ID and count direct reports, then filtering for counts >= 5.","Grouping by employee name and manager ID, then filtering where the employee name appears more than 5 times.",Utilizing a correlated subquery that checks if each manager's ID appears at least 5 times in the employee's manager ID column.,Grouping by manager ID and using a HAVING clause to filter for groups with a count of direct reports greater than or equal to 5.,Medium,database systems,Database
572,"Subtree of Another Tree
Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.","Perform a level-order traversal on 'root' and for each node, check if a subtree rooted at that node is identical to 'subRoot' using an iterative approach.",Convert both trees into their inorder and postorder traversal strings. Check if the inorder and postorder strings of 'subRoot' are substrings of the corresponding strings of 'root'.,Serialize both trees into strings representing their structure and values. Use string matching algorithms to find if 'subRoot's string is a substring of 'root's string.,"Compare the hashes of both trees. If the hash of 'subRoot' matches the hash of any subtree of 'root', return true.","Recursively traverse 'root'. At each node, check if the subtree rooted at that node is identical to 'subRoot' using a separate recursive function for tree comparison.",Easy,algorithms,"Tree,Depth-First Search,String Matching,Binary Tree,Hash Function"
575,"Distribute Candies
Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor. The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice. Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.",Iterate through the array and return n / 2,Calculate the mode of the array and return that value.,Sort the array and return the element at index n / 2,Return the length of the array,Find the number of unique candies and return the smaller value between that and n / 2.,Easy,algorithms,"Array,Hash Table"
576,"Out of Boundary Paths
There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.","Use dynamic programming with memoization based on (row, col, moves_left), updating the count by adding paths from adjacent cells within bounds","Employ a greedy approach, prioritizing moves that take the ball furthest from the center of the grid to reach the boundary faster",Simulate all possible paths using recursion without memoization and count paths leading out of bounds within maxMove steps,"Apply a breadth-first search (BFS) algorithm, tracking visited cells and pruning paths that exceed maxMove steps","Apply dynamic programming with memoization based on (row, col, moves_left), updating the count by adding 1 for out-of-bounds moves and paths from adjacent cells within bounds",Medium,algorithms,Dynamic Programming
577,"Employee Bonus
Table: Employee  Table: Bonus  Write a solution to report the name and bonus amount of each employee with a bonus less than 1000. Return the result table in any order. The result format is in the following example.","SELECT E.name, B.bonus FROM Employee E LEFT JOIN Bonus B ON E.empId = B.empId WHERE B.bonus >= 1000","SELECT E.name, COALESCE(B.bonus, 0) FROM Employee E JOIN Bonus B ON E.empId = B.empId","SELECT E.name, IFNULL(B.bonus, 0) FROM Employee E LEFT JOIN Bonus B ON E.empId = B.empId","SELECT E.name, B.bonus FROM Employee E INNER JOIN Bonus B ON E.empId = B.empId WHERE B.bonus < 1000","SELECT E.name, B.bonus FROM Employee E LEFT JOIN Bonus B ON E.empId = B.empId WHERE B.bonus < 1000 OR B.bonus IS NULL",Easy,database systems,Database
581,"Shortest Unsorted Continuous Subarray
Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order. Return the shortest such subarray and output its length.","Use two pointers to find the first out-of-order element from the left and right, then return the distance between them",Sort the entire array and compare it to the original to find differing indices,Iterate through the array and keep track of the minimum and maximum out-of-order elements to define the subarray boundaries,Use a sliding window approach to identify and shrink the unsorted subarray,"Scan from left to right to find the end of the increasing sequence and from right to left to find the start of the decreasing sequence, then determine the boundaries of the unsorted subarray",Medium,algorithms,"Array,Two Pointers,Stack,Greedy,Sorting,Monotonic Stack"
583,"Delete Operation for Two Strings
Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string.","Calculate the edit distance using only insertions and deletions, without substitutions.",Find the longest common substring and subtract its length from the sum of the lengths of the two strings.,Compute the Levenshtein distance and divide the result by two.,Calculate the Hamming distance between the two strings.,Find the longest common subsequence (LCS) and subtract its length twice from the sum of the lengths of the two strings.,Medium,algorithms,"String,Dynamic Programming"
584,"Find Customer Referee
Table: Customer  Find the names of the customer that are not referred by the customer with id = 2. Return the result table in any order. The result format is in the following example.",SELECT name FROM Customer WHERE referee_id = 2 OR referee_id IS NULL;,SELECT name FROM Customer WHERE referee_id <> 2;,SELECT name FROM Customer WHERE NOT EXISTS (SELECT 1 FROM Customer WHERE id = 2);,SELECT name FROM Customer WHERE referee_id = 2;,SELECT name FROM Customer WHERE referee_id IS NULL OR referee_id != 2;,Easy,database systems,Database
585,"Investments in 2016
Table: Insurance  Write a solution to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who: Round tiv_2016 to two decimal places. The result format is in the following example.",Use a correlated subquery to find distinct pid values and calculate tiv_2016,Apply a window function partitioned by tiv_2015 to calculate the sum,Calculate the sum of tiv_2016 without filtering for distinct pid values,Join the Insurance table with itself to filter based on tiv_2015 and lat/lon,Use SUM(tiv_2016) with a WHERE clause to filter for distinct policyholders and tiv_2015 conditions,Medium,database systems,Database
586,"Customer Placing the Largest Number of Orders
Table: Orders  Write a solution to find the customer_number for the customer who has placed the largest number of orders. The test cases are generated so that exactly one customer will have placed more orders than any other customer. The result format is in the following example.",SELECT customer_number FROM Orders GROUP BY customer_number ORDER BY COUNT(*) ASC LIMIT 1;,SELECT DISTINCT customer_number FROM Orders WHERE order_id IN (SELECT MAX(order_id) FROM Orders);,"SELECT customer_number FROM (SELECT customer_number, COUNT(*) AS order_count FROM Orders) AS subquery ORDER BY order_count DESC;",SELECT customer_number FROM Orders WHERE COUNT(*) = (SELECT MAX(COUNT(*)) FROM Orders GROUP BY customer_number);,SELECT customer_number FROM Orders GROUP BY customer_number ORDER BY COUNT(*) DESC LIMIT 1;,Easy,database systems,Database
587,"Erect the Fence
You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.","Graham scan, but only consider the points on the convex hull in counter-clockwise order.",Jarvis march algorithm with a modification to ignore collinear points.,Brute force: try all possible subsets of trees and check if they form a convex hull that encloses all trees.,Divide and conquer: recursively find the convex hull of smaller subsets and merge them.,"Graham scan algorithm to compute the convex hull of the given points, handling collinear points correctly.",Hard,algorithms,"Array,Math,Geometry"
775,"N-ary Tree Preorder Traversal
Given the root of an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)",Postorder traversal processes the root node after all its children.,"Level order traversal processes nodes breadth-first, level by level.","Inorder traversal is applicable only to binary trees, processing the left child, then the root, then the right child.","Reverse inorder traversal processes the right child, then the root, then the left child.","Preorder traversal processes the root node before its children, then recursively processes each child.",Easy,data structures,"Stack,Tree,Depth-First Search"
776,"N-ary Tree Postorder Traversal
Given the root of an n-ary tree, return the postorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)",Store each node's value in a hash table before processing.,Perform a breadth-first search and reverse the resulting list.,Apply a preorder traversal and reverse the resulting list.,Use a queue to store the nodes and process them in FIFO order.,Recursively traverse each child before processing the current node.,Easy,algorithms,"Stack,Tree,Depth-First Search"
591,"Tag Validator
Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:",Implement a bloom filter to check for duplicate characters in the string.,Use regular expressions to extract and validate tags.,Employ a depth-first search (DFS) algorithm to traverse the tag hierarchy.,Tokenize the input using a state machine and then validate tokens based on predefined grammar.,"Utilize a stack to track opening tags and match them against closing tags, while checking for syntax errors.",Hard,algorithms,"String,Stack"
592,"Fraction Addition and Subtraction
Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.","Use regular expressions to extract numerators and denominators, then perform arithmetic operations in floating-point format and simplify.","Parse the expression into a list of tuples representing fractions, then use the `fractions` module for calculation and format the output.",Convert the entire expression into a single string and use `eval()` to compute the result.,Iteratively find the common denominator and update each fraction accordingly before summing.,"Parse the string, find the common denominator, add or subtract numerators, simplify the resulting fraction to its irreducible form, and format the output as a string.",Medium,algorithms,"Math,String,Simulation"
593,"Valid Square
Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square. The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order. A valid square has four equal sides with positive length and four equal angles (90-degree angles).",Check if all pairwise distances are equal.,Check if the sum of the x-coordinates equals the sum of the y-coordinates.,Sort points based on x-coordinate then y-coordinate and compare adjacent points.,Calculate the area of the quadrilateral formed by the points and check if it's non-zero.,"Calculate all six pairwise distances. Ensure there are exactly two distinct distances, where one is sqrt(2) times the other. Also, confirm no zero-length sides exist.",Medium,algorithms,"Math,Geometry"
594,"Longest Harmonious Subsequence
We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1. Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.",O(n log n),O(n^2),O(n!),O(1),O(n),Easy,algorithms,"Array,Hash Table,Sorting"
595,"Big Countries
Table: World  A country is big if: Write a solution to find the name, population, and area of the big countries. Return the result table in any order. The result format is in the following example.",Filter countries where either area OR population is greater than the thresholds.,"Use a subquery to select countries based on area and another for population, then combine with a UNION.","Join the World table to itself, comparing area and population columns.","Apply window functions to calculate the average area and population, then filter based on those averages.",Use a WHERE clause with an OR condition to check if area is greater than 3 million OR population is greater than 25 million.,Easy,database systems,Database
598,"Range Addition II
You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi. Count and return the number of maximum integers in the matrix after performing all the operations.",The element at M[m][n] after all operations,The sum of all elements in the ops array,The number of operations performed,The product of m and n,The product of the minimum row and column values in the ops array,Easy,algorithms,"Array,Math"
599,"Minimum Index Sum of Two Lists
Given two arrays of strings list1 and list2, find the common strings with the least index sum. A common string is a string that appeared in both list1 and list2. A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings. Return all the common strings with the least index sum. Return the answer in any order.","Use a HashMap to store the strings of the first list and their indices, then iterate through the second list and find common strings with their index sum","Sort both lists lexicographically and then compare elements at the same index until a match is found, tracking the minimum index sum","Concatenate both lists into a single list, then iterate through the list and find duplicate strings, calculating their index sum based on their original positions","Compare the lengths of the lists, and then choose the shorter list to iterate through, comparing each element against the entire longer list to find matches","Create a dictionary mapping strings in list1 to their indices, then iterate through list2, checking for membership in the dictionary and tracking the minimum index sum.",Easy,algorithms,"Array,Hash Table,String"
600,"Non-negative Integers without Consecutive Ones
Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.","Use dynamic programming, iterating through all possible binary strings of length up to the length of n's binary representation.",Recursively generate all possible binary strings of length equal to n and filter out those with consecutive ones.,"Convert n to its binary representation, then count the number of integers less than or equal to n that have consecutive ones and subtract from n+1.","Iterate from 0 to n and check each number's binary representation for consecutive ones, incrementing a counter for each valid number.","Use dynamic programming, pre-calculating the number of valid binary strings of different lengths and using these to compute the result for n.",Hard,algorithms,Dynamic Programming
601,"Human Traffic of Stadium
Table: Stadium  Write a solution to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each. Return the result table ordered by visit_date in ascending order. The result format is in the following example.","Use a self-join on the Stadium table with conditions on id and people, then group by the relevant columns and filter by count.","Employ window functions to calculate a rolling average of people for each id, filtering where the average exceeds 100.","Create a temporary table containing the differences between consecutive ids, then join it back to the Stadium table to identify consecutive sequences.",Utilize a recursive CTE to traverse the Stadium table and identify consecutive sequences meeting the criteria.,"Use a self-join to find consecutive IDs where the people count is >= 100, then group by the starting ID of the sequence and filter for sequences of length 3 or more.",Hard,database systems,Database
602,"Friend Requests II: Who Has the Most Friends
Table: RequestAccepted  Write a solution to find the people who have the most friends and the most friends number. The test cases are generated so that only one person has the most friends. The result format is in the following example.","Use a `UNION` to combine the requester_id and accepter_id, then group by user and count the occurrences, ordering to find the maximum.","Create a temporary table to store the counts of requests and accepts, then join this table to itself to find the user with the most friends.","Use window functions to partition by requester_id and accepter_id, count the number of friends for each, and select the maximum count.",Employ a correlated subquery to calculate the number of friends for each user and then select the user with the highest count.,"Use `UNION ALL` to combine requester_id and accepter_id, group by user, count occurrences, and use `LIMIT 1` to find the top user.",Medium,database systems,Database
605,"Can Place Flowers
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.","Iterate through the flowerbed, planting flowers in every other empty plot until n flowers are planted.",Count the number of empty plots and check if it is greater than or equal to n.,"Calculate the number of continuous empty plots. If any sequence has length k, plant floor(k/2) flowers, then check if the total is greater or equal to n.",Consider each empty plot. Plant a flower only if its neighbors are also empty. Repeat until n flowers are planted or no more plots are available.,"Iterate through the flowerbed, planting a flower at plot 'i' only if flowerbed[i-1], flowerbed[i], and flowerbed[i+1] are all 0, decrementing n each time.",Easy,algorithms,"Array,Greedy"
606,"Construct String from Binary Tree
Given the root node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines: Node Representation: Each node in the tree should be represented by its integer value. Parentheses for Children: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically: Omitting Empty Parentheses: Any empty parentheses pairs (i.e., ()) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained. In summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree's structure accurately.",Use an inorder traversal to construct the string,Use a postorder traversal to construct the string,Represent null nodes with '#',"Omit parentheses for all nodes, regardless of children","Use a preorder traversal, including empty parentheses only when a right child exists but a left child does not",Medium,data structures,"String,Tree,Depth-First Search,Binary Tree"
607,"Sales Person
Table: SalesPerson  Table: Company  Table: Orders  Write a solution to find the names of all the salespersons who did not have any orders related to the company with the name ""RED"". Return the result table in any order. The result format is in the following example.",Create a correlated subquery checking for salespersons with 'RED' orders.,"Use a RIGHT JOIN from SalesPerson to Orders, then filter out those associated with 'RED'.","Employ a FULL OUTER JOIN between SalesPerson and Company, filtering for SalesPersons where Company.name is not 'RED'.",Utilize a recursive common table expression (CTE) to identify all orders related to 'RED' and exclude corresponding salespersons.,"Use a subquery to find SalesPerson IDs with 'RED' orders, and then select names NOT IN that set.",Easy,database systems,Database
608,"Tree Node
Table: Tree  Each node in the tree can be one of three types: Write a solution to report the type of each node in the tree. Return the result table in any order. The result format is in the following example.",A left outer join will include all rows from the right table even if there is no matching value in the left table,A right outer join will return all rows from both tables,A full outer join is equivalent to a cross join,An inner join will return all rows from the right table,"A left outer join will return all rows from the left table, and matching rows from the right table",Medium,database systems,Database
609,"Find Duplicate File in System
Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory ""root/d1/d2/.../dm"". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:",Use a hash table where keys are file names and values are lists of paths,Sort the file paths lexicographically and compare adjacent files,Compare all file pairs' contents using nested loops for quadratic time complexity,Use a Bloom filter to quickly identify potential duplicates,Use a hash table where keys are file contents and values are lists of file paths,Medium,algorithms,"Array,Hash Table,String"
610,"Triangle Judgement
Table: Triangle  Report for every three line segments whether they can form a triangle. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to check the triangle inequality for each row,Apply window functions to calculate the sum of the sides and then filter based on triangle inequality,Create a recursive common table expression (CTE) to evaluate all possible triangle combinations,Utilize a cross join to generate all combinations of sides and then apply the triangle inequality theorem in a WHERE clause,Implement a simple IF statement checking if the sum of any two sides is greater than the third side,Easy,database systems,Database
611,"Valid Triangle Number
Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.",O(n),O(log n),O(n^2),O(n!),O(n^2 log n),Medium,algorithms,"Array,Two Pointers,Binary Search,Greedy,Sorting"
617,"Merge Two Binary Trees
You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees.","Perform an in-order traversal of both trees, summing nodes with matching indices in two separate arrays, then build a new tree from those sums.","Serialize both trees into strings, concatenate the strings, and then deserialize the combined string back into a tree.","Create a new tree with the structure of root1. For each node in root1, add the corresponding node value from root2 if it exists, or keep the root1 value if not.","Perform a breadth-first search on both trees simultaneously, storing node values in a hash map keyed by level, and then construct the merged tree from the hash map.","Recursively traverse both trees. If both nodes exist, sum their values. If only one exists, use that node. If neither exists, return null.",Easy,data structures,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
619,"Biggest Single Number
Table: MyNumbers  A single number is a number that appeared only once in the MyNumbers table. Find the largest single number. If there is no single number, report null. The result format is in the following example.",Use a correlated subquery to find numbers with a count of 1 and then find the maximum.,Create a temporary table to store the counts of each number and then select the maximum from this table.,"Use a window function to partition by number and count occurrences, then select the maximum where the count is 1.","Self-join the table and use a HAVING clause to filter for numbers with a count of 1, then select the maximum.","Group by the number, filter with HAVING COUNT(*) = 1, and then find the maximum value.",Easy,database systems,Database
620,"Not Boring Movies
Table: Cinema  Write a solution to report the movies with an odd-numbered ID and a description that is not ""boring"". Return the result table ordered by rating in descending order. The result format is in the following example.",Use a correlated subquery to check for odd IDs and non-boring descriptions,Employ a window function to partition by ID and filter out boring descriptions,Create a common table expression (CTE) to identify boring movies and exclude them using a LEFT JOIN,Filter the table using a WHERE clause with modulo operator and a LIKE condition,"Use a WHERE clause with the MOD operator to check for odd IDs and the NOT operator to exclude 'boring' descriptions, ordered by rating DESC",Easy,database systems,Database
621,"Task Scheduler
You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label. Return the minimum number of CPU intervals required to complete all tasks.","Use a greedy approach, prioritizing the most frequent tasks and filling idle slots optimally.","Sort the tasks lexicographically and schedule them in that order, inserting idle slots when needed.",Simulate the task execution using a priority queue to keep track of available tasks and idle times.,"Calculate the total number of tasks and multiply it by n+1, then subtract the number of tasks exceeding n to adjust for idle slots.","Count task frequencies, find the maximum frequency, and use the formula (max_frequency - 1) * (n + 1) + number of tasks with max_frequency.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Heap (Priority Queue),Counting"
860,"Design Circular Queue
Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called ""Ring Buffer"". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Implement the MyCircularQueue class: You must solve the problem without using the built-in queue data structure in your programming language.",Using dynamic arrays that resize by doubling their capacity whenever the queue is full.,Using a linked list where enqueue operations add to the tail and dequeue operations remove from the head.,Simulating the circular behavior with a fixed-size array and modulo arithmetic for index manipulation.,"Using a stack where push operations add to the top, pop operations remove from the top, and additional shifting is required.",Implementing the queue using a fixed-size array and maintaining head and tail pointers to manage enqueue and dequeue operations efficiently.,Medium,data structures,"Array,Linked List,Design,Queue"
623,"Add One Row to Tree
Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth. Note that the root node is at depth 1. The adding rule is:","Recursively traverse, creating new nodes at the target depth, modifying left/right pointers of the level above only if depth > 1","Use a breadth-first search, inserting new nodes after visiting all nodes at depth 'depth - 1'","Modify the root node's value to 'val' if depth is 1, then return the original tree; otherwise, return null","Perform an in-order traversal, allocating a new node with value 'val' before each existing node when depth is reached","Use a depth-first search, and at depth 'depth - 1', create new nodes with value 'val' and reassign left/right children",Medium,data structures,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
624,"Maximum Distance in Arrays
You are given m arrays, where each array is sorted in ascending order. You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|. Return the maximum distance.",Find the minimum and maximum values in the first array and calculate the difference.,Sort all the arrays and find the difference between the first and last elements.,Calculate the distance between the first element of each array and sum them.,"Compare the first element of the first array with the last element of every other array, and vice versa, returning the maximum of these distances.",Find the minimum and maximum value from each array and compute the maximum absolute difference between them.,Medium,algorithms,"Array,Greedy"
626,"Exchange Seats
Table: Seat  Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped. Return the result table ordered by id in ascending order. The result format is in the following example.",Use a self-join on the Seat table where s1.id + 1 = s2.id to swap even numbered IDs with the next ID,"Create a temporary table to store the original order, then update the Seat table by reassigning IDs based on the temp table.",Use window functions like LEAD and LAG to access adjacent rows and update the Seat table accordingly.,"Apply a modulo operation on the ID and use a CASE statement to conditionally increment or decrement the ID, then update the Seat table.","Use a CASE statement to increment the ID if it's even, decrement if odd and not the last student, otherwise keep the ID the same. Order the result by ID.",Medium,database systems,Database
627,"Swap Salary
Table: Salary  Write a solution to swap all 'f' and 'm' values (i.e., change all 'f' values to 'm' and vice versa) with a single update statement and no intermediate temporary tables. Note that you must write a single update statement, do not write any select statement for this problem. The result format is in the following example.",Use a CASE statement with nested IF conditions,Use two separate UPDATE statements with WHERE clauses for 'f' and 'm',Employ a complex JOIN operation to correlate and swap the values,Utilize a stored procedure with a temporary table to facilitate the swap,Use a CASE statement within a single UPDATE statement to swap 'f' and 'm' values,Easy,database systems,Database
628,"Maximum Product of Three Numbers
Given an integer array nums, find three numbers whose product is maximum and return the maximum product.",Sort the array and return the product of the last three elements.,Find the three largest numbers and return their product.,Iterate through all possible triplets and keep track of the maximum product found so far.,"Return the product of the first, middle, and last elements of the array.",Sort the array and return the maximum of (product of first two and last element) and (product of last three elements).,Easy,algorithms,"Array,Math,Sorting"
629,"K Inverse Pairs Array
For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j]. Given two integers n and k, return the number of different arrays consisting of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.","Use a greedy algorithm to minimize the number of inverse pairs, then adjust to reach k.",Employ dynamic programming with a state representing the current array and the number of inverse pairs so far.,Generate all possible arrays of length n and count the number of inverse pairs for each.,"Recursively build the array, placing each element in a position that contributes to the desired number of inverse pairs.",Apply dynamic programming with a state representing the length of the array and the number of inverse pairs.,Hard,algorithms,Dynamic Programming
630,"Course Schedule III
There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi. You will start on the 1st day and you cannot take two or more courses simultaneously. Return the maximum number of courses that you can take.","Use a greedy approach, sorting by duration and always picking the shortest course first.","Sort the courses by lastDay in descending order and iterate backwards, always picking the earliest course.","Employ dynamic programming, defining dp[i][j] as the maximum number of courses taken up to index i with a time limit of j.",Recursively try all combinations of courses and choose the one that maximizes the number of courses taken without exceeding the time limit.,"Sort the courses by lastDay in ascending order, iterate through them, and use a max-heap to track durations of taken courses, replacing the longest course if adding a new course exceeds the time limit.",Hard,algorithms,"Array,Greedy,Heap (Priority Queue)"
632,"Smallest Range Covering Elements from K Lists
You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.",Use a greedy approach by always selecting the minimum element across all lists and advancing that list's pointer.,Merge all k lists into a single sorted list and then find the smallest range within that list.,Binary search for the smallest range by iteratively narrowing the search space based on range size.,Randomly sample elements from each list and check if they form a valid range; repeat until a sufficiently small range is found.,Use a priority queue (min-heap) to track the smallest element from each list and update the range as elements are processed.,Hard,algorithms,"Array,Hash Table,Greedy,Sliding Window,Sorting,Heap (Priority Queue)"
633,"Sum of Square Numbers
Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.",Use a hash table to store all square numbers less than c and check if c minus any square is also in the table.,Calculate the square root of c and check if it's an integer.,"Perform a linear search from 0 to c, checking if the difference between c and the square of the current number is a perfect square.","Check if c is divisible by 4. If not, return false; otherwise, return true.","Use two pointers, one starting at 0 and the other at the square root of c, and move them inwards based on whether the sum of their squares is greater or smaller than c.",Medium,algorithms,"Math,Two Pointers,Binary Search"
636,"Exclusive Time of Functions
On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1. Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs, where logs[i] represents the ith log message formatted as a string ""{function_id}:{""start"" | ""end""}:{timestamp}"". For example, ""0:start:3"" means a function call with function ID 0 started at the beginning of timestamp 3, and ""1:end:2"" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively. A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3. Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.",A function's exclusive time is calculated only at the end log message.,The timestamp in the log message represents the duration of the function call.,Function calls cannot be nested; each start log must have a corresponding end log immediately following it.,The exclusive time is simply the difference between the last timestamp and the first timestamp for a given function ID.,"The exclusive time of a function call is the difference between its end timestamp and start timestamp, accounting for any nested function calls.",Medium,algorithms,"Array,Stack"
638,"Shopping Offers
In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy. You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer. Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.","Always prioritize the special offer with the largest discount percentage, even if it means buying extra items you don't need.",Sort the special offers by their price per item and greedily choose the offers with the lowest price first.,"Use dynamic programming with a state representing the number of each item remaining to be bought, but only consider buying one special offer at a time.","Calculate the cost of buying each item individually and return that value, ignoring the special offers completely.","Use recursion or dynamic programming to explore all possible combinations of special offers, pruning branches where the needs become negative.",Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Memoization,Bitmask"
639,"Decode Ways II
A message containing letters from A-Z can be encoded into numbers using the following mapping: To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, ""11106"" can be mapped into: Note that the grouping (1 11 06) is invalid because ""06"" cannot be mapped into 'F' since ""6"" is different from ""06"". In addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message ""1*"" may represent any of the encoded messages ""11"", ""12"", ""13"", ""14"", ""15"", ""16"", ""17"", ""18"", or ""19"". Decoding ""1*"" is equivalent to decoding any of the encoded messages it can represent. Given a string s consisting of digits and '*' characters, return the number of ways to decode it. Since the answer may be very large, return it modulo 109 + 7.",Replace each '*' with '1' and use the standard Decode Ways algorithm.,"Treat '*' as '0' and proceed with dynamic programming, ignoring invalid combinations.",Calculate the number of 'A'-'Z' letters represented by each '*' directly and multiply them together.,Pre-calculate all possible expansions of '*' into digits before applying the Decode Ways algorithm.,"Use dynamic programming to track the number of ways to decode substrings, handling '*' as a wildcard for single and double-digit encodings.",Hard,algorithms,"String,Dynamic Programming"
640,"Solve the Equation
Solve a given equation and return the value of 'x' in the form of a string ""x=#value"". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return ""No solution"" if there is no solution for the equation, or ""Infinite solutions"" if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.","If the coefficient of 'x' is zero and the constant is non-zero, there are infinite solutions.","Simplify the equation by combining like terms, then solve for 'x' using division, rounding to the nearest integer.","If the coefficients of 'x' and the constants on both sides are equal, then x=0.","Equations with '+' and '-' always have a solution, and 'x' is equal to the difference between the constants divided by the difference between the coefficients of 'x'.","Simplify the equation by combining like terms. If the coefficient of 'x' is zero, check if the constant is also zero (infinite solutions) or non-zero (no solution). Otherwise, solve for 'x'.",Medium,algorithms,"Math,String,Simulation"
859,"Design Circular Deque
Design your implementation of the circular double-ended queue (deque). Implement the MyCircularDeque class:","Use a dynamically resizing array, shifting elements on add/remove operations at the beginning.","Implement it using two stacks, one for the front and one for the rear.",Simulate the deque with a standard queue and track the front/rear using pointers.,Utilize a single linked list with pointers to the head and tail.,Use a circular array with head and tail pointers to track the deque's boundaries.,Medium,data structures,"Array,Linked List,Design,Queue"
643,"Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.",Calculate the average of all possible subarrays of length k and return the maximum,Sort the array and then calculate the average of the first k elements,Use dynamic programming to store the maximum average of all subarrays up to length k,Calculate the sum of all elements in the array and divide by k,Use a sliding window to efficiently calculate the average of each contiguous subarray of length k,Easy,algorithms,"Array,Sliding Window"
645,"Set Mismatch
You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array.","Hash each number and check if the hash value exceeds a threshold, then identify the missing number by iterating from 1 to n.","Sort the array, iterate to find duplicates, and calculate the missing number by subtracting the sum of the array from the sum of 1 to n.",Use bit manipulation (XOR) to find the duplicate and missing numbers. XOR all numbers in the array and 1 to n.,"Iterate through the array. If a number is seen twice, that is the duplicate. Then iterate from 1 to n to find the missing number.",Calculate the sum and sum of squares of the numbers in the array and compare them with the expected sum and sum of squares from 1 to n to derive the duplicate and missing numbers.,Easy,algorithms,"Array,Hash Table,Bit Manipulation,Sorting"
646,"Maximum Length of Pair Chain
You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti. A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals. You can select pairs in any order.",Sort pairs by their left values and greedily select pairs with the smallest right value that allows for chain extension.,"Use dynamic programming, where dp[i] stores the length of the longest chain ending at index i, considering all possible subchains.","Recursively explore all possible combinations of pairs, keeping track of the longest chain found so far.",Sort pairs by the sum of their left and right values and select the first N pairs to form the chain.,Sort pairs by their right values and greedily select non-overlapping pairs to maximize chain length.,Medium,algorithms,"Array,Dynamic Programming,Greedy,Sorting"
647,"Palindromic Substrings
Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.","Dynamic Programming: Build a table storing palindrome status for all substrings, bottom-up",Recursion: Recursively check substrings centered at each character and expand outwards,Brute Force: Generate all possible substrings and check each for palindrome property,Greedy Approach: Iteratively select the longest palindrome from the remaining string,Expand Around Center: Iterate through each character as a potential center and expand to find palindromes,Medium,algorithms,"String,Dynamic Programming"
648,"Replace Words
In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root ""help"" is followed by the word ""ful"", we can form a derivative ""helpful"". Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length. Return the sentence after the replacement.","Use a trie to store the dictionary, then iterate through the sentence and search the trie for each word.","Sort the dictionary by word length, then for each word in the sentence, check against the dictionary in order.",Use a hash table to store the roots and replace derivatives with the first matching root found.,Split the sentence into characters and look for the shortest root to replace,"Use a set to store the roots and for each word in the sentence, check prefixes against the set for the shortest root.",Medium,algorithms,"Array,Hash Table,String,Trie"
649,"Dota2 Senate
In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be ""Radiant"" or ""Dire"".",Use a greedy algorithm to always ban the senator of the opposite party closest to the current senator.,"Simulate the process using a priority queue to represent senators, prioritizing those with more remaining rights.",Maintain separate counters for 'R' and 'D' and always ban the party with the lower count.,Sort the senators alphabetically by party ('D' before 'R') and ban in that order.,"Simulate the voting rounds using a queue to track senators, banning opponents and re-enqueuing until only one party remains.",Medium,algorithms,"String,Greedy,Queue"
650,"2 Keys Keyboard
There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step: Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.","Prime factorization, summing the prime factors","Dynamic programming, storing optimal steps for smaller n values","Recursion, exploring all possible copy-paste sequences","Greedy approach, repeatedly doubling 'A' and adding 'A' as needed","Factorize n, summing its prime factors for the minimal operation count",Medium,algorithms,"Math,Dynamic Programming"
652,"Find Duplicate Subtrees
Given the root of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values.",Use a hash table to store the inorder traversal of each subtree and compare them.,Employ a level-order traversal and compare the serialized strings of each level.,"Recursively compare subtrees based on their height and value, pruning when differences are found.",Store the preorder traversal of each subtree in an array and look for repeated sequences.,"Serialize each subtree into a string, store it in a hash table, and return the roots of subtrees with duplicate serializations.",Medium,algorithms,"Hash Table,Tree,Depth-First Search,Binary Tree"
653,"Two Sum IV - Input is a BST
Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",Use a hash table to store each node's value during an inorder traversal and check for `k - value`.,"Perform a breadth-first search, storing nodes in a queue, and then iterate the queue to find two numbers that sum to k.",Sort the BST into an array and apply binary search to locate the second element that sums to k.,Recursively check every pair of nodes in the BST to determine if their sum equals k.,"Perform an inorder traversal and store it in a sorted list, then use two pointers to find if any two elements sum up to k.",Easy,algorithms,"Hash Table,Two Pointers,Tree,Depth-First Search,Breadth-First Search,Binary Search Tree,Binary Tree"
654,"Maximum Binary Tree
You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Return the maximum binary tree built from nums.","Build the tree level by level using a breadth-first approach, always placing the largest element at the current level's root.",Sort the input array and then iteratively insert elements into the tree based on their sorted order.,Randomly select an element as the root and recursively build subtrees with the remaining elements.,Create a min-heap from the array and iteratively extract the minimum element to build the tree.,"Find the maximum element in the array, make it the root, and recursively build left and right subtrees with the elements to the left and right of the maximum.",Medium,data structures,"Array,Divide and Conquer,Stack,Tree,Monotonic Stack,Binary Tree"
655,"Print Binary Tree
Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree. The formatted layout matrix should be constructed using the following rules: Return the constructed matrix res.","Perform an in-order traversal, filling the matrix row by row from left to right.","Calculate the tree's height, then use a depth-first search to fill the matrix, prioritizing nodes with smaller values.","Use a breadth-first search, filling the matrix column by column from top to bottom.",Recursively fill the matrix by placing the root at the center of the first row and distributing subtrees evenly.,"Calculate tree height, then use a recursive pre-order traversal, placing each node at its calculated position based on level and position in the tree.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
657,"Robot Return to Origin
There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down). Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise. Note: The way that the robot is ""facing"" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.",Use a hash map to store the frequency of each move and check if 'U' equals 'D' and 'R' equals 'L',"Employ recursion to simulate each move and return true only if the base case (no moves left) results in (0,0)","Calculate the net horizontal and vertical displacement by treating 'R' as +1, 'L' as -1, 'U' as +1, and 'D' as -1 and check if the absolute values are equal.","Convert the move string into a complex number representation where 'R' is 1+0i, 'L' is -1+0i, 'U' is 0+1i, and 'D' is 0-1i. Return true if the sum has magnitude 0.","Maintain counters for horizontal (x) and vertical (y) movements. Increment x for 'R', decrement for 'L', increment y for 'U', and decrement for 'D'. Return true if x and y are both 0.",Easy,algorithms,"String,Simulation"
658,"Find K Closest Elements
Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if:",Use a heap data structure to maintain the k closest elements seen so far.,"Iterate through the array, keeping track of the k smallest differences between each element and x.","Perform a linear search to find the element closest to x, then expand outwards k/2 elements in each direction.","Calculate the absolute difference between each element and x, and sort the array based on these differences, taking the first k elements.","Use binary search to find the element closest to x, then expand outwards k elements, adjusting the window based on proximity to x.",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting,Heap (Priority Queue)"
659,"Split Array into Consecutive Subsequences
You are given an integer array nums that is sorted in non-decreasing order. Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true: Return true if you can split nums according to the above conditions, or false otherwise. A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).",Use dynamic programming to find the optimal split points.,Sort the array and then greedily form subsequences.,Recursively check all possible subsequence combinations.,Use a priority queue to keep track of the smallest elements and form subsequences.,Use a greedy approach with hashmaps to track the frequency and required length of subsequences.,Medium,algorithms,"Array,Hash Table,Greedy,Heap (Priority Queue)"
661,"Image Smoother
An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother). Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.",Use a 2D prefix sum array to efficiently calculate the sum of neighbors for each cell.,Apply a Gaussian blur filter instead of the averaging filter to reduce noise.,Iterate through the image and only consider cells with even row and column indices for smoothing.,"Perform the smoothing operation in-place, modifying the original image directly.","Iterate through each cell and calculate the average of its neighbors, handling boundary conditions carefully.",Easy,algorithms,"Array,Matrix"
662,"Maximum Width of Binary Tree
Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer.",Use a depth-first search (DFS) approach without considering null nodes in between non-null nodes.,Employ a level-order traversal using a queue and only count non-null nodes at each level.,"Perform a recursive traversal calculating node positions using powers of 2, without handling integer overflow for large trees.",Use a modified breadth-first search (BFS) storing only the first and last node values at each level without properly accounting for positional gaps.,"Employ a modified breadth-first search (BFS) where each node is assigned a position value, and the width at each level is the difference between the last and first node's position.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
664,"Strange Printer
There is a strange printer with the following two special properties: Given a string s, return the minimum number of turns the printer needed to print it.","Dynamic programming, considering all possible sub-intervals and merging adjacent identical characters.","Greedy approach, always printing the longest possible contiguous segment of the same character.","Divide and conquer, splitting the string into halves and recursively calculating the minimum turns.",Simulate the printer's actions by iteratively identifying and printing the most frequent character first.,"Dynamic programming, defining dp[i][j] as the minimum turns to print s[i:j+1] and considering all possible split points k.",Hard,algorithms,"String,Dynamic Programming"
665,"Non-decreasing Array
Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).",Always return true if the array length is less than 3.,Modify the largest element to be equal to the smallest element.,"If nums[i] > nums[i+1], modify nums[i+1] to be nums[i] only if nums[i-1] <= nums[i+1].",Sort the array and check if the difference between adjacent elements is at most 1.,"Keep track of the number of modifications made. If nums[i] > nums[i+1], try modifying either nums[i] or nums[i+1] to satisfy the non-decreasing condition, incrementing the modification count. Return false if the modification count exceeds 1.",Medium,algorithms,Array
667,"Beautiful Arrangement II
Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement: Return the list answer. If there multiple valid answers, return any of them.",Sort the input array and then swap elements to achieve the k distinct differences.,Start with a sorted array and repeatedly reverse sub-arrays of size k until the condition is met.,Generate all possible permutations of the array and check if any satisfy the k distinct differences condition.,"Fill the array with numbers increasing from 1 to n/2, then decreasing from n to n/2 + 1.",Fill the array with increasing and decreasing numbers in alternating order to create k distinct differences.,Medium,algorithms,"Array,Math"
668,"Kth Smallest Number in Multiplication Table
Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed). Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.",Sort all elements in the multiplication table and return the element at index k-1,"Perform binary search on the range [1, m*n] to find a number such that there are exactly k-1 elements smaller than it",Use min-heap of size k to store the k smallest elements found so far,"Iterate the table row by row and compare each element with the current kth smallest, updating if necessary","Perform binary search on the range [1, m*n] to find a number such that there are at least k elements smaller than or equal to it",Hard,algorithms,Binary Search
669,"Trim a Binary Search Tree
Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.",Recursively trim the left and right subtrees after processing the current node.,"Iteratively traverse the tree using a stack, removing nodes outside the range.","Perform an in-order traversal, storing valid nodes in a new tree structure.",Replace out-of-range nodes with their closest in-range ancestor.,"Recursively process each node: if out of range, return the appropriate subtree; otherwise, update its children.",Medium,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
670,"Maximum Swap
You are given an integer num. You can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get.","Iterate through the number from right to left, swapping adjacent digits if the right digit is larger",Sort the digits in descending order and construct a new number,"Convert the number to a string, reverse it, and then convert it back to an integer",Find the smallest digit and swap it with the largest digit,"Iterate from left to right, finding the largest digit to the right of the current digit and swapping if it's larger than the current digit",Medium,algorithms,"Math,Greedy"
671,"Second Minimum Node In a Binary Tree
Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead.","Perform an inorder traversal and return the second smallest distinct value encountered, or -1 if none exists.","Return the value of the left child if it's greater than the root, otherwise return the value of the right child.",Return the maximum value in the tree if the root's left and right children have the same value as the root.,Sort the node values and return the second element in the sorted list. Return -1 if the length is less than 2.,"Perform a depth-first search, maintaining a minimum and second minimum value. Update them appropriately and return the second minimum, or -1 if not found.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
672,"Bulb Switcher II
There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where: You must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press. Given the two integers n and presses, return the number of different possible statuses after performing all presses button presses.",The number of possible statuses is always 8 regardless of n and presses.,The number of possible statuses is determined by n * presses.,"If presses is even, the number of possible statuses is always 1.",The number of possible statuses grows exponentially with n.,"The number of possible statuses depends on the parity of n and presses, and is at most 8.",Medium,algorithms,"Math,Bit Manipulation,Depth-First Search,Breadth-First Search"
673,"Number of Longest Increasing Subsequence
Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing.",Dynamic programming with memoization,Greedy approach using binary search,Recursion with backtracking,Divide and conquer strategy,Dynamic programming with two arrays to track length and count of LIS,Medium,algorithms,"Array,Dynamic Programming,Binary Indexed Tree,Segment Tree"
674,"Longest Continuous Increasing Subsequence
Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].","O(n^2), comparing each element with every other element to find subsequences","O(n log n), sorting the array and then finding the longest increasing subsequence","O(n log n), using binary search to find the optimal length of subsequences","O(n^3), exhaustively checking all possible subarrays","O(n), iterating through the array once to track the current and maximum lengths",Easy,algorithms,Array
675,"Cut Off Trees for Golf Event
You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix: In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off. You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell). Starting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1. Note: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.",Use Dijkstra's algorithm to find the shortest path between all pairs of trees.,Sort the trees by their coordinates instead of their height.,"Use a greedy approach, always cutting the closest tree regardless of height order.",Perform a depth-first search (DFS) to explore all possible paths and choose the shortest.,"Sort the trees by height, then use A* search to find the shortest path between each consecutive pair of trees.",Hard,algorithms,"Array,Breadth-First Search,Heap (Priority Queue),Matrix"
676,"Implement Magic Dictionary
Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure. Implement the MagicDictionary class:","Use a simple linear search, comparing the input string to each word in the dictionary after modifying one character at a time.",Precompute all possible one-character variations of each word in the dictionary and store them in a hash set for quick lookup.,"Sort the dictionary words by length and then use binary search to find potential matches, followed by a character-by-character comparison.","Build a trie data structure from the dictionary words and then perform a backtracking search, allowing for one mismatch.","Create a dictionary (hash map) where keys are word lengths and values are lists of words with that length. For the search, check if there are words of the same length as the search word. Iterate through these words and compare them with the search word, counting differences.",Medium,algorithms,"Hash Table,String,Design,Trie"
677,"Map Sum Pairs
Design a map that allows you to do the following: Implement the MapSum class:","Use a Bloom filter to check if a string is present, but it might have false positives","Store all prefixes and their values in a single, large hash table for efficient lookup",Recompute the sum for each prefix every time a new key-value pair is inserted,Use a trie where each node stores the value of the corresponding prefix,Use a trie where each node stores the sum of all values of keys that pass through it,Medium,data structures,"Hash Table,String,Design,Trie"
678,"Valid Parenthesis String
Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid. The following rules define a valid string:",The string is always valid if it contains any '*',The string is valid if the number of '(' equals the number of ')',The string is invalid if a ')' appears before a '(',The string is valid if the number of '*' is greater than the combined number of '(' and ')',Treat '*' as either '(' or ')' or empty and check for all possible valid combinations using dynamic programming or range-based checks with counters.,Medium,algorithms,"String,Dynamic Programming,Stack,Greedy"
679,"24 Game
You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24. You are restricted with the following rules: Return true if you can get such expression that evaluates to 24, and false otherwise.",Apply Depth-First Search (DFS) with pruning based on intermediate results exceeding a threshold.,"Use a constraint satisfaction solver, encoding the problem as a set of arithmetic constraints.","Employ a Monte Carlo method, randomly generating expressions and evaluating them.",Convert the array to a string and use regular expressions to identify valid arithmetic expressions.,Explore all possible permutations of numbers and operators using recursion with backtracking.,Hard,algorithms,"Array,Math,Backtracking"
680,"Valid Palindrome II
Given a string s, return true if the s can be palindrome after deleting at most one character from it.",Always delete the character at the beginning of the string.,Recursively check all possible substrings formed by deleting a single character.,Only consider deleting characters at even indices.,"Reverse the string and compare it to the original, deleting the first differing character.","Use two pointers to traverse the string from both ends, and if a mismatch is found, check if deleting either character results in a palindrome.",Easy,algorithms,"Two Pointers,String,Greedy"
682,"Baseball Game
You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record. You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following: Return the sum of all the scores on the record after applying all the operations. The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.","Use a hash map to store operations and their scores, updating the map iteratively",Convert operations to integers directly and sum them without validation.,"Apply regular expressions to extract scores and operations, then calculate the total",Use dynamic programming to store intermediate results and calculate the final score,Use a stack to keep track of scores and perform operations according to the given rules,Easy,algorithms,"Array,Stack,Simulation"
684,"Redundant Connection
In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.","Use Depth-First Search (DFS) to detect cycles, removing the edge encountered first during the cycle detection.",Sort the edges lexicographically and remove the first edge to ensure the smallest numbered nodes remain connected.,"Iterate through the edges in reverse order, performing a Minimum Spanning Tree (MST) algorithm; return the edge that prevents MST formation.",Apply Kruskal's algorithm and remove the edge that closes the first cycle found during the union operations.,Use a Union-Find data structure to detect cycles; return the last edge that creates a cycle.,Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
685,"Redundant Connection II
In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi. Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.",Use Depth-First Search (DFS) to detect cycles and remove the edge encountered first.,"Apply topological sort. If a cycle is detected, remove the edge that creates the cycle.",Always remove the last edge in the input because it is the redundant one.,Use Breadth-First Search (BFS) to find the longest path and remove the edge on that path.,Employ Union-Find to detect cycles and identify nodes with multiple parents. Remove the edge causing either the cycle or the multiple parents based on the input order.,Hard,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
686,"Repeated String Match
Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b​​​​​​ to be a substring of a after repeating it, return -1. Notice: string ""abc"" repeated 0 times is """", repeated 1 time is ""abc"" and repeated 2 times is ""abcabc"".","Apply brute-force string matching after concatenating 'a' some constant number of times (e.g., 5) regardless of the lengths of 'a' and 'b'.","Use regular expressions to search for 'b' within 'a' repeated only once, and return 1 if found, otherwise -1.","Precompute all possible substrings of 'a' and check if 'b' is among them; return the number of repetitions needed, which would be minimal.","Only consider the case where 'b' is shorter than 'a'; otherwise, immediately return -1.",Repeat 'a' until its length is greater than or equal to the length of 'b' plus the length of 'a'. Check for 'b' as a substring within each repetition and return the minimum count. Return -1 if no match is found.,Medium,algorithms,"String,String Matching"
687,"Longest Univalue Path
Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root. The length of the path between two nodes is represented by the number of edges between them.",Use breadth-first search to explore each possible path and track the maximum length.,Sort the tree based on node values and find the longest consecutive sequence.,Apply Dijkstra's algorithm to find the shortest path and subtract that from the total number of nodes.,Perform a level-order traversal and store the counts of identical values at each level.,"Use recursion to explore each subtree, comparing node values and tracking the longest univalue path length.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
688,"Knight Probability in Chessboard
On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1). A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction. Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly k moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.","Store intermediate results in a single global variable, updating it after each move",Precompute all possible knight paths and use a lookup table for the final probability,Simulate the knight's moves using a Monte Carlo method with a small number of trials,"Use a greedy approach, always selecting the move that maximizes the probability of staying on the board in the next step",Use dynamic programming to store the probability of being at each cell after each move,Medium,algorithms,Dynamic Programming
689,"Maximum Sum of 3 Non-Overlapping Subarrays
Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.","Use dynamic programming to store the maximum sums of 1, 2, and 3 subarrays ending at each index.",Iterate through all possible combinations of three subarrays of length k and calculate their sums.,Use a sliding window of size 3k and find the maximum sum within that window.,Sort the array and select the first 3k elements to form the subarrays.,Precompute left and right maximum sum arrays to efficiently find the optimal middle subarray.,Hard,algorithms,"Array,Dynamic Programming"
690,"Employee Importance
You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs. You are given an array of employees employees where: Given an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.",Use a breadth-first search (BFS) algorithm to traverse the employee hierarchy.,Sort the employee list by ID and then iterate to sum importance values.,"Use dynamic programming, storing intermediate sums in a cache.","Employ a greedy algorithm, always selecting the employee with the highest importance.",Use a depth-first search (DFS) algorithm to recursively calculate the total importance.,Medium,algorithms,"Hash Table,Depth-First Search,Breadth-First Search"
algorithms,691,"Stickers to Spell Word
We are given n different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1. Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.",Greedy approach: Always pick the sticker that contains the most frequent character of the remaining target string.,"Dynamic programming with a bottom-up approach, building solutions for smaller substrings of the target.","A* search algorithm, prioritizing stickers that minimize the estimated remaining cost (number of stickers).",Brute-force search: Try all possible combinations of stickers until the target is formed.,,"['dynamic programming', 'string manipulation', 'memoization']","Dynamic programming with memoization, where the state represents the remaining characters to form in the target."
algorithms,692,"Top K Frequent Words
Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.","Use a hash map to count word frequencies, then sort the map entries by frequency only.","Use a trie to store words and their frequencies, then traverse the trie in lexicographical order.","Sort the input array lexicographically, then count frequencies using a sliding window approach.","Use a min-heap to maintain the k most frequent words seen so far, without considering lexicographical order for ties.",,"['hash map', 'sorting', 'frequency']","Use a hash map to count word frequencies, then sort the map entries by frequency and lexicographical order."
algorithms,693,"Binary Number with Alternating Bits
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.",Use bitwise AND with a mask of all 1s to check for alternating patterns,Convert the integer to a string and compare adjacent characters,"Recursively check if the last two bits are different, then shift right",Divide the integer by 2 repeatedly and check if remainders alternate,,"['bitwise operations', 'XOR', 'alternating bits']",Right shift the number by 1 and XOR with the original number; the result should be all 1s
algorithms,695,"Max Area of Island
You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.",Use dynamic programming to store the area of each cell and then find the maximum,"Apply a breadth-first search (BFS) algorithm, marking visited cells and calculating area iteratively using a queue","Use a depth-first search (DFS) algorithm, marking visited cells, and recursively counting the area of each connected component",Employ a greedy approach by always selecting the largest contiguous '1' region found so far,,"['graph traversal', 'DFS', 'matrix']","Iterate through the matrix, and for each '1' found, perform a depth-first search (DFS) to calculate the area of the connected island, updating the maximum area seen so far."
algorithms,696,"Count Binary Substrings
Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.",Use dynamic programming to store results of smaller substrings and build up to the full string.,"Employ a sliding window approach, expanding the window until the counts of '0' and '1' are equal.",Recursively divide the string into halves and count substrings in each half.,Sort the string and then count substrings with equal '0's and '1's.,,"['string manipulation', 'substring', 'counting']","Iterate through the string, tracking consecutive groups of '0's and '1's and counting valid substrings based on adjacent group lengths."
697,"Degree of an Array
Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.",The sum of squares of the number of occurrences of each unique element.,The number of distinct elements in the array.,The length of the longest increasing subsequence in the array.,The product of the frequencies of all elements.,The maximum frequency of any one of its elements.,Easy,algorithms,"Array,Hash Table"
698,"Partition to K Equal Sum Subsets
Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.","Sort the array and use a greedy approach, always assigning the largest element to the subset with the smallest current sum.","Employ dynamic programming, considering all possible subsets and their sums to determine if a valid partition exists.","Recursively explore all possible subset combinations, backtracking when the current subset sum exceeds the target sum.","Calculate the total sum of the array and check if it's divisible by k. If not, return false; otherwise, proceed without further partitioning logic.","Use backtracking to explore possible subset assignments, pruning branches when a subset sum exceeds the target or when a duplicate state is encountered.",Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Memoization,Bitmask"
699,"Falling Squares
There are several squares being dropped onto the X-axis of a 2D plane. You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti. Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved. After each square is dropped, you must record the height of the current tallest stack of squares. Return an integer array ans where ans[i] represents the height described above after dropping the ith square.",Use a segment tree to store height intervals and update them efficiently.,"Simulate the drops and for each drop, iterate through all existing squares to check for overlaps and calculate the new height.",Employ dynamic programming to store the maximum height at each position on the X-axis.,Sort the squares by their left position and maintain a heap of heights to find the maximum height.,"Use an interval tree to represent the heights of existing squares, efficiently finding overlaps and updating heights after each drop.",Hard,algorithms,"Array,Segment Tree,Ordered Set"
783,"Search in a Binary Search Tree
You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",Perform a level-order traversal and check each node's value.,Always go to the left subtree until the value is found or the end is reached.,Always go to the right subtree until the value is found or the end is reached.,Traverse the BST in-order and return the first node with the matching value.,"Compare the target value with the current node's value; if smaller, go left; if larger, go right; if equal, return the node; if null, return null.",Easy,data structures,"Tree,Binary Search Tree,Binary Tree"
784,"Insert into a Binary Search Tree
You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.",Always insert the new node as the right child of the root.,Insert the new node as the left child of the leaf node encountered during traversal.,Replace the root node with the new node and rearrange the tree to maintain BST properties.,"Insert the new node at a random location in the tree, ensuring BST properties are eventually satisfied through rotations.","Traverse the tree to find the appropriate leaf node where the new node can be inserted as either the left or right child, maintaining the BST property.",Medium,data structures,"Tree,Binary Search Tree,Binary Tree"
789,"Kth Largest Element in a Stream
You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores. You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores. Implement the KthLargest class:","Use a full sort on the entire stream each time a new element arrives, then return the element at index k.",Maintain a heap (priority queue) of size k and only add new elements if they are smaller than the current minimum in the heap.,Keep an unsorted array of the stream and iterate through the array to find the kth largest element using quickselect on the full array.,Store all elements in a sorted array. Shift the array and insert the new element in the correct sorted position.,"Maintain a min-heap of size k. If a new element is larger than the root, replace the root and heapify. The root is always the kth largest.",Easy,data structures,"Tree,Design,Binary Search Tree,Heap (Priority Queue),Binary Tree,Data Stream"
792,"Binary Search
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",Linear search through the entire array.,Iterate through the array until the target is found or a larger value is encountered.,Divide the array into thirds and search the relevant third.,Use a hash map to store the indices of each element for quick lookup.,Repeatedly divide the search interval in half.,Easy,algorithms,"Array,Binary Search"
816,"Design HashSet
Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class:",Use a single boolean array where the index represents the key and the value indicates presence.,"Store elements in a sorted array and use binary search for add, remove, and contains operations.","Implement a linked list to store the elements, iterating through it for each operation.",Use a fixed-size array and store the elements directly based on their values.,"Employ an array of linked lists (buckets) and a hash function to distribute keys across the buckets, handling collisions via chaining.",Easy,data structures,"Array,Hash Table,Linked List,Design,Hash Function"
817,"Design HashMap
Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class:","Use linear probing to resolve collisions, storing key-value pairs directly in an array","Employ a single linked list to store all key-value pairs, iterating through it for each operation","Utilize a binary search tree to store key-value pairs, sorted by key value","Implement a fixed-size array where each index stores only the value, discarding the key after hashing","Use separate chaining with a hash function to map keys to buckets, each containing a linked list of key-value pairs",Easy,data structures,"Array,Hash Table,Linked List,Design,Hash Function"
838,"Design Linked List
Design your implementation of the linked list. You can choose to use a singly or doubly linked list.
A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.
If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class:","Use a fixed-size array to store elements, simulating linked list behavior with index manipulation.",Implement the linked list using only global variables to store head and tail pointers.,"Utilize a binary tree structure to represent the linked list, ensuring logarithmic time complexity for operations.",Employ a hash table where keys represent node indices and values store node data.,"Create a Node class with 'val' and 'next' (and optionally 'prev' for doubly-linked) attributes, managing head/tail pointers and implementing insertion/deletion methods.",Medium,data structures,"Linked List,Design"
742,"To Lower Case
Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.",Use ASCII codes and bitwise OR operation with 32,Iterate through the string and use the `isupper()` method with conditional replacement,Employ regular expressions to match uppercase letters and replace them with their lowercase equivalents,Utilize string slicing to separate uppercase letters and concatenate lowercase versions,Iterate through the string and apply the `tolower()` function from the cctype library,Easy,algorithms,String
894,"Random Pick with Blacklist
You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned. Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language. Implement the Solution class:",Use a hash table to map blacklisted numbers to available numbers in the valid range and generate a random number within the reduced range.,"Sort the blacklist and perform binary search to check if a randomly generated number is blacklisted, regenerating if necessary.","Generate a random number between 0 and n-1, then iterate through the blacklist to check if the generated number exists. If so, generate a new random number.","Create a boolean array of size n, marking blacklisted numbers as false. Generate random indices until a true value is found.","Map the blacklisted numbers in the range [0, n - len(blacklist)) to available numbers in the range [n - len(blacklist), n - 1].",Hard,algorithms,"Hash Table,Math,Binary Search,Sorting,Randomized"
712,"Minimum ASCII Delete Sum for Two Strings
Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.",Recursively compute the edit distance with insertions and deletions only.,"Use a greedy approach, always deleting the character with the higher ASCII value if they don't match.",Calculate the Longest Common Subsequence (LCS) and subtract the sum of ASCII values of the LCS characters from the sum of ASCII values of both strings.,Compute the edit distance with substitutions only.,Use dynamic programming to build a table where dp[i][j] stores the minimum delete sum for s1[0...i-1] and s2[0...j-1].,Medium,algorithms,"String,Dynamic Programming"
713,"Subarray Product Less Than K
Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.","Use a sliding window, shrinking it from the left when the product exceeds k, and incrementing a counter by the window's size","Calculate the product of all possible subarrays and increment a counter if the product is less than k, leading to O(n^3) time complexity","Sort the array first, then iterate through it and keep track of the product","Use dynamic programming, storing the product of subarrays ending at each index","Use a sliding window approach, expanding it to the right, and dividing the current product by the leftmost element when the product exceeds k, updating the count accordingly",Medium,algorithms,"Array,Sliding Window"
714,"Best Time to Buy and Sell Stock with Transaction Fee
You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note:","Use a greedy approach, buying at the lowest price and selling at the highest, ignoring the fee",Apply dynamic programming with a single state representing the maximum profit,"Sort the prices array and calculate the difference between the highest and lowest prices, subtracting the fee","Keep track of the minimum buying price and maximum selling price, and only perform transactions if the profit exceeds the fee","Use dynamic programming with two states: holding stock and not holding stock, updating the maximum profit at each step considering the fee",Medium,algorithms,"Array,Dynamic Programming,Greedy"
715,"Range Module
A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them. A half-open interval [left, right) denotes all the real numbers x where left <= x < right. Implement the RangeModule class:","Use a sorted array to store intervals; inserting or deleting intervals requires shifting elements, resulting in O(n) complexity for these operations.",Employ a hash table where keys are start points and values are end points; this offers fast lookups but inefficient range merging and splitting.,"Utilize a binary search tree where nodes represent intervals; querying involves tree traversal, and insertion/deletion may require rebalancing.","Represent ranges using a bit array; querying involves bitwise operations, but the space complexity is proportional to the maximum range value.","Employ a balanced binary search tree (e.g., AVL or Red-Black tree) where nodes represent intervals; querying, insertion, and deletion have O(log n) complexity due to the balanced structure.",Hard,data structures,"Design,Segment Tree,Ordered Set"
717,"1-bit and 2-bit Characters
We have two special characters: Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.","The last element is 0, thus it is always a 1-bit character",Return true if the length of the array is even,"If the second to last element is 1, return false; otherwise return true","Always return false, as there's no way to determine the character type","Iterate through the array, incrementing the index by 1 or 2 based on the current bit, and return true if the last index visited is the last element's index",Easy,algorithms,Array
718,"Maximum Length of Repeated Subarray
Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.",Greedily match elements and extend the subarray until a mismatch is found.,Use dynamic programming to build a table storing lengths of common suffixes.,Sort both arrays and then find the longest common prefix.,Hash all possible subarrays of one array and check if they exist in the other.,Use dynamic programming to build a table storing lengths of common prefixes.,Medium,algorithms,"Array,Binary Search,Dynamic Programming,Sliding Window,Rolling Hash,Hash Function"
719,"Find K-th Smallest Pair Distance
The distance of a pair of integers a and b is defined as the absolute difference between a and b. Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.","Brute force: Calculate distances of all pairs and sort them, then return the k-th element.",Use a min-heap to maintain the k smallest distances encountered so far.,"Apply binary search on the possible distance range, counting pairs with distance less than or equal to the mid-value.","Sort the input array, then iterate through it maintaining a sliding window of size k to calculate distances.","Sort the input array. Use binary search on the distance range, and for each distance, use a two-pointer technique to count pairs with that distance or less.",Hard,algorithms,"Array,Two Pointers,Binary Search,Sorting"
720,"Longest Word in Dictionary
Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Note that the word should be built from left to right with each additional character being added to the end of a previous word.","Sort the words by length (descending) and lexicographical order, then check each word against all shorter words for buildability.",Use dynamic programming to store buildable words and iterate to find the longest buildable word.,Create a graph where words are nodes and edges connect buildable words. Find the longest path in the graph.,Employ a brute-force approach by generating all possible word combinations and checking their existence in the dictionary.,"Use a set to store buildable words. Sort the words by length, then iterate through the sorted list, checking if the prefix is in the set.",Medium,algorithms,"Array,Hash Table,String,Trie,Sorting"
721,"Accounts Merge
Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.","Employ a disjoint-set data structure (Union-Find) to group accounts based on shared emails, then construct the merged accounts.","Create a graph where accounts are nodes and shared emails represent edges, then perform a breadth-first search to identify connected components and merge accounts within each component.","Use a hash map to map each email to the account it belongs to, then iterate through the map and consolidate accounts with matching names.","Sort all accounts lexicographically by their email addresses, then iterate through the sorted accounts and merge adjacent accounts with common emails.","Construct a graph where emails are nodes and accounts are represented implicitly by their email lists. Use depth-first search to find connected components of emails, each representing a merged account.",Medium,algorithms,"Array,String,Depth-First Search,Breadth-First Search,Union Find"
722,"Remove Comments
Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\n'. In C++, there are two types of comments, line comments, and block comments. The first effective comment takes precedence over others. If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty. There will be no control characters, single quote, or double quote characters. Also, nothing else such as defines or macros will interfere with the comments. It is guaranteed that every open block comment will eventually be closed, so ""/*"" outside of a line or block comment always starts a new comment. Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details. After removing the comments from the source code, return the source code in the same format.",Replace single-line comments with empty strings and multi-line comments with carefully crafted regular expressions.,Use a state machine to track whether the current character is inside a comment and discard appropriately.,"Iterate through the code character by character, using flags to denote the start and end of comments; construct a new string by omitting characters within comment blocks.","Tokenize the source code based on comment delimiters ('//' and '/*'), and exclude tokens identified as comments.","Employ boolean flags to track 'in_block_comment' and iterate through each line, managing single-line and multi-line comments and constructing the result string.",Medium,algorithms,"Array,String"
724,"Find Pivot Index
Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1.","Calculate prefix sums from the left and right, then compare them at each index.","Sort the array first, then iterate and check for the pivot condition.",Divide the array into two halves and check the sum of each half separately.,Use recursion to find the pivot index by repeatedly dividing the array.,"Calculate the total sum of the array and iterate through it, subtracting each element from the total sum to find the pivot index.",Easy,algorithms,"Array,Prefix Sum"
725,"Split Linked List in Parts
Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts.","Use a greedy approach, assigning ceiling(n/k) elements to each part until exhausted.","Create k empty lists and distribute nodes round-robin, cycling through the lists.","Determine the size of each part using integer division only, ignoring the remainder.","Calculate the remainder, and append all remainder nodes to the last part.","Calculate base size and remainder. Assign base size + 1 to the first 'remainder' parts, then base size to the rest.",Medium,algorithms,Linked List
726,"Number of Atoms
Given a string formula representing a chemical formula, return the count of each atom. The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. Two formulas are concatenated together to produce another formula. A formula placed in parentheses, and a count (optionally added) is also a formula. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. The test cases are generated so that all the values in the output fit in a 32-bit integer.","Use a stack to track parentheses and recursively process subformulas, multiplying counts when closing parentheses","Iteratively parse the formula, maintaining a single counter for all atoms, and applying a global multiplier","Preprocess the string to replace all parentheses with multiplication symbols, then evaluate the expression using operator precedence","Use regular expressions to extract atom names and counts, then sum the counts for each atom","Use recursion with a dictionary to store atom counts, handling parentheses and multipliers during parsing",Hard,algorithms,"Hash Table,String,Stack,Sorting"
728,"Self Dividing Numbers
A self-dividing number is a number that is divisible by every digit it contains. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right] (both inclusive).",Check if the number is divisible by all numbers from 1 to 9,Convert the range to a string and check divisibility by the string's length,"Skip any number containing an even digit, then check for self-divisibility",Use a bitwise AND operation to confirm divisibility by each digit,"Iterate through the range, and for each number, check if it's self-dividing by verifying divisibility by each of its non-zero digits",Easy,algorithms,Math
729,"My Calendar I
You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime. Implement the MyCalendar class:","Using a single lock for the entire calendar, allowing only one event modification at a time.","Employing a read-write lock, permitting concurrent reads but exclusive writes during event additions.",Checking for overlapping intervals using binary search on a sorted list of existing events.,Maintaining a hash map to quickly locate overlapping events based on start and end times.,Iterating through all existing events and comparing the new event's start and end times for overlaps.,Medium,algorithms,"Design,Segment Tree,Ordered Set"
730,"Count Different Palindromic Subsequences
Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7. A subsequence of a string is obtained by deleting zero or more characters from the string. A sequence is palindromic if it is equal to the sequence reversed. Two sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi.",Brute-force: Generate all subsequences and check for palindromes (exponential time),Dynamic programming: Build a table storing palindrome counts for substrings without considering overlapping subsequences,"Recursion with memoization: Explore all possible subsequences, pruning branches that don't form palindromes and memoizing intermediate results without handling modulo correctly",Greedy approach: Always choosing the smallest possible palindrome at each step,"Dynamic programming: Build a table storing palindrome counts for substrings, considering overlapping subsequences and applying modulo arithmetic",Hard,algorithms,"String,Dynamic Programming"
731,"My Calendar II
You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking. A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.). The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime. Implement the MyCalendarTwo class:",Use a difference array to track overlaps and efficiently determine if a triple booking exists.,Store events in a sorted list of tuples and perform a linear scan to check for triple bookings.,Employ a segment tree to maintain booking counts and efficiently query for triple bookings.,Utilize a hash map to count overlaps and reject new bookings if any overlap count exceeds 2.,Maintain two lists: one for single bookings and one for double bookings. Check for overlaps against both lists before adding a new event.,Medium,algorithms,"Design,Segment Tree,Ordered Set"
732,"My Calendar III
A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [startTime, endTime), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class:","Use a brute-force approach, iterating through all possible time intervals and counting overlaps for each new event.","Maintain a list of start times and a list of end times, sorting each list separately, and using binary search to find overlaps.",Employ a segment tree data structure to efficiently query and update the maximum overlap count for each time interval.,"Store events in a hash map with timestamps as keys and counts as values, incrementing counts for start times and decrementing for end times, then finding the maximum count.","Utilize a TreeMap to store the difference in event counts at each timestamp, calculating the running sum and tracking the maximum value.",Hard,algorithms,"Design,Segment Tree,Ordered Set"
733,"Flood Fill
You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill: Return the modified image after performing the flood fill.","Use Breadth-First Search (BFS), stopping when all pixels are a different color than the starting color.",Recursively call the floodFill function only for the neighboring pixels that have a higher value than the starting pixel.,"Perform a Depth-First Search (DFS), only changing the color of the pixel at (sr, sc) and not exploring its neighbors.",Iterate through the entire image array and change the color of every pixel to the specified color.,Use Depth-First Search (DFS) or Breadth-First Search (BFS) to change the color of connected pixels with the same initial color to the new color.,Easy,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
735,"Asteroid Collision
We are given an array asteroids of integers representing asteroids in a row. The indices of the asteriod in the array represent their relative position in space. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.","All asteroids survive the collisions, resulting in the original input array.","Only the largest asteroid survives regardless of direction, eliminating all others.","All asteroids moving in the same direction as the majority survive, and others explode.",Asteroids moving in opposite directions merge into a single asteroid with the combined size and direction of the larger one.,"Return the array representing the asteroids that remain after all collisions, simulating the explosions based on size and direction.",Medium,algorithms,"Array,Stack"
736,"Parse Lisp Expression
You are given a string expression representing a Lisp-like expression to return the integer value of. The syntax for these expressions is given as follows.","Evaluate all 'let' expressions sequentially from left to right, substituting values into the main expression after each 'let' evaluation.","Recursively evaluate the expression, handling 'let' expressions by storing variable bindings in a global dictionary that persists across recursive calls.",Preprocess the entire expression to identify all variables and their dependencies before starting evaluation.,Tokenize the expression and use a stack-based approach to evaluate operators and handle variable scopes.,"Use recursion with a scope (environment) to track variable bindings, evaluating expressions based on the current scope.",Hard,algorithms,"Hash Table,String,Stack,Recursion"
738,"Monotone Increasing Digits
An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y. Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits.","Greedily decrement digits from right to left until the monotone property holds, adjusting subsequent digits if necessary.","Convert the integer to a string, sort the string lexicographically, and convert back to an integer.",Calculate all possible monotone increasing numbers less than n and select the largest.,Start with the largest possible integer of the same length as n and decrement until a monotone increasing number is found.,"Scan the number from left to right. When a decreasing pair is found, decrement the left digit and set all subsequent digits to 9.",Medium,algorithms,"Math,Greedy"
739,"Daily Temperatures
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.","Use brute force: For each day, iterate through the rest of the array to find the next warmer day.","Sort the temperatures array and then for each original temperature, find its index in the sorted array.","Employ dynamic programming, storing the indices of warmer days encountered so far.",Utilize a binary search tree to efficiently locate the next warmer temperature for each day.,"Employ a stack to keep track of decreasing temperatures and their indices, popping elements when a warmer temperature is encountered.",Medium,algorithms,"Array,Stack,Monotonic Stack"
740,"Delete and Earn
You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times: Return the maximum number of points you can earn by applying the above operation some number of times.","Sort the array and greedily pick numbers, skipping adjacent ones, until the array is empty",Use dynamic programming with a state representing the current index and whether the previous number was taken,"Recursively explore all possible combinations of numbers to take, maximizing the sum at each step",Transform the array into a histogram and use a knapsack algorithm to determine optimal earning,"Create a frequency map, then use dynamic programming to determine maximum points, either including or excluding each number",Medium,algorithms,"Array,Hash Table,Dynamic Programming"
741,"Cherry Pickup
You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. Return the maximum number of cherries you can collect by following the rules below:","Greedily choose the path with the most cherries at each step, ignoring potential future gains.","Calculate the maximum cherries obtainable by one person traveling from (0,0) to (n-1, n-1) and back, ignoring the other person.",Use dynamic programming with two independent states representing the row and column of each person.,"Only consider paths that move strictly down or right, neglecting the return path.","Use dynamic programming with a state representing the row of both people and the column of one person, exploiting the symmetry of the paths.",Hard,algorithms,"Array,Dynamic Programming,Matrix"
744,"Network Delay Time
You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",Depth-First Search,Breadth-First Search,Topological Sort,Prim's Algorithm,Dijkstra's Algorithm,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Heap (Priority Queue),Shortest Path"
745,"Find Smallest Letter Greater Than Target
You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters. Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.","Return target + 1 directly, assuming it's within the ASCII range of letters","Iterate through letters and return the first character whose ASCII value is greater than target's, wrapping around if necessary","Use binary search on letters to find the target, then return the next element, or the first if target is the last element","Sort the letters array, then return the first element that's greater than the target","Perform a binary search to find the smallest element greater than the target, wrapping around to the start of the array if no such element exists",Easy,algorithms,"Array,Binary Search"
746,"Prefix and Suffix Search
Design a special dictionary that searches the words in it by a prefix and a suffix. Implement the WordFilter class:","Use a brute-force approach by checking every word against the given prefix and suffix, resulting in O(N*M*K) complexity where N is the number of words, M is the length of the prefix, and K is the length of the suffix.","Implement a Trie for prefixes and a reverse Trie for suffixes, then intersect the results of searching both Tries independently, with O(M+K) search time, but high memory usage.","Store all possible prefix-suffix combinations as keys in a hash map, leading to fast lookups but requiring O(N^2) space.","Use a Bloom filter to check if a word matches the prefix and suffix, which offers probabilistic matching with possible false positives.","Combine a Trie for prefixes with a hash map storing the maximum index for each prefix-suffix combination, providing O(M+K) search time and efficient memory usage compared to storing all combinations.",Hard,data structures,"String,Design,Trie"
747,"Min Cost Climbing Stairs
You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.",Use recursion with memoization to explore all possible paths.,Apply Dijkstra's algorithm to find the shortest path from the starting steps to the top.,"Use a greedy approach, always choosing the step with the lowest cost.",Calculate the average cost of each step and multiply by the total number of steps.,Use dynamic programming to calculate the minimum cost to reach each step.,Easy,algorithms,"Array,Dynamic Programming"
748,"Largest Number At Least Twice of Others
You are given an integer array nums where the largest integer is unique. Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.",Return -1 if the array is empty or has only one element,Sort the array and check if the last element is twice the second to last element,"Iterate through the array, finding the largest element and the second largest element, then compare them",Return the index of the first element if it's larger than all other elements combined,"Find the largest element and its index, then iterate through the array checking if any other element is larger than half the largest element",Easy,algorithms,"Array,Sorting"
749,"Shortest Completing Word
Given a string licensePlate and an array of strings words, find the shortest completing word in words. A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more. For example, if licensePlate = ""aBc 12c"", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are ""abccdef"", ""caaacab"", and ""cbca"". Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words.",Sort 'words' lexicographically and return the first word that satisfies the completion criteria.,Convert both 'licensePlate' and each word in 'words' to sets of characters and check for subset inclusion.,"Use regular expressions to filter 'words' for those containing the required letters, then find the shortest.",Precompute a hash map of character frequencies for 'licensePlate' and compare against precomputed character frequencies for each word in 'words'.,"Count character frequencies in 'licensePlate'. For each word in 'words', check if it contains sufficient character frequencies. Return the shortest completing word.",Easy,algorithms,"Array,Hash Table,String"
750,"Contain Virus
A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls. The world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary. Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie. Return the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.","Recursively explore each infected region, calculating walls needed and threatened cells, then choosing the region needing the fewest walls.","Prioritize quarantining based on the number of infected cells in a region, regardless of the number of threatened cells.","Greedily quarantine the smallest infected region first, assuming it will require the least number of walls.",Simulate the virus spread for each possible quarantine strategy and choose the one that delays full infection the longest.,"Identify infected regions, calculate the number of walls needed and the number of cells each region threatens; quarantine the region threatening the most cells until no infected regions remain.",Hard,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix,Simulation"
753,"Open the Lock
You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot. The lock initially starts at '0000', a string representing the state of the 4 wheels. You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.",Depth-First Search (DFS),Greedy Algorithm,Dynamic Programming,Divide and Conquer,Breadth-First Search (BFS),Medium,algorithms,"Array,Hash Table,String,Breadth-First Search"
754,"Cracking the Safe
There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1]. The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit. Return any string of minimum length that will unlock the safe at some point of entering it.",Use a greedy algorithm to prioritize shorter substrings for faster verification.,Construct a de Bruijn sequence of order 'n' using an alphabet of size 'k'.,Generate all possible password combinations and concatenate them with a delimiter.,Employ a backtracking algorithm to explore potential password sequences.,"Build a directed graph where nodes represent all possible (n-1)-digit sequences, and edges represent adding a digit; find a Eulerian path in this graph.",Hard,algorithms,"Depth-First Search,Graph,Eulerian Circuit"
755,"Reach a Number
You are standing at position 0 on an infinite number line. There is a destination at position target. You can make some number of moves numMoves so that: Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.","Use a breadth-first search (BFS) algorithm, treating each position as a node and each move as an edge.","Apply dynamic programming, storing the minimum moves required to reach each position.",Solve the problem using binary search to find the optimal number of moves.,"Employ a greedy approach, always moving towards the target with the largest possible step.","Calculate the sum of the first n natural numbers until it's greater than or equal to the absolute value of the target, then adjust for parity.",Medium,algorithms,"Math,Binary Search"
757,"Pyramid Transition Matrix
You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid. Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.",Always choose the lexicographically smallest possible top block.,"If any two adjacent blocks in a row are not a valid pattern, immediately return false.","Recursively build the pyramid row by row, backtracking when no valid top blocks exist.","Prioritize building the pyramid from the top down, checking if the base can be formed.","Use dynamic programming to determine if each possible row can be built from the row below, given the allowed patterns.",Medium,algorithms,"Bit Manipulation,Depth-First Search,Breadth-First Search"
759,"Set Intersection Size At Least Two
You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively. A containing set is an array nums where each interval from intervals has at least two integers in nums. Return the minimum possible size of a containing set.",Sort the intervals by their end points and greedily pick the two largest numbers within each interval.,Sort the intervals by their start points and use dynamic programming to find the minimum size.,"Recursively process the intervals, keeping track of the set of numbers selected so far.","For each interval, pick two arbitrary numbers and add them to the containing set.","Sort the intervals by their end points. Then, for each interval, greedily add the two largest possible numbers that are not already in the set.",Hard,algorithms,"Array,Greedy,Sorting"
763,"Special Binary String
Special binary strings are binary strings with the following two properties: You are given a special binary string s. A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string. Return the lexicographically largest resulting string possible after applying the mentioned operations on the string.","Divide the string into substrings where the number of 0s equals the number of 1s, then sort these substrings lexicographically in ascending order and concatenate them.","Recursively find all possible substrings, sort them lexicographically in descending order, and select the largest one that satisfies the special binary string property.","Greedily swap any two adjacent substrings that are special binary strings if the swap results in a lexicographically larger string, repeating until no such swaps are possible.",Sort the string directly using a standard sorting algorithm and then check if it satisfies the special binary string properties.,"Decompose the string into its maximal special substrings, sort these substrings lexicographically in descending order, and concatenate them to form the result.",Hard,algorithms,"String,Recursion"
767,"Prime Number of Set Bits in Binary Representation
Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of 1's present when written in binary.",Store the count of set bits for each number in a hash table and then check for primality.,Precompute all prime numbers up to 'right' and use them to filter the numbers based on their binary representation.,"Calculate the total number of set bits across the entire range [left, right] and check if that sum is prime.",Convert each number in the range to its decimal representation and then determine if the decimal value is a prime number.,"Iterate through the range, count set bits for each number, and increment a counter if the set bit count is a prime number.",Easy,algorithms,"Math,Bit Manipulation"
768,"Partition Labels
You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string ""ababcc"" can be partitioned into [""abab"", ""cc""], but partitions such as [""aba"", ""bcc""] or [""ab"", ""ab"", ""cc""] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.","O(n log n), due to sorting the string.","O(n^2), due to nested loops for finding partitions.","O(26n), since we are checking for at most 26 characters.","O(n!), as we might explore all possible partition combinations.","O(n), where n is the length of the string.",Medium,algorithms,"Hash Table,Two Pointers,String,Greedy"
769,"Largest Plus Sign
You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0. Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0. An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.",Calculate the number of connected components in the grid using Depth-First Search (DFS) and return the maximum size.,Iterate through each cell and use a sliding window approach to determine the maximum size of a plus sign centered at that cell.,"Apply dynamic programming to precompute the lengths of consecutive ones in each direction (up, down, left, right) from each cell, then iterate to find the maximum plus sign order.",Convert the grid into a 1D array and use binary search to find the maximum length of consecutive ones representing the arms of the plus sign.,"Use dynamic programming to create four auxiliary matrices storing the maximum lengths of consecutive 1s extending in each direction from each cell, then iterate to find the minimum of these values at each cell to determine the maximum plus sign order.",Medium,algorithms,"Array,Dynamic Programming"
770,"Couples Holding Hands
There are n couples sitting in 2n seats arranged in a row and want to hold hands. The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1). Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.","Use a greedy approach, swapping adjacent elements until all couples are together.",Calculate the number of inversions in the array 'row' and divide by two.,Apply a recursive algorithm that checks if each pair is correctly seated and swaps when not.,Sort the array 'row' and count the number of misplaced couples.,Model the problem as a graph and count the number of cycles. The answer is n minus the number of cycles.,Hard,algorithms,"Greedy,Depth-First Search,Breadth-First Search,Union Find,Graph"
777,"Toeplitz Matrix
Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.",Check if matrix[i][j] == matrix[j][i] for all i and j.,Compare the first row and first column to all other elements.,Verify that the matrix is square before proceeding with any checks.,Only compare adjacent elements to determine if they are equal.,Compare matrix[i][j] with matrix[i+1][j+1] for all valid i and j.,Easy,algorithms,"Array,Matrix"
778,"Reorganize String
Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return """" if not possible.","Use a greedy approach, always placing the most frequent character next, without considering edge cases.","Sort the string and then alternate characters, returning an empty string if adjacent characters are identical.","Generate all permutations of the string and return the first one that satisfies the condition, or an empty string if none exist.","Randomly shuffle the string until a valid rearrangement is found, or return an empty string after a certain number of attempts.","Use a max heap to store character counts and iteratively build the rearranged string, ensuring no adjacent characters are the same.",Medium,algorithms,"Hash Table,String,Greedy,Sorting,Heap (Priority Queue),Counting"
779,"Max Chunks To Make Sorted II
You are given an integer array arr. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.",Greedily create chunks whenever the maximum value to the left is less than or equal to the minimum value to the right.,Sort the entire array and then create chunks of size one whenever two consecutive elements are in sorted order.,Count the number of inversions in the array and return the length of the array minus the number of inversions.,"Sort the array and compare it to the original, creating chunks whenever the elements match at a given index.",Use prefix maximums from the left and suffix minimums from the right to determine valid chunk boundaries.,Hard,algorithms,"Array,Stack,Greedy,Sorting,Monotonic Stack"
780,"Max Chunks To Make Sorted
You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1]. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.","Apply a greedy algorithm comparing element value to index, incrementing the chunk count when they match.",Sort the input array and compare it to the original. The number of differences gives the optimal chunk count.,Recursively divide the array into smaller subarrays until each subarray is sorted. The number of divisions is the result.,Calculate the prefix sum of the array. The largest prefix sum will give the number of chunks.,"Iterate through the array, tracking the maximum value seen so far. Increment the chunk count when the maximum value equals the current index.",Medium,algorithms,"Array,Stack,Greedy,Sorting,Monotonic Stack"
781,"Basic Calculator IV
Given an expression such as expression = ""e + 8 - a + 5"" and an evaluation map such as {""e"": 1} (given in terms of evalvars = [""e""] and evalints = [1]), return a list of tokens representing the simplified expression, such as [""-1*a"",""14""] Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. The format of the output is as follows: Note: You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].",Use Dijkstra's algorithm to find the shortest path through the expression tree.,Evaluate the expression using a context-free grammar parser with operator precedence rules.,Substitute variables and simplify by iteratively applying algebraic identities.,"Tokenize the expression, then evaluate it using dynamic programming to store intermediate results.","Parse the expression into an expression tree, substitute variables, and simplify using polynomial arithmetic.",Hard,algorithms,"Hash Table,Math,String,Stack,Recursion"
782,"Jewels and Stones
You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so ""a"" is considered a different type of stone from ""A"".","Use nested loops to iterate through `stones` and `jewels`, incrementing a counter for each match without considering case sensitivity.","Create a dictionary mapping stone types to their counts and then iterate through `jewels`, summing the counts of matching stones in the dictionary, ignoring the jewel string.",Convert both strings to lowercase and then use a single loop to check if each stone exists in the jewels string.,"Sort both strings alphabetically and then use a linear scan to find common characters, considering only unique characters in each string.","Convert the `jewels` string into a set for fast lookups, then iterate through the `stones` string, incrementing a counter for each stone found in the set.",Easy,algorithms,"Hash Table,String"
787,"Sliding Puzzle
On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.",Depth-First Search (DFS),Greedy Search,Dynamic Programming,A* Search with a poorly chosen heuristic,Breadth-First Search (BFS),Hard,algorithms,"Array,Breadth-First Search,Matrix"
790,"Global and Local Inversions
You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1]. The number of global inversions is the number of the different pairs (i, j) where: The number of local inversions is the number of indices i where: Return true if the number of global inversions is equal to the number of local inversions.",O(n^2) due to nested loops to count global inversions.,O(n log n) due to sorting algorithms typically used for counting inversions.,O(1) as the result is always pre-computed.,O(n!) because it involves checking all permutations.,O(n) because it can be determined in a single pass if local inversions equal global inversions.,Medium,algorithms,"Array,Math"
793,"Swap Adjacent in LR String
In a string composed of 'L', 'R', and 'X' characters, like ""RXXLRXRXL"", a move consists of either replacing one occurrence of ""XL"" with ""LX"", or replacing one occurrence of ""RX"" with ""XR"". Given the starting string start and the ending string result, return True if and only if there exists a sequence of moves to transform start to result.",The length of the start and end strings are different.,The number of 'L' and 'R' characters differ between the start and end strings.,An 'R' character appears to the left of an 'L' character in the end string where it was not in the start string after removing 'X' characters.,The relative order of 'R' and 'L' characters are changed between start and end strings after removing all 'X' characters.,An 'L' character has moved right or an 'R' character has moved left.,Medium,algorithms,"Two Pointers,String"
794,"Swim in Rising Water
You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).","Use a breadth-first search, keeping track of visited cells and the maximum elevation encountered so far",Apply Dijkstra's algorithm with the edge weights being the elevation difference between adjacent cells,"Perform a depth-first search, prioritizing cells with the lowest elevation",Calculate the average elevation of the entire grid and use that as the estimated time,"Employ binary search on the possible time range, and within each iteration, use a graph traversal algorithm (e.g., DFS or BFS) to check if the bottom right cell is reachable",Hard,algorithms,"Array,Binary Search,Depth-First Search,Breadth-First Search,Union Find,Heap (Priority Queue),Matrix"
795,"K-th Symbol in Grammar
We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.",The kth symbol is always equal to k mod 2,"The kth symbol is determined by the number of set bits in the binary representation of k-1. If even, it's 0; otherwise, it's 1.","The kth symbol is the same as the (n-k)th symbol in the previous row, negated",The kth symbol alternates between 0 and 1 in each row.,The kth symbol is the bitwise XOR of n-1 and k-1. If the result has an even number of set bits the symbol is 0 else it's 1 after the first symbol in the first row,Medium,algorithms,"Math,Bit Manipulation,Recursion"
796,"Reaching Points
Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise. The allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).","Greedily move towards (sx, sy) by subtracting the smaller of tx and ty from the larger until either tx == sx and ty == sy, or one coordinate is smaller than its corresponding starting coordinate","Use dynamic programming to store all reachable points from (sx, sy) up to (tx, ty) and return true if (tx, ty) is among them","Employ a breadth-first search algorithm starting from (sx, sy), exploring possible paths until (tx, ty) is reached or all paths are exhausted","Apply the Euclidean algorithm to find the greatest common divisor (GCD) of (tx - sx) and (ty - sy), then check if the GCD divides both (tx - sx) and (ty - sy)","Starting from (tx, ty), work backwards by repeatedly subtracting the smaller coordinate from the larger, using the modulo operator to avoid unnecessary calculations and handle edge cases",Hard,algorithms,Math
797,"Rabbits in Forest
There is a forest with an unknown number of rabbits. We asked n rabbits ""How many rabbits have the same color as you?"" and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest.",Store each answer as a key in a hash map and sum the values directly.,Sort the answers array and simply sum up all the unique elements.,Calculate the mode of the array and multiply it by the length of the array.,Multiply the number of distinct answers by the average answer.,"For each distinct answer 'x', calculate ceil(count(x) / (x + 1)) * (x + 1), and sum these values.",Medium,algorithms,"Array,Hash Table,Math,Greedy"
798,"Transform to Chessboard
You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other. Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1. A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.","Find the row with the maximum number of 1s and swap it to the first row and column with maximum 1s to first column, then repeat recursively for submatrix","Calculate the number of differing bits between the first row and an ideal chessboard row, and the first column and an ideal chessboard column, and return the minimum of those two.","Check if the counts of 0s and 1s in each row and column are equal. If not return -1 else, find the optimal row swaps and column swaps independently by greedily swapping nearest mismatched rows and columns until the grid is chessboard",Use dynamic programming to store the minimum moves needed to transform the top-left k x k subgrid into a chessboard.,"Check for validity: equal 0s and 1s, at most two distinct rows/columns. Calculate row and column swaps independently by counting differences to ideal chessboard patterns. Return -1 if conditions not met.",Hard,algorithms,"Array,Math,Bit Manipulation,Matrix"
799,"Minimum Distance Between BST Nodes
Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.",Perform a breadth-first search and calculate the difference between each node and all other nodes.,Sort the node values in an array and then iterate through the sorted array to find the minimum difference between adjacent elements.,Calculate the difference between the root node and all its descendants.,Use dynamic programming to store previously computed differences.,Perform an inorder traversal of the BST and keep track of the minimum difference between consecutive nodes.,Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Search Tree,Binary Tree"
800,"Letter Case Permutation
Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order.",Implement a backtracking algorithm exploring all possible uppercase/lowercase combinations using bit manipulation on the ASCII values,"Recursively generate permutations by choosing either uppercase or lowercase for each character, pruning branches when the string length exceeds the input","Convert the input string to lowercase, then generate all possible strings by selectively uppercasing characters based on a binary representation of numbers from 0 to 2^n","Use dynamic programming, storing intermediate permutations in a table, and combining them to generate the final list of permutations",Employ a depth-first search (DFS) algorithm to explore all possible letter case combinations,Medium,algorithms,"String,Backtracking,Bit Manipulation"
801,"Is Graph Bipartite?
There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite.",Depth-First Search (DFS) without cycle detection,A greedy algorithm that assigns nodes to sets based on immediate neighbors,Checking if the graph is strongly connected,Using Dijkstra's algorithm to find the shortest path between all pairs of nodes,Breadth-First Search (BFS) or Depth-First Search (DFS) with coloring to check for odd-length cycles,Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
802,"K-th Smallest Prime Fraction
You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].","Binary search the possible range of fractions, counting fractions less than or equal to the mid-point using a nested loop with O(n^2) complexity.",Generate all possible fractions and sort them using a comparison-based sorting algorithm like merge sort with O(n^2 log n) complexity.,"Use a min-heap to store the fractions, initially containing arr[0]/arr[1], arr[0]/arr[2]... and repeatedly extract the smallest and add new fractions involving its numerator.","Apply quickselect to find the k-th smallest fraction directly without sorting all fractions, resulting in O(n^2) average time complexity.","Use binary search to find the k-th smallest fraction. For a given mid value, count the number of fractions less than mid in O(n) time, resulting in O(n log(max_fraction)) complexity.",Medium,algorithms,"Array,Binary Search,Heap (Priority Queue)"
803,"Cheapest Flights Within K Stops
There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.","Use Dijkstra's algorithm, pruning paths that exceed K stops after visiting each node.","Employ a Breadth-First Search (BFS) algorithm, tracking the number of stops and price at each level, and prioritizing lower prices.",Apply Depth-First Search (DFS) with memoization to explore all possible paths and return the cheapest one within K stops.,"Implement a Bellman-Ford algorithm, relaxing edges only up to K iterations to represent the maximum allowed stops.","Utilize a modified Bellman-Ford or BFS algorithm that considers the number of stops as a separate dimension, updating prices only if the stop count is within the limit.",Medium,algorithms,"Dynamic Programming,Depth-First Search,Breadth-First Search,Graph,Heap (Priority Queue),Shortest Path"
804,"Rotated Digits
An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. For example: Given an integer n, return the number of good integers in the range [1, n].","Count integers where all digits are in {0, 1, 8}","Count integers where no digits are in {3, 4, 7}","Count integers where digits are only in {2, 5, 6, 9}","Count integers where digits are exclusively in {0, 1, 8} or exclusively in {2, 5, 6, 9}","Count integers containing at least one digit from {2, 5, 6, 9} and no digits from {3, 4, 7}",Medium,algorithms,"Math,Dynamic Programming"
805,"Escape The Ghosts
You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. All inputs are integral coordinates. Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. All actions happen simultaneously. You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape. Return true if it is possible to escape regardless of how the ghosts move, otherwise return false.",The ghost with the furthest Euclidean distance can be ignored since it cannot reach the target first,Compare the Manhattan distance from the player to the target with the average Manhattan distance from ghosts to the target,"If there is a ghost on the target at the beginning, then you cannot escape",Use Dijkstra's algorithm to find the shortest path from the player to the target and compare it with the shortest paths from ghosts to the target,Compare the Manhattan distance from the player to the target with the minimum Manhattan distance from ghosts to the target,Medium,algorithms,"Array,Math"
806,"Domino and Tromino Tiling
You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes. Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7. In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.","O(n) time, O(n) space, using two variables to track full and partial tilings ending at n","O(n^2) time, O(n) space, using dynamic programming and considering all possible sub-tilings","O(2^n) time, O(1) space, using recursion and memoization of overlapping subproblems","O(n log n) time, O(n) space, by sorting the tiling configurations based on their energy levels","O(n) time, O(1) space, using dynamic programming with optimized state variables to track tiling possibilities",Medium,algorithms,Dynamic Programming
807,"Custom Sort String
You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string. Return any permutation of s that satisfies this property.","Use a hash table to store the counts of characters in 's', then iterate through 'order' and append characters to the result. Finally, append the remaining characters from 's' not present in 'order'.",Sort the string 's' alphabetically and then iterate through 'order' swapping elements in 's' to match the order.,"Create a frequency array for 'order' and 's', compare frequency arrays to determine the sorted array",Remove common characters from both 'order' and 's' and combine to produce the required string,"Create a custom sorting function that prioritizes characters based on their order in 'order'. If a character is not in 'order', it can be appended at the end.",Medium,algorithms,"Hash Table,String,Sorting"
808,"Number of Matching Subsequences
Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",Use dynamic programming to find the longest common subsequence between s and each word[i],"Employ a trie data structure to store all words, then traverse s, marking nodes representing subsequences","For each word, iterate through s and use regular expressions to check if the word exists as a subsequence",Sort the words array lexicographically and then perform a binary search on s for each word,"Iterate through the 'words' array and for each word, check if it's a subsequence of 's' using two pointers",Medium,algorithms,"Hash Table,String,Trie,Sorting"
809,"Preimage Size of Factorial Zeroes Function
Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1. Given an integer k, return the number of non-negative integers x have the property that f(x) = k.",k must be prime,The preimage size is always 1,The preimage size fluctuates randomly with k,The preimage size is equal to k,The preimage size is always 5,Hard,algorithms,"Math,Binary Search"
810,"Valid Tic-Tac-Toe State
Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array that consists of characters ' ', 'X', and 'O'. The ' ' character represents an empty square. Here are the rules of Tic-Tac-Toe:",The number of 'X's must equal the number of 'O's,There cannot be two winners on the board simultaneously,The number of empty cells must be a multiple of 3,The first player ('X') must have made the first move,"The number of 'X's must be equal to or one greater than the number of 'O's, and there cannot be two winners",Medium,algorithms,"Array,String"
691,"Stickers to Spell Word
We are given n different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1. Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.","Employ a brute-force search trying all possible combinations of stickers, which guarantees finding the optimal solution but may timeout.",Preprocess the stickers to create a single string containing all characters and then find the shortest substring matching the target.,Sort the stickers by length and greedily choose the longest stickers that contain the most characters from the target string.,"Use dynamic programming with a state representing the letters of the target already covered, minimizing the number of stickers used.","Utilize dynamic programming where the state represents the remaining characters of the target to be covered, optimizing the number of stickers needed.",Hard,algorithms,"Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
692,"Top K Frequent Words
Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.","Use a hash map to count frequencies and then sort the map by value in descending order, breaking ties lexicographically using a separate sort","Sort the input array lexicographically, then iterate, counting frequencies, and select the top k using a min-heap","Use a trie data structure to store the words and their frequencies, then perform a depth-first search to retrieve the top k","Sort the input array by length, then by lexicographical order, and count frequencies to determine the top k","Use a hash map to count frequencies, then use a min-heap of size k to maintain the k most frequent words, comparing by frequency and lexicographical order",Medium,algorithms,"Hash Table,String,Trie,Sorting,Heap (Priority Queue),Bucket Sort,Counting"
693,"Binary Number with Alternating Bits
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.",Check if the number is a power of 2,"Right shift the number until it becomes zero, checking the least significant bit each time against a fixed value",Convert the number to its base-3 representation and check if any digit is equal to 2,Perform a bitwise AND operation with a pre-calculated mask,"Right shift the number and XOR it with the original number, then check if the result is all 1s",Easy,algorithms,Bit Manipulation
695,"Max Area of Island
You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.","Use Breadth-First Search (BFS) and keep track of the number of nodes visited in each connected component, returning the maximum count.","Use Depth-First Search (DFS) but only traverse the first row and first column, assuming island size decreases monotonically.","Iterate through the entire grid and count the number of '1's, returning that count as the max area.",Randomly sample cells in the grid and estimate the island size based on the frequency of '1's encountered.,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore each island, marking visited cells and counting the number of cells in each island, returning the maximum area found.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
696,"Count Binary Substrings
Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.",Use a sliding window of size 2 and increment the count if the characters are different,"Generate all possible substrings and check if each substring meets the criteria, resulting in O(n^3) complexity","Recursively check substrings of increasing length, pruning branches that don't start with alternating 0s and 1s",Count consecutive groups of 0s and 1s and sum the minimum counts of adjacent groups,"Iterate through the string, keeping track of the counts of consecutive 0s and 1s, and update a counter when a valid substring is found",Easy,algorithms,"Two Pointers,String"
811,"Number of Subarrays with Bounded Maximum
Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right]. The test cases are generated so that the answer will fit in a 32-bit integer.",O(n^3),O(n log n),O(n),O(log n),O(n^2),Medium,algorithms,"Array,Two Pointers"
812,"Rotate String
Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s. A shift on s consists of moving the leftmost character of s to the rightmost position.",Check if the lengths of 's' and 'goal' are equal and if 's' is a substring of 'goal',Compare sorted versions of 's' and 'goal' to see if their character sets match,Calculate the hash values of both strings and compare them directly,Use regular expressions to check if 'goal' can be formed by rearranging characters in 's',Check if the lengths of 's' and 'goal' are equal and if 'goal' is a substring of 's + s',Easy,algorithms,"String,String Matching"
813,"All Paths From Source to Target
Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).",Breadth-First Search (BFS) with path reconstruction.,Depth-First Search (DFS) without backtracking.,"Iterative Depth-First Search using a stack, but not maintaining the path.","Dijkstra's algorithm to find the shortest path, and then enumerate paths near that length.",Depth-First Search (DFS) with backtracking to explore all paths.,Medium,algorithms,"Backtracking,Depth-First Search,Breadth-First Search,Graph"
814,"Smallest Rotation with Highest Score
You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point. Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.",Use binary search to find the optimal rotation point.,Calculate the score for all possible rotations and return the maximum.,Sort the input array and return the index of the first element.,Apply Kadane's algorithm to find the maximum sum subarray and use its starting index as the rotation.,Use an auxiliary array to store score changes caused by each element and compute the accumulated score for each rotation.,Hard,algorithms,"Array,Prefix Sum"
815,"Champagne Tower
We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)","Use dynamic programming, storing the amount of champagne in each glass in a 2D array, iterating from top to bottom, and calculating overflow for each glass.","Simulate the pouring process using recursion, with base cases for the top row and boundary conditions for overflowing glasses, returning the champagne amount for the specified glass.","Approximate the amount of champagne using a Monte Carlo simulation, randomly distributing champagne and calculating the average amount in the target glass.","Employ a greedy algorithm, filling glasses row by row, always prioritizing the glasses closest to the top and neglecting overflow calculation.","Employ dynamic programming to simulate champagne distribution. The state is the amount of champagne in each glass. Iterate row by row, distributing excess from full glasses to the next row.",Medium,algorithms,Dynamic Programming
819,"Minimum Swaps To Make Sequences Increasing
You are given two integer arrays of the same length nums1 and nums2. In one operation, you are allowed to swap nums1[i] with nums2[i]. Return the minimum number of needed operations to make nums1 and nums2 strictly increasing. The test cases are generated so that the given input always makes it possible. An array arr is strictly increasing if and only if arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1].",Recursively check all possible swap combinations and choose the minimum swaps,"Use dynamic programming, tracking the minimum swaps ending at each index with and without a swap","Greedily swap if nums1[i] >= nums1[i-1] or nums2[i] >= nums2[i-1], otherwise do nothing","Sort both arrays first, then count the differing elements at each index","Use dynamic programming, tracking minimum swaps needed up to index i if we swap at i, or if we don't swap at i.",Hard,algorithms,"Array,Dynamic Programming"
820,"Find Eventual Safe States
There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.",Use Depth-First Search (DFS) to detect cycles; nodes not in cycles are safe,Apply Dijkstra's algorithm to find the shortest path to a terminal node; nodes with finite paths are safe,"Employ a greedy algorithm, marking nodes as safe if they have fewer outgoing edges than incoming edges",Simulate random walks from each node; nodes that consistently reach terminal nodes are safe,Utilize Depth-First Search (DFS) to detect cycles and mark nodes on the path; safe nodes are those not on any cycle,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
821,"Bricks Falling When Hit
You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if: You are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks). Return an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied. Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.",Use Depth-First Search (DFS) after each hit to count connected components and identify falling bricks.,"Apply a Union-Find algorithm on the grid before hits, then disconnect bricks based on hits and count disconnected components after each hit.","Simulate the brick removal and use a dynamic programming approach to determine the number of falling bricks after each hit, caching intermediate results.","Reverse the grid and hits array, then simulate the brick placements using a breadth-first search (BFS) to identify bricks that become connected to the roof.","Apply a Union-Find algorithm on the grid before hits, mark hit locations, then iterate hits in reverse, adding bricks back and counting the connected components to the roof.",Hard,algorithms,"Array,Union Find,Matrix"
822,"Unique Morse Code Words
International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: For convenience, the full table for the 26 letters of the English alphabet is given below: Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. Return the number of different transformations among all words we have.","Return the length of the input array, as each word contributes a unique transformation","Return the number of words with the longest length, assuming they map to different transformations",Calculate the total number of dots and dashes across all words and return that number,Count the number of unique characters present across all the words,"Transform each word to its Morse code, store the transformations in a set, and return the size of the set",Easy,algorithms,"Array,Hash Table,String"
823,"Split Array With Same Average
You are given an integer array nums. You should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B). Return true if it is possible to achieve that and false otherwise. Note that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr.",Check if the total sum is divisible by 2 and distribute the numbers equally,"Sort the array and try to split it in the middle, comparing the averages","Use dynamic programming to store all possible sums for subsets of the array, then iterate through the array testing to see if there is a feasible split","Recursively explore all possible combinations of splitting the array, pruning branches where the averages are clearly diverging",Iterate through all possible lengths of array A and check if there is a subset with the required sum to make the average(A) equal to average(nums),Hard,algorithms,"Array,Math,Dynamic Programming,Bit Manipulation,Bitmask"
algorithms,824,"Number of Lines To Write String
You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of 'a', widths[1] is the width of 'b', and so on. You are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s. Return an array result of length 2 where:","Calculate the total width of the string and divide by 100, rounding up to the nearest integer for the number of lines and using the modulo operator for the last line's width.","Use dynamic programming to determine the optimal line breaks for minimizing the number of lines, considering all possible sub-strings of `s`.","Iteratively add characters to each line until it exceeds the width. If it exceeds, move to the next line, and reset the width of the current line by removing the last character. This approach is not efficient but guarantees a solution.",Sort the `widths` array and string `s` alphabetically before computing the line count and the last line width.,,"['string', 'array', 'iteration']","Iterate through the string, accumulating the width of each character. When the current line's width exceeds 100, increment the line count and reset the current line's width to the current character's width."
algorithms,825,"Max Increase to Keep City Skyline
There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c. A city's skyline is the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different. We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction. Return the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.",Calculate the increase for each building based on the average of the row and column maximums,Iterate through the grid and increase each building to the global maximum height,Calculate the increase for each building based on the product of the row and column maximums,Only increase buildings that are taller than both their row and column maximums,,"['arrays', 'grid', 'maximum']","For each building, determine the minimum of its row maximum and column maximum, and increase the building's height to that value if possible. Sum these increases."
algorithms,826,"Soup Servings
There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations: When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup. Note that we do not have an operation where all 100 ml's of soup B are used first. Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.",0.5,0.75,1.0,0.25,,"['probability', 'dynamic programming', 'recursion']",0.625
algorithms,827,"Expressive Words
Sometimes people repeat letters to represent extra feeling. For example: In these strings like ""heeellooo"", we have groups of adjacent letters that are all the same: ""h"", ""eee"", ""ll"", ""ooo"". You are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more. Return the number of query strings that are stretchy.","Decompose both the target string and words into runs of characters, then compare the lengths of the runs requiring exact matches or target runs to be extended from word runs of length 1",Use regular expressions to find matching groups of characters and compare their lengths for stretchiness,Employ dynamic programming to calculate the minimum edits needed to transform each word to the target string,Precompute all possible 'stretchy' variations of the target string and check if each word exists within this set,,"['string manipulation', 'grouping', 'stretchy']","Group consecutive identical characters in both the target string and each word, and check if the groups in each word can be extended to match the target string's groups based on length criteria"
algorithms,828,"Chalkboard XOR Game
You are given an array of integers nums represents the numbers written on a chalkboard. Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0. Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return true if and only if Alice wins the game, assuming both players play optimally.",Alice wins if the initial XOR sum is non-zero and the array length is odd,Alice wins if the initial XOR sum is zero and the array length is even,"Alice always loses, regardless of the input array",Alice wins if the array length is prime,,"['bitwise XOR', 'game theory', 'arrays']",Alice wins if and only if the length of the array is even or the XOR sum of the initial array is zero
algorithms,829,"Subdomain Visit Count
A website domain ""discuss.leetcode.com"" consists of various subdomains. At the top level, we have ""com"", at the next level, we have ""leetcode.com"" and at the lowest level, ""discuss.leetcode.com"". When we visit a domain like ""discuss.leetcode.com"", we will also visit the parent domains ""leetcode.com"" and ""com"" implicitly. A count-paired domain is a domain that has one of the two formats ""rep d1.d2.d3"" or ""rep d1.d2"" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself. Given an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order.","[""9001 discuss.leetcode.com""]","[""9001 discuss.leetcode.com"", ""9001 leetcode.com""]","[""9001 discuss.leetcode.com"", ""9001 leetcode.com"", ""9001 com""]","[""9001 discuss.leetcode.com"", ""9002 leetcode.com"", ""9003 com""]",,"['string processing', 'hash map', 'domain parsing']","[""9001 discuss.leetcode.com"", ""9001 leetcode.com"", ""9001 com""]"
algorithms,830,"Largest Triangle Area
Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.",Calculate the area of all possible triangles using Heron's formula and return the maximum,Sort the points based on x-coordinate and only consider adjacent points to form triangles,Use dynamic programming to store areas of triangles formed by the first i points,Find the convex hull of the points and only consider triangles formed by points on the hull,,"['geometry', 'area calculation', 'combinatorics']",Iterate through all combinations of three points and calculate the area using the determinant formula; return the maximum area
algorithms,831,"Largest Sum of Averages
You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray. Note that the partition must use every integer in nums, and that the score is not necessarily an integer. Return the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted.",Recursively compute the average of the first i elements and add it to the result of partitioning the remaining elements into k-1 parts.,Iterate through all possible partitions using nested loops and calculate the score for each partition.,Use a greedy approach by always choosing the largest element to start a new subarray.,Precompute the cumulative sums of the array and use binary search to find the optimal partition points.,,"['dynamic programming', 'partitioning', 'averages']",Use dynamic programming to store the maximum score achievable for partitioning the first i elements into j parts.
algorithms,832,"Binary Tree Pruning
Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node.",Perform a breadth-first search and remove nodes with a value of 0 and no children iteratively,"Convert the binary tree to an array, remove elements equal to 0, and reconstruct the tree","Use a stack-based iterative approach, pruning nodes with zero values encountered during traversal","Prune nodes during an inorder traversal, only considering left and right subtrees independently",,"['binary tree', 'recursion', 'tree traversal']","Use a recursive post-order traversal, pruning subtrees where both children are null or have been pruned and the current node's value is 0"
algorithms,833,"Bus Routes
You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only. Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.",Use Depth-First Search (DFS) to explore all possible bus routes,Apply Dijkstra's algorithm to find the shortest path between source and target,Perform a linear search through the routes array until the target is found,Randomly select bus routes until the target is reached,,"['graph theory', 'BFS', 'shortest path']","Use Breadth-First Search (BFS) to find the shortest path between source and target bus stops, treating bus routes as edges in a graph"
834,"Ambiguous Coordinates
We had some 2-dimensional coordinates, like ""(1, 3)"" or ""(2, 0.5)"". Then, we removed all commas, decimal points, and spaces and ended up with the string s. Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like ""00"", ""0.0"", ""0.00"", ""1.0"", ""001"", ""00.01"", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like "".1"". The final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)","A left outer join will include all records from both tables, regardless of matching keys",A right outer join includes only records where the join keys exist in both tables,A full outer join is identical to an inner join,An inner join returns all possible combinations of rows from both tables,"A full outer join returns all records from both tables, filling in NULLs for missing matches",Medium,database systems,"String,Backtracking"
835,"Linked List Components
You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values. Return the number of connected components in nums where two values are connected if they appear consecutively in the linked list.","Use a hash set to store the values in 'nums' and iterate through the linked list, incrementing the count when a value from 'nums' is encountered after a non-'nums' value.","Sort the 'nums' array and the linked list, then count the overlapping sections between them.","Iterate through the linked list, creating sublists based on consecutive values in 'nums', and return the total number of sublists.",Convert both the linked list and the 'nums' array to strings and count the occurrences of 'nums' as substrings in the linked list string.,"Create a set from 'nums', then traverse the linked list. Increment a counter when a node's value is in the set and the next node's value is not, or the next node is null.",Medium,algorithms,"Hash Table,Linked List"
836,"Race Car
Your car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse): For example, after commands ""AAR"", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes to 1 --> 2 --> 4 --> -1. Given a target position target, return the length of the shortest sequence of instructions to get there.","Use Dijkstra's algorithm treating each (position, speed) as a node, and 'A' and 'R' as edges",Apply A* search with a heuristic function that estimates the remaining distance based on current speed,"Employ a breadth-first search (BFS) exploring possible states (position, speed, instruction sequence) until the target is reached",Use dynamic programming to store the minimum steps to reach each position and speed,"Solve using BFS where each state is (position, speed, steps), and the transitions are 'A' and 'R'",Hard,algorithms,Dynamic Programming
837,"Most Common Word
Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase. Note that words can not contain punctuation symbols.",Use regular expressions to find all words and count their occurrences without normalization,Convert the paragraph to a set and subtract the banned words set to find the most frequent word,Sort all the words in the paragraph alphabetically and linearly search for the most common word,"Count word frequencies without removing punctuation, then filter based on the banned list","Normalize the paragraph, count word frequencies, and filter out banned words to find the most frequent non-banned word",Easy,algorithms,"Hash Table,String,Counting"
839,"Short Encoding of Words
A valid encoding of an array of words is any reference string s and array of indices indices such that: Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.",Sort the words by length in ascending order and concatenate them,Create a prefix tree (Trie) of the words and count the total number of nodes,Remove all words that are substrings of other words and sum the lengths of the remaining words,Calculate the sum of the lengths of the words without accounting for overlapping suffixes,"Iterate through the words, adding each to a set; then remove suffixes present in the set, and sum the lengths of the remaining words plus the number of remaining words",Medium,algorithms,"Array,Hash Table,String,Trie"
841,"Shortest Distance to a Character
Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s. The distance between two indices i and j is abs(i - j), where abs is the absolute value function.",Hash each element and compare hashes to known secure values,Implement a custom encryption algorithm with a rolling key,Use a combination of Caesar cipher and transposition cipher,Store passwords as plain text with restricted access controls,"Use a strong, salted hashing algorithm like Argon2 or bcrypt",Easy,security,"Array,Two Pointers,String"
842,"Card Flipping Game
You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero). After flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card. Return the minimum possible good integer after flipping the cards. If there are no good integers, return 0.",Return the smallest element present in both 'fronts' and 'backs' arrays.,Return the smallest element that appears only in the 'fronts' array.,Return the smallest element that appears only in the 'backs' array.,"Return the smallest element in the 'backs' array if it is not present in the 'fronts' array, otherwise return 0.",Return the minimum element in 'backs' that is not present in 'fronts'; return 0 if no such element exists.,Medium,algorithms,"Array,Hash Table"
843,"Binary Trees With Factors
Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1. We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children. Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.","Use dynamic programming, sorting the array and iterating, multiplying when a factor is found","Recursively build all possible trees and count those that satisfy the condition, with memoization",Create a hashmap to store the factors of each number and perform a brute-force search through the array,"Sort the array and use two pointers to find pairs that satisfy the product condition, incrementing a counter","Sort the array, use dynamic programming, where dp[i] represents the number of trees rooted at arr[i], and iterate to find factors",Medium,algorithms,"Array,Hash Table,Dynamic Programming"
851,"Goat Latin
You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to ""Goat Latin"" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: Return the final sentence representing the conversion from sentence to Goat Latin.","Append 'ma' to the end of each word, and add a number of 'a's equal to the word's index","Reverse each word, append 'ma' to the end, and add 'aa' to the end of the whole sentence","Capitalize the first letter of each word, append 'ma', and then add 'a' based on the word length","Remove all vowels from each word, append 'ma', and then add the word's index as a string","If a word starts with a vowel, append 'ma'. Otherwise, move the first letter to the end and append 'ma'. Finally, add 'a' to the end of each word, repeated a number of times equal to the word's index in the sentence.",Easy,algorithms,String
852,"Friends Of Appropriate Ages
There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person. A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true: Otherwise, x will send a friend request to y. Note that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself. Return the total number of friend requests made.",Calculate the number of people older than each person and sum the differences.,"Sort the ages array and iterate through it, applying the conditions without considering duplicates.",Use a hash map to store the frequency of each age and iterate through the map to calculate friend requests.,Calculate the average age and use it to estimate the number of friend requests.,"Count the frequency of each age, then for each age x, count the valid ages y based on the given conditions and multiply by the frequencies of x and y.",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
853,"Most Profit Assigning Work
You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where: Every worker can be assigned at most one job, but one job can be completed multiple times. Return the maximum profit we can achieve after assigning the workers to the jobs.","Sort jobs by difficulty and workers by ability, then greedily assign the most profitable jobs to the most capable workers.","Use dynamic programming to find the optimal assignment, considering all possible subsets of jobs and workers.","Apply a max-flow algorithm to a bipartite graph representing workers and jobs, with edges weighted by profit.",Calculate the average profit per difficulty for each job and assign workers to jobs with the highest ratio.,"Sort jobs by difficulty, calculate the maximum profit achievable for each difficulty level, and then assign workers to the highest profit job they can perform.",Medium,algorithms,"Array,Two Pointers,Binary Search,Greedy,Sorting"
854,"Making A Large Island
You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1. Return the size of the largest island in grid after applying this operation. An island is a 4-directionally connected group of 1s.","Depth-First Search (DFS) from each cell, keeping track of visited cells and island sizes without optimization","Iterate through all zero cells, temporarily changing them to one, and using Breadth-First Search (BFS) to find island size, reverting the change afterward","Union-Find algorithm to connect all 1s, then iterate through 0s and check the connected components of their neighbors, and add those sizes",Dynamic programming to calculate the size of the largest island that can be formed at each cell,"Use Depth-First Search (DFS) to find all islands and store their sizes; then, iterate through zero cells and sum the sizes of adjacent islands.",Hard,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
855,"Count Unique Characters of All Substrings of a Given String
Let's define a function countUniqueChars(s) that returns the number of unique characters in s. Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer. Notice that some substrings can be repeated so in this case you have to count the repeated ones too.",Use dynamic programming to store intermediate substring uniqueness counts in a 3D array.,Precompute the frequency of all characters and use a sliding window to update the unique character count.,Iterate through all possible substrings and use a hash table to count unique characters for each substring.,"Sort the string, then calculate the unique character count for each substring based on sorted order.","For each character, calculate how many substrings it uniquely contributes to, summing these contributions.",Hard,algorithms,"String,Dynamic Programming"
856,"Consecutive Numbers Sum
Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.","Check if n is a power of 2; if so, return 1, else return 2","Iterate from 1 to n, checking for each i if (n - i) is divisible by i; if so, increment the count","Recursively divide n by 2 until the result is 1, and count the number of divisions","Check if n is prime; if so, return 2, else return 1",Count the number of odd factors of n,Hard,algorithms,"Math,Enumeration"
857,"Positions of Large Groups
In a string s of lowercase letters, these letters form consecutive groups of the same character. For example, a string like s = ""abbxxxxzyy"" has the groups ""a"", ""bb"", ""xxxx"", ""z"", and ""yy"". A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, ""xxxx"" has the interval [3,6]. A group is considered large if it has 3 or more characters. Return the intervals of every large group sorted in increasing order by start index.",Use regular expressions to identify groups and then filter for large groups.,"Iterate through the string, keeping track of the current group's character and length, storing potential large groups in a hash table.","Sort the string first, then iterate to identify and store large groups.","Recursively divide the string, find large groups in each half, and then merge the results.","Iterate through the string once, tracking the start and end indices of each group, and add intervals to the result as large groups are identified.",Easy,algorithms,String
858,"Masking Personal Information
You are given a personal information string s, representing either an email address or a phone number. Return the masked personal information using the below rules. Email address: An email address is: To mask an email: Phone number: A phone number is formatted as follows: To mask a phone number:",Use substring operations and character replacements to create the masked string.,Employ regular expressions to identify and replace specific patterns in the input.,Split the input string into an array of characters and conditionally modify elements based on index.,"Convert the input to bytes, manipulate the byte array, and convert it back to a string.","Parse the input to determine if it's an email or phone number, then apply masking rules accordingly using string manipulation.",Medium,algorithms,String
861,"Flipping an Image
Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.",Swap elements across the main diagonal and then XOR each element with 1.,"Transpose the matrix, then reverse each row.","Reverse the order of rows, and then subtract each element from 1.","Invert the matrix by XORing each element with 1, then transpose it.",Reverse each row and then invert each element by XORing with 1.,Easy,algorithms,"Array,Two Pointers,Matrix,Simulation"
862,"Find And Replace in String
You are given a 0-indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k. To complete the ith replacement operation: For example, if s = ""abcd"", indices[i] = 0, sources[i] = ""ab"", and targets[i] = ""eee"", then the result of this replacement will be ""eeecd"". All replacement operations must occur simultaneously, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will not overlap. Return the resulting string after performing all replacement operations on s. A substring is a contiguous sequence of characters in a string.",Replace all occurrences sequentially from left to right based on the order in the indices array.,Sort the indices array and perform replacements sequentially based on the sorted order of indices.,Perform replacements in reverse order of indices to avoid index shifting issues.,Create a copy of the string 's' and perform replacements on the copy while referencing the original string's indices.,"Identify valid replacements, adjust indices after each replacement, and construct the result string using substring operations.",Medium,algorithms,"Array,String,Sorting"
863,"Sum of Distances in Tree
There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges. You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.",Perform a Depth-First Search (DFS) from each node to calculate the sum of distances. This approach has a time complexity of O(n^2).,"Use Dijkstra's algorithm starting from each node to find the shortest paths to all other nodes, then sum these distances. This also results in O(n^2 * log n) time complexity.",Randomly sample nodes and estimate the sum of distances based on these samples. This is an approximation and may not be accurate.,Calculate the diameter of the tree and use it as an approximation for the average distance to each node.,"Use a two-pass approach: first, calculate the size of each subtree and the sum of distances from a root node. Then, propagate this information to calculate the sum of distances for each node.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Graph"
864,"Image Overlap
You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values. We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images. Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased. Return the largest possible overlap.",Compute the cross-correlation of the two images directly in the spatial domain.,"Use a brute-force approach, shifting img1 and img2 by all possible amounts.","Apply a Fast Fourier Transform (FFT) to both images, multiply in the frequency domain, and then inverse transform.",Calculate the Hamming distance between the flattened image representations.,"Iterate through all possible horizontal and vertical shifts, counting overlapping 1s.",Medium,algorithms,"Array,Matrix"
866,"Rectangle Overlap
An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.",Ensure that `rec1[0] > rec2[2] or rec2[0] > rec1[2]`,"Calculate the areas of both rectangles. If the sum equals the area of their combined bounding box, return false.",Only check if the bottom-left corners are equal,Return `true` if any corner of `rec1` lies within `rec2` or vice versa,Ensure that `rec1[0] < rec2[2] and rec1[2] > rec2[0] and rec1[1] < rec2[3] and rec1[3] > rec2[1]`,Easy,algorithms,"Math,Geometry"
867,"New 21 Game
Alice plays the following game, loosely based on the card game ""21"". Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets k or more points. Return the probability that Alice has n or fewer points. Answers within 10-5 of the actual answer are considered accepted.",Use dynamic programming with a 2D array where dp[i][j] stores the probability of having j points after i draws.,Simulate the game a large number of times and calculate the empirical probability.,"Apply a greedy algorithm, always choosing the maximum possible points until exceeding n.",Use a Monte Carlo method with a small number of simulations for speed.,"Use dynamic programming with a 1D array to store the probabilities of reaching each point from 0 to n+maxPts, iteratively calculating probabilities from k-1 down to 0.",Medium,algorithms,"Math,Dynamic Programming,Sliding Window,Probability and Statistics"
868,"Push Dominoes
There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. You are given a string dominoes representing the initial state where: Return a string representing the final state.",Propagate forces simultaneously from left and right until no changes occur.,"Process each domino individually, checking its neighbors and updating based on local state in each iteration.",Maintain a count of forces acting on each domino and resolve the state at the end.,Simulate the process by tracking the exact time each domino falls using a priority queue.,"Use two pointers to track the net force on each domino over time, resolving conflicts based on proximity.",Medium,algorithms,"Two Pointers,String,Dynamic Programming"
869,"Similar String Groups
Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X. For example, ""tars"" and ""rats"" are similar (swapping at positions 0 and 2), and ""rats"" and ""arts"" are similar, but ""star"" is not similar to ""tars"", ""rats"", or ""arts"". Together, these form two connected groups by similarity: {""tars"", ""rats"", ""arts""} and {""star""}.  Notice that ""tars"" and ""arts"" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?",Use a greedy algorithm to iteratively merge the closest similar strings until no more merges are possible.,Compute the edit distance between each pair of strings and cluster those with a distance of at most 2.,Sort the strings lexicographically and count the number of unique strings after sorting.,Iterate through all possible subsets of strings and check if each subset forms a similar group.,Use the Union-Find algorithm to connect similar strings into groups and count the number of connected components.,Hard,algorithms,"Array,String,Depth-First Search,Breadth-First Search,Union Find"
870,"Magic Squares In Grid
A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given a row x col grid of integers, how many 3 x 3 magic square subgrids are there? Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.","Check all 3x3 subgrids, returning true if all numbers are unique and between 1 and 9 (inclusive), and sums of all rows, columns, and diagonals are equal.","Iterate through the grid and count the number of 3x3 subgrids where the sum of each row, column, and diagonal is 15, regardless of the numbers' uniqueness or range.","Calculate the sum of each possible 3x3 subgrid and return the count of those with the sum of each row, column and diagonal equalling any constant value.",Use dynamic programming to store partial sums and efficiently compute the sum of each 3x3 subgrid; only count the subgrids that meet the sum requirement without validating the number ranges or uniqueness.,"Iterate through the grid, and for each 3x3 subgrid, check that numbers are unique and between 1 and 9 (inclusive) and that sums of all rows, columns, and diagonals are equal, incrementing a counter if true.",Medium,algorithms,"Array,Math,Matrix"
871,"Keys and Rooms
There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.",Use Depth-First Search (DFS) and return true only if the maximum recursion depth is reached.,Sort the rooms array and check if the sorted array contains all numbers from 0 to n-1.,Use Breadth-First Search (BFS) and return true if the queue empties before visiting all rooms.,"Simulate the process without using any graph traversal algorithm; if a key is not found, immediately return false.","Use Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the rooms as a graph, marking visited rooms. Return true if all rooms are visited.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph"
872,"Split Array into Fibonacci Sequence
You are given a string of digits num, such as ""123456579"". We can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list f of non-negative integers such that: Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from num, or return [] if it cannot be done.",Dynamic programming with memoization to avoid redundant calculations,"Greedy approach, always selecting the smallest possible numbers for the sequence",Backtracking with pruning to explore all possible splits and validate Fibonacci property,"Divide and conquer, recursively splitting the input string into smaller subproblems",Depth-first search to explore possible Fibonacci-like sequences by choosing the first two numbers and checking the subsequent ones.,Medium,algorithms,"String,Backtracking"
873,"Guess the Word
You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word. You are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns: There is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word). For each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get: The test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).",Always guess the first word in the list.,Guess words randomly until the number of allowed guesses is exhausted.,Use minimax to minimize the worst-case number of remaining guesses.,Calculate the Hamming distance between each pair of words and always guess the pair with the smallest distance.,"Iteratively select a word, guess it, and filter the remaining words to only those with the same Hamming distance to the guess as the result.",Hard,algorithms,"Array,Math,String,Interactive,Game Theory"
874,"Backspace String Compare
Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty.","Process both strings from left to right, deleting characters directly without an auxiliary data structure.",Reverse both strings and then compare them directly character by character.,"Compare the lengths of the strings. If they are equal, they are equal after backspaces.","Recursively remove '#' characters until no '#' remains, then compare.",Use stacks to simulate the typing process and then compare the resulting strings.,Easy,algorithms,"Two Pointers,String,Stack,Simulation"
875,"Longest Mountain in Array
You may recall that an array arr is a mountain array if and only if: Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.",O(1),O(log n),O(n log n),O(n^2),O(n),Medium,algorithms,"Array,Two Pointers,Dynamic Programming,Enumeration"
876,"Hand of Straights
Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",Sort the `hand` array and use a sliding window of size `groupSize` to check for consecutive cards.,Use a hash map to count the frequency of each card and greedily form groups of size `groupSize` from the most frequent cards.,Recursively divide the `hand` array into smaller subarrays and check if each subarray can be rearranged.,"Iterate through the `hand` array and for each card, check if there are `groupSize - 1` consecutive cards following it. If not, return false.","Sort the `hand` array and use a hash map to track card counts. Iterate through the sorted array, decrementing counts of consecutive cards as you form groups. Return false if a card isn't available.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting"
877,"Shortest Path Visiting All Nodes
You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.",Use Dijkstra's algorithm to find the shortest path between each pair of nodes and then combine these paths.,"Apply a greedy approach, always choosing the unvisited node closest to the current node.",Perform a depth-first search (DFS) from each node and choose the shortest path that visits all nodes.,Employ a breadth-first search (BFS) from a random starting node and terminate once all nodes have been visited.,"Use a breadth-first search (BFS) with a bitmask to track visited nodes, enabling revisiting and starting at any node.",Hard,algorithms,"Dynamic Programming,Bit Manipulation,Breadth-First Search,Graph,Bitmask"
878,"Shifting Letters
You are given a string s of lowercase English letters and an integer array shifts of the same length. Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a'). Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times. Return the final string after all such shifts to s are applied.","Apply shifts sequentially, updating the string after each shift, resulting in O(n*m) time complexity where n is the string length and m is the sum of shifts.","Calculate the net shift for each character by summing shifts[i] values, modulo 26, and apply the shifts to the string in a single pass, resulting in O(n) time complexity.","Precompute prefix sums of the shifts array and apply these sums modulo 26 to corresponding characters in the string, also handling negative shift values.","Use dynamic programming to store intermediate shifted strings for each shift operation, improving performance for large input sizes.","Compute the cumulative shift from the end to the beginning of the shifts array, applying each cumulative shift modulo 26 to the corresponding character in the string.",Medium,algorithms,"Array,String"
879,"Maximize Distance to Closest Person
You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed). There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. Return that maximum distance to the closest person.","Find the largest gap between two people, and the gaps at the start and end, then return the average of the largest gap.",Count the number of consecutive zeros and return the maximum count.,Calculate the distance to the closest person for each empty seat and return the minimum distance.,Return the index of the empty seat closest to the middle of the array.,"Calculate the distances to the closest person on the left and right for each empty seat, and return the maximum of the minimums of these distances.",Medium,algorithms,Array
880,"Rectangle Area II
You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once. Return the total area. Since the answer may be too large, return it modulo 109 + 7.","Use a quadtree to recursively subdivide the space and calculate area, handling overlaps at each level.","Compute the area of each rectangle individually, then subtract the areas of all pairwise intersections, add the areas of all three-way intersections, and so on, using inclusion-exclusion principle.",Rasterize the entire space into a grid and count the number of occupied cells.,"Sort all x and y coordinates, then iterate through all possible rectangular regions formed by these coordinates, checking for overlap.","Use a line sweep algorithm along the x-axis, maintaining an active set of intervals for each y-coordinate and calculating the covered area.",Hard,algorithms,"Array,Segment Tree,Line Sweep,Ordered Set"
881,"Loud and Rich
There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time). Return an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",Perform a topological sort on the 'richer' array and then iterate through the sorted array to find the least quiet person.,Create an adjacency matrix representing the 'richer' relationship and use Dijkstra's algorithm to find the shortest path to the least quiet person.,Sort the 'quiet' array and use binary search to find the corresponding richest person for each quietness level.,"For each person, perform a breadth-first search on the 'richer' relationships to find all richer people and then find the least quiet among them.",Use Depth-First Search (DFS) with memoization to efficiently find the least quiet person richer than or equal to each person.,Medium,algorithms,"Array,Depth-First Search,Graph,Topological Sort"
882,"Peak Index in a Mountain Array
You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease. Return the index of the peak element. Your task is to solve it in O(log(n)) time complexity.",Linear search through the array to find the element greater than its neighbors.,Recursively divide the array and compare middle elements until the peak is found.,Sort the array and return the index of the largest element.,Return the index of the last element in the array.,"Apply binary search: if arr[mid] < arr[mid+1], search right; else, search left.",Medium,algorithms,"Array,Binary Search"
883,"Car Fleet
There are n cars at given miles away from the starting mile 0, traveling to reach the mile target. You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour. A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car. A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet. If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet. Return the number of car fleets that will arrive at the destination.","Sort the cars by their initial positions and iterate, merging cars into fleets based on arrival time at the target",Use a priority queue to track the arrival times of each car and increment the fleet count when a car's arrival time is less than or equal to the previous car's arrival time,"Divide the cars into fleets based on their initial speeds, assuming cars with similar speeds will form a fleet",Calculate the time each car takes to reach the target and group cars with close arrival times into fleets,"Calculate the time each car takes to reach the target, sort by position, and increment the fleet count only when a car takes longer than the previous car",Medium,algorithms,"Array,Stack,Sorting,Monotonic Stack"
884,"K-Similar Strings
Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2. Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.",Use a greedy approach by swapping mismatched characters from left to right.,Apply dynamic programming with memoization based on substring pairs.,"Use recursion, exploring all possible swap combinations.",Sort both strings and compare the difference in ASCII values.,"Employ Breadth-First Search (BFS) to explore possible swap sequences, tracking visited states.",Hard,algorithms,"String,Breadth-First Search"
885,"Exam Room
There is an exam room with n seats in a single row labeled from 0 to n - 1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0. Design a class that simulates the mentioned exam room. Implement the ExamRoom class:",A bit array representing seat occupancy,A simple integer array representing seat assignments,A hash map to store seat numbers and student IDs,A stack to keep track of available seats,A priority queue (or TreeSet) to maintain intervals of empty seats and their lengths,Medium,data structures,"Design,Ordered Set"
886,"Score of Parentheses
Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule:",Recursively compute the score by dividing the string into smaller balanced substrings and summing their scores.,"Iterate through the string, incrementing the score for each '(' and decrementing for each ')'.",Use a stack to keep track of the parenthesis nesting level and compute the score based on powers of 2.,"Replace all '()' with '1', then sum all the numbers.  If the current char is '(', multiply the sum by 2. Otherwise, do nothing.","Maintain a stack to track the scores of balanced substrings, updating the score based on the current character and the stack's top element.",Medium,algorithms,"String,Stack"
887,"Minimum Cost to Hire K Workers
There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker. We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules: Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.","Sort workers by quality, then iterate through all combinations of k workers to find the minimum cost.","Sort workers by wage, then iterate through all combinations of k workers to find the minimum cost.",Calculate the average wage for each worker and select the k workers with the lowest average wage.,"Select the k workers with the lowest quality scores, and pay them their minimum wage expectation.","Sort workers by wage/quality ratio. Iterate through sorted workers, maintaining a max-heap of quality scores of the first k workers encountered so far. Calculate cost based on current worker's ratio and total quality in the heap.",Hard,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
888,"Mirror Reflection
There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Given the two integers p and q, return the number of the receptor that the ray meets first. The test cases are guaranteed so that the ray will meet a receptor eventually.",Use trigonometry to calculate the angle of incidence and reflection and simulate the ray's path until it hits a receptor.,Employ dynamic programming to store previously visited points and prevent infinite loops.,"Simulate the ray's path with integer arithmetic, incrementing x by p and y by q until a receptor is hit.",Apply binary search on the possible receptor distances to find the closest match.,"Compute the least common multiple (LCM) of p and q, then determine the receptor based on (LCM/q) % 2 and (LCM/p) % 2.",Medium,algorithms,"Math,Geometry"
889,"Buddy Strings
Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].",The strings must be identical for a swap to result in equality.,"If the strings are of different lengths, return true if at least one common character exists.","If the strings are equal and no character appears more than once, return true.",The strings must differ by exactly one character.,The strings must be of equal length and either differ by one swap or be identical with at least one repeating character.,Easy,algorithms,"Hash Table,String"
890,"Lemonade Change
At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.","Use a greedy approach, prioritizing giving $10 bills as change before $5 bills.","If a customer pays with a $20, always give one $10 and one $5 bill as change if possible.",Simulate the transactions using a depth-first search (DFS) algorithm to explore all possible change combinations.,"If you run out of $5 bills, check if you can form $5 using $10 bills and $20 bills.","Maintain counters for $5 and $10 bills, and greedily provide change, returning false if change cannot be provided.",Easy,algorithms,"Array,Greedy"
891,"Score After Flipping Matrix
You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves).","Always flip rows with a leading 0, and then flip columns with more 0s than 1s",Greedily flip the row or column that increases the score the most at each step,"Flip all rows, then flip all columns",Flip rows and columns randomly until the score converges,"Flip each row so the first element is 1, then flip each column if its number of 0s in the rows seen so far is greater than the number of 1s.",Medium,algorithms,"Array,Greedy,Bit Manipulation,Matrix"
892,"Shortest Subarray with Sum at Least K
Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1. A subarray is a contiguous part of an array.","Greedily expand the subarray until the sum is at least K, then shrink from the beginning.","Sort the input array first, then find the shortest subarray with sum at least K.",Use dynamic programming to store the minimum length subarray ending at each index.,Binary search for the minimum length and check if a subarray of that length exists with sum at least K.,Use a monotonic queue to maintain a sliding window of prefix sums.,Hard,algorithms,"Array,Binary Search,Queue,Sliding Window,Heap (Priority Queue),Prefix Sum,Monotonic Queue"
893,"All Nodes Distance K in Binary Tree
Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node. You can return the answer in any order.","Perform a breadth-first search (BFS) from the root, tracking distances and filtering nodes at distance K.","Perform a depth-first search (DFS) from the root, recording paths and selecting nodes K steps from the target along each path.","Compute the distances between all pairs of nodes in the tree, then select nodes at distance K from the target.","Use a modified DFS that prioritizes exploring the subtree containing the target node, stopping after finding all nodes at distance K.","Convert the tree to a graph, then perform a BFS from the target node to find all nodes at distance K.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
895,"Shortest Path to Get All Keys
You are given an m x n grid grid where: You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall. If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key. For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys. If it is impossible, return -1.",Depth-first search (DFS),Greedy algorithm,Dynamic programming,A* search algorithm with a heuristic prioritizing collecting keys,"Breadth-first search (BFS) using a queue to explore possible states, where each state includes position and keys collected",Hard,algorithms,"Bit Manipulation,Breadth-First Search"
896,"Smallest Subtree with all the Deepest Nodes
Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree. A node is called the deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.",The lowest common ancestor of all nodes.,The subtree rooted at the node with the smallest value among the deepest nodes.,The smallest subtree containing all nodes with depth greater than half the maximum depth.,The subtree rooted at the first deepest node encountered in a pre-order traversal.,The lowest common ancestor of all the deepest nodes.,Medium,data structures,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
897,"Prime Palindrome
Given an integer n, return the smallest prime palindrome greater than or equal to n. An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number. An integer is a palindrome if it reads the same from left to right as it does from right to left. The test cases are generated so that the answer always exists and is in the range [2, 2 * 108].",Check primality by dividing n by all numbers up to n,Generate all palindromes and check each for primality starting from n,"Start with n, increment by 1, and check if the new number is a prime number",Use a sieve of Eratosthenes to precompute primes up to 2 * 10^8 and then search for palindromes,"Generate palindromes greater than or equal to n, then test each for primality",Medium,algorithms,Math
898,"Transpose Matrix
Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",Memory bandwidth will be significantly lower,"No performance impact, just increased power consumption",Write latency will always be higher than read latency,CPU cache hit rate will be unaffected,Read latency will be significantly higher than write latency,Easy,system design,"Array,Matrix,Simulation"
899,"Binary Gap
Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0. Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in ""1001"" have a distance of 3.",Divide the number by 2 until it becomes 0 and count the maximum consecutive 0s encountered.,"Convert the integer to a string, split it into substrings at each '1', and find the longest substring.",Use bitwise AND with decrementing numbers to find adjacent 1's and calculate their distance.,Iterate through all possible pairs of bits and calculate the distance between any two '1's.,"Convert the integer to its binary representation, then iterate through the bits, tracking the last seen '1' and calculating the distance to the current '1'.",Easy,algorithms,"Math,Bit Manipulation"
900,"Reordered Power of 2
You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this so that the resulting number is a power of two.",Check if the number of digits in n is equal to the number of digits in any power of 2.,Sort the digits of n and compare it to the sorted digits of the powers of 2 less than n.,Generate all permutations of the digits of n and check if any of them are powers of 2.,Count the frequency of each digit in n and compare it to the frequency of digits in powers of 2 within a reasonable range.,Count the frequency of each digit in n and check if it matches the frequency of digits in any power of 2.,Medium,algorithms,"Math,Sorting,Counting,Enumeration"
901,"Advantage Shuffle
You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] > nums2[i]. Return any permutation of nums1 that maximizes its advantage with respect to nums2.","Sort `nums1` in ascending order and `nums2` in descending order, then greedily assign elements from `nums1` to `nums2` based on index.","For each element in `nums2`, find the smallest element in `nums1` that is greater than it, and if no such element exists, assign the smallest element from `nums1`.","Calculate all possible permutations of `nums1`, compute the advantage for each, and return the permutation with the maximum advantage (brute force).",Sort both `nums1` and `nums2` in ascending order and compare elements sequentially; swap elements in `nums1` if needed.,"Sort `nums1` in ascending order. Iterate through `nums2` with its original indices. For each element in `nums2`, find the smallest element in `nums1` greater than it, assigning it and marking it as used. If no such element exists, assign the smallest remaining element from `nums1`.",Medium,algorithms,"Array,Greedy,Sorting"
902,"Minimum Number of Refueling Stops
A car travels from a starting position to a destination which is target miles east of the starting position. There are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. Return the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.",Use dynamic programming to calculate the maximum reachable distance after visiting each station.,Sort the stations by fuel quantity and greedily choose the stations with the most fuel.,"Simulate the car's journey, always refueling at the nearest station until the target is reached.",Calculate the total fuel available and divide by the distance to the target.,Use a max heap to keep track of the fuel available at visited stations and greedily refuel when necessary.,Hard,algorithms,"Array,Dynamic Programming,Greedy,Heap (Priority Queue)"
904,"Leaf-Similar Trees
Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.  For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.",Compare the sums of node values at each level of both trees using a level-order traversal.,Check if the number of nodes at each level of both trees is equal.,Compare the inorder traversals of both trees.,Check if the pre-order traversals of both trees are identical.,"Perform a depth-first search on both trees to obtain the leaf-value sequences, and then compare the sequences.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
905,"Length of Longest Fibonacci Subsequence
A sequence x1, x2, ..., xn is Fibonacci-like if: Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0. A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",Brute-force: Generate all subsequences and check if they are Fibonacci-like.,Greedy: Always pick the two smallest numbers and extend the sequence if possible.,Dynamic Programming: Build a table `dp[i][j]` storing the length of the longest Fibonacci-like subsequence ending with `arr[i]` and `arr[j]` using only numbers before index j.,Recursion: Define a recursive function to find the longest Fibonacci-like subsequence starting from each index.,Hash Map + Dynamic Programming: Use a hash map to quickly check if a number exists in `arr` and DP to store lengths of subsequences.,Medium,algorithms,"Array,Hash Table,Dynamic Programming"
906,"Walking Robot Simulation
A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot receives an array of integers commands, which represents a sequence of moves that it needs to execute. There are only three possible types of instructions the robot can receive: Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, it will stay in its current location (on the block adjacent to the obstacle) and move onto the next command. Return the maximum squared Euclidean distance that the robot reaches at any point in its path (i.e. if the distance is 5, return 25). Note:","Use a breadth-first search to explore all possible paths, pruning paths that hit obstacles","Simulate the robot's movements, tracking the maximum distance using floating-point arithmetic to maintain precision",Precompute all possible robot positions and store them in a hash table for fast lookup,Sort the obstacle coordinates and use binary search to quickly check for collisions during movement,"Simulate the robot's movements, maintaining the current direction and updating position while checking for obstacle collisions using a set for efficient lookup, and track the max squared Euclidean distance",Medium,algorithms,"Array,Simulation"
907,"Koko Eating Bananas
Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.","Always choose the largest pile and eat from it, decreasing k if time permits.",Start with k as the average number of bananas per pile and adjust based on the time constraint.,"Use a greedy approach, prioritizing the smallest piles first to minimize wasted time.","Set k to the total number of bananas divided by h, rounding up to the nearest integer.",Apply binary search on the possible range of k to find the minimum k that satisfies the time constraint.,Medium,algorithms,"Array,Binary Search"
908,"Middle of the Linked List
Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",Use a single pointer and increment it until the end of the list.,Use recursion to find the middle element.,"Calculate the length of the list, then create an array of that size, fill it with nodes from the linked list, and return the element in the middle.",Convert the linked list into a doubly linked list and then traverse from both ends until you meet in the middle.,"Use two pointers, one moving one step at a time, and the other moving two steps at a time. When the faster pointer reaches the end, the slower pointer will be at the middle.",Easy,data structures,"Linked List,Two Pointers"
909,"Stone Game
Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties. Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.","Always false, since Bob can mirror Alice's moves and force a loss.",Only true if the first and last piles sum to more than half the total stones.,False if the sum of the piles at even indices is less than the sum of the piles at odd indices.,"Always false, the constraints always lead to Bob winning.","Always true, since Alice can always choose the larger of the first or last pile each turn.",Medium,algorithms,"Array,Math,Dynamic Programming,Game Theory"
910,"Nth Magical Number
A positive integer is magical if it is divisible by either a or b. Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7.","Iterate through all numbers from 1 to n * max(a, b) and check divisibility by a or b.",Use dynamic programming to store previously calculated magical numbers and extend the sequence.,Apply the Sieve of Eratosthenes to pre-calculate all magical numbers up to a certain limit.,Recursively divide the search range until the nth magical number is found using a brute-force approach.,Use binary search to find the nth magical number based on the inclusion-exclusion principle.,Hard,algorithms,"Math,Binary Search"
911,"Profitable Schemes
There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n. Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7.",Greedily select crimes with the highest profit-to-member ratio until minProfit is reached and n is exceeded.,"Sort the crimes by profit and iteratively select crimes until minProfit is reached, backtracking if n is exceeded.","Use a recursive approach to explore all possible subsets of crimes, pruning branches that exceed n members or fall short of minProfit.","Employ a brute-force method to generate all possible crime subsets and count the profitable ones, without optimization.","Apply dynamic programming with states (crime index, members used, profit achieved) to count the number of profitable schemes.",Hard,algorithms,"Array,Dynamic Programming"
916,"Decoded String at Index
You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken: Given an integer k, return the kth letter (1-indexed) in the decoded string.",Construct the fully decoded string and then return the character at index k.,Use binary search on the length of the decoded string segments to find the relevant segment and then recursively decode that segment.,Calculate the length of the decoded string and use the modulo operator to map k to an equivalent index within a smaller string segment.,Keep track of the repetition counts using a hash map and look up the kth character from the hash map.,"Iterate backwards through the encoded string, using the modulo operator to reduce k and effectively reverse the encoding process.",Medium,algorithms,"String,Stack"
917,"Boats to Save People
You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.","Sort the people array and use two pointers, one from the beginning and one from the end, pairing the lightest and heaviest people.","Iterate through the people array and for each person, find the heaviest person that can fit in the same boat, then remove both.",Use dynamic programming to find the optimal pairing of people to minimize the number of boats.,"Sort the people array and greedily assign each person to a boat, prioritizing filling boats to their maximum capacity with one person.","Sort the people array. Use two pointers, one at the beginning and one at the end. If people[left] + people[right] <= limit, increment left and decrement right. Otherwise, decrement right.",Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
918,"Reachable Nodes In Subdivided Graph
You are given an undirected graph (the ""original graph"") with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge. To subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi]. In this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less. Given the original graph and maxMoves, return the number of nodes that are reachable from node 0 in the new graph.","Use Depth-First Search (DFS) without considering the edge subdivisions, potentially overcounting reachable nodes.","Ignore the maxMoves constraint and count all nodes, regardless of their distance from node 0.","Apply Dijkstra's algorithm directly on the original graph without simulating the subdivisions, leading to incorrect distances.","Use Breadth-First Search (BFS) but fail to account for the cost of traversing subdivided edges, resulting in inaccurate reachability assessment.",Build the subdivided graph explicitly and then use Dijkstra's algorithm or BFS to find reachable nodes within maxMoves.,Hard,algorithms,"Graph,Heap (Priority Queue),Shortest Path"
919,"Projection Area of 3D Shapes
You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j). We view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the ""shadow"" when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.","Sum all the elements in the grid and multiply by 3, since there are three projections.","Calculate the xy projection area by summing all grid elements. Then calculate the yz and zx projection areas by summing the maximum value in each row and column, respectively.  Return the product of these three values.","Find the minimum value in the grid, subtract it from each element, and then sum the modified grid elements to represent the projections.","Calculate the xy projection area by counting non-zero elements. Calculate the yz projection area by finding the maximum in each row, and zx by finding the maximum in each column. Return the maximum of these three areas.","Calculate the xy projection area by counting non-zero elements. Calculate the yz projection area by finding the maximum in each row, and zx by finding the maximum in each column. Return the sum of these three areas.",Easy,algorithms,"Array,Math,Geometry,Matrix"
920,"Uncommon Words from Two Sentences
A sentence is a string of single-space separated words where each word consists only of lowercase letters. A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.",Use nested loops to compare each word in s1 with every word in s2,Create sets of all words and return the intersection of the sets,Return the words that only appear in s1 or s2 without checking the count,Use a single dictionary to store counts of each word across s1 and s2 and return words with a count greater than one.,Use dictionaries to count word frequencies in each sentence and return words that appear exactly once in only one sentence.,Easy,algorithms,"Hash Table,String"
921,"Spiral Matrix III
You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column. You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid. Return an array of coordinates representing the positions of the grid in the order you visited them.","Incrementally increase the side length and use nested loops to traverse each side of the spiral, checking for valid coordinates within the bounds before adding them to the result.","Recursively call a function to generate coordinates layer by layer, adding coordinates to the result regardless of their validity, and filtering them at the end.","Maintain a boolean matrix representing visited cells, and perform a breadth-first search starting from (rStart, cStart), prioritizing clockwise movement.","Simulate the spiral walk using a while loop that continues until all cells have been visited, always staying within the grid boundaries by reflecting the direction when hitting a boundary.","Simulate the spiral walk, incrementing the side length and direction at each turn, adding valid coordinates to the result until all rows * cols cells are visited.",Medium,algorithms,"Array,Matrix,Simulation"
922,"Possible Bipartition
We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.","Use a greedy approach by assigning people to groups based on the first dislike encountered, without backtracking.",Model the problem as a maximum flow problem and check if the maximum flow is less than n.,Sort the dislikes array and use a disjoint set data structure to merge groups of people who dislike each other.,Represent the problem as a linear programming problem and use the simplex algorithm to find a solution.,Model the problem as a graph coloring problem and use depth-first search to color the graph with two colors.,Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
923,"Super Egg Drop
You are given k identical eggs and you have access to a building with n floors labeled from 1 to n. You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. Each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves. Return the minimum number of moves that you need to determine with certainty what the value of f is.",Binary search on the number of floors with k as the number of attempts in the worst case.,"Linearly search each floor until an egg breaks, repeating with fewer eggs if needed.",Start from the middle floor and linearly search upwards or downwards based on whether the egg breaks.,"Use dynamic programming with a bottom-up approach, minimizing the number of attempts for each floor and egg combination assuming the egg never breaks.",Use dynamic programming to build a table representing the maximum floors testable with a given number of eggs and moves.,Hard,algorithms,"Math,Binary Search,Dynamic Programming"
924,"Fair Candy Swap
Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.",Hash each element in `aliceSizes` and check if the corresponding swap element exists in `bobSizes` while iterating through `bobSizes`.,Sort both arrays and use two pointers to find the pair of boxes that satisfy the condition.,Calculate the difference in sums directly and apply binary search within `bobSizes` after sorting `aliceSizes`.,Calculate all possible sums from `aliceSizes` and `bobSizes` and check if a pair gives the same total amount.,"Calculate the difference in total candies, and then iterate through one array, checking if the corresponding value exists in a set derived from the other array.",Easy,algorithms,"Array,Hash Table,Binary Search,Sorting"
925,"Construct Binary Tree from Preorder and Postorder Traversal
Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree. If there exist multiple answers, you can return any of them.",The root is the last element of the postorder traversal,The left subtree can be determined by matching elements in preorder and postorder without considering duplicates,The length of the preorder and postorder traversals will always be different,The right subtree is determined using the root's index in the preorder traversal,"The first element of the preorder traversal is the root, and the left subtree's size can be determined from the postorder traversal to recursively construct the tree",Medium,data structures,"Array,Hash Table,Divide and Conquer,Tree,Binary Tree"
926,"Find and Replace Pattern
Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.",Use backtracking to explore all possible mappings and check if any lead to a match.,Compare the frequency of each character in the word and pattern.,Sort both the word and pattern alphabetically before comparison.,Check if the lengths of the word and pattern are equal and return true if they are.,"Create mappings from pattern characters to word characters and vice versa, ensuring consistency.",Medium,algorithms,"Array,Hash Table,String"
927,"Sum of Subsequence Widths
The width of a sequence is the difference between the maximum and minimum elements in the sequence. Given an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].",Calculate the width of each subsequence individually and sum them.,Sort the array and use combinations to count subsequences.,Use dynamic programming to store previously calculated subsequence widths.,Iterate through all possible bitmasks representing subsequences and calculate widths.,"Sort the array and for each element, calculate its contribution to the total width based on its position.",Hard,algorithms,"Array,Math,Sorting"
928,"Surface Area of 3D Shapes
You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j). After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes. Return the total surface area of the resulting shapes. Note: The bottom face of each shape counts toward its surface area.","Consider only the top faces of the towers, multiplying the number of towers by the area of one face.","Sum the values in the grid and multiply the result by 6, the number of faces on a cube.",Calculate the surface area of each tower individually as 6 times its height and sum the results.,Sum all values in the grid and use that as the surface area assuming adjacent faces are glued together.,"Iterate through each cell, calculate the surface area of each tower, subtract the overlapping faces between adjacent towers, and sum the results.",Easy,algorithms,"Array,Math,Geometry,Matrix"
929,"Groups of Special-Equivalent Strings
You are given an array of strings of the same length words. In one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i]. Two strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j]. A group of special-equivalent strings from words is a non-empty subset of words such that: Return the number of groups of special-equivalent strings from words.",Strings are special-equivalent if their sorted forms are equal.,Strings are special-equivalent if the number of vowels is equal.,Strings are special-equivalent if their lengths are equal.,Strings are special-equivalent if they are anagrams of each other.,Strings are special-equivalent if the sorted odd-indexed chars and sorted even-indexed chars are equal.,Medium,algorithms,"Array,Hash Table,String"
930,"All Possible Full Binary Trees
Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0. Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order. A full binary tree is a binary tree where each node has exactly 0 or 2 children.","Recursively construct trees by combining all pairs of valid left and right subtrees, ensuring the total node count remains odd and summing to n.",Build a single full binary tree of n nodes and generate all its permutations.,"Iteratively build trees by adding nodes level by level, ensuring each level is completely full.",Create a binary search tree with n nodes and transform it into a full binary tree.,"Recursively construct trees by combining all pairs of valid left and right subtrees, where the number of nodes in each subtree is odd and their sum, plus 1 (for the root), equals n.",Medium,data structures,"Dynamic Programming,Tree,Recursion,Memoization,Binary Tree"
931,"Maximum Frequency Stack
Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the FreqStack class:","Use a single stack to store elements and a hash map to track frequencies, popping from the stack directly without frequency checks.",Maintain a single stack and re-sort the entire stack after each push and pop operation to ensure the most frequent element is always at the top.,"Use a priority queue to store elements based on their frequency, updating the queue after each push and pop, but without considering the push order.",Implement the stack using a linked list and linearly search for the most frequent element during each pop operation.,"Use multiple stacks, each representing a frequency level, and a hash map to track element frequencies, popping from the stack with the highest frequency.",Hard,data structures,"Hash Table,Stack,Design,Ordered Set"
932,"Monotonic Array
An array is monotonic if it is either monotone increasing or monotone decreasing. An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j]. Given an integer array nums, return true if the given array is monotonic, or false otherwise.",O(n log n) due to the sorting algorithm,O(n^2) because of nested loops for comparison,O(1) as it performs a constant number of operations regardless of input size,O(n!) because every permutation needs to be checked,O(n) as it iterates through the array once to check the monotonic properties,Easy,algorithms,Array
933,"Increasing Order Search Tree
Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.","Perform an in-order traversal and store the nodes in a sorted array, then construct the new tree from the array.","Recursively process the left subtree, then the current node, then the right subtree, modifying pointers as you go.","Use a stack to store the nodes during in-order traversal, then pop them off the stack to build the new tree.","Convert the BST to a max heap, then repeatedly extract the maximum to build the increasing order tree.","Perform an in-order traversal while modifying the tree structure directly, setting the left child to null and right child to the next node in the traversal.",Easy,data structures,"Stack,Tree,Depth-First Search,Binary Search Tree,Binary Tree"
934,"Bitwise ORs of Subarrays
Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr. The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer. A subarray is a contiguous non-empty sequence of elements within an array.","The outer loop iterates backwards, and the inner loop iterates forwards, modifying the array in place",Using dynamic programming to store intermediate OR values for overlapping subarrays to improve efficiency,Employing a sliding window approach to maintain a fixed-size subarray while calculating bitwise ORs,Sorting the array first to reduce the number of potential distinct OR values,Iterating through all possible subarrays and using a set to track distinct bitwise OR values,Medium,algorithms,"Array,Dynamic Programming,Bit Manipulation"
935,"Orderly Queue
You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string. Return the lexicographically smallest string you could have after applying the mentioned step any number of moves.","If k=1, repeatedly move the first character to the end and choose the minimum.","Sort the string if k>1, otherwise repeatedly move the first character to the end and choose the minimum.",Generate all possible permutations of the string and return the lexicographically smallest one.,"Reverse the string if k>1, otherwise repeatedly move the first character to the end and choose the minimum.","If k>1, sort the string; otherwise, repeatedly move the first character to the end and choose the minimum.",Hard,algorithms,"Math,String,Sorting"
936,"RLE Iterator
We can use run-length encoding (i.e., RLE) to encode a sequence of integers. In a run-length encoded array of even length encoding (0-indexed), for all even i, encoding[i] tells us the number of times that the non-negative integer value encoding[i + 1] is repeated in the sequence. Given a run-length encoded array, design an iterator that iterates through it. Implement the RLEIterator class:","Return the next element in the encoding and decrement its count, or -1 if exhausted, but do not update the internal index.","Always return the first element of the encoding, regardless of the current index or count.","Return the current element if the count is greater than zero, otherwise return -1 without advancing to the next element.",Return the next element in the encoding and reset its count to zero.,"If the current count is greater than zero, decrement the count and return the current value. Otherwise, advance to the next pair and repeat. Return -1 if no elements remain.",Medium,algorithms,"Array,Design,Counting,Iterator"
937,"Online Stock Span
Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day. The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day. Implement the StockSpanner class:",Use a binary search tree to store past prices and efficiently find the span.,Store all prices in an array and iterate backwards for each new price to calculate the span.,Calculate a moving average of the stock price and use it to approximate the span.,Maintain a sorted list of prices and use binary search to find the start of the span.,"Use a stack to store (price, span) pairs, popping elements until a greater price is found.",Medium,algorithms,"Stack,Design,Monotonic Stack,Data Stream"
938,"Numbers At Most N Given Digit Set
Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'. Return the number of positive integers that can be generated that are less than or equal to a given integer n.",Dynamic programming with memoization based on prefix matching and digit count,Backtracking to generate all possible numbers and count those less than or equal to N,Greedily construct the largest possible number less than or equal to N using the given digits,Convert N to a string and use mathematical series to calculate the possible numbers,"Decompose N into digits, and iterate through the given digits array, calculating possibilities based on length and prefix comparison",Hard,algorithms,"Array,Math,Binary Search,Dynamic Programming"
939,"Valid Permutations for DI Sequence
You are given a string s of length n where s[i] is either: A permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i: Return the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",Use dynamic programming with a 2D array where dp[i][j] represents the number of permutations of length i ending with the j-th smallest element,"Employ a greedy algorithm, always choosing the smallest or largest available number based on the current 'I' or 'D' character",Recursively generate all possible permutations and filter out the ones that don't satisfy the 'DI' sequence condition,"Apply a backtracking algorithm, exploring each possible number assignment and pruning branches that violate the 'DI' condition","Apply dynamic programming with memoization, considering the ranges of available numbers based on 'I' and 'D' characters",Hard,algorithms,Dynamic Programming
940,"Fruit Into Baskets
You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: Given the integer array fruits, return the maximum number of fruits you can pick.","Use a greedy algorithm, always picking the fruit type that appears most frequently in the remaining trees.",Sort the fruits array and then pick the longest consecutive sequence of the same fruit type.,"Use dynamic programming to store the maximum fruits picked up to each tree, considering all possible combinations of two fruit types.","Pick fruits randomly until you have two types, then only pick those two types going forward.","Use a sliding window approach to maintain two fruit types and expand the window until a third fruit type is encountered, then shrink the window from the left until only two fruit types remain.",Medium,algorithms,"Array,Hash Table,Sliding Window"
941,"Sort Array By Parity
Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition.",Use a sorting algorithm with a custom comparator based on parity,"Create two new arrays, one for even numbers and one for odd numbers, then concatenate them",Iterate through the array and swap elements based on their parity using nested loops,Use a hash map to count the occurrences of even and odd numbers and then reconstruct the array,"Use two pointers, one at the beginning and one at the end, and swap elements until they meet",Easy,algorithms,"Array,Two Pointers,Sorting"
942,"Super Palindromes
Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome. Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].","Generate all palindromes, square them, and check if the result is a palindrome and within the range.",Iterate through the range and check if each number is both a palindrome and a perfect square.,"Generate all perfect squares, check if they are palindromes and if their square root is also a palindrome.",Precompute a fixed list of super-palindromes and check how many fall within the range.,"Generate palindrome square roots, square them, and check if the result is a palindrome and within the range.",Hard,algorithms,"Math,Enumeration"
943,"Sum of Subarray Minimums
Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.","Calculate the minimum of each subarray using brute force and sum them directly, without modulo operation","Use dynamic programming to store the minimums of subarrays starting at each index, but iterate inefficiently",Sort the array first and then calculate the subarray minimums based on the sorted array,Compute the product of the array elements instead of the sum of subarray minimums,"Use a stack-based approach to efficiently determine the contribution of each element as the minimum in various subarrays, applying the modulo operation",Medium,algorithms,"Array,Dynamic Programming,Stack,Monotonic Stack"
944,"Smallest Range I
You are given an integer array nums and an integer k. In one operation, you can choose any index i where 0 <= i < nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after applying the mentioned operation at most once for each index in it.",k * min(nums),k - max(nums),max(nums) - min(nums),max(nums) + min(nums) + k,"max(0, max(nums) - min(nums) - 2 * k)",Easy,algorithms,"Array,Math"
945,"Snakes and Ladders
You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row. You start on square 1 of the board. In each move, starting from square curr, do the following: A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 are not the starting points of any snake or ladder. Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder. Return the least number of dice rolls required to reach the square n2. If it is not possible to reach the square, return -1.",Depth-First Search (DFS),Greedy Search,Divide and Conquer,Dynamic Programming,Breadth-First Search (BFS),Medium,algorithms,"Array,Breadth-First Search,Matrix"
946,"Smallest Range II
You are given an integer array nums and an integer k. For each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after changing the values at each index.",Always choose to either add k or subtract k based on whether nums[i] is less than or greater than the average of the array.,Sort the array and then add k to the first half of the elements and subtract k from the second half.,Calculate all possible combinations of additions and subtractions of k for each element and then find the minimum range.,"Add k to all elements and subtract k from all elements, then find the difference between the maximum and minimum of each resulting array and take the minimum of these differences.","Sort the array, then for each element, consider either adding k to it or subtracting k from it and maintain the minimum and maximum seen so far.",Medium,algorithms,"Array,Math,Greedy,Sorting"
947,"Online Election
You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i]. For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. Implement the TopVotedCandidate class:","Binary search on the times array to find the latest time <= t, then linearly scan persons up to that index to find the leader.",Maintain a prefix sum array of votes for each person and perform a linear search for the leader at time t.,Use a hash map to store the vote count for each person at each time and then iterate through the map to find the leader.,Sort the votes based on time and then apply a sliding window approach to determine the leader at time t.,"Use binary search to find the latest time <= t, then use a precomputed array storing the leader at each time.",Medium,algorithms,"Array,Hash Table,Binary Search,Design"
948,"Sort an Array
Given an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",Insertion Sort,Bubble Sort,Selection Sort,Shell Sort,Merge Sort,Medium,algorithms,"Array,Divide and Conquer,Sorting,Heap (Priority Queue),Merge Sort,Bucket Sort,Radix Sort,Counting Sort"
949,"Cat and Mouse
A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0). Then, the game can end in three ways: Given a graph, and assuming both players play optimally, return",The mouse wins if it reaches the cat's starting position (node 2).,The cat wins if the graph is acyclic and the cat and mouse eventually occupy the same node.,The mouse wins if it can reach the hole (node 0) before the cat catches it.,The game is a draw if both cat and mouse alternate between their initial positions.,"Return 1 if the mouse can win, 2 if the cat can win, and 0 if it is a draw, assuming optimal play.",Hard,algorithms,"Math,Dynamic Programming,Breadth-First Search,Graph,Memoization,Game Theory"
950,"X of a Kind in a Deck of Cards
You are given an integer array deck where deck[i] represents the number written on the ith card. Partition the cards into one or more groups such that: Return true if such partition is possible, or false otherwise.",Brute force every possible combination of card groupings and check if each group has the same number,"Sort the deck and iterate, checking if adjacent cards are identical and calculating the greatest common divisor (GCD) of the group sizes",Calculate the frequency of each card number and check if the sum of all frequencies is divisible by the number of cards,"Return true if the minimum frequency of any card number is greater than 1, otherwise false","Calculate the frequency of each card number and find the greatest common divisor (GCD) of all frequencies. Return true if the GCD is greater than or equal to 2, otherwise false.",Easy,algorithms,"Array,Hash Table,Math,Counting,Number Theory"
951,"Partition Array into Disjoint Intervals
Given an integer array nums, partition it into two (contiguous) subarrays left and right so that: Return the length of left after such a partitioning. Test cases are generated such that partitioning exists.",Find the maximum element in the entire array.,Iterate through the array and keep track of the global maximum and minimum.,Sort the array and find the first index where the element is greater than the previous element.,Calculate prefix sums and suffix sums to find the split point.,"Iterate through the array, maintaining the maximum value seen so far in the left subarray and checking if it's less than or equal to the minimum value in the right subarray starting from the next index.",Medium,algorithms,Array
952,"Word Subsets
You are given two string arrays words1 and words2. A string b is a subset of string a if every letter in b occurs in a including multiplicity. A string a from words1 is universal if for every string b in words2, b is a subset of a. Return an array of all the universal strings in words1. You may return the answer in any order.",Use a sliding window approach on `words1` for each string in `words2` to check the subset condition.,Create a frequency map for each string in both arrays and directly compare the maps to find universal strings.,"Sort both `words1` and `words2` lexicographically, then iterate through `words1` checking the subset condition against the first element of `words2`.",Precompute all possible subsets of `words2` and check if each word in `words1` contains all of them.,"Compute the maximum frequency of each character required by any string in `words2`, then check if each string in `words1` satisfies these requirements.",Medium,algorithms,"Array,Hash Table,String"
953,"Reverse Only Letters
Given a string s, reverse the string according to the following rules: Return s after reversing it.",Allocate an auxiliary array and copy elements in reverse order using pointer arithmetic,Utilize recursion to swap characters from the outside in until the middle is reached,"Convert the string to an array of ASCII codes, reverse the array, and convert it back to a string","Split the string into words, reverse the order of the words, then rejoin them","Use two pointers, one at each end, and swap only letter characters, ignoring non-letters",Easy,algorithms,"Two Pointers,String"
954,"Maximum Sum Circular Subarray
Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.",Kadane's Algorithm directly provides the solution without modification.,Divide the array into two halves and apply Kadane's Algorithm independently on each half.,Find the minimum subarray sum and subtract it from the total sum of the array.,Sort the array and take the sum of the first half of the elements.,Apply Kadane's Algorithm to find the maximum subarray sum and also to find the minimum subarray sum. The maximum circular subarray sum will be the maximum of the two (total sum - minimum subarray sum) and the maximum subarray sum.,Medium,algorithms,"Array,Divide and Conquer,Dynamic Programming,Queue,Monotonic Queue"
955,"Complete Binary Tree Inserter
A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion. Implement the CBTInserter class:",Insert the node as the leftmost child of the root.,Recursively find the rightmost leaf node and insert the new node there.,Insert the node as the rightmost child of the root.,Perform a breadth-first search to find the first node with less than two children and insert the new node there.,"Maintain a queue of nodes that may have an open spot, and insert the new node as a child of the first available node in the queue.",Medium,data structures,"Tree,Breadth-First Search,Design,Binary Tree"
956,"Number of Music Playlists
Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that: Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.",Use inclusion-exclusion principle on the total possible playlists without the repetition constraint.,Recursively calculate the number of playlists by considering the last song added.,"Apply dynamic programming with memoization, tracking playlist length and distinct songs used.",Employ a greedy algorithm to choose the most popular songs first.,"Use dynamic programming to calculate playlists of different lengths, satisfying the repetition constraint.",Hard,algorithms,"Math,Dynamic Programming,Combinatorics"
957,"Minimum Add to Make Parentheses Valid
A parentheses string is valid if and only if: You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string. Return the minimum number of moves required to make s valid.",Use a stack to track open parentheses and increment a counter for each unmatched close parenthesis.,Recursively check sub-strings for validity and sum the number of insertions needed for each sub-string.,Count the total number of open and close parentheses and take the absolute difference.,Replace all valid parenthesis pairs '()' with an empty string and count the remaining characters.,"Maintain a balance counter; increment for '(' and decrement for ')'. If the balance becomes negative, increment the moves and reset the balance to zero. Add the final balance to the moves.",Medium,algorithms,"String,Stack,Greedy"
958,"Sort Array By Parity II
Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition.","Use two separate arrays, one for even numbers and one for odd numbers, and then merge them.",Sort the array and then swap elements to satisfy the condition.,Iterate through the array and move elements to their correct positions using repeated swaps with adjacent elements.,"Create a frequency map to count even and odd numbers, then reconstruct the array.","Use two pointers, one for even indices and one for odd indices, and swap elements when they are in the wrong positions.",Easy,algorithms,"Array,Two Pointers,Sorting"
959,"3Sum With Multiplicity
Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7.","Use three nested loops to check all possible combinations, which has a time complexity of O(n^3)","Sort the array and use a two-pointer approach for each element to find pairs that sum up to target - arr[i], with a time complexity of O(n log n)","Use a hash map to store the frequency of each number and then iterate through all possible combinations of three numbers, calculating the result based on the frequencies",Recursively find two numbers that sum to target-arr[i] for each i in array,"Count the frequency of each number using a hash map and then iterate through all possible combinations of three distinct numbers, considering multiplicity using combinatorics and modular arithmetic",Medium,algorithms,"Array,Hash Table,Two Pointers,Sorting,Counting"
960,"Minimize Malware Spread
You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial. Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.",Select the node with the highest degree in the graph.,Randomly select a node from the initial list and remove it.,Remove the node that is connected to the fewest other initially infected nodes.,Remove the node with the largest index in the initial list.,"For each node in initial, remove it, calculate M(initial), and return the node that minimizes M(initial) with the smallest index.",Hard,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
961,"Long Pressed Name
Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.",The typed string must be a subsequence of the name string.,The counts of each character in both strings must be identical.,The typed string must be an anagram of the name string.,"The typed string must have a length greater than or equal to the name string, and the name string should be a substring of the typed string.","For each character, the count in the typed string must be greater than or equal to the count in the name string, maintaining order.",Easy,algorithms,"Two Pointers,String"
962,"Flip String to Monotone Increasing
A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing.",Greedily flip bits from right to left until a monotone increasing sequence is found.,Calculate all possible monotone increasing subsequences and choose the one requiring the fewest flips.,Dynamically track the minimum flips needed to end with a '0' or a '1' at each position.,Reverse the string and apply a standard longest increasing subsequence algorithm.,"Iterate through the string, tracking the cost of converting the prefix to all zeros or the suffix to all ones, and minimize the sum of these costs.",Medium,algorithms,"String,Dynamic Programming"
963,"Three Equal Parts
You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i + 1 < j, such that: If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.",Perform a brute-force search checking every possible split of the array,"Count the number of ones. If not divisible by three, return [-1, -1]. Otherwise, find indices such that each third has the same binary value disregarding leading zeros.",Calculate the decimal value of the entire array and divide by three to find the required binary value for each part,Use dynamic programming to store all possible sub-array values and check if any three are equal,"Count the ones. If not divisible by 3, return [-1, -1]. Otherwise, find the first and last indices of the first and second occurrence of 'ones / 3' ones after leading zeros.",Hard,algorithms,"Array,Math"
964,"Minimize Malware Spread II
You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial, completely removing it and any connections from this node to any other node. Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.",Return the node with the fewest connections in the graph.,Return the node with the highest index in the initial malware set.,Return a random node from the initial malware set.,"Return the node that, when removed, results in the largest connected component amongst the remaining infected nodes.","Return the node that, when removed, minimizes the number of infected nodes after malware propagation.",Hard,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
965,"Unique Email Addresses
Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'. If you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names. If you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names. It is possible to use both of these rules at the same time. Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.",The number of emails in the input array.,"The number of valid email addresses, regardless of duplicates.",The total length of all email addresses combined.,The number of distinct domain names in the input.,The number of distinct email addresses after applying the local name transformations.,Easy,algorithms,"Array,Hash Table,String"
966,"Binary Subarrays With Sum
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal. A subarray is a contiguous part of the array.","Use a sliding window, expanding when the sum is less than the goal and contracting when it's greater, but only counting windows of a fixed length.","Calculate the prefix sum for each index and then iterate through all possible subarrays, summing each one individually to check against the goal.","Sort the binary array first, then use a sliding window to find subarrays that sum to the goal, ignoring the impact of the sorting on subarray contiguity.","Apply dynamic programming, storing the counts of subarrays summing to values less than the goal, but failing to account for subarrays summing exactly to the goal.","Use a sliding window, expanding the right boundary and contracting the left boundary to maintain a sum close to the goal, efficiently counting valid subarrays.",Medium,algorithms,"Array,Hash Table,Sliding Window,Prefix Sum"
967,"Minimum Falling Path Sum
Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix. A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).",Recursively explore all possible paths and choose the path with the minimum sum,"Use a greedy approach, always selecting the smallest element in the next row without considering the overall path",Sort each row and then select the smallest element from each row to form a falling path,Calculate the sum of all possible falling paths and then determine the minimum using a brute-force method,"Use dynamic programming to store the minimum path sum to each cell, building up from the first row",Medium,algorithms,"Array,Dynamic Programming,Matrix"
968,"Beautiful Array
An array nums of length n is beautiful if: Given the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.",Use dynamic programming to build the array from smaller beautiful arrays.,Recursively divide the input n into smaller subproblems without memoization.,Randomly shuffle an array of integers from 1 to n until a beautiful array is found.,Sort the array in ascending order to make it beautiful.,"Construct the beautiful array using the divide and conquer strategy, ensuring odd numbers are on one side and even numbers on the other.",Medium,algorithms,"Array,Math,Divide and Conquer"
969,"Number of Recent Calls
You have a RecentCounter class which counts the number of recent requests within a certain time frame. Implement the RecentCounter class: It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.",Return the queue's size regardless of the ping value,Use a binary search to find the number of pings within the time frame,Maintain a sorted list of ping times and return its length,Only store the most recent ping time and return 1,"Use a queue to store ping times, removing those outside the time frame, and return the queue's size",Easy,data structures,"Design,Queue,Data Stream"
971,"Shortest Bridge
You are given an n x n binary matrix grid where 1 represents land and 0 represents water. An island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid. You may change 0's to 1's to connect the two islands to form one island. Return the smallest number of 0's you must flip to connect the two islands.","Use Depth-First Search (DFS) to find one island, then use DFS to expand from that island until the other is found.","Iterate through the entire grid, changing 0s to 1s at random until the islands connect.","Employ a greedy algorithm, prioritizing the smallest contiguous water regions to convert to land.",Apply Dijkstra's algorithm to find the shortest path between any two 1's in the grid.,"Use Breadth-First Search (BFS) to find one island, then expand that island's boundary using BFS until the other is found; the number of expansion steps is the answer.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
972,"Knight Dialer
The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagram: A chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell). Given an integer n, return how many distinct phone numbers of length n we can dial. You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps. As the answer may be very large, return the answer modulo 109 + 7.","Use dynamic programming with memoization to store the number of ways to reach each digit after k moves, but only consider moves within the 3x3 grid.","Calculate the total possible knight moves without considering the phone pad's constraints, then subtract invalid moves based on probabilities.","Employ a greedy approach, always selecting the digit with the most available knight moves for each position in the phone number.","Simulate all possible phone numbers of length n using recursion without memoization, and apply modulo only to the final result.","Apply dynamic programming with memoization to count the number of distinct phone numbers, considering valid knight moves within the phone pad and applying modulo at each step.",Medium,algorithms,Dynamic Programming
973,"Stamping The Sequence
You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'. In one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp. We want to convert s to target using at most 10 * target.length turns. Return an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array.","Employ a greedy approach, repeatedly stamping at the earliest possible position to match the target",Utilize dynamic programming to determine the optimal stamping sequence from right to left,"Apply a brute-force approach, trying all possible stamping positions until the target is matched or the limit is exceeded",Reverse the stamp and target strings and apply a standard string matching algorithm,"Iteratively find and stamp 'stamp' onto 's' to match 'target', starting from the end, and working backwards to minimize stamping turns",Hard,algorithms,"String,Stack,Greedy,Queue"
974,"Reorder Data in Log Files
You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier. There are two types of logs: Reorder these logs so that: Return the final order of the logs.",Use a hash table to count word occurrences and then reorder based on frequency.,"Sort the logs alphabetically ignoring the identifier, then sort digit-logs after.",Use regular expressions to classify logs and sort based on identifier length.,Split logs into groups based on the number of words and concatenate the groups.,"Separate logs into letter-logs and digit-logs, sort letter-logs lexicographically (excluding identifier), and then concatenate.",Medium,algorithms,"Array,String,Sorting"
975,"Range Sum of BST
Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].","Use a breadth-first search and sum all node values, then subtract values outside the range",Sort the BST using an in-order traversal and then sum elements between the low and high indices,"Perform a pre-order traversal and accumulate the sum of all nodes, ignoring the range",Convert the BST to a sorted array and sum elements in the given range,"Use an in-order traversal with pruning, summing only nodes within the range [low, high]",Easy,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
976,"Minimum Area Rectangle
You are given an array of points in the X-Y plane points where points[i] = [xi, yi]. Return the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.","Use a brute-force approach, checking all possible combinations of four points to form a rectangle.",Sort the points based on their x-coordinates and then iterate through the sorted list to find potential rectangles.,"Use a divide-and-conquer strategy, recursively splitting the points and finding the minimum area in each subproblem.",Apply dynamic programming to store intermediate results and avoid redundant calculations.,"Use sets to efficiently check for the existence of points needed to complete a rectangle, given two points.",Medium,algorithms,"Array,Hash Table,Math,Geometry,Sorting"
977,"Distinct Subsequences II
Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.","Employ a greedy algorithm, always choosing the smallest available element at each step.","Apply Dijkstra's algorithm to find the shortest paths, effectively minimizing subsequences.",Utilize a sliding window approach to identify repeating patterns and reduce redundant counting.,Recursively generate all possible subsequences and then remove duplicates using a set.,Use dynamic programming to track the number of subsequences ending with each character.,Hard,algorithms,"String,Dynamic Programming"
978,"Valid Mountain Array
Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if:",The array is strictly increasing or strictly decreasing,The array has a single peak where the elements on either side are equal,The array contains at least three elements and is sorted in ascending order,"The array is non-decreasing and then non-increasing, allowing plateaus","The array has at least three elements, a single peak, strictly increasing before the peak, and strictly decreasing after the peak",Easy,algorithms,Array
979,"DI String Match
A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where: Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.",Always initialize the result array with `[0] * (n + 1)` and then fill it based on 'I' and 'D',Prioritize processing 'D' characters first to ensure larger numbers are placed correctly,"Use two separate pointers, one for 'I' and one for 'D', and increment/decrement them independently",Initialize the permutation with numbers in descending order and then adjust based on 'I' characters,"Maintain a low and high pointer, incrementing low for 'I' and decrementing high for 'D', adding the respective value to the result",Easy,algorithms,"Array,Math,Two Pointers,String,Greedy"
980,"Find the Shortest Superstring
Given an array of strings words, return the smallest string that contains each string in words as a substring. If there are multiple valid strings of the smallest length, return any of them. You may assume that no string in words is a substring of another string in words.","Use a greedy approach, always merging the strings with the maximum overlap length first without considering cycles.",Generate all possible permutations of the input strings and check each permutation for the shortest superstring.,"Employ a randomized algorithm to find approximate solutions, optimizing for speed over absolute correctness.",Sort the strings by length and then concatenate them in that order.,Model the problem as a Traveling Salesperson Problem (TSP) where edges represent overlap lengths and use dynamic programming.,Hard,algorithms,"Array,String,Dynamic Programming,Bit Manipulation,Bitmask"
981,"Delete Columns to Make Sorted
You are given an array of n strings strs, all of the same length. The strings can be arranged such that there is one on each line, making a grid. You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1. Return the number of columns that you will delete.","Check if any adjacent characters in a column are equal; if so, increment the deletion count.",Maintain a separate array to store the sorted status of each column and update it iteratively.,Sort each column independently and compare it with the original column to detect unsorted columns.,Delete any column where the first character is lexicographically greater than the last character in that column.,"Iterate through each column and check if it is lexicographically sorted; if not, increment a counter for the number of columns to delete.",Easy,algorithms,"Array,String"
982,"Minimum Increment to Make Array Unique
You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1. Return the minimum number of moves to make every value in nums unique. The test cases are generated so that the answer fits in a 32-bit integer.","Sort the array and greedily increment elements until unique, tracking the increments.",Use a hash map to count frequencies and increment elements until no duplicates exist.,Calculate the sum of differences between sorted and unsorted array elements.,"Iterate through the array, keeping track of the maximum seen so far, and incrementing duplicates to max + 1.","Sort the array and iterate, incrementing the current element to be at least one greater than the previous element if needed, accumulating the increments.",Medium,algorithms,"Array,Greedy,Sorting,Counting"
983,"Validate Stack Sequences
Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.","Using a temporary array, simulate the push and pop operations and check if the popped sequence matches",Sort both the pushed and popped arrays and compare them for equality,Check if all elements in 'popped' are present in 'pushed' using set operations,Recursively compare the last elements of 'pushed' and 'popped',"Simulate the push and pop operations using a stack, returning true if the popped sequence is correctly generated",Medium,algorithms,"Array,Stack,Simulation"
984,"Most Stones Removed with Same Row or Column
On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.","Use Depth-First Search (DFS) on the stone coordinates, incrementing a counter for each stone visited.",Employ a greedy algorithm by always removing stones with the fewest neighbors.,Sort the stones based on their x-coordinates and then remove them sequentially.,Calculate the Euclidean distance between all stone pairs and remove those closest together.,Model the stones as nodes in a graph where stones in the same row or column are connected. The answer is n - number of connected components.,Medium,algorithms,"Depth-First Search,Union Find,Graph"
985,"Bag of Tokens
You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] denotes the value of tokeni. Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token): Return the maximum possible score you can achieve after playing any number of tokens.","Always play the largest token if your power is sufficient, otherwise play the smallest token to gain power.",Sort the tokens array in descending order and play them in that order as long as power permits.,Use dynamic programming to compute the maximum score for every possible subset of tokens.,"Randomly choose a token to play, repeating until all tokens are played or no moves are possible.","Sort the tokens array and use a two-pointer approach to maximize score, playing the smallest when possible and largest to gain power when needed.",Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
986,"Largest Time for Given Digits
Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once. 24-hour times are formatted as ""HH:MM"", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59. Return the latest 24-hour time in ""HH:MM"" format. If no valid time can be made, return an empty string.","Generate all 4! permutations and check each for validity, returning the largest valid time found.","Sort the array in descending order and construct the time from the largest digits first, backtracking if necessary.","Greedily choose the largest possible digit for each position (tens of hours, ones of hours, tens of minutes, ones of minutes) without backtracking.",Use dynamic programming to store valid intermediate time components and build up to the largest valid time.,"Use backtracking to explore all possible permutations of the digits, pruning invalid time combinations early to reduce search space.",Medium,algorithms,"String,Enumeration"
987,"Reveal Cards In Increasing Order
You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i]. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Return an ordering of the deck that would reveal the cards in increasing order. Note that the first entry in the answer is considered to be the top of the deck.",Sort the deck and then reverse it,Randomly shuffle the deck until the condition is met,"Create a min-heap from the deck and repeatedly extract the minimum, placing it in the revealed deck's next available position, skipping positions strategically.",Sort the deck and return it as is.,Simulate the card revealing process using a queue or list to track card positions and iteratively placing the next card in the correct revealed index.,Medium,algorithms,"Array,Queue,Sorting,Simulation"
988,"Flip Equivalent Binary Trees
For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.",Always choose the subtree with the smaller root value to be the left subtree.,"Perform a depth-first search on both trees simultaneously, and only flip nodes where root1.val > root2.val.",Convert both trees into arrays representing their pre-order traversals and check if the arrays are identical after sorting.,The trees are flip equivalent if and only if they have the same number of nodes.,"Recursively check if the trees are identical or if their left and right subtrees are flipped and identical, handling null cases correctly.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
989,"Largest Component Size by Common Factor
You are given an integer array of unique positive integers nums. Consider the following graph: Return the size of the largest connected component in the graph.","Use Depth-First Search (DFS) on the graph, tracking visited nodes with a set, and return the size of the largest connected component found.","Sort the array, then iterate through it. If any adjacent numbers share a common factor larger than 1, merge their connected components using a disjoint set data structure.",Create a graph where an edge exists between two numbers if they share a common factor. Find the greatest common divisor (GCD) between each pair of numbers and use it as the weight of the edges.,"Create a boolean array to store prime numbers upto the largest number in the input, then perform connected components search.","Use a disjoint set data structure to union numbers sharing a common factor greater than 1, then return the size of the largest connected component.",Hard,algorithms,"Array,Math,Union Find"
990,"Verifying an Alien Dictionary
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.","Use a topological sort to find cycles within the alien alphabet and return false if a cycle exists, otherwise, compare the words based on the alphabet order.",Compare each adjacent pair of words using the provided alien alphabet order. Return true only if every pair is in the correct order.,Sort the input 'words' array lexicographically using standard English ordering and compare the sorted array to the original. Return true if they match.,Create a hashmap mapping each character to its index in the alien alphabet. Sort the 'words' array based on this mapping and return true if the sorted array equals the input array.,Build a graph representing the order of characters based on the 'words' array. Perform a lexicographical comparison using the derived order.,Easy,algorithms,"Array,Hash Table,String"
991,"Array of Doubled Pairs
Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2, or false otherwise.",Sort the array and greedily match elements with their doubles; return false if a match isn't found,"Use a hash map to store the frequency of each number and iterate through the sorted keys, checking if double exists with enough frequency",Iterate through the array and swap elements such that arr[2*i+1] is always equal to 2 * arr[2*i]; return false if unable to achieve this arrangement,Recursively divide the array into halves and check if each half satisfies the condition; merge results,"Count element frequencies, then iterate through sorted unique elements, ensuring that for each element 'x', '2x' exists with at least the same frequency",Medium,algorithms,"Array,Hash Table,Greedy,Sorting"
992,"Delete Columns to Make Sorted II
You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [""abcdef"",""uvwxyz""] and deletion indices {0, 2, 3}, then the final array after deletions is [""bef"", ""vyz""]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the minimum possible value of answer.length.",Count columns where all characters are the same.,Count columns where at least one string is lexicographically smaller than the previous.,Count columns where all strings are in strictly increasing lexicographical order.,Count columns where any two adjacent strings are not in lexicographical order after removing that column.,"Iterate through columns, keeping track of 'sorted' string pairs. If a column makes a pair unsorted, increment count; otherwise update 'sorted' pairs.",Medium,algorithms,"Array,String,Greedy"
993,"Tallest Billboard
You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.",Use dynamic programming to calculate all possible subset sums and then find the maximum common sum.,"Apply a greedy approach, always choosing the largest rods to build the supports until the sums are equal.","Sort the rods and use a recursive function to explore all possible combinations, pruning branches that exceed the total sum.",Calculate the total sum of all rods and divide by two; this is the maximum possible height.,Employ dynamic programming with a state representing the difference between the two supports' heights.,Hard,algorithms,"Array,Dynamic Programming"
994,"Prison Cells After N Days
There are 8 prison cells in a row and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors. You are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n. Return the state of the prison after n days (i.e., n such changes described above).","Simulate the entire N days directly, updating the cells array in each iteration.",Simulate the first few days and assume the pattern continues indefinitely.,"Simulate N days, caching states to detect cycles and skip redundant computations, but only cache states encountered early in the simulation.",Calculate the final state by averaging the initial and intermediate states.,Simulate the first few days and use cycle detection to reduce N to its equivalent value within the cycle before final simulation.,Medium,algorithms,"Array,Hash Table,Math,Bit Manipulation"
998,"Check Completeness of a Binary Tree
Given the root of a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.",Use depth-first search (DFS) to check if all nodes have two children.,Employ a recursive approach to verify that the number of nodes at each level is a power of 2.,Utilize a priority queue to keep track of node values and ensure they are monotonically increasing.,Perform an in-order traversal and check if the node values are sequentially ordered.,Use breadth-first search (BFS) and check for null nodes after encountering a non-null node.,Medium,data structures,"Tree,Breadth-First Search,Binary Tree"
999,"Regions Cut By Slashes
An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\', or blank space ' '. These characters divide the square into contiguous regions. Given the grid grid represented as a string array, return the number of regions. Note that backslash characters are escaped, so a '\' is represented as '\\'.",Use Depth-First Search (DFS) treating each cell as a node and slashes as edges to find connected components,"Apply the Union-Find algorithm directly to the grid cells, merging cells separated only by blank spaces",Calculate the total number of slashes and backslashes and subtract this from the total number of cells,Divide each cell into four triangles and use BFS to identify connected regions based on slash direction,Divide each cell into four triangles and use Union-Find to merge adjacent triangles based on slash direction,Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
1000,"Delete Columns to Make Sorted III
You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [""abcdef"",""uvwxyz""] and deletion indices {0, 2, 3}, then the final array after deletions is [""bef"", ""vyz""]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]), and (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length.","Greedily select columns to keep, prioritizing those that maximize the number of lexicographically sorted rows after deletion.","Use dynamic programming where dp[i] represents the length of the longest non-decreasing subsequence ending at column i, considering deletions before i.",Sort the strings based on the length of the string and then compare characters.,Iteratively delete columns that violate lexicographical order in the first encountered row.,"Employ dynamic programming where dp[i] stores the length of the longest non-decreasing subsequence of columns, retaining column 'i' in the subsequence.",Hard,algorithms,"Array,String,Dynamic Programming"
1001,"N-Repeated Element in Size 2N Array
You are given an integer array nums with the following properties: Return the element that is repeated n times.",The element at the middle index nums[n/2],The maximum element in the array,The first element of the array nums[0],The last element of the array nums[2n-1],Iterate through the array and use a hash map or set to count occurrences of each element,Easy,algorithms,"Array,Hash Table"
1002,"Maximum Width Ramp
A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i. Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.","O(n log n), due to sorting the array.","O(n^2), because we compare each element with every other element.","O(1), as the algorithm uses constant time irrespective of the input size.","O(log n), similar to binary search due to the ramp property.","O(n), achievable with a single pass using auxiliary data structures.",Medium,algorithms,"Array,Stack,Monotonic Stack"
1003,"Minimum Area Rectangle II
You are given an array of points in the X-Y plane points where points[i] = [xi, yi]. Return the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0. Answers within 10-5 of the actual answer will be accepted.","Check all combinations of four points to see if they form a rectangle by calculating side lengths and angles; highly inefficient, O(n^4).","Sort the points and iterate through adjacent pairs to find possible rectangle vertices, which may miss rotated rectangles; O(n log n).",Compute the convex hull of the points and search for rectangles within the hull; this simplifies the search but doesn't guarantee finding the minimum area; O(n log n) for convex hull.,Use a grid-based approximation by discretizing the space; this can introduce significant errors and might not find the exact minimum area rectangle.,"Iterate through all pairs of points to consider each as a diagonal; for each diagonal, look for other pairs of points that form the same diagonal midpoint and length, indicating a rectangle; O(n^3).",Medium,algorithms,"Array,Math,Geometry"
1004,"Least Operators to Express Number
Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used.",Greedily choose the operator that minimizes the absolute difference between the current value and the target.,"Use dynamic programming with a state representing the current value and the number of operators used, minimizing the operator count.","Apply branch and bound search, pruning branches where the number of operators exceeds a threshold.","Employ a Monte Carlo tree search, exploring different operator combinations randomly and selecting the most promising ones.","Utilize dynamic programming to track the cost of reaching the target and its negative, considering +, -, *, and / operators.",Hard,algorithms,"Math,Dynamic Programming"
1005,"Univalued Binary Tree
A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.",A balanced tree where each node's value equals the root's value.,"A complete tree where each level has nodes with identical values, but different from other levels.","A tree with at most two distinct node values, where one value is the root and the other is a different constant.",A tree that is both height-balanced and where the root value is the median of all node values.,A tree where all nodes have the same value.,Easy,data structures,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1006,"Vowel Spellchecker
Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word. For a given query word, the spell checker handles two categories of spelling mistakes: In addition, the spell checker operates under the following precedence rules: Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].","Use a Bloom filter to quickly approximate set membership, accepting potential false positives.",Perform a binary search on the wordlist directly for each query.,Apply the Levenshtein distance algorithm to find the closest match in the wordlist.,Use a hash table to store the wordlist and perform constant-time lookups for exact matches only.,"First check for exact matches, then vowel errors, then capitalization errors, using a prioritized lookup.",Medium,algorithms,"Array,Hash Table,String"
1007,"Numbers With Same Consecutive Differences
Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order. Note that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.","Use dynamic programming to store intermediate results based on length and last digit, avoiding redundant calculations.","Employ a greedy approach, always choosing the digit that minimizes the difference from the previous digit.",Generate all possible n-digit numbers and filter out those that do not satisfy the consecutive difference condition.,Sort the digits from 0-9 and recursively build number combinations based on allowed differences.,Utilize depth-first search (DFS) to explore possible digit combinations while pruning branches that violate the difference constraint.,Medium,algorithms,"Backtracking,Breadth-First Search"
1008,"Binary Tree Cameras
You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree.","Use a greedy approach, placing cameras at every leaf node.","Use dynamic programming, considering the states: covered, not covered, and camera installed for each node.","Place cameras at every other level of the tree, starting from the root.",Perform a level-order traversal and place a camera at the first uncovered node encountered.,"Employ a recursive depth-first search, returning states indicating covered, monitored by child, or needs camera.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Binary Tree"
1009,"Pancake Sorting
Given an array of integers arr, sort the array by performing a series of pancake flips. In one pancake flip we do the following steps: For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3. Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.",Bubble Sort,Merge Sort,Insertion Sort,Quick Sort,A modified selection sort that places the largest unsorted element at its correct position with pancake flips,Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
1010,"Powerful Integers
Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. An integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0. You may return the answer in any order. In your answer, each value should occur at most once.","Use nested loops to calculate x^i + y^j for all i and j up to bound, adding to a set.","Precompute all powers of x and y less than bound, then iterate through all pairs of powers to sum them and add to a set.",Use dynamic programming to store all possible sums of powers of x and y less than bound.,"Calculate x + y, x * y, x - y, and x / y. If any are less than or equal to bound, return them.","Iterate through powers of x and y while they are less than bound, summing them and adding to a set to avoid duplicates.",Medium,algorithms,"Hash Table,Math"
1011,"Flip Binary Tree To Match Preorder Traversal
You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree. Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect: Flip the smallest number of nodes so that the pre-order traversal of the tree matches voyage. Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].",Return `[-1]` immediately if the root value doesn't match the current voyage value.,Prioritize right subtree traversal before left subtree traversal in all cases.,Flip every node encountered during the preorder traversal.,"If a flip is needed, store the parent of the flipped node instead of the node itself.","Recursively traverse the tree, comparing node values with the voyage; flip nodes if necessary to match the preorder, recording flipped nodes.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1012,"Equal Rational Numbers
Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number. A rational number can be represented using up to three parts: <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will be represented in one of the following three ways: The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:",Convert both strings to floating-point numbers using Python's `float()` and compare them directly.,"Normalize both strings by removing parentheses and repeating the repeating part a fixed number of times, then compare them as strings.","Parse both strings to extract the integer, non-repeating, and repeating parts. Calculate the value of each part as a fraction and compare the sum of fractions.","Compare the lengths of the strings. If they are equal, compare them directly. Otherwise, return False.","Parse both strings into their integer, non-repeating, and repeating parts. Convert each to a rational number representation (numerator/denominator) and compare the fractions.",Hard,algorithms,"Math,String"
1014,"K Closest Points to Origin
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).","Use a min-heap of size k to store the distances and points, updating the heap as needed.","Calculate the distance for all points, sort the distances, and then select the k smallest.",Employ a k-d tree to partition the space and efficiently search for the nearest neighbors.,"Apply a brute-force approach, calculating all distances and linearly scanning for the smallest k distances.",Utilize quickselect (or a similar selection algorithm) to partition the points array around the kth smallest distance.,Medium,algorithms,"Array,Math,Divide and Conquer,Geometry,Sorting,Heap (Priority Queue),Quickselect"
1016,"Subarray Sums Divisible by K
Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k. A subarray is a contiguous part of an array.","Calculate the sum of all possible subarrays and check divisibility individually, resulting in O(n^3) complexity","Compute the prefix sum array and check divisibility of differences, but without handling negative remainders correctly","Use dynamic programming to store divisibility results for subarrays ending at each index, but miss overlapping subarrays","Only consider subarrays starting from the beginning of the array, ignoring all other possible subarrays","Maintain a hash map to store the count of prefix sums modulo k, and increment the result based on existing remainders",Medium,algorithms,"Array,Hash Table,Prefix Sum"
1017,"Odd Even Jump
You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices. You may jump forward from index i to index j (with i < j) in the following way: A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once). Return the number of good starting indices.",Sort the array and then use binary search to find the next jump index,"Use dynamic programming to store previously calculated jump paths, starting from the end of the array","Apply a greedy approach, always jumping to the nearest possible index",Recursively explore all possible jump combinations and check if the end is reachable,"Use dynamic programming to determine 'good' indices for odd and even jumps separately, working backward from the end",Hard,algorithms,"Array,Dynamic Programming,Stack,Monotonic Stack,Ordered Set"
1018,"Largest Perimeter Triangle
Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.",Divide the array into halves and recursively find the largest perimeter in each half.,Sort the array in ascending order and check the last three elements for the triangle property.,Use dynamic programming to store the possible triangle perimeters for each subset of the array.,Generate all possible combinations of three numbers and check if they satisfy the triangle inequality.,"Sort the array in descending order and iterate through it, checking if the triangle inequality holds for consecutive triplets.",Easy,algorithms,"Array,Math,Greedy,Sorting"
1019,"Squares of a Sorted Array
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.",Sort the array after squaring each element,Square only the positive elements and then sort the entire array,Square each element and then reverse the array,Use a hash map to count occurrences of squared values and then reconstruct the array,"Use two pointers, one at the beginning and one at the end, and compare absolute values to build the squared array from the end",Easy,algorithms,"Array,Two Pointers,Sorting"
1020,"Longest Turbulent Subarray
Given an integer array arr, return the length of a maximum size turbulent subarray of arr. A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:",O(1),O(n log n),O(n^2),O(n!),O(n),Medium,algorithms,"Array,Dynamic Programming,Sliding Window"
1021,"Distribute Coins in Binary Tree
You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent. Return the minimum number of moves required to make every node have exactly one coin.",Perform a level-order traversal and redistribute coins based on node depth.,"Calculate the difference between coins and nodes, then divide by the number of nodes.",Use dynamic programming to store the minimum moves needed for subtrees.,Perform a breadth-first search and greedily move coins to the nearest deficient node.,"Use a post-order traversal, calculating the 'excess' or 'deficit' of coins at each node and passing the moves up the tree.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1022,"Unique Paths III
You are given an m x n integer array grid where grid[i][j] could be: Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.","Use Dijkstra's algorithm to find the shortest path, then check if all non-obstacle cells were visited.",Employ a greedy algorithm that always chooses the adjacent cell with the lowest value.,Implement a breadth-first search (BFS) to explore all possible paths without revisiting any cells.,"Apply dynamic programming to store the number of paths to each cell, considering visited cells.","Use backtracking to explore all possible paths, marking visited cells and ensuring all non-obstacle cells are visited exactly once.",Hard,algorithms,"Array,Backtracking,Bit Manipulation,Matrix"
1023,"Time Based Key-Value Store
Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class:",Using a hash table to store all timestamps for each key and iterating over the hash table for retrieval.,Storing all values in a single unsorted array and using a linear search to find the closest timestamp.,"Employing a binary search tree to store timestamps, resulting in O(log n) insertion but slower retrieval.",Storing all timestamps and values in separate unsorted arrays.,"Using a hash table to store keys, and for each key, storing timestamps and values in a sorted array, enabling binary search for retrieval.",Medium,data structures,"Hash Table,String,Binary Search,Design"
1024,"Triples with Bitwise AND Equal To Zero
Given an integer array nums, return the number of AND triples. An AND triple is a triple of indices (i, j, k) such that:","Calculate the bitwise AND of all possible triplets and count those equal to zero, regardless of index order.","For each number, count pairs that, when ANDed with it, result in zero; sum these counts.","Use a hash map to store counts of each number, then iterate through the hash map to find AND triples.",Sort the array and only check triplets where the first element is less than the other two.,"Iterate through all possible index triplets (i, j, k) and increment a counter if nums[i] & nums[j] & nums[k] equals zero.",Hard,algorithms,"Array,Hash Table,Bit Manipulation"
1025,"Minimum Cost For Tickets
You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365. Train tickets are sold in three different ways: The passes allow that many days of consecutive travel. Return the minimum number of dollars you need to travel every day in the given list of days.",Greedy approach selecting the cheapest ticket available for each travel day,Using dynamic programming with a state representing the current day and the last ticket purchased,"Recursively calculate the cost for each day, choosing the minimum among the three ticket options","Sort the travel days and then iterate through them, buying the longest ticket possible","Employ dynamic programming where the state represents the cost to travel up to a given day, considering all possible ticket choices for each day",Medium,algorithms,"Array,Dynamic Programming"
1026,"String Without AAA or BBB
Given two integers a and b, return any string s such that:","Construct the string by alternating 'a' and 'b' characters, prioritizing the character with the larger count and adding extra characters when counts are significantly different.","Generate all possible strings and filter the ones that satisfy the condition, then return any one of the accepted strings if any exist.","Start with an empty string and repeatedly append the character with the larger count until its count reaches zero, then append the other character.",Use dynamic programming to build a table of valid prefixes and choose the string with optimal length.,"Greedily append 'a' or 'b' based on their counts, adding at most two consecutive occurrences of the same character to avoid 'aaa' or 'bbb'.",Medium,algorithms,"String,Greedy"
1027,"Sum of Even Numbers After Queries
You are given an integer array nums and an array queries where queries[i] = [vali, indexi]. For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums. Return an integer array answer where answer[i] is the answer to the ith query.",Modify the original array and recalculate the sum of even numbers in each iteration.,Create a new array for each query and compute the sum of even numbers for the new array.,Only update the sum if the modified element was previously even or odd.,Use a hash map to store the frequency of even numbers to compute the sum.,Maintain a running sum of even numbers and update it based on whether the value at the index was even or odd before and after the query.,Medium,algorithms,"Array,Simulation"
1028,"Interval List Intersections
You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].",Calculate the Cartesian product of the intervals and filter for overlaps,Sort all intervals by their start times and then merge overlapping intervals,Treat the intervals as nodes in a binary tree and perform an in-order traversal,Use a hash map to store the frequency of each number within the intervals,"Use two pointers to iterate through both lists, identify overlaps, and create new intersection intervals",Medium,algorithms,"Array,Two Pointers"
1029,"Vertical Order Traversal of a Binary Tree
Given the root of a binary tree, calculate the vertical order traversal of the binary tree. For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0). The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values. Return the vertical order traversal of the binary tree.","Breadth-first search modified to track horizontal distances in a hash map, with values sorted lexicographically","Depth-first search assigning level order indices to each node, sorting nodes based on these indices, and extracting vertical orders","Level-order traversal where children are visited first before the parent, and then the vertical order is built by reversing the traversal path","Inorder traversal assigning weights to left and right children differently, then ordering by sum of weights","Perform a modified breadth-first search, tracking the column of each node and sorting nodes within the same column by value",Hard,algorithms,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1030,"Smallest String Starting From Leaf
You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'. Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root. As a reminder, any shorter prefix of a string is lexicographically smaller. A leaf of a node is a node that has no children.","Use a breadth-first search, keeping track of paths and comparing strings as you encounter leaves.","Perform a depth-first search, always choosing the smaller value, and reverse the resulting string.",Convert the tree into an array and sort the array before processing to find the minimum string.,Use dynamic programming to store the smallest string starting from each node and build the solution.,"Perform a depth-first search, constructing strings from leaf to root, and keep track of the lexicographically smallest string found so far.",Medium,algorithms,"String,Tree,Depth-First Search,Binary Tree"
1031,"Add to Array-Form of Integer
The array-form of an integer num is an array representing its digits in left to right order. Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.","Convert the array to an integer, add k, then convert the result back to an array of digits.","Prepend 'k' as a string to the array, then sort the array numerically.","Add k to the last element of the array, and if the result is greater than 9, propagate the carry to the previous element.","Return the array representing k, ignoring the input array.","Iterate through the array from right to left, adding digits and handling carry-over from k, forming a new array.",Easy,algorithms,"Array,Math"
1032,"Satisfiability of Equality Equations
You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: ""xi==yi"" or ""xi!=yi"".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",Use Depth-First Search (DFS) to identify connected components based on '==' and then check for contradictions with '!=',"Sort the equations alphabetically and then process them sequentially, assigning arbitrary values to variables",Convert each variable to its ASCII value and perform arithmetic operations directly on the equation strings,"Maintain a global counter, assigning each variable a unique number based on its first appearance",Use the Union-Find algorithm to group equal variables and then check if any unequal variables belong to the same group,Medium,algorithms,"Array,String,Union Find,Graph"
1033,"Broken Calculator
There is a broken calculator that has the integer startValue on its display initially. In one operation, you can: Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator.","Continuously multiply startValue by 2 until it exceeds target, then repeatedly subtract 1","If target is smaller than startValue, return startValue - target. Otherwise, return target - startValue.",Use dynamic programming to store the minimum operations for each intermediate value between startValue and target.,Apply Dijkstra's algorithm treating each number as a node and operations as edges.,"Work backward from target to startValue, dividing by 2 if target is even or adding 1 if odd.",Medium,algorithms,"Math,Greedy"
1034,"Subarrays with K Different Integers
Given an integer array nums and an integer k, return the number of good subarrays of nums. A good array is an array where the number of different integers in that array is exactly k. A subarray is a contiguous part of an array.","Use a sliding window approach, expanding the window until it contains k distinct elements, then shrinking until it contains k-1 distinct elements.",Recursively generate all possible subarrays and then count the number of subarrays with exactly k distinct integers.,Sort the array and then count subarrays of length k with unique elements.,Apply dynamic programming by storing the counts of distinct integers for all subarrays starting at index 0.,Use the inclusion-exclusion principle: count subarrays with at most k distinct integers minus subarrays with at most k-1 distinct integers.,Hard,algorithms,"Array,Hash Table,Sliding Window,Counting"
1035,"Cousins in Binary Tree
Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. Two nodes of a binary tree are cousins if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1.",All currently executing tasks are immediately terminated.,The `ExecutorService` immediately throws an exception if there are any pending tasks.,"No new tasks can be submitted, and the `ExecutorService` waits indefinitely for all tasks to complete.","Only tasks that are already in the queue will be executed, any actively running tasks are interrupted.","No new tasks can be submitted, but the `ExecutorService` continues to execute all previously submitted tasks until they are finished.",Easy,system design,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1036,"Rotting Oranges
You are given an m x n grid where each cell can have one of three values: Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",Perform a Depth-First Search (DFS) from each rotten orange to infect adjacent fresh oranges recursively.,"Simultaneously iterate through the grid, converting fresh oranges to rotten based on a probability factor.",Sort the grid based on the number of fresh oranges in each row and prioritize rotting in rows with more fresh oranges.,Randomly select fresh oranges and convert them to rotten oranges until no fresh oranges remain.,"Use a Breadth-First Search (BFS) to simulate the rotting process, tracking the time elapsed as the distance from the initial rotten oranges increases.",Medium,algorithms,"Array,Breadth-First Search,Matrix"
1037,"Minimum Number of K Consecutive Bit Flips
You are given a binary array nums and an integer k. A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1. A subarray is a contiguous part of an array.","Apply a greedy approach, flipping the first encountered 0 in each k-sized window.",Use dynamic programming to store the minimum flips needed for each prefix of the array.,Sort the array and then apply flips to negative elements.,"Recursively divide the array into halves, solve each half, and then merge the results.","Iterate through the array, keeping track of the number of active flips affecting the current position. Flip when encountering a 0 and update the active flips count.",Hard,algorithms,"Array,Bit Manipulation,Sliding Window,Prefix Sum"
1038,"Number of Squareful Arrays
An array is squareful if the sum of every pair of adjacent elements is a perfect square. Given an integer array nums, return the number of permutations of nums that are squareful. Two permutations perm1 and perm2 are different if there is some index i such that perm1[i] != perm2[i].","Use dynamic programming to store the number of squareful permutations for each sub-array, optimizing overlapping subproblems.","Sort the array first and then use backtracking to explore permutations, pruning branches when a pair doesn't sum to a perfect square.",Generate all possible permutations of the array and then check each permutation for the squareful property.,"Calculate the frequency of each number, then compute the number of permutations using factorials of frequencies, only considering unique permutations.","Use backtracking to explore permutations, maintaining a set of visited numbers to avoid duplicates and pruning branches when a pair doesn't sum to a perfect square.",Hard,algorithms,"Array,Math,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
1039,"Find the Town Judge
In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.",Sort the 'trust' array and find the person with the most incoming edges.,Return the person who trusts the fewest number of people.,Return the person who trusts only themselves.,Check if there is a person trusted by exactly 'n-2' other people.,Find the person trusted by everyone else (n-1) and who trusts nobody.,Easy,algorithms,"Array,Hash Table,Graph"
1040,"Maximum Binary Tree II
A maximum tree is a tree where every node has a value greater than any other value in its subtree. You are given the root of a maximum binary tree and an integer val. Just as in the previous problem, the given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine: Note that we were not given a directly, only a root node root = Construct(a). Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values. Return Construct(b).",Replace the root node's value with 'val' and discard the original tree.,Insert 'val' as a leaf node at a random location in the tree.,"Append 'val' to an in-order traversal list of the tree, sort the list, and reconstruct the tree.",Insert 'val' as a child of the node with the smallest value in the tree.,"Create a new node with value 'val'. If 'val' is greater than the root's value, make the original tree the left subtree of the new node. Otherwise, recursively insert 'val' into the right subtree of the current node.",Medium,data structures,"Tree,Binary Tree"
1041,"Available Captures for Rook
You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by 'R', some number of white bishops 'B', and some number of black pawns 'p'. Empty squares are represented by '.'. A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn's square in one move. Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path. Return the number of pawns the white rook is attacking.",Use dynamic programming to calculate the maximum number of attacked pawns considering only sub-boards.,Check all 64 squares around the rook for pawns and bishops without considering board boundaries.,"Recursively explore possible paths for the rook, pruning branches when a bishop is encountered.","Calculate the Manhattan distance between the rook and all pawns, only counting those within a threshold.","Iterate in all four directions from the rook until an edge or another piece is hit, counting attacked pawns.",Easy,algorithms,"Array,Matrix,Simulation"
1042,"Minimum Cost to Merge Stones
There are n piles of stones arranged in a row. The ith pile has stones[i] stones. A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles. Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1.",Greedily merge the smallest k consecutive piles until one pile remains.,Use dynamic programming with a 2D array dp[i][j] representing the cost to merge piles i to j.,"Employ a divide-and-conquer approach, recursively merging subranges of piles.",Prioritize merging piles with the largest number of stones first.,Use dynamic programming with a 3D array dp[i][j][m] representing the cost to merge piles i to j into m piles.,Hard,algorithms,"Array,Dynamic Programming"
1043,"Grid Illumination
There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off. You are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. Even if the same lamp is listed more than once, it is turned on. When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal. You are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj]. Return an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.",Use a quadtree to represent the grid and efficiently query illumination status.,Simulate the grid using a 2D array and update illumination status for each lamp and query.,"Employ a graph data structure where nodes are cells and edges represent adjacency to lamps, using Dijkstra's algorithm to determine illumination.","Utilize a bloom filter to quickly check if a cell is potentially illuminated, followed by a detailed check of relevant lamps.","Employ hash maps to store lamp positions and their counts for rows, columns, and diagonals, allowing for efficient updates and illumination checks.",Hard,algorithms,"Array,Hash Table"
1044,"Find Common Characters
Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.","Use a hash map to store character counts for each string, then find the intersection of the counts.","Concatenate all strings in the array, then count the occurrences of each character in the combined string.","Sort each string alphabetically, then compare the sorted strings to find the common characters.","For each string, create a set of its characters. Return the intersection of these sets.","Maintain a count array for each character ('a' to 'z'). Iterate through the words, updating the count array to the minimum occurrences of each character across all words.",Easy,algorithms,"Array,Hash Table,String"
1045,"Check If Word Is Valid After Substitutions
Given a string s, determine if it is valid. A string s is valid if, starting with an empty string t = """", you can transform t into s after performing the following operation any number of times: Return true if s is a valid string, otherwise, return false.",Use regular expressions to repeatedly remove occurrences of 'abc' until the string is empty.,Employ dynamic programming to store intermediate results and optimize the substitution process.,Recursively check if the string starts with 'abc' and recursively call the function on the remaining substring.,Convert the string to a character array and use nested loops to find and remove 'abc' sequences.,"Utilize a stack to track the characters; when 'abc' is found at the top, pop them; otherwise, push the character.",Medium,algorithms,"String,Stack"
1046,"Max Consecutive Ones III
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.","Use a greedy approach, always flipping the leftmost 0 until k is exhausted, then calculate the length of the resulting sequence.",Apply binary search to find the longest possible consecutive sequence length.,"Maintain a sliding window that only expands, and update the maximum length if the current window has fewer than k 0s.",Recursively divide the array into subproblems and solve them independently.,"Use a sliding window technique, tracking the number of 0s, expanding the window until the number of 0s exceeds k, then shrinking it from the left until the number of 0s is within the limit.",Medium,algorithms,"Array,Binary Search,Sliding Window,Prefix Sum"
1047,"Maximize Sum Of Array After K Negations
Given an integer array nums and an integer k, modify the array in the following way: You should apply this process exactly k times. You may choose the same index i multiple times. Return the largest possible sum of the array after modifying it in this way.",Always negate the largest element in the array,Sort the array in descending order and negate the first k elements,Negate the first k elements of the array regardless of their values,Only negate positive elements,"Sort the array in ascending order, negate the smallest elements k times, and if k is odd after negating all negative numbers, negate the smallest element again if necessary",Easy,algorithms,"Array,Greedy,Sorting"
1048,"Clumsy Factorial
The factorial of a positive integer n is the product of all positive integers less than or equal to n. We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order. However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right. Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11. Given an integer n, return the clumsy factorial of n.",Dynamic programming with memoization to avoid redundant calculations,Recursion with a fixed number of stack frames for each level of the factorial,"A single loop iterating from n down to 1, applying operators using a modulo operation",Utilizing the gamma function to approximate the factorial and apply the operations,"Iterating from n down to 1, tracking the intermediate result and cycling through *, /, +, - operations",Medium,algorithms,"Math,Stack,Simulation"
1049,"Minimum Domino Rotations For Equal Row
In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same. If it cannot be done, return -1.",Greedily choose the number that appears most frequently in either `tops` or `bottoms`.,Use dynamic programming to store the minimum rotations needed for each prefix of the dominoes.,Check if making all `tops` equal to `tops[0]` is possible and if making all `bottoms` equal to `bottoms[0]` is possible; return the minimum of these.,Sort `tops` and `bottoms` individually; the minimum rotations will then be the number of misplaced elements.,"For each of the numbers 1 to 6, count the minimum rotations needed to make all `tops` equal to that number and all `bottoms` equal to that number. Return the overall minimum.",Medium,algorithms,"Array,Greedy"
1050,"Construct Binary Search Tree from Preorder Traversal
Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root. It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases. A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val. A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.","The first element is always the root. Recursively build the left subtree with elements smaller than the root and the right subtree with the remaining elements, without explicitly tracking indices.","Sort the preorder array first, then construct the BST using an inorder traversal algorithm.","Iteratively insert each element into the BST, maintaining the BST property by comparing values against existing nodes.","Use a stack to keep track of potential parent nodes, and create left or right children based solely on the order of elements in the preorder array.",Use recursion with a range (lower and upper bound) for each node to ensure the BST property while constructing the tree. Update the index as the tree is built.,Medium,data structures,"Array,Stack,Tree,Binary Search Tree,Monotonic Stack,Binary Tree"
1054,"Complement of Base 10 Integer
The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation. Given an integer n, return its complement.",Subtract n from the next largest power of 2.,Calculate the bitwise XOR of n with the largest integer representable by the same number of bits as n.,"Convert n to its binary representation, invert the bits, and convert back to decimal.","Left-shift n until it becomes a power of 2, then subtract the original n.","Find the smallest number greater than or equal to n that is a power of 2, subtract n, then subtract 1.",Easy,algorithms,Bit Manipulation
1055,"Pairs of Songs With Total Durations Divisible by 60
You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.",Compute the sum of all pairs naively with O(n^2) complexity.,Sort the array and then use binary search to find complements for each element.,Use a hash table to store the frequencies of each element and its complement modulo 60.,Calculate the sum of all elements in the array and check if the sum is divisible by 60.,Count the frequency of each time duration modulo 60 and use these frequencies to compute the number of pairs.,Medium,algorithms,"Array,Hash Table,Counting"
1056,"Capacity To Ship Packages Within D Days
A conveyor belt has packages that must be shipped from one port to another within days days. The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.",Use Depth-First Search to find all possible capacity values that work.,Sort the weights array and return the sum of the first `days` elements.,Set the capacity to the average weight and increment if shipping exceeds `days`.,Set the capacity to the maximum weight and check the number of shipping days; adjust capacity linearly.,Use binary search on the range between the maximum weight and the sum of all weights to find the minimum capacity.,Medium,algorithms,"Array,Binary Search,Greedy"
1057,"Numbers With Repeated Digits
Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.",Employ dynamic programming to count numbers with distinct digits and subtract from n.,Generate all numbers from 1 to n and check each for repeated digits using string conversion and set comparison.,Use inclusion-exclusion principle to count numbers without repeated digits within specified ranges.,"Convert the number n to its binary representation, then count repeated digits by iterating through the digits.",Calculate the number of integers with distinct digits using combinatorics and subtract it from 'n' to find the answer.,Hard,algorithms,"Math,Dynamic Programming"
1062,"Partition Array Into Three Parts With Equal Sum
Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",Return true if the sum of the array is divisible by 3 and there are at least two indices i and j such that arr[0...i] == arr[i+1...j] == arr[j+1...n-1],Use a hash map to store prefix sums and check if there exist two indices i and j where prefix_sum[i] == prefix_sum[j] - prefix_sum[i] == total_sum - prefix_sum[j],"Iterate through all possible combinations of i and j and check if the three parts have equal sums, returning true immediately if a valid partition is found","Sort the array and check if the first third, second third, and last third of the sorted array have equal sums","Calculate the total sum and target sum (total_sum / 3). Iterate through the array, keeping track of the current sum. Increment a counter each time the current sum equals the target sum. Return true if the counter is greater than or equal to 3.",Easy,algorithms,"Array,Greedy"
1063,"Best Sightseeing Pair
You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them. The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots.","Brute force: Calculate the score for every pair (i, j) and return the maximum.",Sort the array and choose the first and last elements.,"Iterate through the array, keeping track of the overall sum.",Keep track of the maximum value seen so far and calculate the score using only that value.,"Iterate through the array, keeping track of the maximum value of values[i] + i seen so far and updating the maximum score.",Medium,algorithms,"Array,Dynamic Programming"
1064,"Smallest Integer Divisible by K
Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1. Return the length of n. If there is no such n, return -1. Note: n may not fit in a 64-bit signed integer.","Return k if k is a power of 2 or a power of 5, otherwise -1",Check if the repeating decimal 1/k has a repeating block containing only 1s,"Brute force by generating numbers consisting of 1s until a number divisible by k is found, with a maximum length limit","Return -1 if k is divisible by 2 or 5, otherwise return k","Iteratively check remainders when dividing numbers consisting of ones by k, using the property that (10*r + 1) % k can be efficiently computed",Medium,algorithms,"Hash Table,Math"
1065,"Binary String With Substrings Representing 1 To N
Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise. A substring is a contiguous sequence of characters within a string.",Convert 'n' to binary and check if it's a substring of 's'.,Check if all powers of 2 up to 'n' are substrings of 's'.,"Iterate through numbers from 1 to 'n', convert them to decimal strings, and check if they are substrings of 's'.",Check if the string 's' contains at least 'n' ones.,"Iterate through numbers from 1 to 'n', convert them to binary strings, and check if they are substrings of 's'.",Medium,algorithms,String
1070,"Convert to Base -2
Given an integer n, return a binary string representing its representation in base -2. Note that the returned string should not have leading zeros unless the string is ""0"".","Repeatedly divide by -2, keeping track of remainders, and reverse the result, handling negative remainders by adding 2 and adjusting the quotient.","Convert the number to its absolute value, perform standard base 2 conversion, and then invert the bits where necessary.",Use a lookup table to map decimal values to their corresponding base -2 representations and concatenate the results.,Recursively convert the number by checking if it's even or odd and appending '0' or '1' accordingly.,"Repeatedly divide by -2 and use the remainder as the digit (0 or 1). If the remainder is negative, add 2 and carry 1 to the next quotient.",Medium,algorithms,Math
1071,"Binary Prefix Divisible By 5
You are given a binary array nums (0-indexed). We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit). Return an array of booleans answer where answer[i] is true if xi is divisible by 5.","Calculate xi modulo 2 repeatedly, checking for divisibility by 5 at the end.",Convert the entire binary array to a single integer and then check divisibility by 5.,Use bitwise left shift operator on a running sum and check divisibility by 5 after processing the entire array.,Check if the sum of all the bits in the range nums[0..i] is divisible by 5.,Maintain a running modulo 5 value and update it with each new bit.,Easy,algorithms,Array
1072,"Next Greater Node In Linked List
You are given the head of a linked list with n nodes. For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it. Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.",A hash table to store visited nodes and their distances from the start,Breadth-first search (BFS) starting from the head node,Dynamic programming to store optimal next greater nodes for sublists,"Recursion, exploring the list from tail to head",A stack to maintain decreasing elements and efficiently find the next greater element,Medium,data structures,"Array,Linked List,Stack,Monotonic Stack"
1073,"Number of Enclaves
You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid. Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.","Use Depth First Search (DFS) and mark all land cells connected to the boundary as '0', then count remaining '1's","Iterate through the grid and if a land cell has any adjacent sea cell, mark it as a sea cell, and count remaining land cells",Use Breadth First Search (BFS) starting from any land cell to determine reachable cells and subtract that count from the total number of land cells.,Reverse the grid (transpose rows and columns) and apply a flood fill algorithm.,Use Depth First Search (DFS) or Breadth First Search (BFS) starting from boundary land cells to mark reachable land cells; then count remaining unmarked land cells.,Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
algorithms,1078,"Remove Outermost Parentheses
A valid parentheses string is either empty """", ""("" + A + "")"", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.","O(n^2), where n is the length of the input string due to nested loops for identifying primitive strings.","O(n log n), where n is the length of the input string, resulting from sorting primitive substrings.","O(k), where k is the number of primitive strings in the decomposition, assuming constant time processing for each.","O(2^n), where n is the length of the input string, arising from exploring all possible decompositions.",,"['string manipulation', 'time complexity', 'parentheses']","O(n), where n is the length of the input string, as each character is processed at most once."
algorithms,1079,"Sum of Root To Leaf Binary Numbers
You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer.",Perform a level-order traversal and convert each path to an integer after reaching a leaf node.,Convert the binary tree to an array and then calculate the sum of all possible sub-arrays.,Use dynamic programming to store intermediate sums and avoid redundant calculations.,Calculate the sum of all node values and multiply by the number of leaves.,,"['binary tree', 'depth-first search', 'recursion']","Perform a depth-first traversal, accumulating the binary number along each path and adding to the total sum when a leaf is reached."
algorithms,1080,"Camelcase Matching
Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.",Convert the query string to lowercase and check if the pattern is a substring.,"Check if the pattern is a subsequence of the query string, ignoring case.","Use regular expressions to match the pattern against the query string, allowing any characters between the pattern's characters.","Compute the Levenshtein distance between the query and pattern; if it is less than a threshold, consider it a match.",,"['string matching', 'pattern recognition', 'greedy algorithm']","Iterate through the query string, matching uppercase characters in the pattern sequentially, allowing lowercase letters in the query to be skipped."
algorithms,1081,"Video Stitching
You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi. We can cut these clips into segments freely. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.","Use dynamic programming with a bottom-up approach, iterating through possible end times.",Sort the clips by end time and greedily select the clip that covers the most uncovered time.,"Sort the clips by start time, and for each start time, select the clip with the earliest end time.",Recursively explore all possible combinations of clips using backtracking.,,"['greedy algorithm', 'dynamic programming', 'intervals']","Sort clips by start time, then greedily choose the clip that extends the coverage furthest."
algorithms,1086,"Divisor Game
Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of: Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.",Alice wins if 'n' is odd.,Alice wins if 'n' is a prime number.,Alice wins only if 'n' is a power of 2.,"Alice always loses, regardless of 'n'.",,"['game theory', 'number theory', 'recursion']",Alice wins if and only if 'n' is even.
1092,"Maximum Difference Between Node and Ancestor
Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b. A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.",Perform a level-order traversal and calculate the difference between each node and the root's value.,Calculate the difference between the maximum and minimum node values in the entire tree.,"Calculate the difference between each node and its parent, and return the largest of these.","Store all ancestor-descendant pairs and their differences in a hash map, then find the maximum.","Perform a depth-first search, maintaining the minimum and maximum values seen along each path.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1087,"Longest Arithmetic Subsequence
Given an array nums of integers, return the length of the longest arithmetic subsequence in nums. Note that:",Dynamic programming with memoization based on the difference between elements.,Greedily selecting elements that maintain an approximately constant difference.,Brute-force searching all possible subsequences for an arithmetic progression.,Sorting the array and then finding the longest increasing subsequence.,Using dynamic programming to store the length of arithmetic subsequences ending at each index for each possible difference.,Medium,algorithms,"Array,Hash Table,Binary Search,Dynamic Programming"
1093,"Recover a Tree From Preorder Traversal
We run a preorder depth-first search (DFS) on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0. If a node has only one child, that child is guaranteed to be the left child. Given the output traversal of this traversal, recover the tree and return its root.","Use a stack to keep track of nodes and their depths, popping nodes when the current depth is less than or equal to the stack's top node's depth.","Recursively process the string, creating nodes based on the number of dashes and assuming that the right subtree always starts after the left subtree is fully processed.","Iteratively process the string, using a queue to hold nodes at each level, and assigning children based on the number of dashes.",Sort the input string based on the number of dashes before processing. Create the root node and then add children level by level.,"Maintain a stack of nodes, adding a new node as a child of the deepest node with depth one less than the current node's depth.",Hard,algorithms,"String,Tree,Depth-First Search,Binary Tree"
1095,"Two City Scheduling
A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti. Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.",Greedily send each person to the city with the lower cost for that individual.,"Recursively explore all possible combinations of assignments, pruning when the number of people exceeds n for either city.","Use dynamic programming with a state representing the number of people sent to city A, but without considering the cost differences.","Sort the costs array based on the sum of aCosti and bCosti, then send the first n to city A and the rest to city B.","Sort the costs array based on the difference between aCosti and bCosti, then send the first n to city A and the rest to city B.",Medium,algorithms,"Array,Greedy,Sorting"
1094,"Matrix Cells in Distance Order
You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter). Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition. The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.",Use a priority queue (heap) to store cells and retrieve them based on distance,Sort all possible coordinate pairs using a built-in sorting function with a lambda for distance calculation,Apply a breadth-first search (BFS) starting from the center cell to visit cells in increasing order of distance,Generate all coordinate pairs and apply the distance formula to each pair and filter duplicates,Create an array of all cell coordinates and sort it using a custom comparator based on Manhattan distance,Easy,algorithms,"Array,Math,Geometry,Sorting,Matrix"
1096,"Maximum Sum of Two Non-Overlapping Subarrays
Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen. The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping. A subarray is a contiguous part of an array.",Maintain a single sliding window of size `firstLen + secondLen` and find the maximum sum within it,"Compute all possible subarrays of length `firstLen` and `secondLen` and check for overlaps, keeping track of the maximum sum of non-overlapping pairs","Sort the array and select the largest `firstLen + secondLen` elements, then split them into two subarrays","Use dynamic programming to find the maximum sum subarray of any length, then combine the results for `firstLen` and `secondLen`","Compute prefix sums to efficiently calculate subarray sums, then iterate through possible split points to maximize the sum of two non-overlapping subarrays",Medium,algorithms,"Array,Dynamic Programming,Sliding Window"
1097,"Stream of Characters
Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words. For example, if words = [""abc"", ""xyz""] and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', your algorithm should detect that the suffix ""xyz"" of the characters ""axyz"" matches ""xyz"" from words. Implement the StreamChecker class:","A Bloom filter, as it provides probabilistic membership testing with low memory usage","A hash table, mapping prefixes of the stream to boolean values indicating a match","A singly linked list, storing the stream in reverse order and comparing suffixes","A min-heap, prioritizing the shortest words in the dictionary for faster comparison","A Trie (prefix tree), allowing efficient searching for prefixes of dictionary words within the character stream's suffixes",Hard,algorithms,"Array,String,Design,Trie,Data Stream"
1103,"Moving Stones Until Consecutive
There are three stones in different positions on the X-axis. You are given three integers a, b, and c, the positions of the stones. In one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions x, y, and z with x < y < z. You pick up the stone at either position x or position z, and move that stone to an integer position k, with x < k < z and k != y. The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions). Return an integer array answer of length 2 where:",Sort the integers and return the difference between the largest and smallest integers minus 2.,Calculate the absolute difference between each pair of integers and return the smallest difference minus 1.,"Return 0 if the integers are already consecutive; otherwise, return 1 if the difference between any pair is less than or equal to 2, and 2 otherwise.","Return 1 if the stones are already consecutive; otherwise, return the maximum difference between adjacent sorted positions minus 1.","Sort the integers. If max - min == 2, return 0. Else, return min(b-a-1, c-b-1) <= 1 ? 1 : 2",Medium,algorithms,"Math,Brainteaser"
1104,"Coloring A Border
You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location. Two squares are called adjacent if they are next to each other in any of the 4 directions. Two squares belong to the same connected component if they have the same color and they are adjacent. The border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column). You should color the border of the connected component that contains the square grid[row][col] with color. Return the final grid.",Use Depth-First Search (DFS) to identify the connected component and color all squares regardless of border status.,Use Breadth-First Search (BFS) and color the initial square and all its neighbors with the new color.,Iterate through the entire grid and change the color of any square that matches the original color.,Apply a flood fill algorithm without boundary checks to the entire grid.,"Use either Depth-First Search (DFS) or Breadth-First Search (BFS) to identify the connected component, marking only the border squares for recoloring.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
1105,"Uncrossed Lines
You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way.","Using a greedy approach, connect the closest numbers in value between the two arrays.","Sort both arrays and then iterate through them, connecting elements with the same index.",Connect all identical numbers between the two arrays regardless of their positions.,Use a binary search to find matching numbers and connect them if their indices haven't been used.,"Solve using dynamic programming, specifically finding the Longest Common Subsequence (LCS) length.",Medium,algorithms,"Array,Dynamic Programming"
1106,"Escape a Large Maze
There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi). Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid. Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.","Use Breadth-First Search (BFS) without considering the blocked cells, resulting in potential infinite loops","Employ Depth-First Search (DFS) without a visited set, possibly leading to stack overflow due to cycles","Apply Dijkstra's algorithm, which is inefficient for unweighted graphs and does not guarantee finding a path within the limited search space",Only check the immediate neighbors of the source and target for blocked cells and assume a path exists if they are clear,"Use Breadth-First Search (BFS) within a limited search radius, checking for blocked cells and early exit if area exceeds limit, or if target is reached",Hard,algorithms,"Array,Hash Table,Depth-First Search,Breadth-First Search"
1115,"Valid Boomerang
Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang. A boomerang is a set of three points that are all distinct and not in a straight line.","The points are collinear, lying on the same straight line.",The points form a right-angled triangle.,At least two points are identical.,The area of the triangle formed by the points is greater than zero.,"The points are distinct, and the area of the triangle formed by them is non-zero.",Easy,algorithms,"Math,Geometry"
1114,"Binary Search Tree to Greater Sum Tree
Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints:","Perform an inorder traversal and store the node values in an array, then replace each node with the sum of elements after it in the sorted array.","Perform a level-order traversal, compute the sum of all nodes greater than the current node for each level, and update the node's value.","Perform a preorder traversal, maintain a global sum, and add the sum to each node's value as you visit it.","Reverse the BST, perform an inorder traversal, and assign values accordingly.","Perform a reverse inorder traversal, maintain a running sum, and update each node's value with the running sum.",Medium,algorithms,"Tree,Depth-First Search,Binary Search Tree,Binary Tree"
1111,"Minimum Score Triangulation of Polygon
You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex in clockwise order. Polygon triangulation is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. Note that no other shapes other than triangles are allowed in the division. This process will result in n - 2 triangles. You will triangulate the polygon. For each triangle, the weight of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these weights over all n - 2 triangles. Return the minimum possible score that you can achieve with some triangulation of the polygon.",Greedily pick the smallest edges to form triangles until the polygon is fully triangulated.,Divide the polygon into triangles by always connecting vertex 0 to all other non-adjacent vertices.,Calculate the triangulation score for all possible combinations of triangles and select the minimum.,Sort the vertices by their values and then greedily form triangles based on the sorted order.,Use dynamic programming to calculate the minimum triangulation score for all possible sub-polygons.,Medium,algorithms,"Array,Dynamic Programming"
1113,"Moving Stones Until Consecutive II
There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones. Call a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions). Return an integer array answer of length 2 where:","O(n log n), where n is the number of stones","O(1), constant time complexity regardless of the input","O(n^2), due to nested loops for finding optimal positions","O(k), where k is the range of stone positions","O(n log n) in the worst case due to sorting, and O(n) for the sliding window approach to find optimal arrangements.",Medium,algorithms,"Array,Math,Two Pointers,Sorting"
1119,"Robot Bounded In Circle
On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that: The robot can receive one of three instructions: The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.",The robot will always return to the origin after one cycle of instructions.,The robot's path will diverge exponentially from the origin.,The robot will trace a spiral outwards indefinitely.,The robot's heading will remain consistently north after each instruction cycle.,The robot either returns to the origin or does not face north after one cycle of instructions.,Medium,algorithms,"Math,String,Simulation"
1120,"Flower Planting With No Adjacent
You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers. All gardens have at most 3 paths coming into or leaving it. Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.","Use a greedy algorithm, assigning the lowest available flower type to each garden without checking for future conflicts.","Use a backtracking algorithm, exploring all possible flower assignments and reverting when a conflict is found.","Sort the paths array and then assign flower types sequentially, ensuring no adjacent gardens have the same flower.","Use a hash table to store the flower types of adjacent gardens and randomly assign flower types, retrying until a valid assignment is found.","Use graph coloring with a greedy approach, iterating through gardens and assigning the smallest available flower type not used by neighbors.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph"
1121,"Partition Array for Maximum Sum
Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.",Greedily choose the largest element in each subarray of size k.,Calculate the sum of the original array without partitioning.,Recursively explore all possible partitions and choose the partition with the maximum average subarray value.,Sort the array and then partition it into subarrays of size k.,"Use dynamic programming to store the maximum sum for each prefix of the array, considering all possible subarray lengths up to k.",Medium,algorithms,"Array,Dynamic Programming"
1122,"Longest Duplicate Substring
Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is """".","Use a hash table to store all substrings and their counts, returning the longest substring with a count greater than 1",Employ dynamic programming to build a table of substring matches and extract the longest one,Recursively divide the string into smaller parts and check for duplicate substrings within each part,Sort all possible substrings and then iterate through them to find adjacent identical substrings,Apply binary search on the length of the substring combined with Rabin-Karp for efficient substring comparison,Hard,algorithms,"String,Binary Search,Sliding Window,Rolling Hash,Suffix Array,Hash Function"
1135,"Customers Who Bought All Products
Table: Customer  Table: Product  Write a solution to report the customer ids from the Customer table that bought all the products in the Product table. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to check if each customer bought all products,Employ a window function to partition by customer and count distinct products,Join the tables and use a GROUP BY clause with a HAVING COUNT(*) equal to the total number of products,Use EXCEPT to find customers who did not buy a product and exclude them,"Use division of the counts of (customer, product) pairs by the total product count to find customers with a ratio equal to 1",Medium,database systems,Database
1127,"Last Stone Weight
You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is: At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.",Use a min-heap and repeatedly extract the two smallest stones.,"Sort the array once at the beginning and then iterate, removing the last two elements.",Recursively smash the first two stones until only one remains.,Randomly select two stones and smash them until a single stone is left.,Use a max-heap (priority queue) to efficiently track the heaviest stones and simulate the smashing process.,Easy,algorithms,"Array,Heap (Priority Queue)"
1128,"Remove All Adjacent Duplicates In String
You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.",Use recursion to iteratively compare and remove adjacent duplicates from the end of the string.,Convert the string to a character array and use two pointers to track the current character and the next potential duplicate.,Sort the string alphabetically and then remove any adjacent duplicates.,"Iterate through the string, building a new string only including characters that are not equal to their neighbors.","Use a stack; if the current character matches the top of the stack, pop the stack; otherwise, push the character onto the stack.",Easy,algorithms,"String,Stack"
1129,"Longest String Chain
You are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words.",Depth-First Search (DFS),Breadth-First Search (BFS),Greedy Algorithm,Divide and Conquer,Dynamic Programming,Medium,algorithms,"Array,Hash Table,Two Pointers,String,Dynamic Programming"
1130,"Last Stone Weight II
You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0.","Use a greedy approach, always combining the two heaviest stones.",Sort the stones array and iteratively subtract the smaller from the larger until one or zero stones remain.,Calculate all possible subset sums and return the minimum absolute difference from the total sum.,Apply dynamic programming to find the closest possible partition of the stones into two groups of equal weight.,"Use dynamic programming to find the subset sum closest to half the total sum, then calculate the remaining difference.",Medium,algorithms,"Array,Dynamic Programming"
1136,"Actors and Directors Who Cooperated At Least Three Times
Table: ActorDirector  Write a solution to find all the pairs (actor_id, director_id) where the actor has cooperated with the director at least three times. Return the result table in any order. The result format is in the following example.","Use a correlated subquery to count the collaborations for each (actor_id, director_id) pair and filter accordingly.",Create a temporary table to store the count of collaborations and then select the pairs with a count greater than or equal to 3.,Join the table to itself twice and then group by actor_id and director_id with a count greater than or equal to 3.,Use a window function to partition by actor_id and director_id and count the collaborations.,Group by actor_id and director_id and use a HAVING clause to filter for counts greater than or equal to 3.,Easy,database systems,Database
1137,"Height Checker
A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i].",Use a hash map to store the frequency of each height in 'heights' and compare with 'expected',Sort both 'heights' and 'expected' and then compare them element by element,Calculate the difference between the sum of elements in 'heights' and 'expected',Use a recursive function to compare elements at each index,Sort a copy of 'heights' and compare it with 'heights' to count mismatches,Easy,algorithms,"Array,Sorting,Counting Sort"
1138,"Grumpy Bookstore Owner
There is a bookstore owner that has a store open for n minutes. You are given an integer array customers of length n where customers[i] is the number of the customers that enter the store at the start of the ith minute and all those customers leave after the end of that minute. During certain minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise. When the bookstore owner is grumpy, the customers entering during that minute are not satisfied. Otherwise, they are satisfied. The bookstore owner knows a secret technique to remain not grumpy for minutes consecutive minutes, but this technique can only be used once. Return the maximum number of customers that can be satisfied throughout the day.","Calculate the total satisfied customers without using the technique, and return that value directly.","Apply the technique to every possible contiguous subarray of 'grumpy', and return the *minimum* number of satisfied customers among those applications.",Calculate the sum of all customer values regardless of grumpy status.,Apply the technique on the longest contiguous sequence of zeros in the 'grumpy' array.,Use a sliding window to find the subarray of length 'minutes' within 'grumpy' where applying the technique maximizes customer satisfaction.,Medium,algorithms,"Array,Sliding Window"
1139,"Previous Permutation With One Swap
Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array. Note that a swap exchanges the positions of two numbers arr[i] and arr[j]",Find the first increasing element from the end and swap it with the largest element to its right,Sort the array in descending order and return it if it's different from the original array,Randomly shuffle the array and check if the result is lexicographically smaller and requires only one swap,Reverse the entire array and then swap the first two elements,"Find the first decreasing element from the end, then find the largest element to its right that is smaller than it and swap them",Medium,algorithms,"Array,Greedy"
1140,"Distant Barcodes
In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i]. Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.","Use a greedy approach, placing the most frequent barcode first, followed by the next most frequent, etc.",Sort the barcodes array and then swap adjacent elements that are equal.,Randomly shuffle the array until no two adjacent elements are the same.,Sort the barcode array and place even indexed elements in the first half and odd indexed elements in second half.,Use a max-heap to store the frequency of each barcode and iteratively place the most frequent barcode while ensuring it's not adjacent to the previously placed one.,Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Heap (Priority Queue),Counting"
1058,"Lexicographically Smallest Equivalent String
You are given two strings of the same length s1 and s2 and a string baseStr. We say s1[i] and s2[i] are equivalent characters. Equivalent characters follow the usual rules of any equivalence relation: For example, given the equivalency information from s1 = ""abc"" and s2 = ""cde"", ""acd"" and ""aab"" are equivalent strings of baseStr = ""eed"", and ""aab"" is the lexicographically smallest equivalent string of baseStr. Return the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.","""morris""","""parker""","""marsor""","""morser""","""parser""",Medium,algorithms,"String,Union Find"
1153,"Product Sales Analysis I
Table: Sales  Table: Product  Write a solution to report the product_name, year, and price for each sale_id in the Sales table. Return the resulting table in any order. The result format is in the following example.",Use a correlated subquery to find the product name for each sale.,Join the tables using a CROSS JOIN and then filter by sale_id.,Create a view that pre-calculates the product name for each product_id and then join with the Sales table.,Use a UNION ALL to combine the Sales and Product tables before joining.,Join the Sales and Product tables on their respective product_id columns and select the desired columns.,Easy,database systems,Database
1155,"Product Sales Analysis III
Table: Sales Write a solution to find all sales that occurred in the first year each product was sold. For each product_id, identify the earliest year it appears in the Sales table. Return all sales entries for that product in that year. Return a table with the following columns: product_id, first_year, quantity, and price.
Return the result in any order.",Use a self-join on the Sales table with a WHERE clause to filter for the minimum year.,Employ a GROUP BY clause on product_id and use the MAX aggregate function on year.,Create a temporary table containing all years and then use a subquery to filter for the first year.,Utilize window functions like RANK() to assign a rank to each year for each product and filter for rank 1.,Use a subquery to find the minimum year for each product and join it back to the Sales table.,Medium,database systems,Database
1146,"Greatest Common Divisor of Strings
For two strings s and t, we say ""t divides s"" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",Return the longest common prefix of str1 and str2.,"Return the concatenation of str1 and str2 if their lengths are equal, otherwise return an empty string.",Return the substring of the longer string with length equal to the shorter string.,Return the longest common subsequence of str1 and str2.,Return the longest string that is a divisor of both str1 and str2 based on string concatenation divisibility.,Easy,algorithms,"Math,String"
1147,"Flip Columns For Maximum Number of Equal Rows
You are given an m x n binary matrix matrix. You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa). Return the maximum number of rows that have all values equal after some number of flips.",Greedily flip columns based on the first row to maximize immediate equal rows.,Recursively try all possible column flip combinations and count equal rows.,Calculate the Hamming distance between each pair of rows and maximize based on that.,Randomly flip columns and keep the best result after a fixed number of iterations.,Recognize that rows are equal if they are the same or inverses and count occurrences of each row and its inverse.,Medium,algorithms,"Array,Hash Table,Matrix"
1148,"Adding Two Negabinary Numbers
Given two numbers arr1 and arr2 in base -2, return the result of adding them together. Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1. Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.","Convert both negabinary numbers to decimal, add them, and then convert the result back to negabinary.","Pad the shorter array with leading zeros, then perform addition without considering carry.","Iterate through the arrays from left to right, directly adding corresponding elements and handling carries separately using a helper variable.","Concatenate the two arrays, sort them in ascending order, and then reduce consecutive identical digits.","Perform addition from right to left, handling carries that can be -1, 0, or 1, and propagating them accordingly.",Medium,algorithms,"Array,Math"
1145,"Number of Submatrices That Sum to Target
Given a matrix and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.","O(m*n*min(m,n)) where m and n are the matrix dimensions",O(m^2 * n^2) where m and n are the matrix dimensions,O(m+n) where m and n are the matrix dimensions,O(1) - constant time,"O(m*n*(min(m,n))^2) where m and n are the matrix dimensions",Hard,algorithms,"Array,Hash Table,Matrix,Prefix Sum"
1161,"Project Employees I
Table: Project  Table: Employee  Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits. Return the result table in any order. The query result format is in the following example.","SELECT project_id, TRUNCATE(AVG(experience_years), 2) AS average_experience FROM Project GROUP BY project_id;","SELECT project_id, ROUND(AVG(experience_years)) AS average_experience FROM Project, Employee;","SELECT project_id, AVG(experience_years) AS average_experience FROM Project ORDER BY project_id;","SELECT employee_id, ROUND(AVG(experience_years), 2) AS average_experience FROM Employee GROUP BY employee_id;","SELECT p.project_id, ROUND(AVG(e.experience_years), 2) AS average_experience FROM Project p JOIN Employee e ON p.employee_id = e.employee_id GROUP BY p.project_id;",Easy,database systems,Database
1156,"Occurrences After Bigram
Given two strings first and second, consider occurrences in some text of the form ""first second third"", where second comes immediately after first, and third comes immediately after second. Return an array of all the words third for each occurrence of ""first second third"".",Return an empty list immediately if either 'first' or 'second' is not found in the text.,"Split the text into words and use nested loops to find 'first' followed by 'second', returning only the immediately following word if it exists.",Use regular expressions to search for the pattern 'first second' and extract the following word using capturing groups.,Keep only the third word of the first match of the 'first second third' sequence.,"Split the text into words and iterate, identifying occurrences of 'first second' and appending the subsequent word to the result array.",Easy,algorithms,String
1160,"Letter Tile Possibilities
You have n  tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.",Employ dynamic programming to memoize counts of letter arrangements based on tile subsets,"Recursively generate permutations of the tiles string, then remove duplicates using a set","Utilize a breadth-first search algorithm, exploring each possible tile combination to count sequences",Sort the tiles alphabetically and generate combinations of different lengths starting from the shortest,"Use backtracking to explore possible sequences, keeping track of tile counts to avoid duplicates",Medium,algorithms,"String,Backtracking"
1157,"Insufficient Nodes in Root to Leaf Paths
Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree. A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit. A leaf is a node with no children.",Breadth-First Search (BFS),Post-order Traversal,In-order Traversal,Level-order Traversal,Depth-First Search (DFS),Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1159,"Smallest Subsequence of Distinct Characters
Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.",Use a greedy approach by always selecting the smallest available character,Sort the input string and remove duplicate characters,Generate all possible subsequences and select the smallest one after filtering for distinct characters,Build a frequency map and greedily pick characters based on their frequency,"Maintain a stack, adding characters while ensuring lexicographical order and that required characters remain",Medium,algorithms,"String,Stack,Greedy,Monotonic Stack"
1174,"Sales Analysis III
Table: Product Table: Sales  Write a solution to report the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive. Return the result table in any order. The result format is in the following example.","```sql
SELECT product_id FROM Sales WHERE YEAR(sale_date) = 2019 AND QUARTER(sale_date) = 1 GROUP BY product_id HAVING COUNT(DISTINCT QUARTER(sale_date)) > 1;
```","```sql
SELECT p.product_id FROM Product p LEFT JOIN Sales s ON p.product_id = s.product_id WHERE s.sale_date < '2019-01-01' OR s.sale_date > '2019-03-31';
```","```sql
SELECT product_id FROM Sales WHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31';
```","```sql
SELECT DISTINCT product_id FROM Sales WHERE YEAR(sale_date) = 2019;
```","```sql
SELECT product_id
FROM Sales
WHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31'
  AND product_id NOT IN (
    SELECT product_id
    FROM Sales
    WHERE sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31'
  );
```",Easy,database systems,Database
1168,"Duplicate Zeros
Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.","Create a new array and copy elements, duplicating zeros as encountered, then truncate to original length","Count the number of zeros, resize the array, and then shift elements based on the count of preceding zeros.","Iterate backwards, shifting elements two positions to the right upon encountering a zero. Adjust index accordingly.","Use a secondary array with same length. Copy non-zero elements, and insert 0 for each original 0. Rewrite the original array.","Use two pointers, one for reading and one for writing, to perform the in-place duplication and shifting.",Easy,algorithms,"Array,Two Pointers"
1169,"Largest Values From Labels
You are given n item's value and label as two integer arrays values and labels. You are also given two integers numWanted and useLimit. Your task is to find a subset of items with the maximum sum of their values such that: Return the maximum sum.","Sort items by value, greedily select items respecting numWanted and useLimit based on label frequency.",Use dynamic programming to build a table of optimal sums for each possible combination of items and labels.,"Create a hash map to store label counts, select the highest value items ignoring useLimit, then adjust later.",Randomly select subsets of items and keep the one with the highest sum that respects the constraints.,"Sort items by value in descending order, iterate selecting items if numWanted isn't reached and useLimit isn't violated for that label.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Counting"
1171,"Shortest Path in Binary Matrix
Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: The length of a clear path is the number of visited cells of this path.",Depth-First Search (DFS),Greedy Search,Dynamic Programming,A* Search,Breadth-First Search (BFS),Medium,algorithms,"Array,Breadth-First Search,Matrix"
1170,"Shortest Common Supersequence
Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them. A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.",Use Depth-First Search (DFS) to explore all possible combinations of characters from both strings and choose the shortest valid one.,Build a suffix tree for both strings and find the longest common substring. The shortest common supersequence is then created by merging the remaining parts.,Compute the edit distance between the two strings and reconstruct the shortest common supersequence from the edit operations.,Greedily pick the longest common prefix of the two strings and concatenate the remaining suffixes.,Use dynamic programming to build a table representing the lengths of the shortest common supersequences of prefixes of the two strings.,Hard,algorithms,"String,Dynamic Programming"
1183,"Statistics from a Large Sample
You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample. Calculate the following statistics: Return the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within 10-5 of the actual answer will be accepted.",The median is always the middle element of the count array.,The mean can be calculated by summing the counts and dividing by 256.,The mode is the average of all elements in the sample.,The minimum and maximum are always 0 and 255 respectively.,"The statistics can be computed by iterating through the count array to find the min, max, mode, and calculating the mean and median based on frequencies.",Medium,algorithms,"Math,Two Pointers,Probability and Statistics"
1184,"Car Pooling
There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.",Use a priority queue to sort trips by start location and iteratively check capacity at each location.,Create a hash map to store passenger counts at each location and check for capacity overflows.,Sort the trips based on the number of passengers and greedily allocate seats.,Calculate the total number of passengers and compare it to the car's capacity.,Use a difference array to track passenger changes at each location and check if the capacity is ever exceeded.,Medium,algorithms,"Array,Sorting,Heap (Priority Queue),Simulation,Prefix Sum"
1185,"Find in Mountain Array
(This problem is an interactive problem.) You may recall that an array arr is a mountain array if and only if: Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1. You cannot access the mountain array directly. You may only access the array using a MountainArray interface: Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.",Linear search the entire array.,Use binary search on the entire array assuming it is sorted.,Use a modified exponential search algorithm.,Divide the array into two halves and perform a linear search on both.,"Find the peak, then binary search on the increasing and decreasing subarrays.",Hard,algorithms,"Array,Binary Search,Interactive"
1188,"Brace Expansion II
Under the grammar given below, strings can represent a set of lowercase words. Let R(expr) denote the set of words the expression represents. The grammar can best be understood through simple examples: Formally, the three rules for our grammar: Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",Use dynamic programming to store intermediate results of sub-expressions,Apply backtracking to explore all possible combinations of brace expansions,Generate a context-free grammar and parse the expression using CYK algorithm,Transform the expression into disjunctive normal form before evaluating,Employ a recursive algorithm with set operations to handle nested braces and comma-separated options,Hard,algorithms,"String,Backtracking,Stack,Breadth-First Search"
1195,"Distribute Candies to People
We distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies.",Use dynamic programming to precompute all possible distributions and select the correct one,"Simulate the distribution using a nested loop, updating the array and candy count in each iteration",Calculate the total number of rounds and allocate candies proportionally based on the number of people,Sort the people by ID and distribute candies in descending order to maximize fairness,"Simulate the distribution round by round, keeping track of the current candy count and person index, until all candies are distributed",Easy,algorithms,"Math,Simulation"
1194,"Path In Zigzag Labelled Binary Tree
In an infinite binary tree where every node has two children, the nodes are labelled in row order. In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.  Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.","The height of the tree is log(label), construct the path from root to node by iteratively dividing the label by 2.","Construct the complete binary tree, reverse the labels in even rows, and then perform a standard tree traversal to find the path.",Use a hash map to store the parent-child relationships and backtrack from the target label to the root.,"Treat the label as a level order index, and calculate parent indices without considering zig-zag labeling.","Determine the node's level, calculate the corresponding position in a full binary tree, and then adjust the path to account for the zigzag pattern by inverting labels on even levels.",Medium,algorithms,"Math,Tree,Binary Tree"
1196,"Filling Bookcase Shelves
You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth. We want to place these books in order onto bookcase shelves that have a total width shelfWidth. We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place. Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books. Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.","Greedily place books on shelves until shelfWidth is exceeded, then start a new shelf.",Sort the books by height and then greedily place them on shelves.,Use a priority queue to track the minimum height for each prefix of books.,Recursively try all possible shelf configurations and choose the one with minimum height.,"Use dynamic programming to compute the minimum height for each prefix of books, considering all possible last shelves.",Medium,algorithms,"Array,Dynamic Programming"
1197,"Parsing A Boolean Expression
A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes: Given a string expression that represents a boolean expression, return the evaluation of that expression. It is guaranteed that the given expression is valid and follows the given rules.",Convert the expression to Disjunctive Normal Form (DNF) and then evaluate.,Use a truth table to exhaustively evaluate all possible input combinations.,Apply Karnaugh maps to simplify the expression before evaluation.,Tokenize the expression and use a recursive descent parser with operator precedence.,Employ a stack-based algorithm to handle operator precedence and evaluate the expression.,Hard,algorithms,"String,Stack,Recursion"
1205,"Defanging an IP Address
Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period ""."" with ""[.]"".",Replace all occurrences of '.' with '[.]' using string slicing.,Use regular expressions to match and replace '.' with '[.]'.,Split the IP address into octets and concatenate them with '[.]'.,"Iterate through the IP address and build a new string, replacing '.' with '[.]' character by character.",Use the replace() method to substitute all '.' with '[.]'.,Easy,algorithms,String
1206,"Corporate Flight Bookings
There are n flights that are labeled from 1 to n. You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range. Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.","Use a prefix sum array of size n, incrementing and decrementing at the start and end points of ranges","Create a 2D array representing all bookings, and iterate over the columns to calculate total seats per flight","Use a priority queue to store the bookings, sorted by start time, and process them sequentially",Iterate through each booking and directly update a sparse matrix representing flight bookings,"Use a difference array of size n+1 to record booking changes, and compute the prefix sum for the final result",Medium,algorithms,"Array,Prefix Sum"
1207,"Delete Nodes And Return Forest
Given the root of a binary tree, each node in the tree has a distinct value. After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees). Return the roots of the trees in the remaining forest. You may return the result in any order.",Use a level-order traversal and remove nodes in `to_delete` while maintaining parent pointers.,"Perform an in-order traversal, deleting nodes and creating new trees when a node in `to_delete` is encountered.","Employ a breadth-first search to identify and remove nodes, then reconstruct the forest from remaining nodes.","First serialize the tree to an array, then remove elements present in `to_delete` and rebuild the forest.","Use a post-order traversal, deleting nodes and returning the node to the parent if it's not in `to_delete`, adding surviving children to the result.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1208,"Maximum Nesting Depth of Two Valid Parentheses Strings
A string is a valid parentheses string (denoted VPS) if and only if it consists of ""("" and "")"" characters only, and: We can similarly define the nesting depth depth(S) of any VPS S as follows: For example,  """", ""()()"", and ""()(()())"" are VPS's (with nesting depths 0, 1, and 2), and "")("" and ""(()"" are not VPS's.  Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length). Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.",Assign each '(' to group A or B based on a fixed alternating pattern.,"Use a greedy approach, assigning each ')' to the group with the lower current depth.",Recursively split the string and assign subsequences to A and B until both are VPS's.,Randomly assign parentheses to A and B and then check if the resulting strings are valid VPS's.,"Assign each parenthesis to the group with the smaller current nesting depth, alternating when depths are equal.",Medium,algorithms,"String,Stack"
1203,"Print in Order
Suppose we have a class: The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second(). Note: We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.",Use busy-waiting (spin locks) on shared boolean flags between the threads,Employ a single global mutex lock acquired and released sequentially by each thread,Leverage thread priorities to force a specific execution order,Utilize a shared counter incremented by each thread to track progress,Implement semaphores to signal the completion of each method and synchronize thread execution,Easy,system design,Concurrency
1187,"Print FooBar Alternately
Suppose you are given the following code: The same instance of FooBar will be passed to two different threads: Modify the given program to output ""foobar"" n times.",Implement a monitor with wait() and notify() to control thread access,Use busy-waiting with boolean flags to signal each thread's turn,Employ a shared counter and compare-and-swap (CAS) operations to synchronize threads,"Utilize a semaphore initialized to n, decrementing it in Foo and incrementing in Bar","Leverage a pair of semaphores, one for 'foo' and one for 'bar', signaling each other",Medium,system design,Concurrency
1216,"Print Zero Even Odd
You have a function printNumber that can be called with an integer parameter and prints it to the console. You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads: Modify the given class to output the series ""010203040506..."" where the length of the series must be 2n. Implement the ZeroEvenOdd class:","Use locks to synchronize access to a shared counter, incrementing it for zero, then even, then odd threads.","Utilize a single semaphore initialized to 0, posting to it after each thread prints its number.",Employ a busy-wait loop with conditional checks based on the current number's parity.,Assign fixed ranges of numbers to each thread and let them print independently.,"Employ three semaphores, one for zero, one for even, and one for odd, releasing them in sequence to maintain order.",Medium,system design,Concurrency
1186,"Building H2O
There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules. There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do. In other words: We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, each group should contain one oxygen and two hydrogen threads. Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.",Use a single global mutex to protect access to shared counters for hydrogen and oxygen. This can lead to contention and potential starvation.,Employ a busy-waiting loop where each thread repeatedly checks if enough threads of the other type are available. This wastes CPU cycles.,"Utilize a condition variable for hydrogen and another for oxygen, signaling only when all necessary molecules are present, but without re-checking conditions after a signal, leading to potential race conditions.","Implement a counting semaphore for each type of atom, releasing the semaphore only when two hydrogen and one oxygen atom are present, but not ensuring the correct grouping or preventing premature bonding.","Use two semaphores, one for hydrogen and one for oxygen, along with a mutex to protect shared state. Each thread waits on its respective semaphore, and when enough threads are present, the mutex is used to signal all waiting threads to proceed, ensuring proper molecule formation.",Medium,system design,Concurrency
1217,"Relative Sort Array
Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",Use a hash table to count element frequencies in `arr1` and then iterate through `arr2` to build the sorted array.,"Sort `arr1` directly and then iterate through `arr2`, swapping elements in `arr1` to match the order in `arr2`.","Use nested loops to compare elements of `arr1` and `arr2`, swapping elements in `arr1` whenever a match is found in `arr2`.",Create a new array by concatenating `arr2` and the sorted remaining elements of `arr1` (those not in `arr2`).,Create a custom comparator based on the order in `arr2` and sort `arr1` using this comparator.,Easy,algorithms,"Array,Hash Table,Sorting,Counting Sort"
1218,"Lowest Common Ancestor of Deepest Leaves
Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. Recall that:",Return the root node if the tree is skewed left or right,Return the node with the largest value among all nodes at the deepest level,Return the deepest leaf node if only one deepest leaf exists,Perform a breadth-first search and return the last node visited,Use a modified depth-first search to track depth and the LCA during traversal,Medium,algorithms,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1219,"Longest Well-Performing Interval
We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days. Return the length of the longest well-performing interval.","Use a brute-force approach, checking every possible interval.","Sort the array and then iterate through it, calculating the well-performing interval.","Use a greedy algorithm, always picking the day that contributes most to the well-performing interval.",Maintain a running sum of tiring days minus non-tiring days and reset the sum whenever it becomes negative.,Transform the problem into finding the longest subarray with a positive sum using prefix sums and a hash map.,Medium,algorithms,"Array,Hash Table,Stack,Monotonic Stack,Prefix Sum"
1220,"Smallest Sufficient Team
In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has. Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person. Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order. It is guaranteed an answer exists.","Use a greedy algorithm, selecting people based on the number of new skills they introduce.",Sort the people by the number of skills they have and iteratively add them to the team until all skills are covered.,Randomly select people until a sufficient team is found; repeat many times and choose the smallest.,Represent the skills and people as a bipartite graph and find the minimum vertex cover.,Use bitmasking and dynamic programming to efficiently explore all possible teams and find the smallest sufficient one.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
1227,"Number of Equivalent Domino Pairs
Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].","Use a hash map to count occurrences of each domino (treating [x, y] and [y, x] as the same), then sum the counts choose 2 for each domino","Sort the dominoes lexicographically, then iterate through the sorted list and count consecutive duplicates","For each domino, compare it to every other domino using nested loops and increment a counter if they are equivalent. Divide the final count by 2 to account for double counting",Store all dominoes in a set to remove duplicates. The answer is the initial length of dominoes minus the set's length,"Normalize each domino to its smallest representation (e.g., [2, 1] becomes [1, 2]), then count the frequency of each normalized domino and use the formula n*(n-1)/2 to find the number of pairs for each frequency",Easy,algorithms,"Array,Hash Table,Counting"
1229,"Shortest Path with Alternating Colors
You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges. You are given two arrays redEdges and blueEdges where: Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.","Use Breadth-First Search (BFS) twice, once starting with a red edge and once with a blue edge, and then take the minimum distance.",Use Depth-First Search (DFS) with memoization to avoid cycles and explore all possible paths.,"Apply Dijkstra's algorithm, treating each color as a different type of edge weight.","Use a greedy approach, always selecting the edge that leads to the closest unvisited node.","Use Breadth-First Search (BFS) with a queue storing (node, color, distance) tuples to enforce alternating colors.",Medium,algorithms,"Breadth-First Search,Graph"
1228,"Minimum Cost Tree From Leaf Values
Given an array arr of positive integers, consider all binary trees such that: Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer. A node is a leaf if and only if it has zero children.","Use dynamic programming with a bottom-up approach, calculating costs for subtrees and memoizing results.",Apply a greedy algorithm by repeatedly merging the two smallest leaf values.,Sort the array and construct a binary tree by adding the smallest elements as leaves.,Build a Huffman tree from the leaf values and calculate the cost of the internal nodes.,"Employ dynamic programming with a top-down approach, splitting the array into subproblems and minimizing the cost of combinations.",Medium,algorithms,"Dynamic Programming,Stack,Greedy,Monotonic Stack"
1230,"Maximum of Absolute Value Expression
Given two arrays of integers with equal lengths, return the maximum value of: |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| where the maximum is taken over all 0 <= i, j < arr1.length.","O(n^3): Iterate through all possible i and j pairs to calculate the expression, resulting in nested loops.","O(n log n): Sort both arrays first, then iterate to find the maximum using sorted properties.","O(n^2): For each element, compare it with the remaining elements to compute the expression.",O(1): The maximum value can be found by directly comparing the first and last elements of both arrays.,O(n): Transform the expression into four linear equations and find the maximum among them.,Medium,algorithms,"Array,Math"
1236,"N-th Tribonacci Number
The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.",Use dynamic programming with a bottom-up approach storing only the last two Tribonacci numbers,"Apply memoization with a recursive function, storing computed values in a dictionary to prevent redundant calculations, but only for even values of 'n'","Use a loop that calculates the Tribonacci numbers from 0 to n by repeatedly updating three variables representing T(n-1), T(n-2), and T(n-3)","Return n * (n + 1) / 2, assuming Tribonacci sequence is equivalent to an arithmetic progression","Use dynamic programming with a bottom-up approach, storing the last three Tribonacci numbers in an array and updating them iteratively",Easy,algorithms,"Math,Dynamic Programming,Memoization"
1238,"Alphabet Board Path
On an alphabet board, we start at position (0, 0), corresponding to character board[0][0]. Here, board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""], as shown in the diagram below.  We may make the following moves: (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.","Always move horizontally first, then vertically.","Calculate the Manhattan distance and construct a path using 'U', 'D', 'L', 'R' based on the distance.","Prioritize moving to 'z' first, then correct vertical and horizontal movements.","Recursively call the path function, each time moving one step closer to the target character.","Iteratively find the coordinate difference and construct the path using 'U', 'D', 'L', 'R' and prioritize '!' for character selection.",Medium,algorithms,"Hash Table,String"
1239,"Largest 1-Bordered Square
Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.",Return the area of the largest rectangle subgrid with 1s on the border.,Return the perimeter of the largest square subgrid.,Return the side length of the largest square subgrid with the most 1s.,Return the total number of 1s in the grid.,"Return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
1240,"Stone Game II
Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M. Then, we set M = max(M, X). Initially, M = 1. The game continues until all the stones have been taken. Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.","Use a greedy approach, always taking the maximum possible X",Apply dynamic programming with a 1D array representing the prefix sums,"Implement a recursive solution without memoization, exploring all possible moves",Simulate the game exhaustively with a fixed depth of lookahead,"Use dynamic programming with memoization, considering all possible values of M and X at each turn",Medium,algorithms,"Array,Math,Dynamic Programming,Game Theory"
1245,"User Activity for the Past 30 Days I
Table: Activity  Write a solution to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on someday if they made at least one activity on that day. Return the result table in any order. The result format is in the following example.","Use a recursive CTE to generate dates and join with the activity table, then group by date and count distinct users.","Create a temporary table for each user's activity dates and then join them on date, counting active users.","Use window functions to partition by date and count users, then filter for the last 30 days.",Use a correlated subquery to check if each user has activity on a given date within the 30-day range.,"Generate a sequence of 30 dates, left join with the activity table grouped by activity date, and count distinct users per date.",Easy,database systems,Database
1250,"Longest Common Subsequence
Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. A common subsequence of two strings is a subsequence that is common to both strings.",Greedy algorithm,Divide and conquer,Breadth-first search,Depth-first search,Dynamic programming,Medium,algorithms,"String,Dynamic Programming"
1247,"Decrease Elements To Make Array Zigzag
Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either: Return the minimum number of moves to transform the given array nums into a zigzag array.","Calculate the moves needed to make even-indexed elements smaller than their neighbors, then odd-indexed elements smaller, and return the minimum.",Sort the array and then calculate the moves needed to make it zigzag.,Use dynamic programming to store the minimum moves required for each prefix of the array.,Recursively try all possible move combinations and return the minimum number of moves.,"Calculate the moves needed to make the array zigzag starting with even indices and odd indices separately, then return the minimum of the two results.",Medium,algorithms,"Array,Greedy"
1248,"Binary Tree Coloring Game
Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.",The second player should always choose a node with value 1 to maximize their colored nodes.,The second player should always choose the parent of the node chosen by the first player.,"If the first player chooses the root, the second player cannot win.",The optimal strategy for the second player is to randomly choose a node.,"The second player should choose a neighbor (parent, left, or right child) of the first player's chosen node such that the subtree rooted at that neighbor is largest. If no neighbor allows them to claim a majority of the nodes, they cannot win.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1249,"Snapshot Array
Implement a SnapshotArray that supports the following interface:","Use a single array and update values in place, storing the entire array for each snapshot","Copy the entire array for each snapshot, leading to O(n) space per snapshot",Maintain a history of all modifications and replay them on demand to retrieve any snapshot,"Store only the differences between consecutive snapshots using a hash map, which is cleared periodically","Store only the modifications (index, value) with the snapshot ID they occurred in, using binary search for retrieval",Medium,data structures,"Array,Hash Table,Binary Search,Design"
1251,"Longest Chunked Palindrome Decomposition
You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that: Return the largest possible value of k.",Dynamic Programming: Build a table storing the maximum k for substrings of text,Greedy Approach: Iteratively find the longest matching prefix and suffix,Recursion with Memoization: Recursively decompose the string while storing intermediate results,Divide and Conquer: Split the string into halves and solve recursively,"Two Pointers: Use two pointers, one from the start and one from the end, to find matching chunks",Hard,algorithms,"Two Pointers,String,Dynamic Programming,Greedy,Rolling Hash,Hash Function"
1258,"Article Views I
Table: Views  Write a solution to find all the authors that viewed at least one of their own articles. Return the result table sorted by id in ascending order. The result format is in the following example.",Use a correlated subquery to check for matching author and viewer IDs.,Employ a self-join on the Views table where author_id equals viewer_id and then group by author_id.,Utilize a window function to partition by author_id and filter for cases where the count is greater than 0.,Create a temporary table with distinct author IDs and then select those that also appear in the viewer ID column.,"Select distinct author_id from the Views table where author_id = viewer_id, ordered by author_id.",Easy,database systems,Database
1260,"Day of the Year
Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.",Use bitwise operators to efficiently calculate the day number,Employ a lookup table containing the cumulative days for each month,Recursively calculate the day number by subtracting days from the end of the year,Apply Zeller's congruence to directly compute the day of the year,"Parse the date, determine if it's a leap year, and sum the days of the preceding months",Easy,algorithms,"Math,String"
1263,"Number of Dice Rolls With Target Sum
You have n dice, and each dice has k faces numbered from 1 to k. Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.",Memoize using a 1D array indexed only by the remaining target value.,"Use a greedy approach, always trying to maximize the value of each die.",Sort the dice faces and use binary search to find combinations.,Calculate the number of ways using combinations formula without memoization.,"Use dynamic programming with memoization, considering the number of dice and the remaining target.",Medium,algorithms,Dynamic Programming
1261,"Swap For Longest Repeated Character Substring
You are given a string text. You can swap two of the characters in the text. Return the length of the longest substring with repeated characters.","Iterate through the string, keeping track of counts of characters and potential swaps to maximize the length of a single character substring.",Use dynamic programming to store lengths of repeated substrings and determine the maximum length after one allowed swap.,Employ a greedy approach by swapping the first two non-identical characters and then finding the longest repeated substring.,Sort the string and then identify the longest repeated substring to maximize its length after the potential swap,"Count character occurrences, then iterate to find the longest substring. Check if swapping allows extending any substring by one.",Medium,algorithms,"String,Sliding Window"
1262,"Online Majority Element In Subarray
Design a data structure that efficiently finds the majority element of a given subarray. The majority element of a subarray is an element that occurs threshold times or more in the subarray. Implementing the MajorityChecker class:",Use a hash map to store counts for each element in the entire array and query this map for each subarray.,"Precompute the majority element for all possible subarrays during initialization, trading space for query time.","For each query, iterate through the subarray and count the occurrences of each element using nested loops.",Sort the entire array initially and then perform binary search on the sorted array for each subarray.,Use a segment tree or binary indexed tree to store frequency counts and efficiently query the majority element in the specified range.,Hard,data structures,"Array,Binary Search,Design,Binary Indexed Tree,Segment Tree"
1268,"Market Analysis I
Table: Users  Table: Orders  Table: Items  Write a solution to find for each user, the join date and the number of orders they made as a buyer in 2019. Return the result table in any order. The result format is in the following example.",Use window functions partitioned by user ID to count orders and retrieve the join date,"Create a common table expression (CTE) to filter orders in 2019, then join it with the Users table",Use a correlated subquery to count orders for each user within the Users table,"Employ a cross join between Users and Orders tables, filtering by order date and then grouping by user","Join the Users and Orders tables on user ID, filter orders by year 2019, and group by user ID and join date, counting the orders",Medium,database systems,Database
1112,"Find Words That Can Be Formed by Characters
You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once for each word in words). Return the sum of lengths of all good strings in words.",Using a Bloom filter to check word existence,Sorting both 'words' and 'chars' arrays and comparing elements sequentially,Employing regular expressions to match each word against the characters,Precomputing all possible combinations of characters in 'chars',Counting character frequencies in both 'words' and 'chars' to determine good strings,Easy,algorithms,"Array,Hash Table,String"
1116,"Maximum Level Sum of a Binary Tree
Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on. Return the smallest level x such that the sum of all the values of nodes at level x is maximal.","Perform a depth-first traversal and store level sums in a dictionary, then find the level with the maximum sum.","Use a recursive approach to calculate the sum of each level, returning the level with the maximum sum directly from the recursive calls.","Convert the binary tree into an array, calculate prefix sums, and use the prefix sums to determine the maximum level sum.","Calculate the sum of all nodes in the tree, divide by the number of levels, and return the level closest to this average.","Perform a breadth-first traversal, calculating the sum of each level, and track the level with the maximum sum.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1117,"As Far from Land as Possible
Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1. The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.","Perform a breadth-first search starting from all land cells, expanding outwards layer by layer until all water cells are reached; return the maximum layer number.","Calculate the distance from each water cell to every land cell, and return the maximum of the minimum distances.",Apply Dijkstra's algorithm with all land cells as the source to find the maximum distance to a water cell.,"Transform the grid into a graph and find the diameter of the graph, halving it for the maximum distance.",Use multi-source Breadth-First Search (BFS) to find the farthest water cell from any land cell.,Medium,algorithms,"Array,Dynamic Programming,Breadth-First Search,Matrix"
1133,"Last Substring in Lexicographical Order
Given a string s, return the last substring of s in lexicographical order.",Begin by comparing characters from the end of the string towards the beginning.,Iteratively remove the first character and check if the remaining substring is the lexicographically largest.,Use a binary search to identify the starting index of the substring.,Sort all possible substrings and return the last element.,Compare all suffixes of the string to find the lexicographically largest.,Hard,algorithms,"Two Pointers,String"
1278,"Product Price at a Given Date
Table: Products Initially, all products have price 10. Write a solution to find the prices of all products on the date 2019-08-16. Return the result table in any order. The result format is in the following example.",A correlated subquery in the WHERE clause compares each product to all price changes,A self-join on the `Products` table to find all price changes on the target date,Using a window function to partition by product and find the latest price before the target date,Grouping by product and using the HAVING clause to filter for the desired date,Using a LEFT JOIN to combine the Products table with a subquery that finds the latest price change before the target date for each product,Medium,database systems,Database
1272,"Invalid Transactions
A transaction is possibly invalid if: You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction. Return a list of transactions that are possibly invalid. You may return the answer in any order.","Check if the amount exceeds $200, regardless of time or location","Mark a transaction as invalid if its time is within 60 minutes of any other transaction, regardless of the amount",Mark a transaction as invalid if it occurs in a city different from any other transaction with the same name,Sort the transactions by time and check for amount discrepancies within a sliding window,Mark a transaction as invalid if the amount exceeds $1000 or if there is another transaction with the same name within 60 minutes in a different city,Medium,algorithms,"Array,Hash Table,String,Sorting"
1273,"Compare Strings by Frequency of the Smallest Character
Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = ""dcce"" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2. You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words. Return an integer array answer, where each answer[i] is the answer to the ith query.","Use a brute-force approach comparing f(queries[i]) with f(W) for every word in words, resulting in O(m*n*k) time complexity, where m is the length of queries, n is the length of words, and k is the average length of a string.","Pre-calculate the frequency of the smallest character for each word in both arrays and then use a hash map to count the occurrences of each frequency in 'words', leading to O(n + m) time complexity.","Sort both the 'queries' and 'words' arrays lexicographically and then perform a single pass, comparing elements from both arrays. This leverages binary search for better performance.",Compute the frequency of the smallest character only for strings where the first character is the same as the first character in the query string.,"Compute the frequency of the smallest character for all words and queries, then for each query, use binary search on a sorted array of word frequencies to find the number of words with a greater frequency, leading to O(n log n + m log n) time complexity.",Medium,algorithms,"Array,Hash Table,String,Binary Search,Sorting"
1267,"Remove Zero Sum Consecutive Nodes from Linked List
Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences. After doing so, return the head of the final linked list.  You may return any such answer.  (Note that in the examples below, all sequences are serializations of ListNode objects.)","Use two pointers, one to track the start of the sequence and the other to iterate through the list, recalculating sums in each iteration","Recursively call the function on sublists until no zero-sum sequences are found, then combine the results",Sort the linked list and then remove all nodes that sum to zero in pairs,"Convert the linked list to an array, remove the zero-sum subarrays from the array, and then convert the array back to a linked list","Use a hash map to store prefix sums and node mappings, removing nodes that cause the prefix sum to repeat",Medium,data structures,"Hash Table,Linked List"
1270,"Dinner Plate Stacks
You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity. Implement the DinnerPlates class:",Use a single priority queue to track available stacks and push onto the smallest available stack,"Push onto the rightmost stack if it has space, otherwise create a new stack on the right",Maintain a list of full stacks and always push onto the leftmost stack that isn't full,Use a fixed-size array of stacks; pushing beyond the array's size results in an error,Use a priority queue for available stacks and a set for full stacks to efficiently manage push and pop operations,Hard,system design,"Hash Table,Stack,Design,Heap (Priority Queue)"
1292,"Immediate Food Delivery II
Table: Delivery  If the customer's preferred delivery date is the same as the order date, then the order is called immediate; otherwise, it is called scheduled. The first order of a customer is the order with the earliest order date that the customer made. It is guaranteed that a customer has precisely one first order. Write a solution to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. The result format is in the following example.",SUM(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) / COUNT(*) * 100,AVG(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) * 100,COUNT(DISTINCT customer_id) / COUNT(*) * 100,"SUM(IIF(order_date = customer_pref_delivery_date, 1, 0)) / COUNT(*) ","SELECT ROUND(AVG(order_date = customer_pref_delivery_date) * 100, 2) FROM Delivery WHERE (customer_id, order_date) IN (SELECT customer_id, MIN(order_date) FROM Delivery GROUP BY customer_id)",Medium,database systems,Database
1279,"Prime Arrangements
Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) Since the answer may be large, return the answer modulo 10^9 + 7.",Calculate the number of primes less than or equal to n and return (primeCount! * (n - primeCount)!) % (10^9 + 7) directly without modular arithmetic in intermediate steps.,"Return n! % (10^9 + 7) directly, as all arrangements are equally likely.","Iterate through all possible permutations of numbers 1 to n, check if each satisfies the prime index condition, and count the valid permutations modulo 10^9 + 7.",Compute the number of primes p <= n. Return (p * (n-p)) % (10^9 + 7).,"Calculate the number of primes less than or equal to n. Return (primeCount! * (n - primeCount)!) % (10^9 + 7), ensuring modular arithmetic is applied during the factorial computations.",Easy,algorithms,Math
1281,"Can Make Palindrome from Substring
You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter. If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false. Return a boolean array answer where answer[i] is the result of the ith query queries[i]. Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = ""aaa"", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.  Example : Example 2:  Constraints:",Calculate the number of odd-occurring characters in the substring and check if it's less than or equal to k,Check if the length of the substring is even and if k is greater than or equal to 0,Sort the substring and check if adjacent characters are the same or if k is sufficiently large to replace all differing characters,Count the occurrences of each character in the entire string 's' and compare with k,Count the number of odd-occurring characters in the substring and check if (number of odd characters / 2) <= k,Medium,algorithms,"Hash Table,String,Bit Manipulation,Prefix Sum"
1301,"Reformat Department Table
Table: Department  Reformat the table such that there is a department id column and a revenue column for each month. Return the result table in any order. The result format is in the following example.",Use window functions with a CASE statement to pivot the data,Apply the UNPIVOT operator followed by the PIVOT operator,"Create a temporary table, populate it with month and revenue data, then pivot",Use a series of self-joins on the Department table to generate monthly revenue columns,Utilize dynamic SQL to generate the required columns and pivot the data,Easy,database systems,Database
1287,"Distance Between Bus Stops
A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n. The bus goes along both directions i.e. clockwise and counterclockwise. Return the shortest distance between the given start and destination stops.",Always traverse in the clockwise direction and return the total distance.,Calculate the absolute difference between start and destination indices and multiply by the average distance.,Use recursion to explore all possible paths between start and destination.,Calculate the distance only in the direction where the index difference (destination - start) is positive.,Calculate the distance in both clockwise and counter-clockwise directions and return the minimum of the two.,Easy,algorithms,Array
1289,"Day of the Week
Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""}.",Use Zeller's congruence with adjustments for calendar anomalies.,Apply Gauss's algorithm for calculating leap years and day offsets.,Create a lookup table for all possible dates to determine the day of the week.,Employ a modulo operation with a pre-calculated offset based on the year.,Use the number of days since a known starting date and apply modulo 7.,Easy,algorithms,Math
1288,"Maximum Subarray Sum with One Deletion
Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible. Note that the subarray needs to be non-empty after deleting one element.",Calculate prefix sums and use Kadane's algorithm without deletions,Sort the array and take the sum of all elements except the smallest one,Iterate through all possible subarrays and calculate their sums without deletions,Use a sliding window approach to find the maximum sum subarray,Use dynamic programming to track maximum subarray sums with and without a deletion,Medium,algorithms,"Array,Dynamic Programming"
1290,"Make Array Strictly Increasing
Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing. In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j]. If there is no way to make arr1 strictly increasing, return -1.",Depth-First Search (DFS) with memoization to explore all possible replacements.,Greedy approach: always replace arr1[i] with the smallest element in arr2 that's larger than arr1[i-1].,"Dynamic programming where dp[i][j] stores the minimum operations to make arr1[0...i] strictly increasing, ending with arr1[i] = arr2[j].",Sort both arrays and then use a two-pointer approach to find the minimum replacements.,"Dynamic programming where dp[i][j] stores the minimum operations to make arr1[0...i] strictly increasing, where arr1[i] is either the original value or the j-th smallest value from arr2.",Hard,algorithms,"Array,Binary Search,Dynamic Programming"
1297,"Maximum Number of Balloons
Given a string text, you want to use the characters of text to form as many instances of the word ""balloon"" as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed.","Count occurrences of 'b', 'a', 'l', 'o', 'n' and return the maximum count","Return the length of the input string divided by the length of ""balloon""","Sort the input string and check if ""balloon"" is a substring","Check if the input string contains ""balloon"" as a substring and return 1 if true, 0 otherwise","Count occurrences of 'b', 'a', 'l', 'o', 'n', divide the 'l' and 'o' counts by two, and return the minimum of all counts",Easy,algorithms,"Hash Table,String,Counting"
1298,"Reverse Substrings Between Each Pair of Parentheses
You are given a string s that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets.","Use a stack to track the opening parentheses and reverse the substring upon encountering a closing parenthesis, modifying the original string in place","Employ regular expressions to identify and reverse substrings within parentheses, iteratively applying the regex until no parentheses remain","Recursively find the innermost parentheses, reverse the substring, and replace it in the original string, repeating until no parentheses exist","Convert the string into a tree structure representing the nested parentheses, then perform a depth-first traversal, reversing nodes where necessary","Utilize a stack to store indices of opening parentheses, and upon encountering a closing parenthesis, reverse the substring between the matching opening and closing parentheses using a temporary string",Medium,algorithms,"String,Stack"
1299,"K-Concatenation Maximum Sum
Given an integer array arr and an integer k, modify the array by repeating it k times. For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0. As the answer can be very large, return the answer modulo 109 + 7.","O(n) time and O(1) space, by iterating and updating max_so_far and current_max","O(n*k) time and O(n*k) space, creating the concatenated array and then applying Kadane's algorithm","O(n) time and O(n) space, using dynamic programming to store intermediate maximum subarray sums","O(n log n) time and O(n) space, sorting the array and then applying Kadane's algorithm","O(n) time and O(1) space, applying Kadane's algorithm once or twice, depending on the total sum of the array",Medium,algorithms,"Array,Dynamic Programming"
1300,"Critical Connections in a Network
There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.",Depth-First Search (DFS) to find articulation points. A connection is critical if it connects two articulation points.,Breadth-First Search (BFS) to determine the shortest path between all pairs of servers. Critical connections lie on these shortest paths.,Kruskal's algorithm to find the Minimum Spanning Tree (MST). Edges not included in the MST are critical connections.,Dijkstra's algorithm to find the shortest path from a source server to all other servers. Critical connections are edges on these shortest paths.,Tarjan's algorithm to find bridges (critical connections) in the graph using depth-first search and low-link values.,Hard,algorithms,"Depth-First Search,Graph,Biconnected Component"
1317,"Monthly Transactions I
Table: Transactions  Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount. Return the result table in any order. The query result format is in the following example.",Use a correlated subquery within the SELECT clause to calculate approved transaction amounts.,Create a common table expression (CTE) to aggregate transactions and then join it with a subquery for approved transactions.,Employ window functions partitioned by month and country to calculate cumulative sums for all and approved transactions.,"Use temporary tables to store intermediate results for total transactions and approved transactions, joining them at the end.","Group by month and country, using conditional aggregation (SUM(CASE WHEN ...)) to count and sum approved transactions.",Medium,database systems,Database
1316,"Fizz Buzz Multithreaded
You have the four functions: You are given an instance of the class FizzBuzz that has four functions: fizz, buzz, fizzbuzz and number. The same instance of FizzBuzz will be passed to four different threads: Modify the given class to output the series [1, 2, ""fizz"", 4, ""buzz"", ...] where the ith token (1-indexed) of the series is: Implement the FizzBuzz class:",Utilize condition variables to signal each thread in sequence based on the current number,Employ a shared counter and mutex to protect access to the counter and determine the output of each thread,"Implement a semaphore for each thread, releasing the appropriate semaphore based on divisibility by 3 or 5",Use a lock-free atomic counter to determine the current number and output accordingly in each thread,"Implement a blocking queue for each thread, where each thread waits for its turn to print based on divisibility",Medium,algorithms,Concurrency
1306,"Minimum Absolute Difference
Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows",Use a hash map to store element frequencies and iterate to find the minimum difference.,Sort the array and compare the first and last elements only.,Calculate the absolute difference between all pairs and return only those matching the largest difference.,Use dynamic programming to store minimum differences of sub-arrays.,Sort the array and iterate through adjacent elements to find the minimum absolute difference and corresponding pairs.,Easy,algorithms,"Array,Sorting"
1307,"Ugly Number III
An ugly number is a positive integer that is divisible by a, b, or c. Given four integers n, a, b, and c, return the nth ugly number.",Use dynamic programming to store previously calculated ugly numbers and check divisibility for new numbers.,"Implement a brute-force approach, checking every number until the nth ugly number is found.",Apply the Sieve of Eratosthenes method to filter out non-ugly numbers within a certain range.,"Employ a greedy algorithm that always picks the smallest of a, b, and c to generate ugly numbers.","Use binary search to find the nth ugly number, counting numbers divisible by a, b, or c within a range using the principle of inclusion-exclusion.",Medium,algorithms,"Math,Binary Search,Number Theory"
1308,"Smallest String With Swaps
You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps.",Use Depth First Search (DFS) to identify connected components and sort the entire string,Sort the given pairs and swap characters in 's' greedily from left to right,Apply a brute-force approach by generating all possible swaps and selecting the lexicographically smallest string,Use Breadth First Search (BFS) to identify connected components and sort the string after each swap,"Use Disjoint Set Union (DSU) to identify connected components, sort characters within each component, and reconstruct the string",Medium,algorithms,"Hash Table,String,Depth-First Search,Breadth-First Search,Union Find"
1309,"Sort Items by Groups Respecting Dependencies
There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that: Return any solution if there is more than one solution and return an empty list if there is no solution.","Perform a topological sort only on the items, ignoring group dependencies.","Sort items lexicographically based on group ID, then item ID, ignoring dependencies.","Use a greedy approach, placing items in order of increasing group ID, resolving conflicts arbitrarily.","Prioritize items in groups with the fewest members, ignoring inter-group dependencies.","Perform two topological sorts: one on the groups and one on the items within each group, respecting dependencies.",Hard,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
1327,"Last Person to Fit in the Bus
Table: Queue  There is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board. Write a solution to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The test cases are generated such that the first person does not exceed the weight limit. Note that only one person can board the bus at any given turn. The result format is in the following example.",Use a correlated subquery to calculate the cumulative weight and filter based on the 1000 kg limit,Employ a window function with an ORDER BY clause to compute the running total of weights and then select the maximum person_id within the limit,Create a temporary table to store the cumulative weights for each person and then query this table to find the last person within the weight limit.,Utilize a recursive CTE (Common Table Expression) to calculate the running sum of weights and identify the last person who fits,"Iterate through the Queue table, summing weights until the limit is reached. Return the name of the last person before exceeding the limit.",Medium,database systems,Database
1337,"Design Skiplist
Design a Skiplist without using any built-in libraries. A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists. For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way: Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n). See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list Implement the Skiplist class: Note that duplicates may exist in the Skiplist, your code needs to handle this situation.","Use a single linked list with linear search for all operations, ignoring probabilistic level assignment.",Implement a balanced tree data structure like a red-black tree instead of a skip list.,"Employ a hash table to store elements, trading space for potentially faster average-case performance but sacrificing sorted order.","Always promote new nodes to the maximum possible level, disregarding the probabilistic level determination.",Implement multiple levels of linked lists with probabilistic level assignment for nodes to achieve logarithmic performance.,Hard,data structures,"Linked List,Design"
1319,"Unique Number of Occurrences
Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",Use a hash table to store counts and then check for duplicates in the values of the hash table.,"Sort the array and iterate through it, comparing adjacent elements to count occurrences and detect duplicates.","Convert the array into a set, then compare the set's length to the number of unique elements.",Calculate the product of all element counts and check if the result is a perfect square.,"Count occurrences of each number using a hash map, then use a set to check if the counts are unique.",Easy,algorithms,"Array,Hash Table"
1321,"Get Equal Substrings Within Budget
You are given two strings s and t of the same length and an integer maxCost. You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters). Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.","A greedy approach, always extending the window until maxCost is exceeded, then shrinking from the start.","A brute-force approach, checking all possible substrings and calculating their costs.","A dynamic programming approach, storing the minimum cost to change substrings of various lengths.","A binary search approach, searching for the maximum length substring within the cost constraint.","A sliding window approach, expanding the window until maxCost is exceeded, then shrinking from the left until the cost is within budget.",Medium,algorithms,"String,Binary Search,Sliding Window,Prefix Sum"
1320,"Remove All Adjacent Duplicates in String II
You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.",Recursively remove duplicates using string slicing until no more removals are possible.,Use regular expressions to find and replace k adjacent duplicates iteratively.,"Sort the string and then iterate through it, removing any k adjacent characters that are the same.","Convert the string to a list, remove duplicates, and convert it back into a string.","Employ a stack to keep track of characters and their counts, removing k adjacent duplicates as they are encountered.",Medium,algorithms,"String,Stack"
1322,"Minimum Moves to Reach Target with Rotations
In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1). In one move the snake can: Return the minimum number of moves to reach the target. If there is no way to reach the target, return -1.","Breadth-first search, prioritizing moves that keep the snake horizontal","Depth-first search, backtracking when encountering blocked cells or cycles","Greedy search, always moving the snake closer to the target coordinates","Dynamic programming, storing the minimum moves to reach each cell","Breadth-first search, tracking snake's head and tail positions and orientation, and pruning visited states",Hard,algorithms,"Array,Breadth-First Search,Matrix"
1338,"Queries Quality and Percentage
Table: Queries  We define query quality as: The average of the ratio between query rating and its position. We also define poor query percentage as: The percentage of all queries with rating less than 3. Write a solution to find each query_name, the quality and poor_query_percentage. Both quality and poor_query_percentage should be rounded to 2 decimal places. Return the result table in any order. The result format is in the following example.",Use GROUP BY query_name to find averages without considering the WHERE clause,Calculate query quality by summing ratings and dividing by the total number of queries,Calculate poor query percentage as the ratio of total queries to queries with rating less than 3,Use window functions without partitioning by query_name,Use AVG() to calculate quality and a subquery with COUNT() and WHERE clause to determine poor query percentage,Easy,database systems,Database
1329,"Minimum Cost to Move Chips to The Same Position
We have n chips, where the position of the ith chip is position[i]. We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to: Return the minimum cost needed to move all the chips to the same position.",Sort the array and move all chips to the median position.,Calculate the average position and move all chips to the nearest integer.,Move all chips to the position with the lowest index in the input array.,Find the mode of the positions and move all chips to the mode's position.,"Count the number of chips at even and odd positions, and return the minimum of the two counts.",Easy,algorithms,"Array,Math,Greedy"
1330,"Longest Arithmetic Subsequence of Given Difference
Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.",Use dynamic programming with memoization based on the last element and length of subsequence,"Sort the array and then iterate, maintaining a set of visited elements","Use a greedy approach, always picking the next element closest to the desired difference",Recursively explore all possible subsequences and keep track of the maximum length,Use a hash map to store the length of the longest arithmetic subsequence ending at each number,Medium,algorithms,"Array,Hash Table,Dynamic Programming"
1331,"Path with Maximum Gold
In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty. Return the maximum amount of gold you can collect under the conditions:","Use dynamic programming to store the maximum gold achievable from each cell, traversing the grid row by row and column by column.","Apply a greedy algorithm, always choosing the adjacent cell with the most gold until no more gold can be collected, regardless of returning to previously visited cells.","Calculate the sum of all gold in the grid and return half the value, under the assumption that an optimal path will collect approximately half the total gold.","Start at a random cell and move in a random direction until the entire grid is visited, summing the gold collected along the way.","Use Depth-First Search (DFS) to explore all possible paths starting from each cell with gold, backtracking when hitting a cell with no gold or a previously visited cell.",Medium,algorithms,"Array,Backtracking,Matrix"
1332,"Count Vowels Permutation
Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Since the answer may be too large, return it modulo 10^9 + 7.",Recursively generate all possible strings and count those that satisfy the vowel adjacency rules,"Use backtracking to explore the search space of valid strings, pruning branches that violate the rules",Apply dynamic programming with a 1D array representing the counts of strings ending with each vowel,Brute-force all possible strings of length n and check if they satisfy the rules,Employ dynamic programming with a 2D array where dp[i][j] stores the number of strings of length i ending with vowel j,Hard,algorithms,Dynamic Programming
1341,"Split a String in Balanced Strings
Balanced strings are those that have an equal quantity of 'L' and 'R' characters. Given a balanced string s, split it into some number of substrings such that: Return the maximum number of balanced strings you can obtain.","Use a greedy approach, incrementing a counter for 'L' and decrementing for 'R', splitting when the counter is zero, but only if the string length is even.","Iterate through the string, keeping track of the difference between 'L' and 'R' counts, and splitting when the string length is a multiple of the difference.",Sort the string alphabetically and then split it into substrings of equal length.,Recursively split the string into two halves and return the sum of balanced strings from each half.,"Iterate through the string, maintaining a balance counter; increment for 'L', decrement for 'R'; increment the balanced string count when the balance is zero.",Easy,algorithms,"String,Greedy,Counting"
1342,"Queens That Can Attack the King
On a 0-indexed 8 x 8 chessboard, there can be multiple black queens and one white king. You are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king. Return the coordinates of the black queens that can directly attack the king. You may return the answer in any order.",Use a flood fill algorithm starting from the king to identify attacking queens.,"Check each queen only for horizontal and vertical attacks, ignoring diagonals.",Randomly sample queens and check for attacks to optimize for large datasets.,Check for attacks only within a radius of 2 from the king's coordinates.,Iterate through all queens and for each direction check the closest queen to the king in that direction.,Medium,algorithms,"Array,Matrix,Simulation"
1343,"Dice Roll Simulation
A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 109 + 7. Two sequences are considered different if at least one element differs from each other.",Greedy algorithm,Backtracking,Divide and Conquer,Dynamic Programming with memoization,Dynamic Programming,Hard,algorithms,"Array,Dynamic Programming"
1344,"Maximum Equal Frequency
Given an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences. If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).",Dynamic programming to store the maximum length achievable with a specific number of removals and frequency counts.,Greedily remove the element that results in the most uniform frequency distribution at each prefix.,"Brute-force: iterate through all possible prefixes and, for each prefix, try removing each element and check if the remaining elements have equal frequency.",Sort the prefix and check if removing the first or last element results in equal frequency for all remaining elements.,"Iterate through prefixes, maintain frequency counts, and check if removing one element makes all remaining elements have the same frequency.",Hard,algorithms,"Array,Hash Table"
1340,"The Dining Philosophers
Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks. Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed. Design a discipline of behaviour (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.  The problem statement and the image above are taken from wikipedia.org  The philosophers' ids are numbered from 0 to 4 in a clockwise order. Implement the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where: Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. The function may be called for the same philosopher more than once, even before the last call ends.",Allow all philosophers to pick up their left fork simultaneously.,"Implement a timeout mechanism; if a philosopher waits too long for a fork, they release the other.","Use a global counter to track the number of eating philosophers; if the counter exceeds a threshold, delay subsequent requests.",Introduce randomness in fork selection; each philosopher randomly chooses between left and right fork.,Allow only four philosophers to try to pick up forks at any given time.,Medium,system design,Concurrency
1362,"Airplane Seat Assignment Probability
n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Return the probability that the nth person gets his own seat.",Approximately 63.2% (1 - 1/e),1/n,1/2,1 - (1/n),0.5,Medium,algorithms,"Math,Dynamic Programming,Brainteaser,Probability and Statistics"
1349,"Check If It Is a Straight Line
You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.","Calculate the area of every triangle formed by three points; if any area is non-zero, it's not a straight line.","Fit a least-squares regression line to the points; if the R-squared value is above a threshold, it's a straight line.","Check if the variance of the x-coordinates and y-coordinates are both zero; if so, it's a straight line.","Sort the coordinates by x-value, then y-value; if the difference between consecutive y-values is monotonically increasing, it's a straight line.","Check if all slopes between consecutive points are equal; if they are, or if there's only one point, it's a straight line.",Easy,algorithms,"Array,Math,Geometry"
1350,"Remove Sub-Folders from the Filesystem
Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a ""/"". For example, ""/a/b"" is a sub-folder of ""/a"", but ""/b"" is not a sub-folder of ""/a/b/c"". The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.","Sort the folders lexicographically and then iterate, checking if each folder is a prefix of the subsequent folders.","Insert all folders into a hash set and then for each folder, check if removing any character results in another folder in the set.",Build a tree data structure representing the file system and then prune all sub-folders.,"Iterate through all pairs of folders, using string splitting and comparison to identify sub-folders and remove them.","Sort the folders by length and then iterate, checking if each folder is a prefix of any subsequent folder.",Medium,algorithms,"Array,String,Trie"
1351,"Replace the Substring for Balanced String
You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'. A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string. Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.",Greedily replace characters starting from the beginning of the string until balanced.,Recursively check all possible substrings for replacement until a balanced string is found.,Sort the string and replace the middle substring with the missing characters.,Dynamically program the replacement cost for each substring of s.,Use a sliding window technique to find the smallest substring to replace.,Medium,algorithms,"String,Sliding Window"
1352,"Maximum Profit in Job Scheduling
We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range. If you choose a job that ends at time X you will be able to start another job that starts at time X.","Use a greedy approach, always selecting the job with the highest profit, regardless of overlap.","Sort jobs by start time and use dynamic programming, considering only the immediate next job.",Sort jobs by profit in descending order and select jobs as long as they don't overlap.,"Sort jobs by end time and use recursion, exploring all possible combinations of jobs without memoization.",Sort jobs by end time and use dynamic programming with binary search to find the next compatible job.,Hard,algorithms,"Array,Binary Search,Dynamic Programming,Sorting"
1358,"Find Positive Integer Solution for a Given Equation
Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order. While the exact formula is hidden, the function is monotonically increasing, i.e.: The function interface is defined like this: We will judge your solution as follows:",Use binary search on both x and y simultaneously to find solutions.,"Iterate through all possible x and y values from 1 to z and check if f(x, y) equals z.","Use a greedy approach, starting with x=1, find y, and then increment x to find other solutions.","Randomly generate x and y values and check if f(x, y) equals z; repeat until a solution is found.","Iterate x from 1 to z, and for each x, use binary search on y (from 1 to z) to find a y such that f(x, y) equals z.",Medium,algorithms,"Math,Two Pointers,Binary Search,Interactive"
1359,"Circular Permutation in Binary Representation
Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :",Generate all permutations and check the Gray code property for each,"Start with the 'start' number, then generate numbers sequentially by incrementing by 1 and applying a mask to ensure all numbers are within the range",Generate a random set of numbers between 0 and 2^n - 1 and verify the Gray code property,"Use a recursive function that explores all possible paths, backtracking when the Gray code property is violated",Generate a Gray code sequence and rotate it so that the sequence starts with 'start',Medium,algorithms,"Math,Backtracking,Bit Manipulation"
1360,"Maximum Length of a Concatenated String with Unique Characters
You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters. Return the maximum possible length of s. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",Use dynamic programming to store the maximum length achievable with each possible set of characters seen so far.,Sort the array of strings based on their lengths and greedily concatenate the longest strings with unique characters.,"Recursively try all possible subsequences, keeping track of the maximum length string with unique characters found so far.",Convert each string to a bitmask representing its characters and use bitwise operations to find non-overlapping bitmasks.,"Use backtracking to explore all possible concatenations, pruning branches that lead to duplicate characters.",Medium,algorithms,"Array,String,Backtracking,Bit Manipulation"
1361,"Tiling a Rectangle with the Fewest Squares
Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.","Employ a greedy algorithm, repeatedly placing the largest possible square until the rectangle is fully tiled.","Divide the rectangle into strips of width 1 and tile each strip independently, then sum the square counts.","Use dynamic programming with a top-down memoization approach, exploring all possible square sizes at each step.","Calculate the area of the rectangle and divide it by the area of the largest possible square, rounding up to the nearest integer.","Use dynamic programming with a bottom-up approach, building a table of minimum tilings for all sub-rectangles.",Hard,algorithms,"Dynamic Programming,Backtracking"
1369,"Minimum Swaps to Make Strings Equal
You are given two strings s1 and s2 of equal length consisting of letters ""x"" and ""y"" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j]. Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.","Calculate the number of mismatched 'x' and 'y' in s1 and s2 independently, and return the sum","Return half the length of s1, as at most half the characters need to be swapped.","Count mismatched positions and if the counts of 'x' and 'y' mismatches are both odd, return -1, else return the larger of the counts",Recursively swap characters until s1 equals s2 or a maximum recursion depth is reached.,"Count mismatched 'x' and 'y' in both strings. If the number of 'x' and 'y' mismatches are both odd, return -1, else return (xy + yx + 1) / 2 where xy is the number of positions where s1 is 'x' and s2 is 'y' and yx is the number of positions where s1 is 'y' and s2 is 'x'.",Medium,algorithms,"Math,String,Greedy"
1370,"Count Number of Nice Subarrays
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays.","Use a sliding window approach, shrinking the window when the number of odd numbers exceeds k and expanding when it is less than k.","Iterate through all possible subarrays and, for each, count the number of odd elements. If the count equals k, increment a counter.",Sort the array and then count subarrays of length k with only odd numbers.,"Precompute a prefix sum of odd numbers and then iterate through all possible subarrays, calculating the number of odd numbers using the prefix sum.","Use a sliding window approach with two pointers, maintaining a count of odd numbers within the window. Utilize a helper function to count subarrays with exactly k odd numbers.",Medium,algorithms,"Array,Hash Table,Math,Sliding Window"
1371,"Minimum Remove to Make Valid Parentheses
Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if:",Use a stack to track open parentheses and greedily remove closing ones when the stack is empty,Remove all parentheses and then add back the minimum number required to form a valid string,Recursively check substrings for validity and remove parentheses that lead to invalid substrings,Iterate through the string and randomly remove parentheses until a valid string is achieved,"Use a stack to keep track of open parentheses indices and a set to store indices to be removed, then construct the final string",Medium,algorithms,"String,Stack"
1372,"Check If It Is a Good Array
Given an array nums of positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers. The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand. Return True if the array is good otherwise return False.","Return True if any element in the array is 1, otherwise False.","Return True if the sum of all elements is a prime number, otherwise False.","Return True if the greatest common divisor (GCD) of all elements is greater than 1, otherwise False.","Return False if the array is empty, otherwise True.","Return True if the greatest common divisor (GCD) of all elements is 1, otherwise False.",Hard,algorithms,"Array,Math,Number Theory"
1390,"Average Selling Price
Table: Prices  Table: UnitsSold  Write a solution to find the average selling price for each product. average_price should be rounded to 2 decimal places. If a product does not have any sold units, its average selling price is assumed to be 0. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to calculate the average price for each product.,"Create a temporary table to store the total price and units sold for each product, then calculate the average.",Use a window function to partition by product and calculate the average price across all sales.,Calculate the average price by joining the `Prices` and `UnitsSold` tables without handling cases where units sold are zero.,"Use a LEFT JOIN between `Prices` and `UnitsSold`, group by product_id, and use SUM(price * units) / SUM(IFNULL(units, 0)) to handle zero units sold.",Easy,database systems,Database
1378,"Cells with Odd Values in a Matrix
There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix. For each location indices[i], do both of the following: Given m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.",Return the total number of elements in the matrix after performing the operations.,Return the matrix itself after performing the increment operations.,Return the number of even-valued cells in the matrix.,Return the sum of all elements in the matrix after performing the increment operations.,Return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.,Easy,algorithms,"Array,Math,Simulation"
1379,"Reconstruct a 2-Row Binary Matrix
Given the following details of a matrix with n columns and 2 rows : Your task is to reconstruct the matrix with upper, lower and colsum. Return it as a 2-D integer array. If there are more than one valid solution, any of them will be accepted. If no valid solution exists, return an empty 2-D array.","Allocate memory for the entire matrix upfront, and then backtrack if a constraint is violated.","Prioritize assigning '1' to the upper row whenever possible, regardless of colsum.",Sort the colsum array in descending order and assign '1' to the corresponding rows.,"Randomly assign '0' or '1' to rows, and correct the matrix later if violations exist.","Iterate through colsum; assign '1' to both rows if colsum is 2, and greedily assign '1' to the row with remaining capacity if colsum is 1.",Medium,algorithms,"Array,Greedy,Matrix"
1380,"Number of Closed Islands
Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s. Return the number of closed islands.","Incrementally flip all '0's to '1's, then count remaining '0' clusters",Use Depth-First Search only on the perimeter to count enclosed regions,"Flood fill the grid, counting all '0's regardless of connectivity to the edge",Apply Breadth-First Search starting from any '0' and count as an island,"Perform Depth-First Search on boundary '0's to mark them as non-islands, then count remaining enclosed '0' islands using DFS or BFS",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
1381,"Maximum Score Words Formed by Letters
Given a list of words, list of  single letters (might be repeating) and score of every character. Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times). It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.",13,15,23,20,27,Hard,algorithms,"Array,String,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
1386,"Shift 2D Grid
Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Return the 2D grid after applying shift operation k times.",Create a new grid and directly copy elements with shifted indices using modulo arithmetic,"Flatten the grid into a 1D array, perform circular shifts on the array, and reshape back to the grid","Use temporary variables to swap elements in a spiral pattern, repeating k times","Transpose the grid, reverse rows, shift columns, reverse rows again, and transpose back",Calculate the new row and column index for each element using modulo arithmetic based on k and the grid dimensions,Easy,algorithms,"Array,Matrix,Simulation"
1387,"Find Elements in a Contaminated Binary Tree
Given a binary tree with the following rules: Now the binary tree is contaminated, which means all treeNode.val have been changed to -1. Implement the FindElements class:","Reconstruct the tree using Breadth-First Search, assigning values level by level.","Reconstruct the tree using Depth-First Search, assigning values recursively.",Store the structure in a hash table with indices representing the correct values.,Only store the contaminated tree and return -1 for all queries.,"Reconstruct the binary tree during initialization by assigning values using the formula node.val = parent.val * 2 + 1 or parent.val * 2 + 2, then search the tree for a target value.",Medium,data structures,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Design,Binary Tree"
1388,"Greatest Sum Divisible by Three
Given an integer array nums, return the maximum possible sum of elements of the array such that it is divisible by three.",Calculate the sum of all elements and iteratively remove the smallest element until divisible by 3,Calculate all possible subset sums and return the largest one divisible by 3,Sort the array and greedily select elements that maximize the sum while maintaining divisibility by 3,Return the sum of all positive numbers in the array,Use dynamic programming to track the maximum sum for each possible remainder when divided by 3,Medium,algorithms,"Array,Dynamic Programming,Greedy"
1389,"Minimum Moves to Move a Box to Their Target Location
A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations. The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box. Your task is to move the box 'B' to the target position 'T' under the following rules: Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.","Use Dijkstra's algorithm treating each push as a move, focusing on the box's position only.","Employ a greedy approach, always pushing the box in the direction that minimizes the Euclidean distance to the target.","Apply a depth-first search (DFS) to explore all possible push sequences, pruning branches based on a simple heuristic.",Simulate the pushes by swapping the box and target locations until the man can reach the new box location,"Use A* search, where the state includes both the box and player positions, and the heuristic estimates the cost to reach the target.",Hard,algorithms,"Array,Breadth-First Search,Heap (Priority Queue),Matrix"
1395,"Minimum Time Visiting All Points
On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move according to these rules:",Sum the Euclidean distances between consecutive points.,Calculate the Manhattan distance between all pairs of points and take the average.,Use dynamic programming to find the shortest path visiting all points.,Find the convex hull of the points and calculate the perimeter.,Sum the maximum of the absolute differences of x and y coordinates between consecutive points.,Easy,algorithms,"Array,Math,Geometry"
1396,"Count Servers that Communicate
You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.

Return the number of servers that communicate with any other server.",Return the number of servers if the grid is a square matrix,Return the total number of servers in the grid,Return the number of rows and columns which contain at least one server,"Return the number of servers that have at least one adjacent server (up, down, left, or right)",Return the number of servers that communicate with any other server,Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix,Counting"
1397,"Search Suggestions System
You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed.","Sort the `products` array, then for each prefix of `searchWord`, filter `products` and return the first 3 elements",Use a trie data structure to store `products` and perform a depth-first search for each prefix of `searchWord`,"For each prefix of `searchWord`, iterate through `products` and maintain a heap of size 3 to store the lexicographically smallest matches",Utilize dynamic programming to store previously computed suggestions for prefixes of `searchWord`,"Sort `products` lexicographically. For each prefix of `searchWord`, use binary search to find the first product with that prefix, then iterate to collect the next 2 products with the same prefix.",Medium,algorithms,"Array,String,Trie"
1398,"Number of Ways to Stay in the Same Place After Some Steps
You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time). Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.",Memoization with a 1D array of size 'steps',"Greedy algorithm, always moving towards index 0","Using a constant space solution, tracking only the immediate moves","Iterative approach, updating only the current position and step count",Dynamic programming with a 2D array to store the number of ways to reach each position at each step,Hard,algorithms,Dynamic Programming
1400,"Find Winner on a Tic Tac Toe Game
Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are: Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return ""Draw"". If there are still movements to play return ""Pending"". You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.",Check for a winner after each move by iterating through all rows and columns,Simulate the game using recursion to explore all possible move combinations,Maintain separate boolean arrays to track rows and columns occupied by each player,Use a minimax algorithm to predict the optimal moves and determine the winner,"Simulate the moves and check for winning conditions (rows, columns, diagonals) after each move; return 'Draw' if all moves are exhausted and no winner is found; else return 'Pending'",Easy,algorithms,"Array,Hash Table,Matrix,Simulation"
1401,"Number of Burgers with No Waste of Ingredients
Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows: Return [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].",Return an empty list if tomatoSlices is odd or cheeseSlices is less than tomatoSlices / 4,"Greedily make as many jumbo burgers as possible, then calculate the remaining small burgers, returning an empty list if not feasible",Use dynamic programming to find the optimal combination of jumbo and small burgers,Return a list containing the quotient and remainder of dividing tomatoSlices by cheeseSlices,Solve a system of two equations with two unknowns (jumbo and small burgers) and validate non-negative integer solutions,Medium,algorithms,Math
1402,"Count Square Submatrices with All Ones
Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.",Calculate the sum of all elements in the matrix and divide by the area of the largest possible square.,"For each cell, check if it's a '1'. If so, start expanding outwards until you find a '0' or reach the boundary.","Compute the prefix sum matrix, then iterate through all possible square sizes and positions, using the prefix sum to efficiently check for all ones.",Perform a depth-first search (DFS) from each '1' cell to explore potential square submatrices.,"Use dynamic programming to store the side length of the largest square ending at each cell, then sum these values.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
1403,"Palindrome Partitioning III
You are given a string s containing lowercase letters and an integer k. You need to : Return the minimal number of characters that you need to change to divide the string.",Greedily choose the smallest cost partition at each step.,"Use a depth-first search to explore all possible partitions, pruning branches that exceed the allowed k.",Employ a binary search to find the optimal number of partitions with the minimum cost.,"Recursively partition the string, minimizing the cost of changes for each subproblem without memoization.",Use dynamic programming to store the minimum cost to partition substrings with a given number of allowed partitions.,Hard,algorithms,"String,Dynamic Programming"
1415,"Students and Examinations
Table: Students  Table: Subjects  Table: Examinations  Write a solution to find the number of times each student attended each exam. Return the result table ordered by student_id and subject_name. The result format is in the following example.",Using window functions to calculate the cumulative attendance count.,"Employing a cross join between students and subjects, then left joining with examinations and counting.",Calculating attendance using correlated subqueries within the SELECT statement.,Joining all three tables and grouping by all columns to determine the attendance.,"Cross join Students and Subjects, then left join Examinations and group by student_id and subject_name to count occurrences.",Easy,database systems,Database
1407,"Group the People Given the Group Size They Belong To
There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1. You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3. Return a list of groups such that each person i is in a group of size groupSizes[i]. Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.",Use a hash map to count occurrences of each group size and then iterate to form groups when the count matches the size,"Sort the groupSizes array and then iterate through it, forming groups of the specified size sequentially",Use recursion to divide the people into groups based on the groupSizes array,Create a disjoint set data structure and merge people into the same set if they have the same group size,"Use a hash map to store lists of people for each group size, and when a list reaches the required size, add it to the result",Medium,algorithms,"Array,Hash Table"
1408,"Find the Smallest Divisor Given a Threshold
Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). The test cases are generated so that there will be an answer.",Binary search on the prefix sums of the array,Iterate through all possible divisors from 1 to the sum of the array elements,Sort the array and choose the median as the divisor,Use dynamic programming to calculate the minimum sum for each possible divisor,Binary search on the possible divisor range (1 to max(nums)),Medium,algorithms,"Array,Binary Search"
1409,"Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge. Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot. A binary matrix is a matrix with all cells equal to 0 or 1 only. A zero matrix is a matrix with all cells equal to 0.","Dynamic Programming: Build a table storing minimum flips for submatrices, but it won't account for neighbor flips correctly","Greedy Approach: Always flip the cell with the most '1' neighbors, which can lead to suboptimal solutions.","Depth-First Search: Recursively explore all possible flip combinations, but it will be extremely inefficient.","Simulated Annealing: Start with a random state and iteratively improve it by flipping cells based on a probability function, but it doesn't guarantee optimality.","Breadth-First Search: Use BFS to explore all possible matrix states reachable by flips, keeping track of the minimum number of flips needed to reach the zero matrix.",Hard,algorithms,"Array,Bit Manipulation,Breadth-First Search,Matrix"
1211,"Iterator for Combination
Design the CombinationIterator class:","Store all combinations in a set to remove duplicates, then sort lexicographically","Generate combinations recursively, pruning branches that lead to invalid lengths",Use a stack to keep track of the current combination being generated,Precompute all possible combinations and store them in a hash map,Utilize a pointer to track the current combination's index and generate the next combination iteratively,Medium,algorithms,"String,Backtracking,Design,Iterator"
1221,"Element Appearing More Than 25% In Sorted Array
Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.","Return the element at index `n/3`, where `n` is the array length",Return the middle element of the array,Iterate through the array and return the last element encountered,Calculate the mode of the array,"Check elements at indices `n/4`, `n/2`, and `3n/4` against a window of adjacent elements",Easy,algorithms,Array
1222,"Remove Covered Intervals
Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list. The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d. Return the number of remaining intervals.","Sort the intervals by start time, then end time in descending order, and greedily remove covered intervals.",Sort the intervals by their lengths and iteratively check each interval against all other intervals to determine if it's covered.,Use a quadtree data structure to spatially index the intervals and efficiently search for covering intervals.,Calculate the area of each interval and remove intervals with smaller areas that are fully contained within larger intervals.,"Sort the intervals by start time, then end time, and iterate through them, keeping track of the rightmost endpoint seen so far.",Medium,algorithms,"Array,Sorting"
1224,"Minimum Falling Path Sum II
Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts. A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.","Use a greedy approach, always selecting the smallest element in each row regardless of column conflicts","Calculate all possible falling paths using recursion without memoization, and return the minimum sum",Apply Dijkstra's algorithm considering each cell as a node and column shifts as edges,Sort each row independently and sum the first element of each sorted row,"Use dynamic programming, storing the minimum falling path sums ending at each cell in the previous row, avoiding the same column",Hard,algorithms,"Array,Dynamic Programming,Matrix"
1411,"Convert Binary Number in a Linked List to Integer
Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list.",Multiply each bit by its index and sum the result,"Convert the linked list to a string and use int(string, 8)",Treat the linked list as a decimal number and perform standard decimal to binary conversion,Reverse the linked list and interpret it as a decimal number,Use a left bit shift while traversing the linked list,Easy,algorithms,"Linked List,Math"
1212,"Sequential Digits
An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.",Use dynamic programming to build solutions from smaller sequential digits,"Convert the range to strings, generate all possible sequential digit strings, and then convert back to integers, filtering within the range",Recursively generate all possible sequential digit numbers and filter within the range,Iterate through all numbers in the range and check if each number has sequential digits,"Start with single-digit numbers, iteratively build sequential digit numbers by appending the next digit, and filter based on the given range",Medium,algorithms,Enumeration
1413,"Maximum Side Length of a Square with Sum Less than or Equal to Threshold
Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.",O(m*n),O(m+n),O(log(threshold)),O(m*n*threshold),"O(min(m, n) * sqrt(threshold))",Medium,algorithms,"Array,Binary Search,Matrix,Prefix Sum"
1414,"Shortest Path in a Grid with Obstacles Elimination
You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step. Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.","Depth-First Search (DFS) without memoization, pruning paths exceeding k obstacle eliminations.","Greedy algorithm prioritizing cells with fewer obstacles, potentially leading to suboptimal solutions.","A* search algorithm using Manhattan distance as a heuristic, ignoring the obstacle elimination constraint.","Dijkstra's algorithm treating obstacles as high-cost edges, without considering the k elimination limit.","Breadth-First Search (BFS) with a state space that includes position (row, col) and remaining obstacle eliminations (k).",Hard,algorithms,"Array,Breadth-First Search,Matrix"
1421,"Find Numbers with Even Number of Digits
Given an array nums of integers, return how many of them contain an even number of digits.",Convert each number to a string and check if the string length is divisible by 3,Count numbers with digits divisible by 2,Calculate the sum of the digits and check if the sum is even,Use logarithms to find the number of digits and apply the modulo operator (%),Convert each number to a string and check if the string length is divisible by 2,Easy,algorithms,Array
1422,"Divide Array in Sets of K Consecutive Numbers
Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers. Return true if it is possible. Otherwise, return false.","Sort the array and use a greedy approach, repeatedly picking the smallest element and checking for k consecutive elements following it",Use a sliding window of size k to check for consecutive numbers,Recursively divide the array into smaller sub-arrays of size k and check if each sub-array contains consecutive numbers,"Calculate the sum of all elements and check if the sum is divisible by k. If divisible, return true; otherwise, return false","Use a frequency map to count occurrences of each number, then iteratively check if sets of k consecutive numbers can be formed based on the counts",Medium,algorithms,"Array,Hash Table,Greedy,Sorting"
1423,"Maximum Number of Occurrences of a Substring
Given a string s, return the maximum number of occurrences of any substring under the following rules:","Compute the frequency of each substring and return the maximum frequency encountered, without respecting minSize or maxSize constraints.","Generate all possible substrings, irrespective of minSize and maxSize and only count the frequency of substrings that contains less than maxLetters unique characters.","Generate only substrings of length minSize, count their occurrences, and then check if unique character count is within maxLetters","Generate substrings only of length maxSize, count their occurences, and verify the number of distinct letters is less than or equal to maxLetters.","Generate all substrings within the size range [minSize, maxSize], check if the number of unique letters is less than or equal to maxLetters, and then compute the maximum occurrence.",Medium,algorithms,"Hash Table,String,Sliding Window"
1424,"Maximum Candies You Can Get from Boxes
You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where: You are given an integer array initialBoxes that contains the labels of the boxes you initially have. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it. Return the maximum number of candies you can get following the rules above.","Use Depth-First Search (DFS) to explore boxes, prioritizing those with the most candies.","Apply a greedy approach, always opening the box with the highest candy count first.",Sort the initial boxes and the contained boxes by their labels and process them sequentially.,"Use dynamic programming to calculate the maximum candies obtainable from each box, considering dependencies.","Use Breadth-First Search (BFS) to simulate opening boxes, collecting candies, and obtaining keys.",Hard,algorithms,"Array,Breadth-First Search"
1231,"Replace Elements with Greatest Element on Right Side
Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array.",Initialize a new array of the same size with all elements set to positive infinity.,"Iterate through the array from left to right, updating each element with the maximum value found so far.","Sort the array in descending order and then shift elements one position to the right, adding -1 to the end.","Create a copy of the array, find the maximum value in the original, and replace all values in the copy with that maximum.","Iterate through the array from right to left, keeping track of the maximum seen so far and replacing elements with it.",Easy,algorithms,Array
1232,"Sum of Mutated Array Closest to Target
Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target. In case of a tie, return the minimum such integer. Notice that the answer is not neccesarilly a number from arr.","Use binary search to find the value that minimizes the absolute difference between the mutated array sum and the target, optimizing for time complexity but potentially missing edge cases.","Sort the array and iterate through it, calculating the sum of the mutated array for each element and keeping track of the value that produces the smallest difference.","Calculate the average of the array and the target, then adjust this value incrementally until the mutated array sum is close to the target.","Iterate through a predefined range of possible values, calculating the mutated array sum for each value and selecting the one that is closest to the target, without optimization.","Employ binary search on the potential range of values, calculating the mutated array sum for the middle value and adjusting the search range based on whether the sum is greater or less than the target.",Medium,algorithms,"Array,Binary Search,Sorting"
1234,"Number of Paths with Max Score
You are given a square board of characters. You can move on the board starting at the bottom right square marked with the character 'S'. You need to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character 1, 2, ..., 9 or with an obstacle 'X'. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there. Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7. In case there is no path, return [0, 0].",Depth-First Search (DFS) without memoization,"Greedy search, always choosing the path with the highest immediate value",Dijkstra's algorithm,A* search algorithm,Dynamic Programming (DP),Hard,algorithms,"Array,Dynamic Programming,Matrix"
1426,"Find N Unique Integers Sum up to Zero
Given an integer n, return any array containing n unique integers such that they add up to 0.",Use only positive integers from 1 to n and then subtract their sum from the last element to compensate,Populate the array with random integers and then adjust one random element to force the sum to zero,"Fill the array with powers of 2, negating half of them to create a zero sum",Generate n-1 random numbers and set the nth number to 0,"Iterate from 1 to n/2, adding 'i' and '-i' to the array, and if n is odd, also add 0",Easy,algorithms,"Array,Math"
1427,"All Elements in Two Binary Search Trees
Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.","Perform an in-order traversal of both trees, merging the results directly into a single sorted array during the traversal.","Convert both BSTs into sorted arrays, then merge the two arrays using a two-pointer technique.","Insert all elements from both trees into a hash table, then sort the keys of the hash table.",Perform a level-order traversal of both trees and merge the elements into a single list which is then sorted.,Convert both BSTs to sorted arrays using in-order traversal and then apply the merge step from merge sort.,Medium,data structures,"Tree,Depth-First Search,Binary Search Tree,Sorting,Binary Tree"
1428,"Jump Game III
Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach any index with value 0. Notice that you can not jump outside of the array at any time.",Use dynamic programming to determine reachable indices from the start and check if any are zero,"Perform a breadth-first search, tracking visited nodes to avoid cycles, and checking for a zero value",Sort the array and check if the value 0 exists within the bounds of reachable indices from the start position,"Apply Dijkstra's algorithm to find the shortest path to a zero value, treating jumps as edge weights","Use depth-first search with backtracking, marking visited indices to prevent infinite loops, and check for a zero value",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search"
1429,"Verbal Arithmetic Puzzle
Given an equation, represented by words on the left side and the result on the right side. You need to check if the equation is solvable under the following rules: Return true if the equation is solvable, otherwise return false.",Use a hash table to store character frequencies and find the lexicographically smallest solution,"Employ a greedy algorithm, assigning digits based on the most frequent letters first","Backtrack through all possible digit assignments, pruning branches that violate constraints",Convert the words to numerical values based on their ASCII representation and check the sum,Use constraint propagation with backtracking to systematically explore valid digit assignments,Hard,algorithms,"Array,Math,String,Backtracking"
1434,"Decrypt String from Alphabet to Integer Mapping
You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows: Return the string formed after mapping. The test cases are generated so that a unique mapping will always exist.","Hash each character to its integer representation, then decrypt based on hash values",Use dynamic programming to build a table of possible mappings and select the optimal one,Apply a Caesar cipher with a shift based on the position of '#' characters,"Reverse the string, map single digits and combined digits ending in '#' to characters, then reverse the result.","Iterate through the string. If a '#' is encountered, combine the preceding two digits; otherwise, map the current digit directly to a character.",Easy,algorithms,String
1435,"XOR Queries of a Subarray
You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti]. For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where answer[i] is the answer to the ith query.","Calculate the XOR for each query by iterating through the subarray every time, resulting in O(n*q) complexity.",Precompute all possible subarray XORs and store them in a hash map for O(1) lookup per query.,Sort the input array and then use binary search to find the left and right indices for each query.,Calculate the sum of the elements in the subarray instead of the XOR.,"Precompute a prefix XOR array, allowing each query to be answered in O(1) time by XORing two prefix values.",Medium,algorithms,"Array,Bit Manipulation,Prefix Sum"
1436,"Get Watched Videos by Your Friends
There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i. Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.",Use Depth-First Search (DFS) to explore friends at the specified level and collect watched videos without considering duplicates.,"Use a simple for loop to iterate through the friends array and collect watched videos only from direct friends, ignoring the level parameter.",Use a hash map to store friends at different levels and then filter watched videos based on frequency and alphabetical order before returning.,"Use Breadth-First Search (BFS) to find friends at the given level, collect watched videos, and sort them alphabetically.","Use Breadth-First Search (BFS) to find friends at the specified level, count watched video frequencies, and sort videos by frequency then alphabetically.",Medium,algorithms,"Array,Hash Table,Breadth-First Search,Sorting"
1437,"Minimum Insertion Steps to Make a String Palindrome
Given a string s. In one step you can insert any character at any index of the string. Return the minimum number of steps to make s palindrome. A Palindrome String is one that reads the same backward as well as forward.","Recursively remove characters from the beginning and end of the string if they match, otherwise, take the minimum of the results from removing only the first or last character and add 1",Reverse the string and find the longest common subsequence (LCS) between the original and reversed strings. The number of insertions is the length of the original string minus the length of the LCS,Calculate the number of distinct characters in the string. The minimum insertions needed is equal to the number of distinct characters minus 1,Find the longest palindromic substring. The number of insertions is the difference between the length of the string and the length of the longest palindromic substring,Use dynamic programming to find the length of the longest palindromic subsequence. The number of insertions needed is equal to the length of the string minus the length of the longest palindromic subsequence,Hard,algorithms,"String,Dynamic Programming"
1241,"Decompress Run-Length Encoded List
We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list.",Create a new array and repeatedly push 'val' into it 'freq' times using nested loops.,"Use a hash map to store the frequencies and values, then iterate through the map to build the decompressed list.","Use recursion to process each pair, creating a sublist for each and then concatenating them.",Convert the run-length encoded list into a string representation and then use string manipulation techniques to decompress it.,"Iterate through the input array with a step of 2, and for each pair [freq, val], append 'val' to the result list 'freq' times.",Easy,algorithms,Array
1242,"Matrix Block Sum
Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:",Calculate the prefix sum matrix and use it to compute sums for each block,"Iterate through each cell (i, j) and calculate the block sum directly using nested loops without optimization",Use dynamic programming to store intermediate block sums for reuse,Apply a Gaussian blur filter with a kernel size of 2k+1 to approximate the block sums,Utilize a sliding window approach to efficiently calculate the sum for each block,Medium,algorithms,"Array,Matrix,Prefix Sum"
1243,"Sum of Nodes with Even-Valued Grandparent
Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent of a node is the parent of its parent if it exists.",Return the sum of all nodes with even values in the tree.,"Return the sum of the values of all grandchildren, regardless of the grandparent's value.",Return the sum of values of all nodes in the tree whose depth is greater than 2.,Return the sum of values of all nodes that are direct children of even-valued nodes.,Return the sum of values of nodes with an even-valued grandparent.,Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1244,"Distinct Echo Substrings
Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).","Use a brute-force approach, generating all substrings and checking for the echo property with O(n^3) complexity.","Optimize substring generation with a sliding window, focusing on even-length substrings, achieving O(n^2) complexity.","Employ dynamic programming to store previously computed substring echo properties, leading to O(n^2) complexity and increased memory usage.","Use a rolling hash to quickly compare substring pairs, potentially reducing time complexity but introducing collision risks.","Utilize suffix arrays or suffix trees for efficient substring comparison, achieving O(n log n) or O(n) complexity, respectively.",Hard,algorithms,"String,Dynamic Programming,Trie,Sliding Window,Rolling Hash,Hash Function"
1440,"Convert Integer to the Sum of Two No-Zero Integers
No-Zero integer is a positive integer that does not contain any 0 in its decimal representation. Given an integer n, return a list of two integers [a, b] where: The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",Recursively subtract powers of 10 until both numbers are No-Zero,Generate all possible pairs and filter for No-Zero integers that sum to n,Repeatedly increment 'a' and decrement 'b' by 1 until both are No-Zero,"Find the largest No-Zero integer less than n and set it as 'a', then calculate 'b'","Iterate from 1 to n-1; if both 'i' and 'n-i' are No-Zero, return them",Easy,algorithms,Math
1441,"Minimum Flips to Make a OR b Equal to c
Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).
Flip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.","Count the total number of bits set to 1 in a, b, and c and return the difference.",Calculate (a OR b) XOR c. The number of set bits in the result is the answer.,Return the absolute difference between the numerical values of (a OR b) and c.,Use dynamic programming to find the optimal flips for all possible subproblems.,"Iterate through the bits of a, b, and c. If (a[i] OR b[i]) != c[i], increment the flip count. If c[i] is 0, add a[i] + b[i] to the count instead.",Medium,algorithms,Bit Manipulation
1442,"Number of Operations to Make Network Connected
There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network. You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.",Depth-First Search (DFS) to find the longest path and subtract it from `n`.,Kruskal's algorithm to find the Minimum Spanning Tree (MST) and count the unused edges.,Breadth-First Search (BFS) to find the shortest path between all pairs of nodes and sum the path lengths.,Use Dijkstra's algorithm from an arbitrarily chosen node to find the maximum distance and return that as the result.,"Use Depth-First Search (DFS) or Union-Find to count the number of connected components. The result is the number of components minus 1, unless there aren't enough cables, in which case return -1.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
1443,"Minimum Distance to Type a Word Using Two Fingers
You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate. Given the string word, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. Note that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.","Use dynamic programming to calculate the minimum distance for each substring of the word, considering only one finger's position at a time.",Iterate through all possible finger placements on the keyboard for each letter in the word and select the placement with the smallest distance.,Calculate the average position of all letters in the word and use that as a fixed point for one finger while the other finger types the word.,"Greedily choose the closest available finger to type each letter, without considering future letters or the position of the other finger.",Use dynamic programming to store the minimum distance to type a prefix of the word given the positions of the two fingers.,Hard,algorithms,"String,Dynamic Programming"
1452,"Restaurant Growth
Table: Customer  You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day). Compute the moving average of how much the customer paid in a seven days window (i.e., current day + 6 days before). average_amount should be rounded to two decimal places. Return the result table ordered by visited_on in ascending order. The result format is in the following example.",GROUP BY visited_on ORDER BY visited_on,PARTITION BY visited_on ORDER BY visited_on,ORDER BY visited_on RANGE BETWEEN INTERVAL '6 day' PRECEDING AND CURRENT ROW,ROWS BETWEEN 6 PRECEDING AND CURRENT ROW,ORDER BY visited_on RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW,Medium,database systems,Database
1448,"Maximum 69 Number
You are given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).","Convert the number to a string, replace all '6's with '9's, then convert back to an integer.","Convert the number to a string, replace the last '6' with a '9', then convert back to an integer.","Convert the number to a string, replace all '9's with '6's, then convert back to an integer.","Multiply the number by 1.5 if it contains a '6', otherwise return the original number.","Convert the number to a string, replace the first '6' with a '9', then convert back to an integer.",Easy,algorithms,"Math,Greedy"
1449,"Print Words Vertically
Given a string s. Return all the words vertically in the same order in which they appear in s.
Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).
Each word would be put on only one column and that in one column there will be only one word.","Split the string into words, then iterate through the characters of each word by index, padding with spaces as needed.","Create a 2D array where rows represent words and columns represent characters, then transpose the array.","Sort the words alphabetically, then print the characters of each word vertically.",Remove all spaces from the input string and print the characters vertically.,"Split the string into words, find the longest word, and iterate up to its length, printing the character at each index or a space if the word is shorter.",Medium,algorithms,"Array,String,Simulation"
1450,"Delete Leaves With a Given Value
Given a binary tree root and an integer target, delete all the leaf nodes with value target. Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).",Use a breadth-first search (BFS) and remove nodes with the target value level by level.,"Recursively traverse the tree, removing nodes post-order if their value matches the target, without checking for new leaf nodes.","Convert the tree to an array, remove target values from the array, then rebuild the tree.",Perform an in-order traversal and delete leaf nodes equal to the target during the traversal.,"Use a post-order traversal and recursively prune leaf nodes with the target value, repeating until no more removals occur.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1451,"Minimum Number of Taps to Open to Water a Garden
There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e., the length of the garden is n). There are n + 1 taps located at points [0, 1, ..., n] in the garden. Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open. Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.",Use a greedy approach by selecting the tap that waters the smallest interval first.,"Apply dynamic programming with a bottom-up approach, considering all possible combinations of taps.",Open all the taps and then close the unnecessary ones to minimize the number of open taps.,Sort the taps based on their position and use a linear scan to find the minimum number of taps.,"Convert ranges to watering intervals, sort by start point, then greedily select the tap that reaches furthest.",Hard,algorithms,"Array,Dynamic Programming,Greedy"
1462,"List the Products Ordered in a Period
Table: Products  Table: Orders  Write a solution to get the names of products that have at least 100 units ordered in February 2020 and their amount. Return the result table in any order. The result format is in the following example.","SELECT p.product_name, SUM(o.quantity) AS total_quantity FROM Products p JOIN Orders o ON p.product_id = o.product_id WHERE MONTH(o.order_date) = 2 AND YEAR(o.order_date) = 2020 GROUP BY p.product_name HAVING SUM(o.quantity) > 100","SELECT p.product_name, o.quantity FROM Products p, Orders o WHERE p.product_id = o.product_id AND o.order_date LIKE '2020-02%' AND o.quantity >= 100","SELECT product_name, SUM(quantity) FROM Products NATURAL JOIN Orders WHERE EXTRACT(YEAR_MONTH FROM order_date) = 202002 GROUP BY product_name","SELECT p.product_name, SUM(o.quantity) AS amount FROM Products p LEFT JOIN Orders o ON p.product_id = o.product_id WHERE o.order_date BETWEEN '2020-02-01' AND '2020-02-29' GROUP BY p.product_name","SELECT p.product_name, SUM(o.quantity) AS unit FROM Products p JOIN Orders o ON p.product_id = o.product_id WHERE EXTRACT(YEAR FROM o.order_date) = 2020 AND EXTRACT(MONTH FROM o.order_date) = 2 GROUP BY p.product_name HAVING SUM(o.quantity) >= 100",Easy,database systems,Database
1252,"Break a Palindrome
Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible. Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, ""abcc"" is lexicographically smaller than ""abcd"" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.","Replace the first non-'a' character with 'a'. If all characters are 'a', replace the last character with 'b'.",Reverse the string and replace the middle character with 'a' to break the palindrome.,"Replace the character with the highest ASCII value with 'a'. If the string length is 1, return an empty string.",Replace all 'a's with 'b's until the string is no longer a palindrome.,"Iterate through the first half of the string. Replace the first non-'a' character with 'a'. If the string is all 'a's, replace the last character with 'b'. If the string length is 1, return an empty string.",Medium,algorithms,"String,Greedy"
1253,"Sort the Matrix Diagonally
A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2]. Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.",Sort each diagonal independently using a simple sorting algorithm like bubble sort.,Use a hash map to store the elements of each diagonal and then sort the diagonals based on their hash values.,"Apply a generic sorting algorithm like quicksort or mergesort to the entire matrix, treating diagonals as subarrays.","Use a min-heap to store all elements, then rebuild the matrix by extracting elements in diagonal order.","Employ a hash map or array to store the values of each diagonal (identified by row - column), sort these values, and then reconstruct the matrix.",Medium,algorithms,"Array,Sorting,Matrix"
1255,"Reverse Subarray To Maximize Array Value
You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1. You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once. Find maximum possible value of the final array.",O(1),O(n log n),O(n^2),O(log n),O(n),Hard,algorithms,"Array,Math,Greedy"
1256,"Rank Transform of an Array
Given an array of integers arr, replace each element with its rank. The rank represents how large the element is. The rank has the following rules:",Sort the array and replace each element with its index in the sorted array.,Replace each element with the number of elements smaller than it.,Divide each element by the sum of the array.,Replace each element with its original index in the unsorted array.,"Sort the array, create a mapping of element to rank, and replace each element with its corresponding rank.",Easy,algorithms,"Array,Hash Table,Sorting"
1454,"Remove Palindromic Subsequences
You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward.","Always return 1, as any string of 'a's and 'b's can be considered a palindrome","Return the length of the string divided by 2, rounded up","Recursively remove the first character if it matches the last, otherwise remove one of them",Return the number of 'a's plus the number of 'b's in the string,"If the string is empty, return 0. If the string is a palindrome, return 1. Otherwise, return 2.",Easy,algorithms,"Two Pointers,String"
1455,"Filter Restaurants by Vegan-Friendly, Price and Distance
Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters. The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively. Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.","Sort the restaurants by ID first, then filter, and finally sort by rating.","Filter the restaurants based on price and distance first, then apply the vegan-friendly filter.","Sort the restaurants by distance first, then apply the vegan-friendly filter and the price constraint.","Apply the vegan-friendly filter and price constraint first, then sort the restaurants by rating in descending order, and if ratings are the same, sort by ID in ascending order.","Apply all filters (vegan-friendly, price, and distance), then sort the remaining restaurants by rating in descending order and, if ratings are equal, by ID in descending order.",Medium,algorithms,"Array,Sorting"
1456,"Find the City With the Smallest Number of Neighbors at a Threshold Distance
There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold. Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.",Prim's Algorithm,Depth-First Search (DFS),Kruskal's Algorithm,Breadth-First Search (BFS),Floyd-Warshall Algorithm,Medium,algorithms,"Dynamic Programming,Graph,Shortest Path"
1457,"Minimum Difficulty of a Job Schedule
You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i). You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day. You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i]. Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.","Dynamic programming with a bottom-up approach, iterating through all possible sub-schedules and calculating the minimum difficulty.","A greedy approach, scheduling the most difficult jobs first and then filling in the remaining days with easier jobs.","Recursion with memoization, exploring all possible schedules by splitting the jobs into groups for each day and caching results.","A divide-and-conquer strategy, recursively dividing the jobs into halves until each half can be scheduled in d/2 days.","Dynamic programming with a top-down approach (memoization), calculating the minimum difficulty by considering all possible splits of jobs for the last day.",Hard,algorithms,"Array,Dynamic Programming"
1463,"The K Weakest Rows in a Matrix
You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row. A row i is weaker than a row j if one of the following is true: Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.","Sort the rows based on their sum and return the first k indices, without considering the original order.","Count the number of soldiers in each row and use a max-heap of size k to maintain the weakest rows, updating as needed.",Implement a binary search in each row to find the index of the first civilian and sort the row indices based on these indices.,"Calculate the sum of each row, store it in a separate array, sort the array, and return the indices corresponding to the first k elements.","Calculate the sum of each row, store the sums along with their original indices, sort based on the sum (and index as a tie-breaker), and return the first k indices.",Easy,algorithms,"Array,Binary Search,Sorting,Heap (Priority Queue),Matrix"
1464,"Reduce Array Size to The Half
You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed.",Use a priority queue to store the frequencies and greedily remove elements with the lowest frequencies until half the array is removed.,Sort the array and remove elements from the beginning until half the array's initial size is reached.,Calculate the mean and standard deviation of the array. Remove all elements outside one standard deviation from the mean.,"Iterate through the array, keeping track of the sum. Remove the smallest element until the sum is less than half the original sum.","Count the frequency of each number, then greedily remove numbers with the highest frequencies until half the array is removed.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Heap (Priority Queue)"
1465,"Maximum Product of Splitted Binary Tree
Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7. Note that you need to maximize the answer before taking the mod and not after taking it.","Use a greedy approach, always cutting the edge that results in the largest subtree sum at each step.","Calculate the sum of the entire tree, then traverse the tree, calculating the product of the current subtree sum and its complement (total sum - subtree sum), updating the maximum product along the way.",Perform a level-order traversal and calculate the product of the sum of nodes at each level.,Sort the nodes in the tree and then split it into two subtrees based on the sorted order.,"Calculate the total sum of the tree. Then, perform a post-order traversal, and for each edge removal, calculate the product of the subtree sum and the (total sum - subtree sum). Keep track of the maximum product.",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1466,"Jump Game V
Given an array of integers arr and an integer d. In one step you can jump from index i to index: In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)). You can choose any index of the array and start jumping. Return the maximum number of indices you can visit. Notice that you can not jump outside of the array at any time.",Depth-First Search (DFS) without memoization,"Greedy approach, always jumping to the nearest valid index",Breadth-First Search (BFS) starting from all indices,Sorting the array and performing linear traversal,Dynamic Programming with Depth-First Search (DFS) and memoization,Hard,algorithms,"Array,Dynamic Programming,Sorting"
1480,"Movie Rating
Table: Movies  Table: Users Table: MovieRating  Write a solution to: The result format is in the following example.",Full-text search will always return accurate results without any configuration.,It is optimized for exact matches and performs poorly with typos or variations.,It solely relies on indexes built on the primary key column of the table.,It only supports searching within a single column of a table.,"It allows indexing and searching of text data for words or phrases, supporting features like stemming and stop words.",Medium,database systems,Database
1444,"Number of Steps to Reduce a Number to Zero
Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.",Use recursion to repeatedly check if the number is even or odd and update a counter,Convert the integer to its binary representation and count the number of set bits and trailing zeros,"Apply dynamic programming, storing the minimum steps for all numbers up to num",Employ a lookup table pre-computed for numbers up to a certain limit,Use a while loop to repeatedly check if the number is even or odd and increment a counter accordingly,Easy,algorithms,"Math,Bit Manipulation"
1445,"Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.","Return the array length minus k plus 1 if the total sum of the array is greater than or equal to the threshold multiplied by k, otherwise return 0",Iterate through all possible sub-arrays of size k and count those where the sum equals the threshold,"Sort the array and then count all sub-arrays of length k using combinations, adjusting for the threshold after counting","Iterate through the array, tracking the minimum value in each sub-array of size k and comparing against the threshold",Use a sliding window of size k to calculate the average of each sub-array and increment a counter if it's greater than or equal to the threshold,Medium,algorithms,"Array,Sliding Window"
1446,"Angle Between Hands of a Clock
Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand. Answers within 10-5 of the actual value will be accepted as correct.",Calculate the angle assuming the hour hand moves continuously and then take the absolute difference,Calculate the angles independently but always return a positive difference.,Treat the clock as a 24-hour clock and calculate angles based on that,Assume the hour hand only moves in discrete steps corresponding to each hour and adjust for minutes later,"Calculate the angles of the hour and minute hands independently, find the absolute difference, and return the smaller of the two possible angles (<= 180 degrees)",Medium,algorithms,Math
1447,"Jump Game IV
Given an array of integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index: Return the minimum number of steps to reach the last index of the array. Notice that you can not jump outside of the array at any time.",Depth-First Search,Greedy Algorithm,Divide and Conquer,Dynamic Programming,Breadth-First Search,Hard,algorithms,"Array,Hash Table,Breadth-First Search"
1468,"Check If N and Its Double Exist
Given an array arr of integers, check if there exist two indices i and j such that :",Sort the array and use binary search to find the double of each element.,"Iterate through the array, and for each element, check if its double exists using a hash set.",Use two nested loops to compare each element with the double of every other element.,Calculate the mean of the array and check if the mean's double exists in the array.,Use a hash set to store each element and check if either its double or half exists in the set.,Easy,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Sorting"
1469,"Minimum Number of Steps to Make Two Strings Anagram
You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character. Return the minimum number of steps to make t an anagram of s. An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.","Use a hash map to store character counts in `s` and then iterate through `t`, incrementing a counter for each character that is not in the hash map.",Sort both strings and then count the number of differing characters at each index.,"Calculate the difference in ASCII values between corresponding characters in `s` and `t`, and sum the absolute values of these differences.","Iterate through `t` and for each character, find the closest matching character in `s` and swap them if necessary, counting the number of swaps.",Calculate the frequency of each character in both strings and then sum the absolute differences of the frequencies for each character.,Medium,algorithms,"Hash Table,String,Counting"
1470,"Tweet Counts Per Frequency
A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller time chunks based on a certain frequency (every minute, hour, or day). For example, the period [10, 10000] (in seconds) would be partitioned into the following time chunks with these frequencies: Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period (10000 in the above example). Design and implement an API to help the company with their analysis. Implement the TweetCounts class:  Example:  Constraints:",Use a hash map to store tweet counts and iterate through the time range linearly for each query,Store tweets in a single sorted list and perform binary search for each query,Pre-calculate tweet counts for all possible time ranges and store them in a matrix for O(1) query time,Use a fixed-size array to store tweet counts and update it periodically based on frequency,"Store tweets in separate sorted lists based on frequency, and merge the relevant lists during query",Medium,system design,"Hash Table,Binary Search,Design,Sorting,Ordered Set"
1471,"Maximum Students Taking Exam
Given a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character. Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible. Students must be placed in seats in good condition.","Solve using a greedy algorithm, placing students in seats with the fewest adjacent neighbors first.",Transform the problem into a minimum vertex cover problem on a bipartite graph.,"Employ dynamic programming, considering all possible subsets of students in each row.","Use backtracking to explore all seating arrangements, pruning branches when cheating is detected.",Model the problem as a maximum independent set problem on a bipartite graph and solve using maximum flow.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Matrix,Bitmask"
1476,"Count Negative Numbers in a Sorted Matrix
Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",Perform a linear search on each row to find the first negative number and count the remaining elements.,Flatten the matrix into a single sorted array and then use binary search to find the first negative number.,Iterate through each element of the matrix and increment a counter if the element is negative.,Apply a modified binary search on each column to find the number of negative elements.,"Start from the top-right corner; if the current element is negative, increment the count and move down; otherwise, move left.",Easy,algorithms,"Array,Binary Search,Matrix"
1477,"Product of the Last K Numbers
Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream. Implement the ProductOfNumbers class: The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.  Example:  Constraints:",Store all the numbers in an array and calculate the product in O(k) time each time getProduct(k) is called.,"Keep a running product of all numbers seen so far. If a zero is encountered, reset the product to 1.",Store only the last k numbers and recalculate the product upon each call to getProduct(k).,Store the cumulative sum of the numbers and use it to calculate the product via exponentiation.,"Store the cumulative product of the stream. If a zero is encountered, reset the cumulative product from the next element.",Medium,algorithms,"Array,Math,Design,Queue,Data Stream"
1478,"Maximum Number of Events That Can Be Attended
You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d. Return the maximum number of events you can attend.","Sort events by start day and use a greedy approach, always attending the event that ends earliest.","Sort events by end day and iterate through the sorted events, using a boolean array to mark attended days.",Use dynamic programming to compute the maximum number of events that can be attended up to a certain day.,Sort the events by duration (endDay - startDay) and attend the shortest events first.,"Use a priority queue (min-heap) to keep track of available events, attending the event with the earliest end day among the available ones each day.",Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
1479,"Construct Target Array With Multiple Sums
You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure : Return true if it is possible to construct the target array from arr, otherwise, return false.",Use dynamic programming to build possible sums from smaller sub-arrays.,Sort the target array and check if the largest element can be reduced to 1 using the sum of the other elements.,Simulate the process by repeatedly subtracting the smallest element from the largest until all elements are 1.,"Check if the sum of the target array is a power of 2. If so, the array can be constructed.","Use a priority queue to track the largest element, repeatedly reduce it by the sum of the rest, and check for validity.",Hard,algorithms,"Array,Heap (Priority Queue)"
1458,"Sort Integers by The Number of 1 Bits
You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order. Return the array after sorting it.","Use a hash map to count the frequency of each integer, then sort by frequency and value","Convert each integer to its binary representation as a string, count the '1's using string methods, and then sort the original integers using this count as the key.","Sort the array using a standard sorting algorithm (e.g., quicksort) and modify the comparison function to prioritize the original integer value.","First, partition the array into subarrays based on the number of '1's (using a counting sort approach), then merge the subarrays.","Use a custom comparison function in a sorting algorithm to count set bits and sort accordingly; if the set bit counts are equal, sort by the integer values themselves.",Easy,algorithms,"Array,Bit Manipulation,Sorting,Counting"
1459,"Apply Discount Every n Orders
There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i]. When a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product). The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100). Implement the Cashier class:","Use a global counter, and if `counter % n == 0`, apply the discount directly without looking up product prices.",Store product IDs and prices in separate lists and use linear search for each product in the customer's bill.,"For each customer, calculate the subtotal and apply the discount using integer division, truncating any decimals.","Apply the discount every time a customer buys more than 10 items, regardless of the order number.","Use a hash map to store product IDs and prices for O(1) lookup, increment a counter, and apply the discount when `counter % n == 0`.",Medium,system design,"Array,Hash Table,Design"
1460,"Number of Substrings Containing All Three Characters
Given a string s consisting only of characters a, b and c. Return the number of substrings containing at least one occurrence of all these characters a, b and c.","Use a sliding window approach, expanding the window until it contains all three characters, then counting valid substrings starting from the left boundary of the window","Generate all possible substrings and check each one for the presence of 'a', 'b', and 'c', incrementing a counter for each valid substring","Sort the string and iterate through all substrings. If the sorted substring begins with 'a', contains 'b' and ends with 'c', increment the counter","Count occurrences of 'a', 'b', and 'c' and apply combinatorics to determine substrings with at least one of each character",Maintain a count of each character within a sliding window and efficiently update the count of valid substrings as the window slides through the string.,Medium,algorithms,"Hash Table,String,Sliding Window"
1461,"Count All Valid Pickup and Delivery Options
Given n orders, each order consists of a pickup and a delivery service. Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). Since the answer may be too large, return it modulo 10^9 + 7.",n! * 2^n,(2n)! / n!,(2n)! / 2^n,(2n choose n),(2n)! / (2^n * n!),Hard,algorithms,"Math,Dynamic Programming,Combinatorics"
1274,"Number of Days Between Two Dates
Write a program to count the number of days between two dates. The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.",Use the Julian Day Number algorithm directly with integer arithmetic,"Utilize a calendar library with date arithmetic functions, accounting for leap years","Calculate the difference in days using only the year and day values, ignoring the month","Manually iterate through each day, incrementing a counter and checking for valid date transitions","Convert dates to Unix timestamps and calculate the difference in seconds, then convert to days",Easy,algorithms,"Math,String"
1275,"Validate Binary Tree Nodes
You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree. If node i has no left child then leftChild[i] will equal -1, similarly for the right child. Note that the nodes have no values and that we only use the node numbers in this problem.",A cycle exists within the parent-child relationships of the nodes.,Multiple root nodes are present in the constructed graph.,"The graph is disconnected, meaning not all nodes are reachable from a single root.",A node has more than one parent.,"The in-degree of a node is greater than 1, or there are multiple root nodes after processing the graph.",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Union Find,Graph,Binary Tree"
1276,"Closest Divisors
Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2. Return the two integers in any order.","Check factors only up to the square root of num + 1 and num + 2, returning the first pair found.",Iterate through all numbers from 1 to num + 2 and pick the closest factors to num.,Use binary search to find factors of num + 1 and num + 2,Start from 1 and increment until a pair is found; always return the first pair,"Start searching for factors from the square root down to 1, optimizing the search for closer divisors.",Medium,algorithms,Math
1277,"Largest Multiple of Three
Given an array of digits digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. If there is no answer return an empty string. Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.","Greedily select digits from largest to smallest, removing the smallest ones that leave the sum divisible by 3, prioritizing removing ones with remainder 1 when possible.","Sort the digits in ascending order, then check all possible sub-sequences for divisibility by 3, returning the largest such sequence.","Calculate the sum of all digits. If the sum is divisible by 3, return the sorted digits. Otherwise, repeatedly remove the smallest digit until divisible by 3.","Construct all possible permutations of the digits, convert them to integers, and return the largest multiple of 3.","Calculate the sum of all digits. If the sum's remainder when divided by 3 is 1 or 2, remove the minimum number of digits with the same remainder, or a pair with remainders 1 and 2, and sort the result in descending order.",Hard,algorithms,"Array,Dynamic Programming,Greedy"
1482,"How Many Numbers Are Smaller Than the Current Number
Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i]. Return the answer in an array.",Use a nested loop with O(n^2) complexity to compare each number with all others.,"Sort the array and then for each element, perform a binary search to find the count of smaller elements.","Utilize a hash map to store the frequency of each number, then iterate through the hash map to calculate the count.",Calculate the average of the array and compare each element to the average.,"Create a sorted copy of the array and for each element in the original array, find its index in the sorted array.",Easy,algorithms,"Array,Hash Table,Sorting,Counting"
1483,"Rank Teams by Votes
In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition. The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter. You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above. Return a string of all teams sorted by the ranking system.","Sort teams by the total number of votes received, ignoring position.","Sort teams alphabetically, breaking ties randomly.",Sort teams based on the lexicographical order of the vote strings.,Sort teams by the number of last-place votes received.,"Sort teams by comparing their vote counts at each position sequentially, resolving ties alphabetically.",Medium,algorithms,"Array,Hash Table,String,Sorting,Counting"
1484,"Linked List in Binary Tree
Given a binary tree root and a linked list with head as the first node. Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False. In this context downward path means a path that starts at some node and goes downwards.",A* Search,Breadth-First Search (BFS),Depth-First Search (DFS) on the binary tree only,Greedy Best-First Search,"Depth-First Search (DFS) on the binary tree, comparing with linked list nodes at each step",Medium,algorithms,"Linked List,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1485,"Minimum Cost to Make at Least One Valid Path in a Grid
Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be: Notice that there could be some signs on the cells of the grid that point outside the grid. You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest. You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only. Return the minimum cost to make the grid have at least one valid path.","Depth-First Search (DFS) with backtracking, exploring all possible paths and minimizing the cost of changes.","Greedy algorithm, always choosing the direction with the lowest immediate cost.","Dynamic programming, building a table of minimum costs to reach each cell, but without considering the starting point.",A* search algorithm using Manhattan distance to the target as a heuristic.,Dijkstra's algorithm or Breadth-First Search (BFS) with a cost of 0 for following the correct direction and 1 for changing it.,Hard,algorithms,"Array,Breadth-First Search,Graph,Heap (Priority Queue),Matrix,Shortest Path"
1472,"Increasing Decreasing String
You are given a string s. Reorder the string using the following algorithm: If the smallest or largest character appears more than once, you may choose any occurrence to append to the result. Return the resulting string after reordering s using this algorithm.","Append the characters in ascending order of ASCII value, then in descending order, until the string is empty.",Sort the string lexicographically and return the sorted string directly.,Randomly shuffle the string until the increasing-decreasing pattern is achieved.,"Append the smallest character, remove all occurrences of the largest, then append the largest, removing all occurrences of the smallest, repeating until the string is empty.","Find the smallest and largest characters, append them alternately in increasing then decreasing order, removing used characters, until the string is empty.",Easy,algorithms,"Hash Table,String,Counting"
1473,"Find the Longest Substring Containing Vowels in Even Counts
Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.",Maintain a count for each vowel and reset the substring when an odd count is encountered,Use dynamic programming to store the longest substring length for each prefix of the string,"Employ a sliding window, expanding it until a vowel appears an odd number of times, then shrinking it",Sort the string and then find the longest substring with vowels appearing in even counts,Use a bitmask to represent vowel counts and a hash map to store the first occurrence of each bitmask,Medium,algorithms,"Hash Table,String,Bit Manipulation,Prefix Sum"
1474,"Longest ZigZag Path in a Binary Tree
You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree.",Perform a breadth-first search (BFS) and track the length of each path encountered.,Conduct a depth-first search (DFS) and always prioritize left branches over right branches.,"Utilize dynamic programming, storing the longest zigzag path ending at each node.","Employ a greedy algorithm, always selecting the branch that appears longer locally.",Use recursion with two parameters: one for the direction (left/right) and another for the current zigzag length.,Medium,algorithms,"Dynamic Programming,Tree,Depth-First Search,Binary Tree"
1475,"Maximum Sum BST in Binary Tree
Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST). Assume a BST is defined as follows:","Perform an in-order traversal, checking for BST properties at each node and calculating the sum if it is a BST. Return the overall maximum.","Transform the tree into an array, then iterate through all possible subarrays, checking if each is a BST and tracking the maximum sum.","Use dynamic programming, storing the maximum BST sum for each subtree, regardless of whether the subtree itself is a BST.","Calculate the sum of all nodes in the tree, then subtract the minimum possible sum of any non-BST subtree.","Recursively traverse the tree, returning the minimum and maximum values of the subtree, a boolean indicating if it's a BST, and its sum. Track the overall maximum BST sum.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Binary Search Tree,Binary Tree"
1490,"Generate a String With Characters That Have Odd Counts
Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.","If n is even, return a string of 'a' repeated n times. If n is odd, return a string of 'b' repeated n times.",Always return a string of 'a' repeated n-1 times followed by 'b'.,"If n is even, return 'a' repeated n/2 times followed by 'b' repeated n/2 times. If n is odd, return 'a' repeated (n+1)/2 times followed by 'b' repeated (n-1)/2 times.",Return a string of 'a' repeated n-2 times followed by 'bc'.,"If n is odd, return 'a' repeated n times. If n is even, return 'a' repeated n-1 times followed by 'b'.",Easy,algorithms,String
1491,"Number of Times Binary String Is Prefix-Aligned
You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index flips[i] will be flipped in the ith step. A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros. Return the number of times the binary string is prefix-aligned during the flipping process.",The number of set bits after each flip must equal the maximum index flipped so far.,The string is prefix-aligned only when all the bits in `flips` are flipped in ascending order.,The number of prefix-aligned states is directly proportional to the standard deviation of the `flips` array.,The number of prefix-aligned states can be determined by checking if the current index is divisible by the number of flips.,Maintain the maximum index flipped so far and the number of ones flipped so far. Increment the count when they are equal.,Medium,algorithms,Array
1492,"Time Needed to Inform All Employees
A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news). Return the number of minutes needed to inform all the employees about the urgent news.","Use a breadth-first search (BFS) to traverse the employee hierarchy, tracking the maximum time at each level",Sort the employees by their informTime and then use a depth-first search (DFS),Calculate the total informTime for each employee and return the sum of all informTimes,Create an adjacency matrix representing the employee hierarchy and apply Dijkstra's algorithm,"Use a depth-first search (DFS) to traverse the employee hierarchy, summing informTime along each path and returning the maximum path sum",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search"
1493,"Frog Position After T Seconds
Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",Use Depth-First Search (DFS) and divide the probability equally among all possible paths regardless of time constraints.,"Apply Breadth-First Search (BFS) without considering visited nodes, potentially leading to cycles and incorrect probability calculations.","Calculate the shortest path using Dijkstra's algorithm and assume the probability is 1 if the path length equals t, otherwise 0.","Simulate random jumps for t seconds and return 1 if the frog lands on the target, otherwise 0 (without averaging over multiple simulations).","Employ Depth-First Search (DFS) with probability tracking, updating the probability at each step based on the number of unvisited neighbors and the remaining time.",Hard,algorithms,"Tree,Depth-First Search,Breadth-First Search,Graph"
1509,"Replace Employee ID With The Unique Identifier
Table: Employees  Table: EmployeeUNI  Write a solution to show the unique ID of each user, If a user does not have a unique ID replace just show null. Return the result table in any order. The result format is in the following example.",Use a LEFT JOIN from `Employees` to `EmployeeUNI` on `Employees.id = EmployeeUNI.id` and select `EmployeeUNI.unique_id` and `Employees.name`.,Use a RIGHT JOIN from `Employees` to `EmployeeUNI` on `Employees.id = EmployeeUNI.id` and select `EmployeeUNI.unique_id` and `Employees.name`.,Use an INNER JOIN between `Employees` and `EmployeeUNI` on `Employees.id = EmployeeUNI.id` and select `EmployeeUNI.unique_id` and `Employees.name`.,Use a CROSS JOIN between `Employees` and `EmployeeUNI` and select `EmployeeUNI.unique_id` and `Employees.name` where `Employees.id = EmployeeUNI.id`.,"Use a LEFT JOIN from `Employees` to `EmployeeUNI` on `Employees.id = EmployeeUNI.id` and select COALESCE(`EmployeeUNI.unique_id`, NULL) and `Employees.name`.",Easy,database systems,Database
1498,"Find a Corresponding Node of a Binary Tree in a Clone of That Tree
Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.","Perform a level-order traversal on both trees, comparing node values to find the target's match in the cloned tree.","Recursively traverse both trees simultaneously, returning the corresponding node in the cloned tree when the target node is found in the original tree.","Store the inorder traversal of the original tree in an array, then search for the target node's value in this array and use its index to find the corresponding node in the inorder traversal of the cloned tree.",Utilize a hash table to map nodes in the original tree to their corresponding nodes in the cloned tree during a pre-order traversal. Return the value from the hash table using the target node as a key.,"Perform a parallel tree traversal on both the original and cloned trees, returning the corresponding node in the cloned tree when the target node is encountered in the original tree.",Easy,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1496,"Lucky Numbers in a Matrix
Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order. A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.",Hash each element and check for collisions.,"Sort each row and column independently, then compare.",Use binary search on each row and column.,Calculate the average of each row and column; lucky numbers will be close to both averages.,Find the minimum of each row and the maximum of each column; compare these values for matches.,Easy,algorithms,"Array,Matrix"
1497,"Design a Stack With Increment Operation
Design a stack that supports increment operations on its elements. Implement the CustomStack class:",Use an auxiliary array to store increment values and apply them lazily on pop operations,Increment the stack elements directly upon receiving the increment command,"Implement increment by pushing new, incremented values onto the stack","Ignore the increment operation entirely, focusing solely on push and pop","Store increment operations in a separate array and apply them when popping elements, considering stack size limits",Medium,data structures,"Array,Stack,Design"
1285,"Balance a Binary Search Tree
Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them. A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.","Perform in-order traversal, sort the resulting array, and construct a balanced BST from the sorted array.",Calculate the height of the tree and apply rotations until the height difference between subtrees is at most 1 for all nodes.,"Convert the BST into an array by level-order traversal, sort the array and recreate the BST.",Use a self-balancing tree algorithm like AVL or Red-Black tree directly to insert the nodes.,"Perform an in-order traversal to get a sorted array, then construct a balanced BST from the sorted array using a recursive approach.",Medium,data structures,"Divide and Conquer,Greedy,Tree,Depth-First Search,Binary Search Tree,Binary Tree"
1499,"Maximum Performance of a Team
You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively. Choose at most k different engineers out of the n engineers to form a team with the maximum performance. The performance of a team is the sum of its engineers' speeds multiplied by the minimum efficiency among its engineers. Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.","Sort engineers by speed and greedily pick the top k fastest, regardless of efficiency.",Sort engineers by efficiency and use dynamic programming to find the optimal subset of size k.,"Iterate through all possible subsets of size k, calculate performance, and find the maximum.","Sort engineers by speed, and for each engineer, consider them as the least efficient, calculating the maximum performance using the k-1 fastest remaining engineers.","Sort engineers by efficiency in descending order. Iterate through them, maintaining a min-heap of speeds of selected engineers. Calculate performance at each step and update the maximum.",Hard,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
1486,"Find the Distance Value Between Two Arrays
Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays. The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.",Return the count of elements in `arr1`.,Return the count of elements in `arr2`.,Return the absolute difference between the sums of `arr1` and `arr2`.,Return the number of elements in `arr1` that are greater than `d`.,"For each element in `arr1`, check if its absolute difference with any element in `arr2` is less than or equal to `d`. Count elements in `arr1` that satisfy this condition.",Easy,algorithms,"Array,Two Pointers,Binary Search,Sorting"
1487,"Cinema Seat Allocation
 A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above. Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved. Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.",Use dynamic programming to find the optimal allocation for each row independently,"Sort the reserved seats and then iterate through rows, greedily allocating groups where possible","Consider only the first four rows and multiply the result by n/4, assuming uniform reservation distribution","Allocate all possible groups and then subtract groups that overlap with reserved seats, adjusting for aisle overlaps","Use a hash map to store reserved seats by row, then iterate through each row, checking for available four-seat blocks considering aisle splits",Medium,algorithms,"Array,Hash Table,Greedy,Bit Manipulation"
1488,"Sort Integers by The Power Value
The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps: For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1). Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order. Return the kth integer in the range [lo, hi] sorted by the power value. Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer.","Use a comparison-based sorting algorithm (e.g., merge sort) directly on the integers in the range [lo, hi], calculating the power value on the fly for each comparison.","Calculate the power value for each integer in the range [lo, hi] and store them in a min-heap, then extract the k-th smallest power value and find the corresponding integer.","Pre-compute the power values for all integers up to 'hi' using memoization. Sort the integers in [lo, hi] based on their pre-computed power values using a stable sorting algorithm.","Employ a radix sort algorithm on the integers in the range [lo, hi], using the power value as the key for each digit position.","Compute the power value for each integer in the range [lo, hi], store them as (integer, power) pairs. Sort these pairs primarily by power value and secondarily by integer value. Return the k-th integer.",Medium,algorithms,"Dynamic Programming,Memoization,Sorting"
1489,"Pizza With 3n Slices
There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows: Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.",Apply dynamic programming with overlapping subproblems considering the circular arrangement by duplicating the first 'n' elements,"Use a greedy approach, always picking the largest slice available at each turn, ensuring to skip adjacent slices picked by others","Sort the slices in descending order and pick every third slice starting from the largest, maximizing the sum",Apply a backtracking algorithm to explore all possible combinations of slices and select the combination that yields the maximum sum,"Model the problem as a constrained subsequence selection and use dynamic programming to find the optimal sum, handling the circular nature of the pizza slices.",Hard,algorithms,"Array,Dynamic Programming,Greedy,Heap (Priority Queue)"
1505,"Create Target Array in the Given Order
Given two arrays of integers nums and index. Your task is to create target array under the following rules: Return the target array. It is guaranteed that the insertion operations will be valid.","Use a hash table to store the elements and their indices, then build the target array.",Sort the 'index' array and rearrange the 'nums' array accordingly before creating the target array.,"Create a temporary array and insert elements at the specified indices using array slicing, then convert to the target array.","Pre-allocate the target array with a default value, then iteratively place the elements using direct assignment.","Iterate through the 'nums' and 'index' arrays, using a list's insert method to place elements at the specified positions.",Easy,algorithms,"Array,Simulation"
1284,"Four Divisors
Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.",Iterate through each number and count its divisors using a loop from 1 to the number itself.,Precompute all prime numbers up to the square root of the maximum number in the input array.,Use dynamic programming to store the number of divisors for each number encountered.,Employ binary search to find pairs of divisors efficiently.,"For each number, check if it has exactly four divisors by iterating up to its square root; sum the divisors if the count is four.",Medium,algorithms,"Array,Math"
1507,"Check if There is a Valid Path in a Grid
You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be: You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets. Notice that you are not allowed to change any street. Return true if there is a valid path in the grid or false otherwise.","Depth-First Search (DFS) always finds the shortest path, so if it reaches the end, the path is valid.",Convert the grid to a graph and use Dijkstra's algorithm to find the shortest path.,"Check if the sum of all street numbers is even. If it is, a valid path exists.","Iterate through the grid randomly until the end is reached, which indicates the existence of a path.","Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the grid, respecting street directions, and check if the destination is reachable.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
1508,"Longest Happy Prefix
A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself). Given a string s, return the longest happy prefix of s. Return an empty string """" if no such prefix exists.","Use a brute-force approach, comparing all possible prefixes and suffixes for equality.",Implement a Trie data structure to store all prefixes and efficiently search for suffixes.,"Employ dynamic programming, building a table of boolean values indicating whether a prefix is also a suffix.",Reverse the string and use a simple string matching algorithm to find common prefixes.,Utilize the Knuth-Morris-Pratt (KMP) algorithm to compute the longest proper prefix suffix (LPS) array.,Hard,algorithms,"String,Rolling Hash,String Matching,Hash Function"
1523,"Capital Gain/Loss
Table: Stocks  Write a solution to report the Capital gain/loss for each stock. The Capital gain/loss of a stock is the total gain or loss after buying and selling the stock one or many times. Return the result table in any order. The result format is in the following example.",Use nested loops to calculate the gain/loss for each transaction of each stock.,Employ a cross join to pair every buy transaction with every sell transaction and compute the difference.,Calculate the total quantity of each stock and multiply by the average price.,Group all transactions by stock and sum only the positive differences between consecutive transactions.,"Group transactions by stock and sum the 'operation' column, where buy operations are negative and sell operations are positive.",Medium,database systems,Database
1510,"Find Lucky Integer in an Array
Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1.","Return the mode of the array if it equals the frequency of the mode; otherwise, return -1","Return the median of the array if it equals the frequency of the median; otherwise, return -1","Iterate through the array and return the smallest integer whose value equals its index; otherwise, return -1","Sort the array and return the average value if it equals the frequency of the average; otherwise, return -1","Count frequencies using a hash map, then iterate to find the largest number matching its frequency, returning -1 if none exists",Easy,algorithms,"Array,Hash Table,Counting"
1511,"Count Number of Teams
There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).","Count triplets where rating[i] < rating[j] < rating[k] with i < j < k, only considering strictly increasing sequences.","Count triplets where rating[i] > rating[j] > rating[k] with i < j < k, only considering strictly decreasing sequences.",Count triplets that are either strictly increasing or strictly decreasing based on the order of indices.,Count all possible combinations of three soldiers and subtract those that do not satisfy the increasing or decreasing rating condition.,Count triplets where rating[i] < rating[j] < rating[k] OR rating[i] > rating[j] > rating[k] with i < j < k.,Medium,algorithms,"Array,Dynamic Programming,Binary Indexed Tree"
1512,"Design Underground System
An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class: You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.",Use two hash maps: one for check-in times and another for total travel times between stations.,"Store all check-in and check-out events in a single, ordered list and compute averages on demand.","Maintain a relational database to store all trips, using SQL queries to compute the average times.","Use a single hash map storing customer ID as key and a tuple containing start station, end station, check-in time, and check-out time.",Use two hash maps: one for active passengers and another for precomputed travel times between station pairs.,Medium,system design,"Hash Table,String,Design"
1513,"Find All Good Strings
Given the strings s1 and s2 of size n and the string evil, return the number of good strings. A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 109 + 7.",Use a brute-force approach by generating all possible strings between s1 and s2 and checking for the evil substring.,"Employ dynamic programming with a state representing the current position, a flag indicating if s1 has been exceeded, a flag indicating if s2 has been reached, and the length of the matched evil string.","Utilize the Aho-Corasick algorithm to build a state machine for the evil string and then perform a search between s1 and s2, avoiding states that match the evil string.","Apply a greedy algorithm, always choosing the lexicographically smallest character that doesn't create the evil substring.",Combine dynamic programming with the KMP algorithm to efficiently track the occurrences of the evil string and count the number of good strings within the given lexicographical range.,Hard,algorithms,"String,Dynamic Programming,String Matching"
1500,"Count Largest Group
You are given an integer n. We need to group the numbers from 1 to n according to the sum of its digits. For example, the numbers 14 and 5 belong to the same group, whereas 13 and 3 belong to different groups. Return the number of groups that have the largest size, i.e. the maximum number of elements.","Iterate from 1 to n, storing counts of digit sums in an array, then find the maximum count.",Calculate the digit sum for each number from 1 to n and store all sums in a set to find unique groups.,Use recursion to calculate the digit sum for each number and store the results in a hash table.,Sort the numbers from 1 to n based on their digit sum and count the largest consecutive group.,"Calculate digit sums for numbers 1 to n, use a hash map to count group sizes, then find the count of the largest group.",Easy,algorithms,"Hash Table,Math"
1502,"Construct K Palindrome Strings
Given a string s and an integer k, return true if you can use all the characters in s to construct non-empty k palindrome strings or false otherwise.","If k is greater than the string length, return true","If the string length is even, always return true",Return true if the number of distinct characters in the string is less than or equal to k,"If k is 1, return true if the string is already a palindrome",Return true if k is less than or equal to the length of s and the number of characters with odd frequency is less than or equal to k,Medium,algorithms,"Hash Table,String,Greedy,Counting"
1501,"Circle and Rectangle Overlapping
You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle. Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time.",Check if the circle's center is within the rectangle.,"Calculate the distance between the circle's center and each corner of the rectangle, returning true if any distance is less than or equal to the radius.",Check if the circle's area is greater than the rectangle's area.,Transform the rectangle into a circle and check for circle-circle overlap.,"Find the closest point on the rectangle to the circle's center, and check if the distance between them is less than or equal to the radius.",Medium,algorithms,"Math,Geometry"
1503,"Reducing Dishes
A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time. Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i]. Return the maximum sum of like-time coefficient that the chef can obtain after preparing some amount of dishes. Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.",Sort the satisfaction array in ascending order and calculate the like-time coefficient by including dishes from left to right.,"Use dynamic programming with a state representing the index of the dish and whether it's included or not, considering all possible subsets.",Sort the satisfaction array in descending order and greedily include dishes as long as the sum of the like-time coefficient increases.,Apply a divide-and-conquer approach by splitting the dishes into smaller groups and recursively calculating the optimal arrangement for each group.,"Sort the satisfaction array in ascending order and iterate from the end, including dishes as long as including the next dish increases the total like-time coefficient.",Hard,algorithms,"Array,Dynamic Programming,Greedy,Sorting"
1519,"Minimum Subsequence in Non-Increasing Order
Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.","Greedily pick elements from the end until the subsequence sum exceeds the remaining elements sum, then sort.",Calculate the total sum and repeatedly remove the smallest element until the remaining sum is less than half of the total sum.,Sort the array and take elements from the beginning until the sum of selected elements is greater than the sum of the remaining elements.,Use dynamic programming to find all possible subsequences and choose the optimal one based on the given criteria.,Sort the array in non-increasing order and greedily select elements from the beginning until their sum exceeds the sum of the remaining elements.,Easy,algorithms,"Array,Greedy,Sorting"
1520,"Number of Steps to Reduce a Number in Binary Representation to One
Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules: If the current number is even, you have to divide it by 2. If the current number is odd, you have to add 1 to it. It is guaranteed that you can always reach one for all test cases.",O(1),O(log log n),O(n^2),O(n log n),O(n),Medium,algorithms,"String,Bit Manipulation"
algorithms,1304,"Longest Happy String
A string s is called happy if it satisfies the following conditions: Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string """". A substring is a contiguous sequence of characters within a string.","Greedily append the character with the largest remaining count, backtracking if it creates an unhappy substring, leading to potential inefficiency.","Recursively explore all possible combinations of characters, pruning branches that lead to unhappy substrings, which can result in stack overflow for large inputs.","Randomly generate strings until a happy string is found with length a+b+c, which may never terminate for certain inputs.","Prioritize characters based on the order 'a', 'b', then 'c', always appending the first available character without considering potential future constraints.",,"['greedy algorithm', 'string manipulation', 'heap']","Greedily append the two most frequent characters, preventing triple repetitions, until all characters are used or no more happy string can be formed."
algorithms,1522,"Stone Game III
Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue. Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row. The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially. The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken. Assume Alice and Bob play optimally. Return ""Alice"" if Alice will win, ""Bob"" if Bob will win, or ""Tie"" if they will end the game with the same score.","Use a greedy approach, always taking the maximum possible stone value.","Apply dynamic programming from the end of the array to the beginning, storing the difference in scores.","Simulate the game using recursion with memoization, exploring all possible moves.",Calculate the total sum and divide it equally between Alice and Bob to determine the winner.,,"['dynamic programming', 'game theory', 'optimization']",Utilize a bottom-up dynamic programming approach to determine the maximum score difference Alice can achieve.
database systems,1541,"Top Travellers
Table: Users  Table: Rides  Write a solution to report the distance traveled by each user. Return the result table ordered by travelled_distance in descending order, if two or more users traveled the same distance, order them by their name in ascending order. The result format is in the following example.","SELECT u.name, SUM(r.distance) AS travelled_distance FROM Users u LEFT JOIN Rides r ON u.id = r.user_id GROUP BY u.id ORDER BY u.name ASC, travelled_distance DESC;","SELECT u.name, COALESCE(SUM(r.distance), 0) AS travelled_distance FROM Users u INNER JOIN Rides r ON u.id = r.user_id GROUP BY u.name ORDER BY travelled_distance DESC, u.name ASC;","SELECT u.name, SUM(r.distance) AS travelled_distance FROM Users u, Rides r WHERE u.id = r.user_id GROUP BY u.id ORDER BY travelled_distance DESC, u.name ASC;","SELECT u.name, SUM(r.distance) AS travelled_distance FROM Users u FULL OUTER JOIN Rides r ON u.id = r.user_id GROUP BY u.id ORDER BY travelled_distance DESC;",,"['SQL', 'JOIN', 'aggregate function']","SELECT u.name, COALESCE(SUM(r.distance), 0) AS travelled_distance FROM Users u LEFT JOIN Rides r ON u.id = r.user_id GROUP BY u.id ORDER BY travelled_distance DESC, u.name ASC;"
algorithms,1524,"String Matching in an Array
Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.","Sort the array and then iterate through adjacent elements, checking for substring relationships",Use a hash table to store all possible substrings of each word and then check for matches,Employ a trie data structure to efficiently search for substrings within the array,Apply dynamic programming to build a table of substring relationships between all words,,"['string matching', 'substring', 'array']",Iterate through each word and check if it is a substring of any other word in the array
algorithms,1525,"Queries on a Permutation With Key
Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules: Return an array containing the result for the given queries.",Use a boolean array to mark visited indices and backtrack when encountering marked indices,"Sort the queries array and then iterate through it, maintaining a sorted list of processed elements",Apply a sliding window approach to find the position of each query in the permutation,Precompute all possible permutations and look up the index for each query,,"['array manipulation', 'permutation', 'index']","Maintain a permutation array and for each query, find its index, move it to the front, and record the index"
1526,"HTML Entity Parser
HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: Given the input text string to the HTML parser, you have to implement the entity parser. Return the text after replacing the entities by the special characters.",Use a regular expression to replace all entities in a single pass.,"Iterate through the string, replacing entities character by character using a switch statement.",Create a dictionary mapping entities to characters and use the replace() method.,Split the string into words and replace entities in each word using a series of if-else statements.,Use a finite state machine to parse the HTML and replace entities.,Medium,algorithms,"Hash Table,String"
1527,"Number of Ways to Paint N × 3 Grid
You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color). Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7.","O(n^3), where n is the number of rows","O(3^n), where n is the number of rows","O(2^n), where n is the number of rows","O(n log n), where n is the number of rows","O(n), where n is the number of rows",Hard,algorithms,Dynamic Programming
1514,"Minimum Value to Get Positive Step by Step Sum
Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1.","Perform a binary search on the possible startValue range, checking if each value satisfies the condition.",Calculate the cumulative sum of the array and return the absolute value of the maximum cumulative sum.,"Return 1, as any positive startValue will eventually lead to a positive step-by-step sum.",Calculate the average of the elements in the array and return its absolute value plus 1.,Calculate the cumulative sum of the array and return the absolute value of the minimum cumulative sum plus 1.,Easy,algorithms,"Array,Prefix Sum"
1515,"Find the Minimum Number of Fibonacci Numbers Whose Sum Is K
Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times. The Fibonacci numbers are defined as:","Use a greedy approach, always subtracting the largest Fibonacci number less than or equal to the current remaining value of k","Generate all Fibonacci numbers up to k, then use dynamic programming to find the minimum count","Generate Fibonacci numbers up to k, then use a depth-first search to explore all possible combinations",Decompose k into its prime factors and count the number of distinct Fibonacci numbers corresponding to each prime,"Generate Fibonacci numbers up to k, then iterate downwards, subtracting the largest possible Fibonacci number from k at each step and incrementing a counter",Medium,algorithms,Greedy
1516,"The k-th Lexicographical String of All Happy Strings of Length n
A happy string is a string that: For example, strings ""abc"", ""ac"", ""b"" and ""abcbabcbcb"" are all happy strings and strings ""aa"", ""baa"" and ""ababbc"" are not happy strings. Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order. Return the kth string of this list or return an empty string if there are less than k happy strings of length n.",Hash all possible combinations and return the k-th element,Use a backtracking algorithm with pruning to generate strings until the k-th is found,Generate all possible strings of length 'n' and then sort and return the k-th string if it exists,Employ dynamic programming to store previously generated happy strings,"Use recursion to explore possible strings, keeping track of the count and returning when the k-th string is reached",Medium,algorithms,"String,Backtracking"
1517,"Restore The Array
A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array. Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.","Employ a greedy algorithm, always choosing the largest possible number less than or equal to k","Utilize dynamic programming with a bottom-up approach, building solutions for smaller substrings","Recursively explore all possible array splits, pruning branches that exceed k",Apply a sliding window technique to identify valid integer substrings,"Implement dynamic programming with memoization, storing the number of valid arrays for each prefix of the string",Hard,algorithms,"String,Dynamic Programming"
1532,"Reformat The String
You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return the reformatted string or return an empty string if it is impossible to reformat the string.","Calculate the difference in counts of digits and letters; if the absolute difference is greater than 1, return an empty string.","Sort the string lexicographically, then alternate characters based on their original order.",Greedily pick the most frequent character type and interleave it with the least frequent one.,"Recursively partition the string into two halves, one containing only digits and the other only letters.","Separate digits and letters into two lists; if the size difference > 1, return ''; otherwise interleave them, starting with the larger list.",Easy,algorithms,String
1533,"Display Table of Food Orders in a Restaurant
Given the array orders, which represents the orders that customers have done in a restaurant. More specifically orders[i]=[customerNamei,tableNumberi,foodItemi] where customerNamei is the name of the customer, tableNumberi is the table customer sit at, and foodItemi is the item customer orders. Return the restaurant's “display table”. The “display table” is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is “Table”, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.","Use a hash map to store food counts for each table, then convert to a sorted list of lists.",Sort the orders array lexicographically and then iterate to construct the display table.,"Create a matrix with tables as rows and food items as columns, initializing all values to zero before counting.","Use SQL to group by table number and food item, then pivot the result into the desired table format.","Collect unique food items and table numbers, sort them, and then count food items per table to construct the display table.",Medium,algorithms,"Array,Hash Table,String,Sorting,Ordered Set"
1534,"Minimum Number of Frogs Croaking
You are given the string croakOfFrogs, which represents a combination of the string ""croak"" from different frogs, that is, multiple frogs can croak at the same time, so multiple ""croak"" are mixed. Return the minimum number of different frogs to finish all the croaks in the given string. A valid ""croak"" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid ""croak"" return -1.","Use a greedy approach, assigning each 'c' to an existing frog if available, otherwise creating a new frog. Return -1 if 'k' count exceeds any other character.","Count the occurrences of each character ('c', 'r', 'o', 'a', 'k'). The maximum count represents the minimum number of frogs. Return -1 if counts are unequal.","Recursively process the string. At each step, find a complete 'croak' sequence and remove it. The recursion depth is the minimum number of frogs. Return -1 if no 'croak' sequence is found.",Simulate a multi-threaded execution where each frog is a thread. The number of threads needed to execute all 'croak' sequences is the answer. Return -1 if a thread gets blocked.,"Maintain a count of active frogs for each stage ('c', 'r', 'o', 'a', 'k'). Increment when a stage starts ('c') and decrement when it ends ('k'). Track the maximum number of active frogs. Return -1 if the sequence is invalid.",Medium,algorithms,"String,Counting"
1535,"Build Array Where You Can Find The Maximum Exactly K Comparisons
You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers: You should build the array arr which has the following properties: Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.","Dynamic programming with state (index, cost, max_so_far) and memoization.",Greedy algorithm that always picks the smallest element possible.,Recursion with backtracking and pruning to explore all possible arrays.,Mathematical formula derived from combinatorics to directly calculate the number of arrays.,"Dynamic programming with state (index, remaining_comparisons, max_so_far) and memoization, calculating transitions based on possible values at each index.",Hard,algorithms,Dynamic Programming
1537,"Maximum Score After Splitting a String
Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.",Count zeros and ones simultaneously from left to right.,"Count the number of possible splits, and return that number.",Split the string at the middle index.,Recursively split the string and calculate the score.,Iterate through all possible split positions and calculate the score for each split.,Easy,algorithms,String
1538,"Maximum Points You Can Obtain from Cards
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain.","Use a greedy approach, always picking the larger point card from either end.",Calculate all possible combinations of picking k cards from the beginning and end using recursion.,Sort the cardPoints array and pick the k largest values.,Compute the sum of all card points and subtract the minimum sum of a subarray of length n-k.,Use a sliding window approach to find the minimum sum of a subarray of length n-k.,Medium,algorithms,"Array,Sliding Window,Prefix Sum"
1539,"Diagonal Traverse II
Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.",Use a hash table to store elements and retrieve them in diagonal order.,Sort the flattened array and then reshape it into the original dimensions.,"Recursively traverse the array, processing diagonals from top-left to bottom-right.",Flatten the array and then sort it according to the sum of row and column indices.,"Group elements by the sum of their row and column indices, then iterate through the groups.",Medium,algorithms,"Array,Sorting,Heap (Priority Queue)"
1286,"Constrained Subsequence Sum
Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied. A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.","Recursively explore all possible subsequences, pruning branches that violate the constraint.",Use dynamic programming with a 2D array to store the maximum sums of subsequences ending at each index.,"Apply a greedy approach, always selecting the largest element within the constraint window.",Sort the array and then select elements based on their indices relative to the original array to maintain subsequence properties.,"Use a deque to maintain a sliding window of maximum subsequence sums, updating the current element's sum based on the maximum sum within the window.",Hard,algorithms,"Array,Dynamic Programming,Queue,Sliding Window,Heap (Priority Queue),Monotonic Queue"
1528,"Kids With the Greatest Number of Candies
There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies.",Sort the `candies` array and compare each element plus `extraCandies` with the last element,Calculate the average number of candies and check if each kid's candies plus `extraCandies` is greater than or equal to the average,Use a priority queue to keep track of the kid with the most candies and update it after adding `extraCandies` to each kid,Create a boolean array initialized to `true` and change each element to `false` if the condition isn't met,Find the maximum value in `candies` and check if each element plus `extraCandies` is greater than or equal to the maximum,Easy,algorithms,Array
algorithms,1529,"Max Difference You Can Get From Changing an Integer
You are given an integer num. You will apply the following steps to num two separate times: Let a and b be the two results from applying the operation to num independently. Return the max difference between a and b. Note that neither a nor b may have any leading zeros, and must not be 0.","Convert `num` to a string. In the first operation, replace all occurrences of the first non-9 digit with 9. In the second operation, replace all occurrences of the first digit with 0, unless it's already 0, then replace the first non-zero digit with 1. Return the difference.","Iterate through all possible digit replacements (0-9 for each digit position) for both operations, calculate all possible numbers, filter out invalid numbers (leading zeros), and find the maximum difference. This is a brute-force approach.","Convert the integer to a string. Operation 1 involves replacing the largest digit with 9, Operation 2 involves replacing the smallest digit with 0. If the leading digit is the smallest, replace the next smallest non-zero digit with 1.",Implement a recursive function to try all possible digit replacements for both operations and compute the difference between the resulting numbers. The base case is when all digits have been considered.,,"['string manipulation', 'greedy algorithm', 'integer manipulation']","Convert `num` to a string. In the first operation, replace all occurrences of the leftmost digit that isn't 9 with 9. In the second operation, if the leftmost digit is 1, replace the leftmost non-zero, non-one digit with 0; otherwise, replace all occurrences of the leftmost digit with 1."
algorithms,1530,"Check If a String Can Break Another String
Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. In other words s2 can break s1 or vice-versa. A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.",Return True immediately if s1 and s2 are identical.,"Compare the ASCII values of the first characters of s1 and s2; return True if s1[0] >= s2[0], otherwise False.","Sort s1 and s2, then check if s1[i] < s2[i] for any i; if so, return False, otherwise True.","Check if the length of s1 is greater than or equal to the length of s2, and return the result.",,"['string comparison', 'sorting', 'permutation']","Sort s1 and s2; check if s1[i] >= s2[i] for all i, or s2[i] >= s1[i] for all i."
algorithms,1531,"Number of Ways to Wear Different Hats to Each Other
There are n people and 40 types of hats labeled from 1 to 40. Given a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person. Return the number of ways that n people can wear different hats from each other. Since the answer may be too large, return it modulo 109 + 7.","Use dynamic programming with a bitmask representing which people have been assigned hats, iterating through all possible hat assignments.",Create a permutation of all hats and check if each person can wear the assigned hat; count valid assignments.,"Employ a greedy approach, assigning each person their least favorite hat and incrementing the count if all people can wear a unique hat.","Backtrack through the possible hat assignments for each person, pruning branches that violate the unique hat constraint.",,"['dynamic programming', 'bitmask', 'combinatorics']",Utilize dynamic programming with a bitmask representing assigned people and memoization to avoid redundant calculations of subproblems.
algorithms,1547,"Destination City
You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",Use a hash map to store the starting cities and iterate through the ending cities to find one not in the map,Sort the paths array alphabetically and return the last city in the last path,"Recursively traverse the paths array, keeping track of visited cities, and return the last visited city",Convert the paths array into a directed graph and perform a depth-first search to find a node with no outgoing edges,,"['graph theory', 'array traversal', 'set']","Create a set of starting cities and iterate through the ending cities, returning the one not present in the set"
algorithms,1548,"Check If All 1's Are at Least Length K Places Away
Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other, otherwise return false.",Check for adjacent 1s and return false immediately if found,Maintain a count and reset it whenever encountering a 0,"Iterate through the array and store indices of all 1s, then calculate the minimum distance between them",Use a sliding window of size k to check if it contains more than one 1,,"['array', 'iteration', 'distance']",Maintain the index of the last seen 1 and compare the current index with it
1549,"Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.","Use a brute-force approach with nested loops to check all possible subarrays, resulting in O(n^2) time complexity.","Apply binary search to find the optimal subarray size, leading to a time complexity of O(n log n).",Maintain a sliding window and update the maximum and minimum values in the window using linear scans.,Sort the entire array first and then find the longest subarray with a difference less than or equal to the limit.,"Utilize two monotonic queues (one for maximum, one for minimum) to efficiently maintain the maximum and minimum values within the sliding window, achieving O(n) time complexity.",Medium,algorithms,"Array,Queue,Sliding Window,Heap (Priority Queue),Ordered Set,Monotonic Queue"
1550,"Find the Kth Smallest Sum of a Matrix With Sorted Rows
You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k. You are allowed to choose exactly one element from each row to form an array. Return the kth smallest array sum among all possible arrays.",Use a min-heap of size k to store the smallest k sums encountered so far.,Generate all possible array combinations and sort them to find the kth smallest sum.,Sort each row of the matrix independently and then sum the first elements of each row.,Binary search for the kth smallest sum within the possible range of sums.,"Use a priority queue (min-heap) to iteratively merge sums from each row with the sums obtained from the previous rows, keeping only the k smallest sums.",Hard,algorithms,"Array,Binary Search,Heap (Priority Queue),Matrix"
1552,"Build an Array With Stack Operations
You are given an integer array target and an integer n. You have an empty stack with the two following operations: You also have a stream of the integers in the range [1, n]. Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules: Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.",Use a priority queue to maintain the order of elements to be pushed and popped,Precompute all possible stack operation sequences and select the shortest one that results in the target array,"Simulate the stack operations using recursion, backtracking when a wrong operation is chosen","First push all numbers from 1 to n, then pop any extra numbers to match the target","Iterate through the target array and the number stream, pushing when the current number is in the target and popping when it's not",Medium,algorithms,"Array,Stack,Simulation"
1553,"Count Triplets That Can Form Two Arrays of Equal XOR
Given an array of integers arr. We want to select three indices i, j and k where (0 <= i < j <= k < arr.length). Let's define a and b as follows: Note that ^ denotes the bitwise-xor operation. Return the number of triplets (i, j and k) Where a == b.",O(n) time complexity and O(1) space complexity,O(n^3) time complexity and O(n) space complexity,O(n^2) time complexity and O(n^2) space complexity,O(n log n) time complexity and O(n) space complexity,O(n^2) time complexity and O(1) space complexity,Medium,algorithms,"Array,Hash Table,Math,Bit Manipulation,Prefix Sum"
1554,"Minimum Time to Collect All Apples in a Tree
Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.",Depth-First Search (DFS) without considering the return path from child nodes.,Breadth-First Search (BFS) that marks nodes with apples as visited but not their parents.,Randomly traverse the tree until all apples are collected and return to the starting vertex.,Calculate the shortest path between every pair of apple-containing vertices and sum them up.,"Perform a Depth-First Search (DFS) to find the minimum path length, considering both the path to an apple and the return path unless the current node is the root.",Medium,algorithms,"Hash Table,Tree,Depth-First Search,Breadth-First Search"
1555,"Number of Ways of Cutting a Pizza
Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person. Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.","Use a greedy approach, always cutting in the way that minimizes the maximum number of apples in any piece.","Recursively try all possible cut combinations without memoization, pruning only when a piece has no apples.",Calculate the total number of apples first and then divide by k to find the ideal apple count per piece; use this to guide the cuts.,Precompute all possible sub-pizzas and their apple counts; then use backtracking to explore combinations.,"Use dynamic programming with memoization to store the number of ways to cut the pizza starting from a given row, column, and number of remaining cuts.",Hard,algorithms,"Array,Dynamic Programming,Memoization,Matrix"
1542,"Consecutive Characters
The power of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string s, return the power of s.",Return the length of the string if all characters are the same,Return the length of the string divided by the number of unique characters,Return the count of the most frequent character in the string,Return the length of the shortest substring with only one unique character,"Iterate through the string, tracking the current character and its consecutive count, updating the maximum count",Easy,algorithms,String
1543,"Simplified Fractions
Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order.",Use a prime sieve to generate all primes less than or equal to n and then generate fractions using these primes as denominators.,"Iterate through all possible numerators and denominators, and only add fractions where the numerator and denominator are relatively prime using trial division up to n.","Iterate through all possible numerators and denominators, and add all fractions between 0 and 1, then remove duplicates from the list.","Maintain a sorted list of fractions and iteratively add new fractions, inserting them at the correct position to maintain sorted order.","Iterate through all possible numerators and denominators, and only add fractions where the numerator and denominator are relatively prime using the Euclidean algorithm.",Medium,algorithms,"Math,String,Number Theory"
1544,"Count Good Nodes in Binary Tree
Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.",Nodes are always good if they are leaf nodes.,The root node is never a good node.,A node is good if its value is greater than or equal to all its ancestors.,Good nodes are those on the longest path from root to a leaf.,A node is good if its value is greater than or equal to the maximum value on the path from the root to that node.,Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1545,"Form Largest Integer With Digits That Add up to Target
Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules: Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return ""0"".","Use dynamic programming with a bottom-up approach, building solutions for smaller targets first.","Greedily choose the digit with the smallest cost until the target is reached, then sort the digits.",Recursively explore all possible combinations of digits until a combination equals the target.,Sort the cost array in descending order and iteratively pick the highest-cost digit possible.,"Use dynamic programming with memoization to store intermediate results, handling leading zeros appropriately.",Hard,algorithms,"Array,Dynamic Programming"
1560,"Number of Students Doing Homework at a Given Time
Given two integer arrays startTime and endTime and given an integer queryTime. The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i]. Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.",Use binary search on sorted `startTime` and `endTime` arrays to find the range of students doing homework at `queryTime`.,Calculate the average start and end times and use that to estimate the number of students doing homework.,"Return the length of the `startTime` array if `queryTime` is greater than the first element of `startTime`, else return 0.",Return the number of elements in `startTime` that are equal to `queryTime`.,"Iterate through the `startTime` and `endTime` arrays, incrementing a counter for each student whose homework interval contains `queryTime`.",Easy,algorithms,Array
1561,"Rearrange Words in a Sentence
Given a sentence text (A sentence is a string of space-separated words) in the following format: Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above.",Sort the words by their ASCII values instead of length.,Reverse the entire sentence and then sort the words.,Sort the words in decreasing order of their lengths.,Group the words by their first letter and then sort within each group.,"Sort the words based on their lengths in ascending order, preserving original order for equal lengths.",Medium,algorithms,"String,Sorting"
1562,"People Whose List of Favorite Companies Is Not a Subset of Another List
Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0). Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.","Iterate through each list and check if it's a subset of any other list, optimizing for early exits",Sort all the lists lexicographically and then compare adjacent lists for subset relationships,Use bit manipulation to represent each list as a bitset and then perform bitwise operations for subset checks,"Compare the lengths of the lists, prioritizing longer lists as potential non-subsets","For each list, check if it is a subset of any other list in the array; return the indices of lists for which no superset is found",Medium,algorithms,"Array,Hash Table,String"
1563,"Maximum Number of Darts Inside of a Circular Dartboard
Alice is throwing n darts on a very large wall. You are given an array darts where darts[i] = [xi, yi] is the position of the ith dart that Alice threw on the wall. Bob knows the positions of the n darts on the wall. He wants to place a dartboard of radius r on the wall so that the maximum number of darts that Alice throws lie on the dartboard. Given the integer r, return the maximum number of darts that can lie on the dartboard.",Brute force: Iterate through all pairs of darts as potential center points and count darts within radius r.,Approximate the center by averaging all dart coordinates and count darts within radius r of that single point.,"Use a greedy approach, always placing the dartboard centered on the dart closest to the origin.","Divide the dartboard into quadrants and check dart density in each quadrant, focusing on the densest.","For each pair of darts, calculate potential circle centers, then count the maximum darts within radius r of those centers.",Hard,algorithms,"Array,Math,Geometry"
1566,"Check If a Word Occurs As a Prefix of Any Word in a Sentence
Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s.",Use dynamic programming to find the longest common prefix,Split the sentence into words and check if `searchWord` == word[:len(searchWord)],Use regular expressions to match `searchWord` at the beginning of each word,Check if the `searchWord` is present anywhere in the sentence using the `in` operator,Split the sentence into words and check if any word starts with `searchWord` using `startswith()`,Easy,algorithms,"String,String Matching"
1567,"Maximum Number of Vowels in a Substring of Given Length
Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.","Use a greedy approach, always selecting the next k characters regardless of vowel count.",Iterate through all possible substrings of length k and calculate the vowel count using regular expressions.,Sort the string alphabetically and count vowels in the first k characters.,Calculate the total number of vowels in the entire string and divide by k.,Use a sliding window of size k to efficiently calculate the vowel count in each substring.,Medium,algorithms,"String,Sliding Window"
1568,"Pseudo-Palindromic Paths in a Binary Tree
Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes.",Use a depth-first search (DFS) without backtracking to count paths where all node values are distinct.,"Use a breadth-first search (BFS) to traverse the tree level by level, checking each level for pseudo-palindromes.","Convert the binary tree into a binary search tree, then count paths with an even number of nodes.","Use a greedy algorithm to always pick the path with the most frequent digit, hoping for a pseudo-palindrome.","Use a depth-first search (DFS) with backtracking, maintaining a frequency count of digits along each path, and increment the count if at most one digit has an odd frequency.",Medium,algorithms,"Bit Manipulation,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
1569,"Max Dot Product of Two Subsequences
Given two arrays nums1 and nums2. Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length. A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).",Calculate the dot product of all possible pairs of elements from nums1 and nums2 and return the maximum.,"Use dynamic programming to compute the maximum dot product considering all possible subsequence lengths up to min(len(nums1), len(nums2)).","Sort both arrays and then calculate the dot product of the sorted arrays, as this will maximize the result.",Return the product of the maximum elements of nums1 and nums2.,"Employ dynamic programming where dp[i][j] represents the maximum dot product using nums1[0...i] and nums2[0...j], considering either including nums1[i]*nums2[j] or excluding one or both elements.",Hard,algorithms,"Array,Dynamic Programming"
1557,"Check If a String Contains All Binary Codes of Size K
Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.","Use a sliding window of size 'k' and check if the number of unique substrings equals 2^k. If it does, return true, otherwise false.",Generate all binary codes of length 'k' and check if each one is present in 's' using the 'in' operator.,Convert 's' to an integer and check if all numbers from 0 to 2^k - 1 are present as substrings when converted back to binary.,Sort all substrings of length 'k' in 's' and check if the sorted list contains all binary codes of length 'k'.,"Iterate through all substrings of length 'k' in 's' and add them to a set. Return true if the set's size is 2^k, else return false.",Medium,algorithms,"Hash Table,String,Bit Manipulation,Rolling Hash,Hash Function"
1558,"Course Schedule IV
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi. Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c. You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not. Return a boolean array answer, where answer[j] is the answer to the jth query.",Depth-First Search (DFS),Kahn's Algorithm,Bellman-Ford Algorithm,Dijkstra's Algorithm,Floyd-Warshall Algorithm,Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
1559,"Cherry Pickup II
You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell. You have two robots that can collect cherries for you: Return the maximum number of cherries collection using both robots by following the rules below:",Greedily move each robot towards the cell with the highest cherry count in the current row.,Use dynamic programming with a 2D array representing the maximum cherries collected up to each cell for each robot.,Calculate the maximum cherries obtainable by each robot independently and sum the results.,"Simulate all possible paths for both robots using recursion, pruning paths that lead to lower cherry counts.",Apply dynamic programming with a 3D array where dp[i][j][k] represents the maximum cherries collected up to row i with robot 1 at column j and robot 2 at column k.,Hard,algorithms,"Array,Dynamic Programming,Matrix"
1575,"Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where: Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.","Multiply the sum of horizontal cuts by the sum of vertical cuts, modulo 10^9 + 7","Find the product of the medians of the horizontal and vertical cuts, modulo 10^9 + 7","Calculate the average spacing between cuts and multiply by h * w, modulo 10^9 + 7","Multiply the number of horizontal cuts by the number of vertical cuts, modulo 10^9 + 7","Find the maximum difference between adjacent horizontal cuts and adjacent vertical cuts, then multiply them, modulo 10^9 + 7",Medium,algorithms,"Array,Greedy,Sorting"
1576,"Reorder Routes to Make All Paths Lead to the City Zero
There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi. This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It's guaranteed that each city can reach city 0 after reorder.",Use Depth-First Search (DFS) and increment a counter for each edge pointing away from city 0 encountered during traversal.,"Construct an adjacency matrix representing the graph, then apply Dijkstra's algorithm to find the shortest path from each city to city 0 and sum the path lengths.",Perform a Breadth-First Search (BFS) starting from city 0 and count the number of edges that need to be reversed to reach all other cities.,"Randomly reverse edges until all cities can reach city 0, then return the number of reversals performed. Repeat multiple times and return the minimum.","Employ Depth-First Search (DFS) from city 0, tracking the number of edges that initially point away from it and need to be flipped.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph"
1577,"Probability of a Two Boxes Having The Same Number of Distinct Balls
Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i. All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully). Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully). Return the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",Calculate the probability using a Monte Carlo simulation,Compute the number of ways to distribute the balls without considering the number of distinct colors,"Use dynamic programming to store intermediate results of distributions, indexed only by the number of balls, not colors",Assume all colors are equally likely and derive a closed-form solution based on the central limit theorem,"Utilize recursion with memoization or dynamic programming to calculate the number of favorable and total outcomes, considering combinations and permutations",Hard,algorithms,"Math,Dynamic Programming,Backtracking,Combinatorics,Probability and Statistics"
1580,"Shuffle the Array
Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn].",Create a new array by interleaving elements from the first and second halves using slicing and concatenation.,"Sort the array based on the index modulo n, then increment the index by 2.","Reverse the array, interleave the first half with the reversed second half, then reverse the entire array again.",Divide the array into n sub-arrays of size 2 and then flatten the resulting list of lists.,"Iterate from 0 to n, inserting nums[i] and nums[i+n] into a new array.",Easy,algorithms,Array
1581,"The k Strongest Values in an Array
Given an array of integers arr and an integer k. A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the centre of the array.
If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j]. Return a list of the strongest k values in the array. return the answer in any arbitrary order. The centre is the middle value in an ordered integer list. More formally, if the length of the list is n, the centre is the element in position ((n - 1) / 2) in the sorted list (0-indexed).",Return the first k elements without any sorting or comparison.,Sort the array and return the last k elements.,Calculate the median and return elements whose value is greater than the median.,Sort the array by absolute difference from the mean and return the first k elements.,"Sort the array, find the median, then sort by strength (absolute difference from the median) and return the first k elements.",Medium,algorithms,"Array,Two Pointers,Sorting"
1582,"Design Browser History
You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class:  Example:  Constraints:",Implement using a singly linked list where forward operations might be inefficient.,"Use an array to store the history, shifting elements when going back or forward.","Use a stack to store the history, popping elements when going back and pushing them back when going forward.",Implement using a queue data structure.,Implement using a doubly linked list with a current pointer.,Medium,system design,"Array,Linked List,Stack,Design,Doubly-Linked List,Data Stream"
1583,"Paint House III
There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that have been painted last summer should not be painted again. A neighborhood is a maximal group of continuous houses that are painted with the same color. Given an array houses, an m x n matrix cost and an integer target where: Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1.","Dynamic programming with memoization based on current house, number of neighborhoods, and previous color, but without considering pre-painted houses","Greedy approach of always choosing the cheapest color for each house to minimize the overall cost, regardless of neighborhood formation","Backtracking search to try all possible color combinations for unpainted houses without proper pruning or memoization, leading to exponential time complexity",Using a minimum spanning tree algorithm to connect houses of the same color to minimize the cost of creating neighborhoods,"Dynamic programming with state (house index, number of neighborhoods formed, last painted color) considering existing colors and costs.",Hard,algorithms,"Array,Dynamic Programming"
1570,"Final Prices With a Special Discount in a Shop
You are given an integer array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all. Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.","Use a stack to store indices and pop when a smaller price is found, calculating the discount.",Sort the prices array and apply a binary search to find the minimum discount for each item.,"Iterate through the array and if no discount is found, set the discount to zero and return the array.",Create a new array containing only prices[j] where j > i. Then subtract the minimum of the new array from prices[i].,"Iterate through the prices array. For each element, find the first smaller element to its right and subtract it. If none exists, keep the original price.",Easy,algorithms,"Array,Stack,Monotonic Stack"
1572,"Subrectangle Queries
Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods: 1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) 2. getValue(int row, int col)","The update operation has O(1) complexity, while getValue has O(m*n) where m and n are dimensions of the subrectangle",Both update and getValue operations have O(1) complexity,"The update operation has O(m+n) complexity, and getValue has O(1)",The update operation has O(1) complexity and getValue has O(log(m*n)) complexity,"The update operation has O(m*n) complexity where m and n are dimensions of the subrectangle, and getValue has O(1)",Medium,algorithms,"Array,Design,Matrix"
1573,"Find Two Non-overlapping Sub-arrays Each With Target Sum
You are given an array of integers arr and an integer target. You have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum. Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.",Use dynamic programming with a 2D array to store minimum lengths ending at each index.,"Apply a greedy approach, always selecting the shortest sub-array that matches the target sum.",Perform a brute-force search by checking all possible sub-array combinations.,"Sort the array first, then use a sliding window to find the sub-arrays.","Use a sliding window to find all sub-arrays with the target sum, then iterate through the sub-arrays to find the minimum combined length of two non-overlapping ones.",Medium,algorithms,"Array,Hash Table,Binary Search,Dynamic Programming,Sliding Window"
1571,"Allocate Mailboxes
Given the array houses where houses[i] is the location of the ith house along a street and an integer k, allocate k mailboxes in the street. Return the minimum total distance between each house and its nearest mailbox. The test cases are generated so that the answer fits in a 32-bit integer.",Dynamic programming with bitmasking to represent mailbox locations,Greedy approach: place mailboxes at the locations of the houses closest to the median,Brute force: try all possible combinations of house locations for mailboxes,"Use a divide-and-conquer strategy, recursively placing mailboxes in subsegments","Dynamic programming with memoization, calculating minimum distance for placing mailboxes up to index i with j mailboxes",Hard,algorithms,"Array,Math,Dynamic Programming,Sorting"
1603,"Running Sum of 1d Array
Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.",Modify the original array in-place by adding each element to the sum of the preceding elements.,"Create a new array and, for each index, calculate the sum of the entire original array and insert it.","Use recursion, summing elements from the end to the beginning of the array.",Sort the array first and then calculate the cumulative sum.,"Create a new array where each element is the sum of all preceding elements in the original array, up to that index.",Easy,algorithms,"Array,Prefix Sum"
1604,"Least Number of Unique Integers after K Removals
Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.",Sort the array and iteratively remove elements from the beginning until k elements are removed.,Use a heap data structure to store the elements and remove the k largest elements.,Randomly select k elements and remove them from the array.,Remove k arbitrary elements from the array without considering their frequency.,"Count element frequencies, store them in a min-heap, and greedily remove elements with the lowest frequency until k elements are removed.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Counting"
1605,"Minimum Number of Days to Make m Bouquets
You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.","Dynamic programming, storing minimum days for sub-gardens and bouquet counts.",Greedily choose the 'm' lowest bloomDay values and check if they form 'k' adjacent groups.,"Sort bloomDay and iterate, incrementing a counter for each day until m*k flowers have bloomed.",Use a priority queue to keep track of blooming flowers and greedily form bouquets.,Binary search on the range of bloomDay values to find the minimum number of days required.,Medium,algorithms,"Array,Binary Search"
1296,"Kth Ancestor of a Tree Node
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node. The kth ancestor of a tree node is the kth node in the path from that node to the root node. Implement the TreeAncestor class:","Depth-First Search (DFS) from the node, tracking visited nodes and stopping after k steps.","Breadth-First Search (BFS) from the root, tracking distances and returning the node at distance k from the target.","Iteratively traverse the parent array k times, moving upwards from the given node.",Maintain a separate array storing the depth of each node and use this to calculate ancestors.,"Utilize binary lifting to precompute ancestors at powers of 2, allowing for logarithmic time queries.",Hard,data structures,"Binary Search,Dynamic Programming,Tree,Depth-First Search,Breadth-First Search,Design"
1625,"Group Sold Products By The Date
Table Activities:  Write a solution to find for each date the number of different products sold and their names. The sold products names for each date should be sorted lexicographically. Return the result table ordered by sell_date. The result format is in the following example.","Using window functions partitioned by sell_date, concatenate distinct products and count them.","Create a common table expression (CTE) to list all products and their sell dates, then group by sell_date and aggregate using string concatenation.","Employ a cursor to iterate through each sell_date, collect distinct products, and format the output.","Create a temporary table to store distinct products for each date, then join it with the Activities table to aggregate the product names.","Group by sell_date, use COUNT(DISTINCT product) to count products, and GROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR ',') to get the sorted product names.",Easy,database systems,Database
1610,"XOR Operation in an Array
You are given an integer n and an integer start. Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length. Return the bitwise XOR of all elements of nums.","Calculate the sum using a loop, applying the XOR operation in each step.",Compute each array element and store them in a list before calculating the XOR sum.,Only calculate the XOR of the first and last elements for optimization.,Find the average of the elements and multiply it by n.,"Calculate the XOR sum of the arithmetic progression directly using bitwise properties and formulas where applicable, optimizing for specific cases of n.",Easy,algorithms,"Math,Bit Manipulation"
1611,"Making File Names Unique
Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i]. Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique. Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.","Use a hash table to store existing names and generate new unique names by incrementing a counter for each collision, but always start the counter at 0","Sort the input `names` array alphabetically and append the index of each name to itself to ensure uniqueness, regardless of existing names",Create a new name by appending the current timestamp to duplicate names,"Only check the immediately preceding folder name for duplicates and increment 'k' by one if it's a duplicate, ignoring other previously generated names","Use a hash map to store existing names and their counts, generating new unique names by incrementing a counter 'k' until a unique name is found, starting 'k' from 1.",Medium,algorithms,"Array,Hash Table,String"
1612,"Avoid Flood in The City
Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake. Given an integer array rains where: Return an array ans where: If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array. Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.","Use a greedy approach, prioritizing drying the lake that will cause the next imminent flood.",Apply dynamic programming to determine the optimal drying sequence for all possible rain sequences.,Employ a backtracking algorithm to explore all possible drying combinations until a solution is found.,"Simulate the rainfall events and track full lakes; if a flood occurs, randomly choose a lake to dry.","Use a set to store full lakes and a priority queue to track available drying days, drying the lake whose next rain is furthest away.",Medium,algorithms,"Array,Hash Table,Binary Search,Greedy,Heap (Priority Queue)"
1613,"Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order.",Edges with the highest weights in the graph.,Edges that are part of every possible spanning tree of the graph.,"Edges that, when forced into the MST, result in a cycle.",Edges that connect nodes with the highest degree.,"Critical edges are those whose removal increases MST weight; pseudo-critical edges can be in some, but not all, MSTs.",Hard,algorithms,"Union Find,Graph,Sorting,Minimum Spanning Tree,Strongly Connected Component"
1584,"Average Salary Excluding the Minimum and Maximum Salary
You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.",Include the minimum salary in the sum and subtract it from the total sum after averaging,"Calculate the average of all salaries, then subtract the minimum and maximum salaries from the average",Sort the salary array and calculate the average of the first and last elements,Return the median of the salary array,"Sum all salaries, subtract the minimum and maximum salaries, and divide by (n-2) where n is the number of employees",Easy,algorithms,"Array,Sorting"
1585,"The kth Factor of n
You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0. Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.",n / k,k % n,"Return the (k-1)th element of a sorted list of factors of n, or -1 if the list's length is less than k","Return the square root of n if k equals 2, otherwise return -1","Iterate from 1 to sqrt(n), checking for factors and incrementing a counter. If the counter equals k, return the factor. Handle perfect squares correctly.",Medium,algorithms,Math
1586,"Longest Subarray of 1's After Deleting One Element
Given a binary array nums, you should delete one element from it. Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.",Use dynamic programming to track the maximum length of subarrays with at most one zero.,Iterate through all possible subarrays and check if deleting one element results in a subarray of all ones.,Sort the array and then find the longest contiguous subarray of ones.,"Replace all zeros with -1, calculate the sum of the array, and return the absolute value of the sum.","Use a sliding window approach, tracking the number of zeros and expanding the window until more than one zero is encountered, then shrinking from the left.",Medium,algorithms,"Math,Dynamic Programming,Sliding Window"
1587,"Parallel Courses II
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k. In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking. Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.","Perform a topological sort and then greedily schedule courses in each semester, prioritizing those with fewer remaining dependencies.","Use a brute-force approach, trying all possible combinations of courses in each semester until all courses are taken.","Solve using dynamic programming, where the state represents the set of courses taken and the value represents the minimum semesters.","Apply a shortest-path algorithm (e.g., Dijkstra's) on a graph where courses are nodes and dependencies are edges.",Use dynamic programming with bitmasking to represent the state of taken courses and compute the minimum semesters needed.,Hard,algorithms,"Dynamic Programming,Bit Manipulation,Graph,Bitmask"
1619,"Path Crossing
Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path. Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.",Maintain a boolean array representing the 2D plane and mark visited cells,Use recursion to traverse the path and check for intersections,Track the perimeter of the traversed path and detect overlapping perimeters,"Calculate the total area covered by the path; if the area is less than the path length, there's a crossing",Store visited coordinates in a set and check for duplicates during traversal,Easy,algorithms,"Hash Table,String"
1620,"Check If Array Pairs Are Divisible by k
Given an array of integers arr of even length n and an integer k. We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k. Return true If you can find a way to do that or false otherwise.",Use dynamic programming to minimize the number of pairs formed with remainders summing to k,Sort the array and greedily pair elements from opposite ends,"Check if the sum of all elements is divisible by k, then return true","Use a hash map to store the frequency of remainders when dividing each element by k; if the frequency of remainder r is not equal to the frequency of k-r, return false","Calculate the remainder of each number when divided by k. Count the frequency of each remainder. For each remainder r, check if its frequency equals the frequency of k-r. If k is even, the frequency of k/2 must also be even.",Medium,algorithms,"Array,Hash Table,Counting"
1621,"Number of Subsequences That Satisfy the Given Sum Condition
You are given an array of integers nums and an integer target. Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.",O(n^2) - Iterate through all possible subsequences and check the condition.,O(n log n) - Sort the array and use two pointers to find pairs that satisfy the condition.,O(n!) - Generate all possible subsequences and check the condition for each.,O(n) - Iterate through the array and count elements less than or equal to target/2.,"O(n log n) - Sort the array, then for each element nums[i], count elements nums[j] such that nums[i] + nums[j] <= target and use binary exponentiation.",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
1622,"Max Value of Equation
You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k. Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length. It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.","Use a brute-force approach, checking all possible pairs of points.",Sort the points by their x-coordinates and then iterate through them sequentially.,Apply dynamic programming to store intermediate results and optimize calculations.,"Utilize a greedy approach, always selecting the points with the largest y-values.",Use a max deque to efficiently maintain the maximum yi + xi values for points within the k distance.,Hard,algorithms,"Array,Queue,Sliding Window,Heap (Priority Queue),Monotonic Queue"
1626,"Can Make Arithmetic Progression From Sequence
A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.","Check if the difference between the maximum and minimum values is divisible by (n-1), where n is the array size.","Calculate the mean and median of the array; if they are equal, it's an arithmetic progression.","Verify that all elements are distinct; if so, any arrangement is an arithmetic progression.",Confirm that the array is sorted in ascending order; an arithmetic progression requires this.,Sort the array and check if the difference between consecutive elements is constant.,Easy,algorithms,"Array,Sorting"
1627,"Last Moment Before All Ants Fall Out of a Plank
We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right. When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time. When an ant reaches one end of the plank at a time t, it falls out of the plank immediately. Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.","The maximum of right[i] over all i, added to the minimum of (n - left[i]) over all i",The average of the maximum value in right and the maximum value in (n - left),The minimum value in right plus the minimum value in (n - left),"The length of the plank, n, divided by the total number of ants",The maximum of (n - min(left)) and max(right),Medium,algorithms,"Array,Brainteaser,Simulation"
1628,"Count Submatrices With All Ones
Given an m x n binary matrix mat, return the number of submatrices that have all ones.",Calculate the sum of all elements and return 2 raised to that power.,"Iterate through all possible submatrices and increment a counter if all elements are ones, using a naive O(n^6) approach.",Calculate the area of the largest all-ones rectangle and multiply it by the total number of elements.,Employ dynamic programming to store the number of ones in each row and then use this information to calculate submatrices.,"Use dynamic programming to store the length of consecutive ones ending at each cell, and then sum the number of submatrices ending at each cell.",Medium,algorithms,"Array,Dynamic Programming,Stack,Matrix,Monotonic Stack"
1629,"Minimum Possible Integer After at Most K Adjacent Swaps On Digits
You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times. Return the minimum integer you can obtain also as a string.","Greedily select the smallest digit and move it to the front, updating k and digit positions accordingly",Sort the digits of the number and rebuild the string using the k smallest digits,Use dynamic programming to track the minimum number achievable with a specific number of swaps,Iterate through all possible permutations of the digits and select the minimum one achievable within k swaps,"Employ a greedy approach, finding the smallest digit within k distance of the current position and swapping it to the front, updating k and indices dynamically",Hard,algorithms,"String,Greedy,Binary Indexed Tree,Segment Tree"
1283,"Reformat Date
Given a date string in the form Day Month Year, where: Convert the date string to the format YYYY-MM-DD, where:","Split the string by spaces, reverse the order, and reassemble with hyphens","Use regular expressions to extract the day, month, and year components and concatenate them",Use Python's `datetime` library with appropriate format codes for parsing and formatting,Replace the month name with its numerical equivalent using a dictionary and then concatenate,"Parse the string, use a lookup table to convert the month, and format the output as YYYY-MM-DD",Easy,algorithms,String
1615,"Range Sum of Sorted Subarray Sums
You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers. Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.","Calculate all subarray sums, sort them, and then sum the elements from left to right using nested loops","Use a priority queue to store subarray sums and efficiently retrieve them in sorted order, then sum the elements from left to right","Precompute prefix sums to calculate subarray sums efficiently, sort them using quicksort, and then iterate to find the range sum","Dynamically calculate and store only the subarray sums within the [left, right] range and sort only those for efficiency","Calculate all subarray sums, sort them using an efficient sorting algorithm like mergesort, and then calculate the range sum modulo 10^9 + 7",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
1616,"Minimum Difference Between Largest and Smallest Value in Three Moves
You are given an integer array nums. In one move, you can choose one element of nums and change it to any value. Return the minimum difference between the largest and smallest value of nums after performing at most three moves.",Return nums[0] - nums[n-1],Sort the array and return nums[3] - nums[n-1],Sort the array and return nums[0] - nums[n-4],Return the average of the three largest values minus the average of the three smallest values,"Sort the array and return the minimum of nums[3] - nums[n-1], nums[0] - nums[n-4], nums[2] - nums[n-2], nums[1] - nums[n-3]",Medium,algorithms,"Array,Greedy,Sorting"
1617,"Stone Game IV
Alice and Bob take turns playing a game, with Alice starting first. Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile. Also, if a player cannot make a move, he/she loses the game. Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.",Alice wins if n is a perfect square.,Alice always loses if n is even.,The winner is determined by the parity of the largest perfect square less than or equal to n.,Alice wins if the number of perfect squares less than or equal to n is even.,Alice wins if and only if she can force Bob into a losing position by removing a perfect square number of stones.,Hard,algorithms,"Math,Dynamic Programming,Game Theory"
1635,"Number of Good Pairs
Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i < j.","Use nested loops to compare each element with every other element, incrementing a counter when a good pair is found, ignoring the i < j constraint.","Sort the array and then iterate through it, counting consecutive duplicates without regard to their indices.",Create a hash map to store the frequency of each number and then sum the frequencies without applying the combinations formula.,Iterate through the array and remove any duplicate elements before searching for pairs.,"Use a hash map to store the frequency of each number, and then calculate the number of good pairs using the formula n*(n-1)/2 for each number's frequency.",Easy,algorithms,"Array,Hash Table,Math,Counting"
1636,"Number of Substrings With Only 1s
Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.","O(n^3), where n is the length of the string","O(n log n), where n is the length of the string",O(1),"O(n^2), where n is the length of the string","O(n), where n is the length of the string",Medium,algorithms,"Math,String"
1325,"Path with Maximum Probability
You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i]. Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability. If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",Use Depth-First Search (DFS) to explore all paths and keep track of the maximum probability.,Apply Breadth-First Search (BFS) to find the shortest path and assume its probability is the maximum.,Employ the Bellman-Ford algorithm to handle negative edge weights (transformed probabilities) and find the path with maximum probability.,Calculate the product of all edge probabilities in the graph and return the result.,"Utilize Dijkstra's algorithm, modified to maximize probabilities instead of minimizing distances, starting from the 'start' node.",Medium,algorithms,"Graph,Heap (Priority Queue),Shortest Path"
1638,"Best Position for a Service Centre
A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that the sum of the euclidean distances to all customers is minimum. Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers. In other words, you need to choose the position of the service center [xcentre, ycentre] such that the following formula is minimized: Answers within 10-5 of the actual value will be accepted.",Use Gradient Descent on the L1 distance (Manhattan distance) to find the optimal location.,Calculate the centroid (mean) of all customer positions and use that as the service center location.,Perform a brute-force search by checking every possible coordinate within a reasonable range.,"Use a greedy approach, iteratively moving the service center towards the nearest customer.",Use Weiszfeld's algorithm or Gradient Descent on the Euclidean distance to iteratively converge on the optimal location.,Hard,algorithms,"Math,Geometry,Randomized"
1664,"Find Users With Valid E-Mails
Table: Users  Write a solution to find the users who have valid emails. A valid e-mail has a prefix name and a domain where: Return the result table in any order. The result format is in the following example.",Use LIKE '%@leetcode.com' to find emails ending with '@leetcode.com',Employ a regular expression to match any string containing '@' and '.' characters,Utilize the SUBSTRING function to extract the domain and verify its validity,Employ the CHARINDEX function to identify the position of the '@' symbol and then check the length of the email,"Use a regular expression that checks for a valid prefix, '@leetcode.com' domain, and correct characters",Easy,database systems,Database
1642,"Water Bottles
There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle. Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.",Use dynamic programming to precompute the optimal number of bottles to drink for all values up to numBottles,Recursively calculate the number of bottles by dividing numBottles by numExchange at each step,"Simulate the process with a while loop, keeping track of empty bottles and exchanged bottles until no more exchanges are possible, but decrement numBottles each loop","Return the product of numBottles and numExchange, as this represents the total potential for drinking","Simulate the process with a while loop, keeping track of empty bottles and exchanged bottles until no more exchanges are possible",Easy,algorithms,"Math,Simulation"
1643,"Number of Nodes in the Sub-Tree With the Same Label
You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]). The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree. Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i. A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.",Maintain a global counter incremented during the Depth-First Search (DFS),Utilize Breadth-First Search (BFS) and a queue to traverse the tree level by level,"Apply dynamic programming, storing results in a hash map",Employ a disjoint set data structure to track connected components,Use Depth-First Search (DFS) to traverse the tree and count nodes with the same label in each subtree,Medium,algorithms,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Counting"
1644,"Maximum Number of Non-Overlapping Substrings
Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions: Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length. Notice that you can return the substrings in any order.",Use dynamic programming to find all possible substrings and then filter for non-overlapping ones.,Iterate through all possible substrings and greedily select the longest one that satisfies the condition at each step.,Sort the characters in the string and then greedily form substrings from the sorted characters.,Recursively divide the string into smaller substrings and solve the problem for each substring.,"Greedily select the shortest valid substring from left to right, removing overlapping intervals.",Hard,algorithms,"String,Greedy"
1645,"Find a Value of a Mysterious Function Closest to Target
 Winston was given the above mysterious function func. He has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible. Return the minimum possible value of |func(arr, l, r) - target|. Notice that func should be called with the values l and r where 0 <= l, r < arr.length.",Return the absolute difference between the sum of the array and the target.,Return the absolute difference between the median of the array and the target.,Return the absolute difference between the first element of the array and the target.,Return the absolute difference between the last element of the array and the target.,"Iterate through all possible subarrays defined by l and r, compute func(arr, l, r) for each, and return the minimum absolute difference between these values and the target.",Hard,algorithms,"Array,Binary Search,Bit Manipulation,Segment Tree"
1630,"Count Odd Numbers in an Interval Range
Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).", (high - low) / 2, (high - low + 1) / 2.0, (high - low) % 2, high - low + 1, (high + 1) / 2 - low / 2,Easy,algorithms,Math
1631,"Number of Sub-arrays With Odd Sum
Given an array of integers arr, return the number of subarrays with an odd sum. Since the answer can be very large, return it modulo 109 + 7.","Count odd and even numbers, then return odd * even % (10**9 + 7)","Calculate the sum of all possible subarrays and count those with odd sums, modulo 10**9 + 7",Maintain a cumulative sum and check its parity for each element,Use dynamic programming to store sum values in an array,"Keep track of the count of subarrays with odd and even sums so far, updating these counts as we iterate through the array, and return the count of odd sum subarrays modulo 10**9 + 7",Medium,algorithms,"Array,Math,Dynamic Programming,Prefix Sum"
1632,"Number of Good Ways to Split a String
You are given a string s. A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same. Return the number of good splits you can make in s.",Count distinct characters by comparing each substring with every other substring,"Iterate through all possible split points and use a hash map to store the character counts for the left and right substrings, then return a match if counts are identical","Keep track of the frequency of each character using a sliding window approach, and increment count for splits with equal frequencies","Employ recursion to explore all possible split combinations, pruning branches when the number of distinct characters significantly differs","Precompute the number of distinct characters from left to right and right to left, then iterate through the string, comparing the counts at each split point",Medium,algorithms,"String,Dynamic Programming,Bit Manipulation"
1633,"Minimum Number of Increments on Subarrays to Form a Target Array
You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros. In one operation you can choose any subarray from initial and increment each value by one. Return the minimum number of operations to form a target array from initial. The test cases are generated so that the answer fits in a 32-bit integer.",Calculate the sum of absolute differences between adjacent elements in the target array.,Find the maximum value in the target array and return it.,Sort the target array and count the number of distinct elements.,Return the length of the target array.,Iterate through the target array and sum the positive differences between consecutive elements (target[i] - target[i-1]).,Hard,algorithms,"Array,Dynamic Programming,Stack,Greedy,Monotonic Stack"
1670,"Patients With a Condition
Table: Patients  Write a solution to find the patient_id, patient_name, and conditions of the patients who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix. Return the result table in any order. The result format is in the following example.","SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions LIKE '% DIAB1%'","SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions = 'DIAB1'","SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions LIKE 'DIAB1'","SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions REGEXP 'DIAB1'","SELECT patient_id, patient_name, conditions FROM Patients WHERE conditions LIKE 'DIAB1%'",Easy,database systems,Database
1651,"Shuffle String
You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string. Return the shuffled string.","Iterate through 'indices' and 's', building a new string by concatenating characters in the order they appear in 's'.",Sort 'indices' and 's' lexicographically before mapping characters to their shuffled positions.,"Reverse both 's' and 'indices', then rebuild 's' using the reversed mappings.","Use a hash map to store the character-index mappings, then sort the map by index and reconstruct the string.","Create a new string of the same length as 's'. Iterate through 's' and 'indices', placing each character s[i] at the index indices[i] in the new string.",Easy,algorithms,"Array,String"
1652,"Minimum Suffix Flips
You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target. In one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'. Return the minimum number of operations needed to make s equal to target.",n,target.count('1'),len(set(target)),target.count('0'),sum(target[i] != target[i+1] for i in range(len(target)-1)),Medium,algorithms,"String,Greedy"
1653,"Number of Good Leaf Nodes Pairs
You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance. Return the number of good leaf node pairs in the tree.",Perform a level-order traversal and count pairs within the distance at each level.,Calculate the depth of each node and count pairs with depths summing to less than or equal to the distance.,Use Dijkstra's algorithm to find the shortest path between all leaf nodes.,Store all possible paths and count only those paths between leaf nodes that have path lengths less than the distance.,Use Depth-First Search (DFS) to compute distances from each leaf to its ancestors and count pairs meeting the distance criterion.,Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
1637,"String Compression II
Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string ""aabccc"" we replace ""aa"" by ""a2"" and replace ""ccc"" by ""c3"". Thus the compressed string becomes ""a2bc3"". Notice that in this problem, we are not adding '1' after single characters. Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length. Find the minimum length of the run-length encoded version of s after deleting at most k characters.",O(1),O(log n),O(n^2),O(n!),O(n),Hard,algorithms,"String,Dynamic Programming"
1656,"Count Good Triplets
Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets. A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true: Where |x| denotes the absolute value of x. Return the number of good triplets.",Use three nested loops iterating through all possible triplets without any condition checks.,"Use three nested loops iterating through all possible triplets, calculating absolute differences directly using multiplication instead of subtraction.","Sort the input array and then use three nested loops, assuming sorted order will optimize the counting of triplets.","Calculate the average of a, b, and c, and count triplets where all absolute differences are less than or equal to the average.","Use three nested loops to iterate through all possible triplets and check if the conditions |arr[i] - arr[j]| <= a, |arr[j] - arr[k]| <= b, and |arr[i] - arr[k]| <= c are all satisfied.",Easy,algorithms,"Array,Enumeration"
1657,"Find the Winner of an Array Game
Given an integer array arr of distinct integers and an integer k. A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds. Return the integer which will win the game. It is guaranteed that there will be a winner of the game.",Maintain a counter for the current winner. Reset the counter when the winner changes.,"Sort the array first, then iterate and count consecutive occurrences of each element.",Use a sliding window of size k to check if any element wins consecutively.,Recursively compare the first two elements and move the smaller one to the end until a winner is found.,"Iterate through the array, keeping track of the current winner and their consecutive win count.",Medium,algorithms,"Array,Simulation"
1658,"Minimum Swaps to Arrange a Binary Grid
Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them. A grid is said to be valid if all the cells above the main diagonal are zeros. Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid. The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).",Sort the rows based on the number of leading zeros and then calculate swaps,Greedily swap rows to place the rows with the most trailing zeros at the top,Use dynamic programming to find the optimal arrangement of rows,Check each permutation of rows to find the minimum swaps required,"For each row, find the number of trailing zeros. Then, greedily place rows with enough trailing zeros above the diagonal, counting the swaps required.",Medium,algorithms,"Array,Greedy,Matrix"
1659,"Get the Maximum Score
You are given two sorted arrays of distinct integers nums1 and nums2. A valid path is defined as follows: The score is defined as the sum of unique values in a valid path. Return the maximum score you can obtain of all possible valid paths. Since the answer may be too large, return it modulo 109 + 7.","Compute the intersection of nums1 and nums2, sum the elements only in the intersection, and multiply it by 2",Iterate through both arrays and always choose the path that yields the larger immediate sum without considering future common elements,"Concatenate nums1 and nums2, sort the result, and return the sum modulo 10^9 + 7",Calculate the sum of nums1 and nums2 independently and return the larger of the two sums modulo 10^9 + 7,"Traverse both arrays, choosing the path with the larger sum between common elements, and return the total sum modulo 10^9 + 7",Hard,algorithms,"Array,Two Pointers,Dynamic Programming,Greedy"
1646,"Kth Missing Positive Number
Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array.",Use a binary search to find the position where k missing numbers would exist.,"Linearly search the array and decrement k for each present number, stopping when k reaches 0.","Create a boolean array representing all positive integers up to arr[n-1]+k, marking present numbers, and finding the kth unmarked.",Calculate the difference between each element and its index and sum it with k until the total exceeds k.,"Iterate through the array, checking the difference between the current element and its expected value. Adjust k accordingly.",Easy,algorithms,"Array,Binary Search"
1647,"Can Convert String in K Moves
Given two strings s and t, your goal is to convert s into t in k moves or less. During the ith (1 <= i <= k) move you can: Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times. Remember that any index j can be picked at most once. Return true if it's possible to convert s into t in no more than k moves, otherwise return false.",Allocate a large array of size 26 * n (where n is the length of s) and mark the required shifts. Return true if the number of marked elements is less than or equal to k.,"Iterate through s and t. If s[i] > t[i], calculate the shift directly; otherwise, return false immediately.",Calculate the total number of shifts needed and return true if this sum is less than or equal to k. Shifts are calculated as the absolute difference in ASCII values.,Simulate the shifting process by creating a frequency map of required shifts (0-25). Check if the maximum frequency multiplied by the length of s is less than or equal to k.,"Compute the shift needed for each character. Use a frequency array of size 26 to track used shifts. If any shift value exceeds k, return false. Otherwise, return true.",Medium,algorithms,"Hash Table,String"
1648,"Minimum Insertions to Balance a Parentheses String
Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if: In other words, we treat '(' as an opening parenthesis and '))' as a closing parenthesis. You can insert the characters '(' and ')' at any position of the string to balance it if needed. Return the minimum number of insertions needed to make s balanced.",Recursively check all possible insertion positions for '(' and ')' and keep track of the minimum insertions needed,Count the number of '(' and ')' characters. Insert the difference to balance the string,"Use a stack to keep track of open parentheses. If a ')' is encountered and the stack is empty, insert a '('. If a ')' is encountered and the stack is not empty, pop from the stack. After processing the string, insert ')' for each remaining '(' in the stack","Replace every occurrence of '()' with an empty string repeatedly until the string is empty, then count the number of replacement iterations","Track the balance as you iterate through the string. When the balance is negative, add '(' to balance. When you encounter '(', increment the balance by 1. When you encounter ')', check the next character. If it is ')', decrement the balance by 1. If it is not ')', insert ')' and decrement the balance by 1. Finally, add the absolute value of the balance.",Medium,algorithms,"String,Stack,Greedy"
1668,"Find Longest Awesome Substring
You are given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it a palindrome. Return the length of the maximum length awesome substring of s.","Recursively check all possible substrings for palindromic properties, leading to exponential time complexity.",Use dynamic programming to store the lengths of palindromic substrings centered at each index.,Employ a greedy approach by expanding around each character and checking if the extended substring is awesome.,Maintain a sliding window and adjust its boundaries based on character frequencies.,"Utilize a prefix XOR array and a hash map to track the parity of character counts, optimizing for palindromic substrings.",Hard,algorithms,"Hash Table,String,Bit Manipulation"
1666,"Make The String Great
Given a string s of lower and upper case English letters. A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where: To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return the string after making it good. The answer is guaranteed to be unique under the given constraints. Notice that an empty string is also good.",Use recursion to repeatedly remove adjacent characters until no more removals are possible.,Sort the string and remove adjacent characters based on ASCII values.,Convert the string to lowercase and then remove identical adjacent characters.,Replace all uppercase characters with lowercase and then remove duplicate adjacent characters.,"Iterate through the string using a stack, removing adjacent characters that violate the condition.",Easy,algorithms,"String,Stack"
1667,"Find Kth Bit in Nth Binary String
Given two positive integers n and k, the binary string Sn is formed as follows: Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0). For example, the first four strings in the above sequence are: Return the kth bit in Sn. It is guaranteed that k is valid for the given n.",Recursively construct Sn and then directly access the kth bit.,"Precompute all binary strings S1 to Sn and store them in an array, then return the kth bit of Sn.","Simulate the string construction process iteratively, tracking only the length to determine the bit at position k.","Convert n and k into binary strings, perform a bitwise XOR, and return the result.","Determine the kth bit using the recursive relationship Sn = Sn-1 + ""1"" + reverse(invert(Sn-1)), without explicitly constructing the strings.",Medium,algorithms,"String,Recursion"
1649,"Maximum Number of Non-Overlapping Subarrays With Sum Equals Target
Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.","Use dynamic programming to store the maximum number of subarrays ending at each index, but only consider subarrays that start at index 0.",Sort the array and greedily select the smallest elements that sum up to the target.,"Use a sliding window approach, expanding the window until the sum exceeds the target, and then shrinking it until the sum equals the target.",Recursively explore all possible subarray combinations and count the non-overlapping subarrays with the target sum.,"Iterate through the array, keeping track of the cumulative sum and using a hash set to store previously seen cumulative sums. When the cumulative sum minus the target is in the hash set, increment the count and reset the cumulative sum and hash set.",Medium,algorithms,"Array,Hash Table,Greedy,Prefix Sum"
1669,"Minimum Cost to Cut a Stick
Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows: Given an integer array cuts where cuts[i] denotes a position you should perform a cut at. You should perform the cuts in order, you can change the order of the cuts as you wish. The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation. Return the minimum total cost of the cuts.","Recursively cut the stick from left to right, always choosing the leftmost cut first.",Sort the cuts array and then iteratively perform the cuts in that order.,"Apply a greedy algorithm, always making the cut that splits the stick into the most even halves.","Dynamically program using a top-down approach with memoization, calculating minimum costs for sub-sticks.","Dynamically program using a bottom-up approach, calculating minimum costs for increasingly larger sub-sticks.",Hard,algorithms,"Array,Dynamic Programming"
1674,"Minimum Operations to Make Array Equal
You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n). In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations. Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.",n * n,n / 2,n * (n + 1),n,(n // 2) * (n - n // 2),Medium,algorithms,Math
1675,"Magnetic Force Between Two Balls
In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum. Rick stated that magnetic force between two different balls at positions x and y is |x - y|. Given the integer array position and the integer m. Return the required force.",Sort the positions and use a greedy approach to place balls as far apart as possible.,Use dynamic programming to calculate the maximum magnetic force for all possible combinations of balls and baskets.,Perform a linear search through all possible minimum force values and check if it is feasible to place the balls with that force.,Randomly distribute the balls and iteratively adjust their positions until the minimum force is maximized.,Sort the positions and use binary search to find the maximum possible minimum magnetic force.,Medium,algorithms,"Array,Binary Search,Sorting"
1676,"Minimum Number of Days to Eat N Oranges
There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows: You can only choose one of the actions per day. Given the integer n, return the minimum number of days to eat n oranges.",Use dynamic programming with a top-down approach and memoization focusing only on multiples of 2 and 3.,"Employ a greedy algorithm, always choosing the largest possible reduction (n/2 or n/3) at each step.",Apply a breadth-first search (BFS) where each state represents the remaining oranges and transitions represent eating options.,"Simulate the eating process day by day, choosing actions randomly until no oranges remain.",Use dynamic programming with a bottom-up approach storing the minimum days to eat i oranges for all i from 0 to n.,Hard,algorithms,"Dynamic Programming,Memoization"
1660,"Thousand Separator
Given an integer n, add a dot (""."") as the thousands separator and return it in string format.",Use regular expressions to insert dots at every third position from the left,Convert the integer to a floating-point number and use locale formatting,Iteratively divide the number by 1000 and prepend the remainder with a dot,"Recursively process the number, adding a dot after every three digits","Convert the integer to a string, iterate from the right, and insert dots at the appropriate positions",Easy,algorithms,String
1661,"Minimum Number of Vertices to Reach All Nodes
Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi. Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order.",Perform a Depth-First Search (DFS) on all nodes and select those that were visited first,Select all nodes with the highest out-degree in the graph,Randomly select a subset of nodes until all nodes are reachable,Select all nodes with a path to every other node in the graph,Select all nodes with an in-degree of 0,Medium,algorithms,Graph
1662,"Minimum Numbers of Function Calls to Make Target Array
You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function: You want to use the modify function to convert arr to nums using the minimum number of calls. Return the minimum number of function calls to make nums from arr. The test cases are generated so that the answer fits in a 32-bit signed integer.","Perform a bitwise OR operation on all elements of the array, then count the set bits.","Iterate through the array, incrementing each element individually until it reaches its target value.","Calculate the sum of all elements in the array and divide by 2 repeatedly, rounding up to the nearest integer after each division.","Find the maximum element in the array, then multiply it by the length of the array.",Find the maximum number of operations needed to make each number using bit manipulation and adding the number of increment operations needed.,Medium,algorithms,"Array,Greedy"
1663,"Detect Cycles in 2D Grid
Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid. A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell. Also, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell. Return true if any cycle of the same value exists in grid, otherwise, return false.",Use Depth-First Search (DFS) without tracking visited nodes; any path of length 4 indicates a cycle.,"Iterate through each cell and check its immediate neighbors; if any neighbor has the same value, a cycle exists.",Apply Breadth-First Search (BFS) from each cell; a cycle is found if the BFS queue becomes empty.,"Sort the grid lexicographically and then check for consecutive identical rows or columns; if found, a cycle exists.","Use Depth-First Search (DFS) to explore paths, tracking visited nodes and the parent node to avoid immediate backtracking; a cycle is detected if a visited node (not the parent) is encountered with path length >= 4.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
1682,"Most Visited Sector in  a Circular Track
Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1] Return an array of the most visited sectors sorted in ascending order. Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).","Create a frequency map and iterate through `rounds`, incrementing counts only for `rounds[i]` and `rounds[i+1]`.","Simulate the entire race by iterating through `rounds` and incrementing sector visit counts until the end of each round is reached, then find the sectors with the maximum counts. This is computationally efficient due to optimal looping.","Calculate the total distance covered by each sector based on the start and end positions in `rounds`, and then rank the sectors based on their calculated distance values. Return only the top sectors based on the count of rounds.","Sort the `rounds` array and create an adjacency matrix representing transitions between sectors. Then, perform a graph traversal to identify the most frequently visited paths and sectors.","Create a frequency map to count visits to each sector based on `rounds`. Increment the frequency for sectors between `rounds[i-1]` and `rounds[i]` considering the circular nature of the track, then identify sectors with maximum frequency.",Easy,algorithms,"Array,Simulation"
1683,"Maximum Number of Coins You Can Get
There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows: Given an array of integers piles where piles[i] is the number of coins in the ith pile. Return the maximum number of coins that you can have.",Sort the piles array in ascending order and sum every third element starting from the second largest.,"Divide each pile's coin count by 3, round down to the nearest integer, and sum the results.",Sort the piles array in descending order and sum the first n elements.,Calculate the average coin count across all piles and multiply it by n.,"Sort the piles array in descending order, then iterate from index 1 to 2n with a step of 2, summing the elements.",Medium,algorithms,"Array,Math,Greedy,Sorting,Game Theory"
1684,"Find Latest Group of Size M
Given an array arr that represents a permutation of numbers from 1 to n. You have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1. You are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction. Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.","Use a disjoint set data structure to track connected components and their sizes, returning the last step where a component of size m exists.","Iterate through the array, setting bits in the binary string and then rescanning the entire string to count groups of size m in each iteration.",Maintain a sliding window of size m across the array and check at each step if all elements in the window are 1. Return the last such step.,Sort the array and then greedily find the largest contiguous group of 1s of size m after each step.,"Use an array to track the length of contiguous segments and update the counts of segments of size m after each bit flip, returning the last step with a count > 0.",Medium,algorithms,"Array,Binary Search,Simulation"
1685,"Stone Game V
There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue. In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row. The game ends when there is only one stone remaining. Alice's is initially zero. Return the maximum score that Alice can obtain.",Use a greedy approach by always choosing the split that minimizes the difference between the sums of the two sub-arrays.,"Apply dynamic programming with a 1D array, storing the maximum score achievable from each index to the end of the array.","Recursively explore all possible splits, pruning branches where the current score is less than a previously computed maximum.",Sort the `stoneValue` array and then calculate Alice's score based on the sorted order.,Use dynamic programming with a 2D array to store the maximum score achievable for each sub-array defined by its start and end indices.,Hard,algorithms,"Array,Math,Dynamic Programming,Game Theory"
1689,"Detect Pattern of Length M Repeated K or More Times
Given an array of positive integers arr, find a pattern of length m that is repeated k or more times. A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions. Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.",A sliding window of size m*k is used to check for repeating patterns.,Dynamic programming is employed to store previously computed pattern repetitions.,Recursion is used to divide the array into smaller subproblems and check for patterns.,The array is sorted first to group similar values together before searching for patterns.,"Iterate through the array, checking for consecutive sequences of length m that repeat at least k times without overlapping.",Easy,algorithms,"Array,Enumeration"
1690,"Maximum Length of Subarray With Positive Product
Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive. A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Return the maximum length of a subarray with positive product.",Use dynamic programming to store lengths of positive and negative product subarrays ending at each index,Sort the array and consider only positive elements for the maximum length,Keep track of the counts of positive and negative numbers and return the count of positive numbers,Return the length of the entire array if it doesn't contain any zero,"Maintain separate variables to track the length of positive and negative product subarrays, updating them as you iterate through the array",Medium,algorithms,"Array,Dynamic Programming,Greedy"
1691,"Minimum Number of Days to Disconnect Island
You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's. The grid is said to be connected if we have exactly one island, otherwise is said disconnected. In one day, we are allowed to change any single land cell (1) into a water cell (0). Return the minimum number of days to disconnect the grid.",Always require at least 2 days to disconnect any grid.,The answer is the number of land cells with exactly two adjacent land cells.,"Perform a single Depth-First Search (DFS) to count the number of connected components, and return 0 if it's greater than 1.",The answer is always 1 because any land cell can be changed to water to disconnect the grid.,"Find the number of connected components in the original grid. Then iterate through each land cell, temporarily change it to water, and check the number of connected components. Return the minimum number of days required.",Hard,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix,Strongly Connected Component"
1692,"Number of Ways to Reorder Array to Get Same BST
Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums. Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums. Since the answer may be very large, return it modulo 109 + 7.","Memoization only, without precomputed combinations",Dynamic programming without modulo operation,"Only calculating combinations, without recursive BST decomposition",Recursively decompose the array without handling duplicates,"Recursively decompose the array, calculate combinations, and apply memoization with modulo",Hard,algorithms,"Array,Math,Divide and Conquer,Dynamic Programming,Tree,Union Find,Binary Search Tree,Memoization,Combinatorics,Binary Tree"
1677,"Matrix Diagonal Sum
Given a square matrix mat, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.",Sum all elements of the matrix,Sum only the elements above the primary diagonal,Sum only the elements on the secondary diagonal,Multiply all elements of the primary and secondary diagonals,"Sum elements of primary and secondary diagonals, excluding overlapping elements",Easy,algorithms,"Array,Matrix"
1678,"Number of Ways to Split a String
Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s. Return the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.",O(n log n) due to sorting the prefixes.,O(n^3) due to iterating all possible substrings.,O(1) as the number of possible splits is constant.,O(n^2) due to checking all possible combinations of two splits.,O(n) as we iterate through the string to count ones and find valid splits.,Medium,algorithms,"Math,String"
1679,"Shortest Subarray to be Removed to Make Array Sorted
Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing. Return the length of the shortest subarray to remove. A subarray is a contiguous subsequence of the array.",Use dynamic programming to find the longest non-decreasing subsequence and subtract its length from the total length.,Sort the array and find the longest common subsequence between the original and sorted arrays.,Remove elements one by one until the remaining array is sorted and return the number of removed elements.,Binary search for the shortest subarray length to remove such that the remaining array is sorted.,Find the longest non-decreasing prefix and suffix. The shortest subarray to remove is the shortest connection between them.,Medium,algorithms,"Array,Two Pointers,Binary Search,Stack,Monotonic Stack"
1680,"Count All Possible Routes
You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively. At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x. Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish). Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.",Backtracking with pruning based on remaining fuel and distance to the finish.,"Dynamic programming where the state is (current city, fuel remaining).",Greedy algorithm that always chooses the city closest to the finish.,"Breadth-first search, exploring possible routes until all paths are exhausted.","Recursion with memoization to avoid recomputing routes for the same (city, fuel) state.",Hard,algorithms,"Array,Dynamic Programming,Memoization"
1698,"Replace All ?'s to Avoid Consecutive Repeating Characters
Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters. It is guaranteed that there are no consecutive repeating characters in the given string except for '?'. Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints.","Replace each '?' with 'a', then iterate and change any consecutive repeats to the next letter","Use recursion to replace '?' from right to left, backtracking when repeats are found",Replace all '?' with the most frequent character in the initial string,Iterate through the string and replace each '?' with the same character as the previous index,"Iterate through the string; for each '?', replace it with a character different from its neighbors",Easy,algorithms,String
1699,"Number of Ways Where Square of Number Is Equal to Product of Two Numbers
Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:",Use nested loops to iterate through all possible pairs in `nums1` and `nums2` and check the condition.,Sort both arrays and use binary search to find pairs that satisfy the given condition.,"Calculate the square of each number in `nums1` and the product of each pair in `nums2`, then compare the counts of each unique number.","Use a hashmap to store the frequencies of the squares of elements in `nums1` and another hashmap for products of pairs in `nums2`, and return the number of matching keys.","Use a hash map to store the frequencies of elements in `nums1` and products of pairs in `nums2`, then iterate and count the valid triplets.",Medium,algorithms,"Array,Hash Table,Math,Two Pointers"
1700,"Minimum Time to Make Rope Colorful
Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope. Return the minimum time Bob needs to make the rope colorful.","Use dynamic programming to store optimal removal times for sub-ropes, indexed by balloon color","Employ a greedy approach, always removing the balloon with the smallest neededTime if it causes a conflict",Sort the balloons by neededTime in descending order and iteratively remove balloons until colorful,Apply a sliding window technique to identify the longest consecutive segments of the same color and remove all but one from each segment,"Iterate through the balloons, keeping track of consecutive balloons of the same color and removing the one with the smaller neededTime until only one remains in each segment",Medium,algorithms,"Array,String,Dynamic Programming,Greedy"
1701,"Remove Max Number of Edges to Keep Graph Fully Traversable
Alice and Bob have an undirected graph of n nodes and three types of edges: Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.","Use Depth First Search (DFS) for Alice's edges and Breadth First Search (BFS) for Bob's edges, removing edges greedily until either becomes disconnected.","Prioritize removing type 3 edges first, then type 1 and type 2 edges, checking connectivity using a standard graph traversal algorithm after each removal.","Employ Kruskal's algorithm separately for Alice's and Bob's subgraphs, removing edges that are not part of the Minimum Spanning Tree (MST) for either.","Sort edges based on their type (3, 1, then 2) and then randomly remove edges of the same type, and at the end check for traversal.","Use a Disjoint Set Union (DSU) data structure to track connected components for Alice and Bob, processing type 3 edges first, then type 1 and 2, maximizing removals while maintaining full traversal for both.",Hard,algorithms,"Union Find,Graph"
1724,"Customer Who Visited but Did Not Make Any Transactions
Table: Visits  Table: Transactions  Write a solution to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits. Return the result table sorted in any order. The result format is in the following example.","Using a LEFT JOIN from Transactions to Visits, filter for NULL transaction IDs and count visit IDs","Using a RIGHT JOIN from Transactions to Visits, filter for NULL transaction IDs and count visit IDs","Using an INNER JOIN between Visits and Transactions, filter for NULL visit IDs and count transaction IDs","Using a UNION ALL of the two tables, group by user ID and count visits, then filter where the transaction count is zero","Using a LEFT JOIN from Visits to Transactions, filter for NULL transaction IDs and count visit IDs",Easy,database systems,Database
1704,"Special Positions in a Binary Matrix
Given an m x n binary matrix mat, return the number of special positions in mat. A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).","Check only the row for all zeros except at (i, j).",Return the total number of 1s in the matrix.,"Check only the column for all zeros except at (i, j).","Count positions where mat[i][j] == 1, ignoring other constraints.","For each position (i, j) where mat[i][j] == 1, verify all other elements in row i and column j are 0.",Easy,algorithms,"Array,Matrix"
1705,"Count Unhappy Friends
You are given a list of preferences for n friends, where n is always even. For each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1. All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi. However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but: Return the number of unhappy friends.",A greedy approach where you always choose the closest available friend in the preference list.,Checking all possible combinations of pairs to find the optimal pairing that minimizes unhappiness.,Using dynamic programming to store the unhappiness level for subsets of friends.,Sorting the preference lists and the pairs array to simplify the unhappiness check.,"Iterating through each person and their pair, then checking every other pair to see if the condition for unhappiness is met.",Medium,algorithms,"Array,Simulation"
1706,"Min Cost to Connect All Points
You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",Depth-First Search (DFS),Dijkstra's Algorithm,Bellman-Ford Algorithm,Divide and Conquer,Prim's Algorithm,Medium,algorithms,"Array,Union Find,Minimum Spanning Tree"
1707,"Check If String Is Transformable With Substring Sort Operations
Given two strings s and t, transform string s into string t using the following operation any number of times: Return true if it is possible to transform s into t. Otherwise, return false. A substring is a contiguous sequence of characters within a string.",The order of characters in 's' must be exactly the same as in 't' after removing duplicates.,The frequency of each character in 's' must be less than or equal to that in 't'.,The sorted version of 's' must be equal to the sorted version of 't'.,Each character in 's' must appear at the same or later index as in 't'.,"For each digit 'd' from 0 to 9, all occurrences of 'd' in 's' must precede all occurrences of 'd' in 't'.",Hard,algorithms,"String,Greedy,Sorting"
1734,"Bank Account Summary II
Table: Users  Table: Transactions  Write a solution to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to calculate each user's balance and filter those exceeding 10000.,"Create a temporary table storing transaction sums per user, then select users from the Users table joined with this temporary table.","Use window functions to partition transactions by user and calculate a running total, filtering users with a final total greater than 10000.","Join the Users and Transactions tables directly, using a WHERE clause to filter transactions with amounts greater than 10000.","Use GROUP BY on the Transactions table to sum amounts per user, join with the Users table, and filter with HAVING to find balances exceeding 10000.",Easy,database systems,Database
1693,"Sum of All Odd Length Subarrays
Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr. A subarray is a contiguous subsequence of the array.","Calculate the sum of all subarrays and then filter for odd lengths, resulting in O(n^3) time complexity.","Iterate through all possible starting points and lengths, creating each subarray explicitly and summing if the length is odd, resulting in O(n^2) space complexity.","Use a sliding window of odd length and sum the elements within the window as it slides across the array, requiring additional memory to store intermediate sums.","Recursively calculate the sum of odd-length subarrays by dividing the array into halves and combining results, potentially leading to stack overflow for large inputs.",Use a formula based on the frequency of each element appearing in odd-length subarrays to directly calculate the sum in O(n) time complexity.,Easy,algorithms,"Array,Math,Prefix Sum"
1695,"Maximum Sum Obtained of Any Permutation
We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed. Return the maximum total sum of all requests among all permutations of nums. Since the answer may be too large, return it modulo 109 + 7.",Sort `nums` in ascending order and process requests in the order they appear.,Sort `nums` in descending order and process requests in the order they appear.,"Calculate the frequency of each index in `requests`, then multiply with `nums` elements directly.",Use dynamic programming to compute sums of all sub-arrays and pick the maximum sums.,"Calculate the frequency of each index in `requests`, sort `nums` in descending order, multiply and sum with frequencies.",Medium,algorithms,"Array,Greedy,Sorting,Prefix Sum"
1694,"Make Sum Divisible by P
Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array. Return the length of the smallest subarray that you need to remove, or -1 if it's impossible. A subarray is defined as a contiguous block of elements in the array.",Use dynamic programming to find the minimum subarray sum.,Sort the array and greedily remove elements from the beginning until the condition is met.,Brute-force: try removing every possible subarray and check if the sum of the remaining elements is divisible by p.,"Calculate the prefix sums modulo p, then use a sliding window to find the smallest subarray whose sum modulo p is equal to the total sum modulo p.","Calculate the total sum modulo p, then use a hash map to store prefix sums modulo p and their indices to find the smallest subarray whose sum modulo p equals the total sum modulo p.",Medium,algorithms,"Array,Hash Table,Prefix Sum"
1696,"Strange Printer II
There is a strange printer with the following two special requirements: You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid. Return true if it is possible to print the matrix targetGrid, otherwise, return false.","Calculate the frequency of each color, then check if the rectangles formed by each color overlap in a non-color-consistent manner.","Iteratively try to remove each color from the targetGrid, checking if the remaining grid is consistently printable in each step, backtracking as needed.","Perform a depth-first search starting from each cell, checking if the connected component of the same color forms a valid rectangle.",Convert the matrix to a graph where nodes are colors and edges represent adjacent cells. Perform topological sort and check for cycles.,"Find the bounding rectangle for each color. Check if rectangles overlap, and if so, check if the overlapping region's color is consistent with the overlapping rectangles' colors.",Hard,algorithms,"Array,Graph,Topological Sort,Matrix"
1714,"Rearrange Spaces Between Words
You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word. Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text. Return the string after rearranging the spaces.","Split the string into words and count the spaces, then distribute spaces evenly between words and append remaining spaces at the beginning.","Calculate the average word length, then pad each word with spaces to reach the average length.","Split the string, calculate the modulo of (number of spaces / number of words), and distribute those as extra spaces at the end","Replace all spaces with a single space, then add the number of spaces to the end of the resulting string.","Split the string into words and count the spaces, then distribute spaces evenly between words and append remaining spaces at the end.",Easy,algorithms,String
1715,"Split a String Into the Max Number of Unique Substrings
Given a string s, return the maximum number of unique substrings that the given string can be split into. You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique. A substring is a contiguous sequence of characters within a string.","Use dynamic programming to store previously computed substring counts, optimizing for overlapping subproblems.","Iteratively try all possible substring splits using a greedy approach, prioritizing longer substrings first.","Apply a divide-and-conquer strategy, recursively splitting the string into halves and combining the results.","Employ a brute-force method, generating all possible substring combinations and checking for uniqueness.","Use backtracking to explore different substring splits, maintaining a set of unique substrings to maximize the count.",Medium,algorithms,"Hash Table,String,Backtracking"
1716,"Maximum Non Negative Product in a Matrix
You are given a m x n matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix. Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (m - 1, n - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path. Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative, return -1. Notice that the modulo is performed after getting the maximum product.",Perform a Depth-First Search (DFS) and prune paths when the current product becomes negative,"Apply dynamic programming, storing only the maximum product seen so far at each cell",Calculate the product of all possible paths independently and keep track of the maximum,"Use a greedy approach, always choosing the path with the larger absolute value","Employ dynamic programming, tracking both the maximum and minimum product at each cell to handle negative numbers",Medium,algorithms,"Array,Dynamic Programming,Matrix"
1717,"Minimum Cost to Connect Two Groups of Points
You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2. The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group. Return the minimum cost it takes to connect the two groups.",Greedily connect each point in the second group to its cheapest connection in the first group and then connect remaining unconnected points in the first group randomly.,"Use a min-cost bipartite matching algorithm, such as the Hungarian algorithm, after modifying the cost matrix to ensure all points are connected.",Calculate all possible connection combinations and pick the one with the lowest cost.,"Iteratively connect the points with the lowest cost until all points are connected, regardless of groups.","Use dynamic programming to explore all possible connection combinations, minimizing the total cost while ensuring all points in both groups are connected.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Matrix,Bitmask"
1720,"Crawler Log Folder
The Leetcode file system keeps a log each time some user performs a change folder operation. The operations are described below: You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed. Return the minimum number of operations needed to go back to the main folder after the change folder operations.","Use a stack to track the folder depth, incrementing for ""./"" and folder names, and decrementing for ""../"", ensuring the depth never goes below zero.","Employ recursion, incrementing the depth on entering a folder and decrementing on exiting, but only if the folder name is not ""."" or ""..""","Simulate the file system using a tree data structure, tracking the current node and moving up or down based on the logs, then calculate the depth of the final node.","Maintain a counter that increments for any log entry except ""."" and decrements for ""../"", stopping decrementing when the counter reaches zero.","Iterate through the logs, incrementing a counter for each folder entered (excluding ""."") and decrementing for each ""../"", ensuring the counter never goes below zero.",Easy,algorithms,"Array,String,Stack"
1721,"Maximum Profit of Operating a Centennial Wheel
You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars. You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again. You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation. Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.",The number of rotations where the running cost equals the boarding cost,"The number of customers multiplied by the boarding cost, divided by the running cost","The number of rotations to serve all customers, regardless of profit",The number of rotations to serve half the customers,"The minimum number of rotations to maximize total profit, considering running cost, boarding cost, and customer arrival rate",Medium,algorithms,"Array,Simulation"
1722,"Throne Inheritance
A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance. For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack. Using the above function, we can always obtain a unique order of inheritance. Implement the ThroneInheritance class:",Use a breadth-first search (BFS) to traverse the family tree and add living members to the inheritance order.,Store the family tree in a sorted array and update the inheritance order after each birth or death by re-sorting the array.,Implement a depth-first search (DFS) that prioritizes younger children over older children when constructing the inheritance order.,"Maintain a separate list of dead people and exclude them from the inheritance order during each traversal, without any specific search algorithm.",Implement a depth-first search (DFS) that prioritizes older children and only includes living members in the inheritance order.,Medium,data structures,"Hash Table,Tree,Depth-First Search,Design"
1723,"Maximum Number of Achievable Transfer Requests
We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in. You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi. All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2. Return the maximum number of achievable requests.",Iterate through all possible subsets of requests and check if the net change in employees for each building is zero.,Sort the requests array based on the building index and process them sequentially.,Greedily accept requests as long as the absolute difference between incoming and outgoing employees for any building does not exceed a threshold.,Use dynamic programming to compute the maximum achievable requests for each building independently and sum the results.,Use backtracking to explore all possible combinations of requests and find the maximum number that satisfy the zero net change condition for all buildings.,Hard,algorithms,"Array,Backtracking,Bit Manipulation,Enumeration"
1708,"Design Parking System
Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the ParkingSystem class:","Use a single integer variable to track available slots for each size and decrement when parking, return slots incorrectly","Utilize a dictionary where keys are slot types and values are booleans to indicate availability, but forget to handle full capacity","Employ a linked list for each slot type, adding and removing nodes when parking/leaving, leading to memory inefficiency","Store available slots in a string, updating the string by replacing characters representing slots, and parsing it inefficiently","Maintain separate integer counters for each slot type, decrementing upon parking and returning boolean if successful",Easy,system design,"Design,Simulation,Counting"
1709,"Alert Using Same Key-Card Three or More Times in a One Hour Period
LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period. You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day. Access times are given in the 24-hour time format ""HH:MM"", such as ""23:51"" and ""09:49"". Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically. Notice that ""10:00"" - ""11:00"" is considered to be within a one-hour period, while ""22:51"" - ""23:52"" is not considered to be within a one-hour period.","Use a hash map to store each worker's keycard usage times and iterate through the map, checking for the alert condition using nested loops.","Sort the keyName and keyTime lists separately and then iterate through them, checking for the alert condition at each index.","Use a sliding window of size 3 on the sorted key times for each employee, checking if the time difference between the first and last element is less than or equal to one hour.",Convert all times to minutes since midnight and then check if any worker has three or more entries with the same minute value.,"Group key times by name, sort each group, convert times to minutes, and check for three entries within a 60-minute window.",Medium,algorithms,"Array,Hash Table,String,Sorting"
1711,"Find Valid Matrix Given Row and Column Sums
You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column. Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements. Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.",Prioritize allocating values to matrix cells based on the largest remaining row sum.,Use dynamic programming to explore all possible matrix configurations and choose the first valid one.,"Start with a matrix filled with zeros and iteratively adjust values based on the differences between row and column sums and their respective targets, potentially leading to negative values which requires further adjustments.","Populate the matrix randomly with non-negative integers until the row and column sums match the given arrays, retrying if necessary.","Iterate through the matrix, assigning each cell the minimum of the remaining row sum and column sum, then updating the row and column sums accordingly.",Medium,algorithms,"Array,Greedy,Matrix"
1710,"Find Servers That Handled Most Number of Requests
You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm: You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers. Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.","Maintain a min-heap of available servers and a sorted list of busy servers, iterating through requests and assigning them to the first available server in the heap.","Simulate the server assignments using a brute-force approach, iterating through each request and assigning it to the first available server, then counting the number of requests handled by each server.","Use a priority queue to store servers sorted by their current load, assigning requests to the server with the smallest load and updating the queue accordingly.","Employ a greedy algorithm, assigning each request to the server with the lowest ID that is currently available.","Utilize a min-heap to track available servers and an array to store request counts per server, assigning each request to the next available server based on the modulo operation and heap.",Hard,algorithms,"Array,Greedy,Heap (Priority Queue),Ordered Set"
1730,"Special Array With X Elements Greater Than or Equal X
You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x. Notice that x does not have to be an element in nums. Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.",Use binary search to find the smallest element greater than or equal to x,"Sort the array and iterate, counting elements greater than the current index",Calculate the mean of the array and round to the nearest integer to find x,Find the median of the array; this is the value of x,Sort the array and use binary search to find an x such that exactly x elements are greater than or equal to it,Easy,algorithms,"Array,Binary Search,Sorting"
1731,"Even Odd Tree
A binary tree is named Even-Odd if it meets the following conditions: Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.","Depth-first search, checking parity at each node without level awareness.","Breadth-first search, verifying level order but ignoring node parity.","Inorder traversal, ensuring values are increasing and of correct parity.","Random traversal, assessing parity and value relations without structure.","Level-order traversal, checking level and node parity conditions.",Medium,algorithms,"Tree,Breadth-First Search,Binary Tree"
1733,"Maximum Number of Visible Points
You are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane. Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2]. Your browser does not support the video tag or this video format. You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view. There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points. Return the maximum number of points you can see.","Calculate angles relative to the east direction and use a sliding window to count points within the 'angle' range, ignoring duplicates.",Sort points by their distance from the location and greedily select the closest points until the 'angle' constraint is violated.,"Iterate through all possible rotation angles (0 to 360) and, for each angle, count the points within the field of view.","Divide the plane into quadrants and independently count visible points in each quadrant, then sum the results.","Calculate angles relative to the east, sort them, and use a sliding window technique to find the maximum number of points within the 'angle' range, handling angle wraparound.",Hard,algorithms,"Array,Math,Geometry,Sliding Window,Sorting"
1732,"Minimum One Bit Operations to Make Integers Zero
Given an integer n, you must transform it into 0 using the following operations any number of times: Return the minimum number of operations to transform n into 0.",Gray Code,Hamming Distance,Fibonacci Sequence,Catalan Number,Recursion with Gray Code conversion,Hard,algorithms,"Dynamic Programming,Bit Manipulation,Memoization"
1737,"Maximum Nesting Depth of the Parentheses
Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.",Use regular expressions to identify and count nested parentheses,Apply dynamic programming to store and reuse depth calculations for substrings,Employ a recursive function to traverse the string and track the maximum depth,Utilize a stack to store the indices of opening parentheses and compute depth based on distance,"Maintain a counter, incrementing on '(' and decrementing on ')', tracking the maximum value of the counter",Easy,algorithms,"String,Stack"
1738,"Maximal Network Rank
There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi. The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once. The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities. Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.",The number of cities minus the number of roads.,The sum of the degrees of all cities divided by two.,The maximum degree of any single city.,The average degree of all cities.,"The maximum sum of degrees of any two cities, subtracting 1 if there is an edge between them.",Medium,algorithms,Graph
1739,"Split Two Strings to Make Palindrome
You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome. When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s = ""abc"", then """" + ""abc"", ""a"" + ""bc"", ""ab"" + ""c"" , and ""abc"" + """" are valid splits. Return true if it is possible to form a palindrome string, otherwise return false. Notice that x + y denotes the concatenation of strings x and y.",Use dynamic programming to find the longest common subsequence and check if removing it results in palindromes.,Reverse both strings and check if the concatenation of the original string 'a' with the reversed string 'b' or vice versa is a palindrome.,"Iterate through all possible split points, create all prefixes and suffixes, and then check if any combination results in a palindrome using string reversal.","Compare the ASCII values of characters at corresponding indices in 'a' and 'b'; if they're equal, form a palindrome. Otherwise, return false.","Iterate through all possible split points, check if aprefix + bsuffix or bprefix + asuffix forms a palindrome by checking if the mismatched parts are palindromes themselves.",Medium,algorithms,"Two Pointers,String,Greedy"
1740,"Count Subtrees With Max Distance Between Cities
There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree. A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other. For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d. Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d. Notice that the distance between the two cities is the number of edges in the path between them.",Brute-force: Generate all possible subtrees and calculate the maximum distance between cities for each.,Dynamic Programming: Compute the maximum distance for subtrees rooted at each node iteratively.,Greedy approach: Start with the largest possible subtree and prune nodes until the maximum distance matches d.,Simulated Annealing: Randomly generate subtrees and optimize towards desired max distances.,"Bitmasking: Represent each subtree as a bitmask, precompute distances using Floyd-Warshall, and count subtrees with the desired max distance.",Hard,algorithms,"Dynamic Programming,Bit Manipulation,Tree,Enumeration,Bitmask"
1210,"Mean of Array After Removing Some Elements
Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements. Answers within 10-5 of the actual answer will be considered accepted.",Sort the array and take the average of all elements except the first 5% and last 5% based on index,"Iterate through the array, keeping track of the 5th and 95th percentile values, and calculate the mean using only values between them","Use a hash map to count the frequency of each number and calculate a weighted average, excluding the 5% most and least frequent numbers","Remove the smallest and largest elements one by one until 90% of the array remains, then calculate the mean","Sort the array, determine the start and end indices based on 5%, and calculate the mean of the subarray between those indices",Easy,algorithms,"Array,Sorting"
1726,"Coordinate With Maximum Network Quality
You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance. You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable. The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula ⌊qi / (1 + d)⌋, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers. Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate. Note:",Return the coordinate with the highest quality factor among all towers.,"Iterate through all towers, calculating the quality at each tower's location, and return the coordinate with the highest individual tower quality.",Calculate the network quality only at locations of the existing towers and return the one with the maximum quality.,"Return the coordinate (0, 0) if no towers are present, otherwise, calculate the average location of all towers and round to the nearest integer coordinates.","Iterate over all possible integral coordinates within a reasonable range, calculate the network quality at each, and return the coordinate with the maximum quality, prioritizing lexicographical order.",Medium,algorithms,"Array,Enumeration"
1725,"Number of Sets of K Non-Overlapping Line Segments
Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, find the number of ways we can draw exactly k non-overlapping line segments such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. The k line segments do not have to cover all n points, and they are allowed to share endpoints. Return the number of ways we can draw k non-overlapping line segments. Since this number can be huge, return it modulo 109 + 7.","O(n^2 * k), using dynamic programming with prefix sums for optimization","O(n * k), using a recursive approach with memoization","O(n^3), using a bottom-up dynamic programming approach without optimizations","O(n + k), using a greedy algorithm to place segments","O(n^2 * k), using dynamic programming to store the number of ways to form segments",Medium,algorithms,"Math,Dynamic Programming"
1728,"Fancy Sequence
Write an API that generates fancy sequences using the append, addAll, and multAll operations. Implement the Fancy class:",Thread safety is automatically guaranteed with appropriate locking mechanisms built into the Fancy class.,The append operation has O(1) complexity while addAll and multAll have O(n) complexity where n is the length of the sequence.,"The Fancy sequence is immutable, meaning operations return a new Fancy sequence, leaving the original unchanged.",The getIndex(idx) operation internally rebuilds the entire sequence up to 'idx' each time it is called.,Lazy propagation is used to efficiently apply addAll and multAll operations across the sequence.,Hard,algorithms,"Math,Design,Segment Tree"
1746,"Largest Substring Between Two Equal Characters
Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1. A substring is a contiguous sequence of characters within a string.",Use a hash map to store the index of each character's first occurrence and calculate the difference between the last and first occurrences.,Sort the string alphabetically and then find the longest sequence of identical characters.,"Iterate through all possible substrings and check if the first and last characters are equal, keeping track of the maximum length.",Employ dynamic programming to store lengths of substrings and reuse previously computed values for overlapping substrings.,"Iterate through the string, recording the first occurrence of each character. Iterate again, checking if the character exists in the recorded first occurrences, and compute the substring length.",Easy,algorithms,"Hash Table,String"
1747,"Lexicographically Smallest String After Applying Operations
You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b. You can apply either of the following two operations any number of times and in any order on s: Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, ""0158"" is lexicographically smaller than ""0190"" because the first position they differ is at the third letter, and '5' comes before '9'.","Increment all digits by 'a' modulo 10, and then rotate the string by 'b' positions.","Always rotate the string by 'b' first, then increment digits by 'a' modulo 10.","Increment digits at even indices by 'a' modulo 10, then rotate the string by 'b' positions. Repeat until no further change.",Sort the string and then apply increments and rotations until the string doesn't change.,"Increment digits at odd indices by 'a' modulo 10, then rotate the string by 'b' positions. Repeat until no further change and choose the smallest.",Medium,algorithms,"String,Breadth-First Search"
1748,"Best Team With No Conflicts
You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team. However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age. Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.",Sort players by age in descending order and use dynamic programming to find the maximum score of a conflict-free team considering players in this order.,"Sort players by score in descending order and greedily choose players, skipping any younger player with a higher score.",Calculate the total score of all players and subtract the highest score among players with conflicts.,"Use a recursive approach, exploring all possible subsets of players and returning the highest score of conflict-free teams.","Sort players by age (or score if ages are the same), then use dynamic programming to find the longest non-decreasing subsequence of scores.",Medium,algorithms,"Array,Dynamic Programming,Sorting"
1223,"Graph Connectivity With Threshold
We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road if and only if x and y share a common divisor strictly greater than some threshold. More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true: Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected directly or indirectly. (i.e. there is some path between them). Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.","Use Depth-First Search (DFS) on the graph represented by the cities and roads with a time complexity of O(V+E) for each query, where V is the number of cities and E is the number of roads.","Use Breadth-First Search (BFS) on the graph represented by the cities and roads with a time complexity of O(n*m) for each query, where n is the number of cities and m is the maximum value in queries","Precompute all possible paths between every pair of cities using Floyd-Warshall's algorithm with a time complexity of O(n^3), and then answer each query in O(1).","Use a simple loop to check for direct divisibility and return true, otherwise return false in O(1) for each query.","Use Disjoint Set Union (DSU) to connect cities sharing a common divisor greater than the threshold and then check if the queried cities belong to the same set with a time complexity close to O(α(n)) per query, where α(n) is the inverse Ackermann function.",Hard,algorithms,"Array,Math,Union Find"
1751,"Slowest Key
A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time. You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released. The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0]. Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration. Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.",Return the key with the smallest ASCII value among those with the longest duration,Return the key that appears most frequently in the keysPressed string,"Return the last key pressed, keysPressed[n-1], as it is guaranteed to have the longest duration",Return the key with the smallest index in the keysPressed string among those with the longest duration,Calculate the duration of each keypress and return the lexicographically largest key with the maximum duration,Easy,algorithms,"Array,String"
1752,"Arithmetic Subarrays
A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i. For example, these are arithmetic sequences: The following sequence is not arithmetic: You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed. Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.","Check if the maximum value minus the minimum value equals the common difference times the length of the subarray minus one, and all elements are distinct","Sort the subarray and check if the difference between consecutive elements is the same, but only for subarrays of length greater than two","Calculate the mean and median of the subarray and compare them; if they are equal, the subarray can form an arithmetic sequence","Check if the sum of the elements at even indices equals the sum of the elements at odd indices; if they are equal, the subarray can form an arithmetic sequence","Find the minimum and maximum elements, calculate the common difference, and verify that all elements can be generated from the minimum using the common difference and that all elements are present",Medium,algorithms,"Array,Sorting"
1753,"Path With Minimum Effort
You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort. A route's effort is the maximum absolute difference in heights between two consecutive cells of the route. Return the minimum effort required to travel from the top-left cell to the bottom-right cell.",Use Dijkstra's algorithm with a priority queue based on the maximum height difference encountered so far,"Apply a greedy algorithm, always moving to the neighbor with the smallest height difference","Perform a depth-first search, pruning branches that exceed a pre-defined effort threshold",Calculate the average height difference between all adjacent cells and return that value,"Employ binary search on the possible effort values, and use a modified Breadth-First Search (BFS) or Depth-First Search (DFS) to check if a path exists for a given effort",Medium,algorithms,"Array,Binary Search,Depth-First Search,Breadth-First Search,Union Find,Heap (Priority Queue),Matrix"
1257,"Rank Transform of a Matrix
Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col]. The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules: The test cases are generated so that answer is unique under the given rules.","Sort each row and column independently, then assign ranks based on sorted order.","Calculate the average of each row and column, then assign ranks based on distance from the average.",Assign ranks sequentially from 1 to m*n based on the order the elements are encountered in a row-major traversal.,Use a depth-first search to explore neighboring cells and assign ranks based on the path length.,"Use Disjoint Set Union (DSU) to find connected components of equal values, and topological sort to determine ranks considering row and column constraints.",Hard,algorithms,"Array,Greedy,Union Find,Graph,Topological Sort,Matrix"
1773,"Percentage of Users Attended a Contest
Table: Users  Table: Register  Write a solution to find the percentage of the users registered in each contest rounded to two decimals. Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order. The result format is in the following example.",Use a correlated subquery to calculate the user count for each contest and divide by the total user count.,Employ a window function partitioned by contest_id to get the user count per contest and divide by the total user count without partitioning.,"Join the `Users` and `Register` tables on user_id and count distinct user_ids, then divide by the total users.","Use a cross join to find every combination of user and contest, then aggregate.","Divide the count of users registered in each contest by the total count of users, multiplying by 100, rounding to two decimal places, and ordering as specified.",Easy,database systems,Database
1741,"Sort Array by Increasing Frequency
Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. Return the sorted array.","Use a hash map to count frequencies, then sort the map's keys by frequency and value in descending order.",Sort the array directly using a comparison function that prioritizes value over frequency.,"Use a priority queue to maintain elements sorted by frequency, breaking ties arbitrarily.",Apply a counting sort algorithm and then reverse the resulting array.,"Use a hash map to count frequencies, then sort the array using a custom comparator that prioritizes frequency and value in descending order.",Easy,algorithms,"Array,Hash Table,Sorting"
1742,"Widest Vertical Area Between Two Points Containing No Points
Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area. A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width. Note that points on the edge of a vertical area are not considered included in the area.","O(n log n) due to the sort operation, where n is the number of points.",O(n^2) because of nested loops required to find the widest area.,O(n) because we iterate through the sorted list of x-coordinates once.,O(1) as the algorithm's complexity is independent of the input size.,"O(n log n) dominated by sorting the x-coordinates, followed by a linear scan.",Easy,algorithms,"Array,Sorting"
1743,"Count Substrings That Differ by One Character
Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character such that the resulting substring is a substring of t. In other words, find the number of substrings in s that differ from some substring in t by exactly one character. For example, the underlined substrings in ""computer"" and ""computation"" only differ by the 'e'/'a', so this is a valid way. Return the number of substrings that satisfy the condition above. A substring is a contiguous sequence of characters within a string.",Use dynamic programming to build a table of longest common subsequences between s and t,"Employ a sliding window approach on s and t, expanding until the difference exceeds one character",Generate all possible substrings of s and t and compare them directly for a single character difference,Compute the edit distance between all substrings of s and t using the Levenshtein distance algorithm,"Iterate through all substrings of s and t, comparing them character by character and counting those with exactly one difference",Medium,algorithms,"Hash Table,String,Dynamic Programming"
1744,"Number of Ways to Form a Target String Given a Dictionary
You are given a list of strings of the same length words and a string target. Your task is to form target using the given words under the following rules: Notice that you can use multiple characters from the same string in words provided the conditions above are met. Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.",Use a greedy algorithm to pick the most frequent characters from words to match target.,"Employ backtracking to explore all possible combinations of characters from words, pruning branches that don't match prefixes of target.","Calculate the edit distance between each word and the target string, and sum the results.",Sort the words lexicographically and then try to form the target string using a sliding window approach.,Use dynamic programming to store the number of ways to form prefixes of the target string using prefixes of the words.,Hard,algorithms,"Array,String,Dynamic Programming"
1760,"Check Array Formation Through Concatenation
You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i]. Return true if it is possible to form the array arr from pieces. Otherwise, return false.",Sort both the 'arr' and elements within 'pieces' arrays before comparison.,Check if 'arr' and the concatenated 'pieces' arrays have the same sum of elements.,"Use a hash table to count element frequencies in 'arr' and 'pieces', then compare the counts.",Recursively try all possible permutations of 'pieces' to see if any form 'arr'.,"Create a dictionary mapping the first element of each piece to the entire piece, then iterate through 'arr' to reconstruct it.",Easy,algorithms,"Array,Hash Table"
1761,"Count Sorted Vowel Strings
Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted. A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.","Use dynamic programming with a 1D array, iterating through each vowel and length, updating the array with the sum of previous vowel counts.","Employ recursion, decrementing the length 'n' and summing the results of calls with the next vowel in the sequence, memoizing the results.","Apply a greedy algorithm, always choosing the lexicographically smallest vowel until length 'n' is reached, multiplying by the number of vowels.","Calculate the number of permutations with repetitions using the formula (n+4)! / (n! * 4!), which directly gives the result.","Apply dynamic programming using a 2D array where dp[i][j] represents the number of strings of length i using the first j vowels, building up from length 1.",Medium,algorithms,Dynamic Programming
1762,"Furthest Building You Can Reach
You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed), Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.",Use dynamic programming to calculate the minimum bricks/ladders needed to reach each building.,"Apply a greedy approach, always using ladders for the largest height differences.","Binary search on the possible furthest building index, simulating the journey for each index.","Prioritize using bricks until they run out, then use ladders for all remaining height differences.",Use a min-heap to track the largest height differences and prioritize using bricks for smaller ones.,Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
489,"Kth Smallest Instructions
Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination. The instructions are represented as a string, where each character is either: Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both ""HHHVV"" and ""HVHVH"" are valid instructions. However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed. Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.",Greedily choose 'H' or 'V' based on remaining steps without considering the lexicographical order.,"Generate all possible paths and sort them lexicographically, then return the kth element. (Brute Force)",Use dynamic programming to calculate the number of possible paths and backtrack to construct the kth smallest instruction.,Employ a binary search approach to guess the instructions and adjust the search space until the kth smallest is found.,Calculate combinations using factorials to determine how many paths start with 'H' or 'V' and recursively construct the string.,Hard,algorithms,"Array,Math,Dynamic Programming,Combinatorics"
1769,"Get Maximum in Generated Array
You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way: Return the maximum integer in the array nums​​​.",Calculate powers of 2 up to n and return the largest,Use dynamic programming to store previously calculated values in a hash map,Recursively calculate the array elements and return the maximum,Initialize an array of size n with random numbers and return the maximum,Iteratively generate the array based on the given rules and keep track of the maximum value,Easy,algorithms,"Array,Dynamic Programming,Simulation"
1770,"Minimum Deletions to Make Character Frequencies Unique
A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return the minimum number of characters you need to delete to make s good. The frequency of a character in a string is the number of times it appears in the string. For example, in the string ""aab"", the frequency of 'a' is 2, while the frequency of 'b' is 1.",Recursively remove characters based on a predefined priority until frequencies are unique,Sort the string and repeatedly remove characters to equalize frequencies until unique.,Greedily delete occurrences of the most frequent character until all frequencies are unique.,"Calculate frequencies, and for each frequency, delete characters to match the next smallest frequency.","Calculate frequencies, sort them, and decrement larger frequencies until unique, tracking deletions.",Medium,algorithms,"String,Greedy,Sorting"
1771,"Sell Diminishing-Valued Colored Balls
You have an inventory of different colored balls, and there is a customer that wants orders balls of any color. The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer). You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order. Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.","Use dynamic programming to greedily choose the most valuable colors first, updating a memoization table",Sort the inventory in ascending order and iteratively sell balls from the least frequent color,"Apply a binary search algorithm to find the optimal value to sell each color, prioritizing larger inventories",Calculate the value by sorting the inventory and always selling one ball from each color until 'orders' depletes,Use binary search to find the minimum value 'x' such that selling all balls with value > 'x' satisfies the order constraint; then calculate the value using arithmetic series.,Medium,algorithms,"Array,Math,Binary Search,Greedy,Sorting,Heap (Priority Queue)"
1772,"Create Sorted Array through Instructions
Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following: For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5]. Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7",Always insert the new element at the end of the sorted array,Use a hash table to count smaller and larger elements,Sort the entire array after each insertion,Calculate the cost by dividing the array length by the element to be inserted,Use a binary indexed tree (BIT) or segment tree to efficiently count smaller and larger elements during each insertion,Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
1755,"Defuse the Bomb
You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k. To decrypt the code, you must replace every number. All the numbers are replaced simultaneously. As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1]. Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!","Shift the array 'code' by 'k' positions to the right if k > 0, or left if k < 0.",Replace each element with the product of its 'k' nearest neighbors (wrapping around the array).,Set each element to the average of the 'k' elements preceding it in the array.,Reverse the array and apply the cumulative sum operation.,Replace each element with the sum of the next 'k' elements (or previous '-k' elements) in the circular array.,Easy,algorithms,Array
1756,"Minimum Deletions to Make String Balanced
You are given a string s consisting only of characters 'a' and 'b'​​​​. You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'. Return the minimum number of deletions needed to make s balanced.","Count leading 'b's and trailing 'a's, deleting the smaller count.",Greedily delete 'b' whenever it precedes an 'a'.,Delete all 'a's to the left of the last 'b'.,Recursively check substrings for balance and delete characters to achieve it.,Use dynamic programming to track the minimum deletions needed up to each index.,Medium,algorithms,"String,Dynamic Programming,Stack"
1757,"Minimum Jumps to Reach Home
A certain bug's home is on the x-axis at position x. Help them get there from position 0. The bug jumps according to the following rules: The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers. Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.",Depth-First Search (DFS),Greedy Search,A* Search,Randomized Search,Breadth-First Search (BFS),Medium,algorithms,"Array,Dynamic Programming,Breadth-First Search"
1758,"Distribute Repeating Integers
You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that: Return true if it is possible to distribute nums according to the above conditions.",Backtracking without memoization will lead to exponential time complexity.,Using a greedy approach by assigning larger orders first guarantees an optimal solution.,A Depth-First Search (DFS) can efficiently explore the possible assignments.,Sorting both `nums` and `quantity` arrays in descending order ensures a feasible distribution.,A backtracking algorithm with memoization can determine if a valid assignment exists within reasonable time.,Hard,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
1775,"Design an Ordered Stream
There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id. Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values. Implement the OrderedStream class:  Example:   Constraints:",Use a hash map to store elements and sort the map's entries before returning the chunk,"Use a priority queue to maintain sorted order, returning a chunk when the smallest idKey matches the expected next value",Store the stream in a list and sort the list after each insertion to determine the next chunk,"Store all pairs in an array and, upon each insertion, scan the entire array to identify the next ordered chunk","Store the stream in an array, tracking the pointer to the next expected idKey, and return the continuous sequence of values from that pointer onwards",Easy,system design,"Array,Hash Table,Design,Data Stream"
1777,"Determine if Two Strings Are Close
Two strings are considered close if you can attain one from the other using the following operations: You can use the operations on either string as many times as necessary. Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.",The strings must be identical after sorting their characters.,"The strings must have the same length and contain the same characters, regardless of frequency.","The strings must have the same length, and corresponding characters at each index must be within one ASCII value of each other.",The strings must be anagrams of each other.,"The strings must have the same set of characters, and the frequencies of characters must be the same after sorting.",Medium,algorithms,"Hash Table,String,Sorting"
1776,"Minimum Operations to Reduce X to Zero
You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations. Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.","Use a two-pointer approach, shrinking the window from both ends until the sum equals x, then return the length of the window.","Sort the array and greedily remove elements from the smallest end until x is zero, or until all elements are removed.",Apply dynamic programming to find all possible subset sums and choose the one closest to x.,"Use a breadth-first search, exploring all possible combinations of removing elements from the left or right.","Use a sliding window to find the longest subarray that sums to sum(nums) - x, then return len(nums) - len(longest_subarray).",Medium,algorithms,"Array,Hash Table,Binary Search,Sliding Window,Prefix Sum"
1778,"Maximize Grid Happiness
You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts. You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid. The happiness of each person is calculated as follows: Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell. The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.",Use a greedy approach by placing extroverts first in the center of the grid.,Employ dynamic programming with a state representing the current cell and remaining introverts/extroverts without considering neighbors.,Try all possible permutations of introverts and extroverts and calculate the happiness for each permutation.,"Calculate the happiness of all introverts and then all extroverts, and sum them.",Use dynamic programming with bitmasking to represent the previously placed people in the grid and track remaining introverts/extroverts.,Hard,algorithms,"Dynamic Programming,Bit Manipulation,Memoization,Bitmask"
1801,"Average Time of Process per Machine
Table: Activity  There is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to complete a process. The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run. The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places. Return the result table in any order. The result format is in the following example.",Use `AVG(timestamp)` to directly compute the average time for each machine.,Compute the difference between the maximum and minimum timestamp for each machine and divide by the count.,Calculate the sum of all timestamps and divide by the total number of activities.,Use a correlated subquery to find matching start and end times and then average the differences.,"Join the table to itself on machine_id, group by machine_id, calculate the difference between end and start timestamps, and then compute the average.",Easy,database systems,Database
1781,"Check If Two String Arrays are Equivalent
Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string.","Compare the lengths of the input arrays. If unequal, return false. Otherwise, return true.",Concatenate the arrays into strings and check if the string lengths match.,Hash each string array and compare hash values; equal hashes indicate equivalence.,"Check if the first element of each array is equal. If so, return true; otherwise, return false.",Concatenate all strings in each array into a single string and then compare the two strings for equality.,Easy,algorithms,"Array,String"
1782,"Smallest String With A Given Numeric Value
The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on. The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string ""abe"" is equal to 1 + 2 + 5 = 8. You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k. Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.",Start by filling the string with the largest possible characters (z) and adjust from the beginning if necessary.,Recursively generate all possible strings and return the lexicographically smallest one that matches the criteria.,Use dynamic programming to build a table of all possible strings for lengths 1 to n and values 1 to k.,Fill the string with 'a' characters and then distribute the remaining value evenly across the characters.,"Start by filling the string with the smallest possible characters ('a') and adjust from the end, replacing them with larger characters as needed to reach the target value.",Medium,algorithms,"String,Greedy"
1783,"Ways to Make a Fair Array
You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal. For example, if nums = [6,1,7,4,1]: An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values. Return the number of indices that you could choose such that after the removal, nums is fair.",Consider only elements at even indices,Calculate the total sum and divide by two,Check if the array is already fair before any removal,Remove all elements and check if the resulting empty array is fair,"Calculate prefix sums of even and odd indices, then iterate through the array to simulate removal and check fairness",Medium,algorithms,"Array,Dynamic Programming"
1784,"Minimum Initial Energy to Finish Tasks
You are given an array tasks where tasks[i] = [actuali, minimumi]: For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it. You can finish the tasks in any order you like. Return the minimum initial amount of energy you will need to finish all the tasks.",Sort tasks by actual energy and greedily select the ones with the lowest energy requirement first.,Sort tasks by minimum energy required and sum all minimum energy requirements to get the initial energy.,Calculate the sum of all actual energy requirements and select the maximum of that sum or the maximum minimum energy requirement.,Sum all actual energy requirements and subtract the smallest actual energy value from this sum.,Sort tasks in descending order of the difference between minimum and actual energy. Start with an initial energy of 0 and increment as needed to meet minimum requirements.,Hard,algorithms,"Array,Greedy,Sorting"
1811,"Fix Names in a Table
Table: Users  Write a solution to fix the names so that only the first character is uppercase and the rest are lowercase. Return the result table ordered by user_id. The result format is in the following example.",Use the `INITCAP` function directly without considering character encoding issues.,Apply `UPPER` to the entire name and then `LOWER` to the whole name except the first character.,"Use `SUBSTR` and `CONCAT` with incorrect index values, causing errors for single-character names.","Employ regular expressions to match and replace the entire name, but fail to handle null values properly.","Use `UPPER` on the first character and `LOWER` on the rest, combining them with `CONCAT` or `||`.",Easy,database systems,Database
1764,"Maximum Repeating Substring
For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0. Given strings sequence and word, return the maximum k-repeating value of word in sequence.","Return the length of sequence divided by the length of word if word is found in sequence, otherwise return 0.","Use dynamic programming to build a table tracking repeating occurrences, and return the maximum value in the table.","Concatenate 'word' with itself increasing number of times until it's not a substring of 'sequence', and return the number of concatenations minus 1.",Use regular expressions to find all occurrences of 'word' in 'sequence' and return the length of the longest match.,"Iteratively check if 'word' repeated k times is a substring of 'sequence' for increasing k, returning the largest such k.",Easy,algorithms,"String,String Matching"
1765,"Merge In Between Linked Lists
You are given two linked lists: list1 and list2 of sizes n and m respectively. Remove list1's nodes from the ath node to the bth node, and put list2 in their place. The blue edges and nodes in the following figure indicate the result: Build the result list and return its head.","Use a hash table to track visited nodes and detect cycles, modifying list1 accordingly","Recursively traverse list1 from a to b, storing the nodes in a temporary array, then insert list2.","Create a new linked list and copy all nodes from list1, excluding the range [a, b], then append list2.","Iterate through list1, deleting nodes from a to b directly without considering memory leaks.","Find the nodes before 'a' and after 'b' in list1, then connect the beginning of list2 to the node before 'a' and the end of list2 to the node after 'b'.",Medium,data structures,Linked List
1767,"Design Front Middle Back Queue
Design a queue that supports push and pop operations in the front, middle, and back. Implement the FrontMiddleBack class: Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:",A single doubly linked list,"Three separate queues: one for the front, one for the middle, and one for the back","An array with three pointers: front, middle, and back","A hash map where keys represent positions (front, middle, back) and values are the elements at those positions","Two doubly linked lists, one for the front and one for the back, with a mechanism to maintain the middle",Medium,data structures,"Array,Linked List,Design,Queue,Data Stream"
1766,"Minimum Number of Removals to Make Mountain Array
You may recall that an array arr is a mountain array if and only if: Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.",Find the longest increasing subsequence (LIS) and longest decreasing subsequence (LDS) for every element and return the length of the input array minus the maximum sum of LIS and LDS for any element.,"Sort the array and remove any element that appears more than once, then return the number of removed elements.","Iterate through all possible subarrays and check if each is a mountain array, then return the number of removals for the longest mountain subarray found.",Calculate the median of the array and remove any element smaller than the median.,"For each element, find the longest increasing subsequence ending at that element and the longest decreasing subsequence starting from that element. Sum the lengths of these subsequences (subtracting 1 for the element itself) and find the maximum of these sums. Return the length of the array minus this maximum sum.",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Greedy"
1791,"Richest Customer Wealth
You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has. A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.",Calculate the average wealth across all customers and return that value.,Return the wealth of the first customer in the accounts array.,Find the minimum wealth among all customers and return that value.,Multiply the number of customers by the number of banks to estimate the richest customer's wealth.,Compute the sum of each customer's wealth and return the maximum sum.,Easy,algorithms,"Array,Matrix"
1792,"Find the Most Competitive Subsequence
Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.",Use dynamic programming to build all possible subsequences of size k and then compare them.,Sort the array 'nums' and select the first 'k' elements.,Randomly select 'k' elements from 'nums' and repeat until a sufficiently competitive subsequence is found.,Select the 'k' smallest elements from 'nums' without considering order.,"Use a stack to maintain a candidate subsequence, popping larger elements if a smaller element is encountered and there are enough remaining elements to form a subsequence of size k.",Medium,algorithms,"Array,Stack,Greedy,Monotonic Stack"
1793,"Minimum Moves to Make Array Complementary
You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive. The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5. Return the minimum number of moves required to make nums complementary.",Find the minimum and maximum elements of the array.,Count the frequency of each element in the array.,Sort the array in ascending order.,Calculate the prefix sum of the array.,Use a difference array technique to track the number of moves required for each possible sum.,Medium,algorithms,"Array,Hash Table,Prefix Sum"
1794,"Minimize Deviation in Array
You are given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times: The deviation of the array is the maximum difference between any two elements in the array. Return the minimum deviation the array can have after performing some number of operations.",Sort the array and greedily apply operations to minimize the difference between adjacent elements.,Calculate the initial deviation and iteratively reduce it by applying operations to elements that contribute most to the deviation.,Use dynamic programming to store the minimum deviation achievable for each sub-array after a certain number of operations.,"Transform all even numbers to odd by dividing by 2, then find the difference between the maximum and minimum elements.",Use a priority queue (or set) to maintain unique numbers and greedily reduce the largest and increase the smallest until no further reduction is possible.,Hard,algorithms,"Array,Greedy,Heap (Priority Queue),Ordered Set"
1797,"Goal Parser Interpretation
You own a Goal Parser that can interpret a string command. The command consists of an alphabet of ""G"", ""()"" and/or ""(al)"" in some order. The Goal Parser will interpret ""G"" as the string ""G"", ""()"" as the string ""o"", and ""(al)"" as the string ""al"". The interpreted strings are then concatenated in the original order. Given the string command, return the Goal Parser's interpretation of command.","Replace all occurrences of '()' with 'G', and '(al)' with 'o'",Use a regular expression to match and replace the patterns,Split the string into an array of characters and use a switch statement to interpret each character,"Remove all parenthesis from the input string, the result will be the final string","Iterate through the string, building the result based on pattern matching 'G', '()', and '(al)'",Easy,algorithms,String
1798,"Max Number of K-Sum Pairs
You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.",Sort the array and use two pointers starting from the beginning to find pairs that sum to k.,"Iterate through each number and check for pairs using nested loops, removing pairs as you find them.",Recursively divide the array and count pairs that sum to k in each sub-array.,"Convert the array into a set to remove duplicates, then iterate and check for pairs.","Use a hash map to store the frequency of each number, then iterate through the map to find pairs that sum to k.",Medium,algorithms,"Array,Hash Table,Two Pointers,Sorting"
1800,"Concatenation of Consecutive Binary Numbers
Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.",O(n log n),O(n),O(log n),O(sqrt(n)),O(n * log(n)),Medium,algorithms,"Math,Bit Manipulation,Simulation"
1799,"Minimum Incompatibility
You are given an integer array nums​​​ and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset. A subset's incompatibility is the difference between the maximum and minimum elements in that array. Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible. A subset is a group integers that appear in the array with no particular order.","Greedily place elements into subsets based on their frequency, minimizing the max-min difference at each step","Sort the input array and divide it into subsets of size n/k, calculating incompatibility for each","Use dynamic programming with a state representing which elements have been placed in subsets, minimizing the total incompatibility using bit masking","Randomly shuffle the input array and repeatedly create subsets, returning the minimum incompatibility found over many iterations","Use backtracking to explore all possible subset combinations, pruning branches when a subset contains duplicate elements or when the current incompatibility sum exceeds the best seen so far",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
1827,"Invalid Tweets
Table: Tweets  Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15. Return the result table in any order. The result format is in the following example.",Use COUNT(*) and GROUP BY to find tweets exceeding 15 characters.,Use the SUBSTRING function to extract the first 15 characters of each tweet and filter based on that substring.,Apply the LENGTH function in a WHERE clause to filter tweets with content less than or equal to 15 characters.,Employ a regular expression to identify and exclude tweets with more than 15 characters.,Use the LENGTH function in a WHERE clause to filter tweets with content strictly greater than 15 characters.,Easy,database systems,Database
1786,"Count the Number of Consistent Strings
You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed. Return the number of consistent strings in the array words.",Use a regular expression to check if each word contains only characters from the allowed string.,Convert the allowed string and each word into sets and check if the word's set is a subset of the allowed string's set.,"Create a frequency map of characters in the allowed string and iterate through each word, checking if all characters exist in the map.","Sort the characters in each word and the allowed string, then compare them character by character.","Iterate through the words array, and for each word, check if all its characters are present in the allowed string.",Easy,algorithms,"Array,Hash Table,String,Bit Manipulation"
1787,"Sum of Absolute Differences in a Sorted Array
You are given an integer array nums sorted in non-decreasing order. Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array. In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).","Brute-force: For each element, iterate through the array to calculate the sum of absolute differences (O(n^2) time complexity).","Precompute the sum of all elements, and for each element, subtract it and then subtract the element itself times n-1 (O(n) time complexity, but prone to overflow).",Sort the array (which is unnecessary since it's already sorted) and then use the brute-force approach.,"Use binary search for each element to find elements greater and smaller than it, and sum accordingly.","Compute prefix and suffix sums. Then for each element, use the prefix sum up to the element before, and the suffix sum after the element, to compute the result in O(n) time.",Medium,algorithms,"Array,Math,Prefix Sum"
1788,"Stone Game VI
Alice and Bob take turns playing a game, with Alice starting first. There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently. You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone. The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally. Both players know the other's values. Determine the result of the game, and:",Always choose the stone with the highest Alice's value.,Always choose the stone with the highest combined value (Alice's + Bob's).,Always choose the stone with the highest absolute difference between Alice's and Bob's values.,Prioritize stones with a high Alice value and low Bob value.,Prioritize stones where the sum of Alice's and Bob's values is greatest; this maximizes the potential loss to the opponent.,Medium,algorithms,"Array,Math,Greedy,Sorting,Heap (Priority Queue),Game Theory"
1789,"Delivering Boxes from Storage to Ports
You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry. You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight. The boxes need to be delivered in the order they are given. The ship will follow these steps: The ship must end at storage after all the boxes have been delivered. Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.",Use dynamic programming with a state representing the current index of boxes and the number of trips made so far.,"Apply a greedy algorithm, always filling the ship to its maximum capacity of boxes and weight.",Sort the boxes by weight and ports and then apply dynamic programming.,"Simulate the process iteratively, calculating trips by attempting to fit as many boxes as possible in each trip until all boxes are delivered.",Employ a sliding window approach with dynamic programming to optimize the number of trips based on the constraints.,Hard,algorithms,"Array,Dynamic Programming,Segment Tree,Queue,Heap (Priority Queue),Monotonic Queue"
1806,"Count of Matches in Tournament
You are given an integer n, the number of teams in a tournament that has strange rules: Return the number of matches played in the tournament until a winner is decided.","Teams are eliminated in pairs until one team remains, so the answer is always n-1","The number of matches is equal to log base 2 of n, rounded down to the nearest integer","Calculate the factorial of n, then subtract 1",The total matches are the sum of the series n + n/2 + n/4... until 1 team remains,"Divide n by 2 (integer division) to get matches, and update n with n/2 + n%2 until n is 1",Easy,algorithms,"Math,Simulation"
1807,"Partitioning Into Minimum Number Of Deci-Binary Numbers
A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not. Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.",Find the length of the string and return its square root,Return the length of the string,Count the number of '1' digits in the string,Return the sum of all digits in the string,Return the largest digit in the string representation of the number,Medium,algorithms,"String,Greedy"
1808,"Stone Game VII
Alice and Bob take turns playing a game, with Alice starting first. There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove. Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score. Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.",O(1),O(n log n),O(n^2),O(n!),O(n^2),Medium,algorithms,"Array,Math,Dynamic Programming,Game Theory"
1367,"Maximum Height by Stacking Cuboids
Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other. You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid. Return the maximum height of the stacked cuboids.",Greedily select cuboids based on the largest dimension to maximize height.,Sort cuboids by volume and use a recursive approach to find the maximum height.,Apply a topological sort based on cuboid compatibility and calculate the longest path.,Use a brute-force approach checking all possible subsets and permutations.,"Sort cuboids based on dimensions, then apply dynamic programming to find the maximum height stack.",Hard,algorithms,"Array,Dynamic Programming,Sorting"
1837,"Daily Leads and Partners
Table: DailySales  For each date_id and make_name, find the number of distinct lead_id's and distinct partner_id's. Return the result table in any order. The result format is in the following example.","Use correlated subqueries to count distinct lead_id's and partner_id's for each (date_id, make_name)","Create temporary tables for lead_id counts and partner_id counts, then join them on date_id and make_name","Use window functions with PARTITION BY date_id, make_name to count distinct IDs separately and then combine the results","Group by date_id, make_name and use COUNT(*) to count all IDs, which is incorrect as it doesn't account for distinctness","Group by date_id, make_name and use COUNT(DISTINCT lead_id), COUNT(DISTINCT partner_id) to get the counts",Easy,database systems,Database
1812,"Reformat Phone Number
You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'. You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows: The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2. Return the phone number after formatting.",Use dynamic programming to determine the optimal block sizes.,Sort the digits and then greedily form blocks of size 3.,Employ recursion to generate all possible groupings and choose the best one.,"Remove spaces and dashes, then insert dashes at fixed intervals assuming multiples of 3.","Remove spaces and dashes, then iteratively create blocks of 3 until 4 or fewer digits remain, handling the final 2 or 4 digits specifically.",Easy,algorithms,String
1813,"Maximum Erasure Value
You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements. Return the maximum score you can get by erasing exactly one subarray. An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).","Use a sliding window, shrinking the window from the left when a duplicate is found until the duplicate is removed.",Calculate the sum of all possible subarrays and then filter out the ones with duplicate elements before finding the maximum.,"Sort the array and then iterate through it, maintaining a running sum, resetting the sum when a duplicate is encountered.","Use dynamic programming to store the maximum sum ending at each index, ignoring subarrays containing duplicates.","Use a sliding window with a set to track unique elements; expand the window, adding to the sum, and shrink from the left if a duplicate is encountered, updating the maximum sum.",Medium,algorithms,"Array,Hash Table,Sliding Window"
1814,"Jump Game VI
You are given a 0-indexed integer array nums and an integer k. You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive. You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array. Return the maximum score you can get.","Recursively explore all possible jump combinations, pruning branches that exceed array bounds or lead to lower scores","Use dynamic programming with a bottom-up approach, storing the maximum score achievable at each index","Employ a greedy approach, always jumping to the next index with the highest value within the allowed range",Calculate the average of the array and multiply by k to estimate the maximum score,"Use a deque to maintain a sliding window of the best reachable indices within the jump range, prioritizing indices with higher scores",Medium,algorithms,"Array,Dynamic Programming,Queue,Sliding Window,Heap (Priority Queue),Monotonic Queue"
1815,"Checking Existence of Edge Length Limited Paths
An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes. Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.",Use Dijkstra's algorithm to find the shortest path between pj and qj and check if its length is less than limitj.,Perform a Breadth-First Search (BFS) or Depth-First Search (DFS) and check if any path exists regardless of edge weights.,"Sort the edgeList array by distance in descending order, and then check if any path exists between pj and qj using the sorted edges.",Ignore the edge weights and check if pj and qj are in the same connected component using a simple graph traversal.,Sort both edgeList and queries by their distance/limit values and use a Union-Find data structure to maintain connected components.,Hard,algorithms,"Array,Union Find,Graph,Sorting"
1802,"Number of Students Unable to Eat Lunch
The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.",Count occurrences of 0 and 1 in both arrays and return the difference in counts if any element exceeds the other in the count,"Simulate the process with nested loops, removing elements from both arrays until a mismatch is found and all remaining students are counted as unable to eat","Sort both arrays and compare elements at corresponding indices; if a mismatch is found, return the remaining number of elements","Use recursion to simulate each step, checking if the student at the front of the queue matches the top sandwich; if not, move the student to the end of the queue","Simulate the process iteratively, using a queue for students and a stack for sandwiches, rotating students if they don't want the top sandwich until either the queue or stack is empty or no student wants the top sandwich.",Easy,algorithms,"Array,Stack,Queue,Simulation"
1803,"Average Waiting Time
There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]: When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input. Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.",Sort customers by processing time and calculate waiting time assuming preemptive scheduling.,Calculate waiting time for each customer independently without considering chef's availability.,Process customers in reverse order of arrival to optimize chef's idle time.,Assume infinite chefs and calculate the waiting time as the processing time for each customer.,"Process customers in arrival order, tracking chef's availability and calculating each customer's waiting time.",Medium,algorithms,"Array,Simulation"
1804,"Maximum Binary String After Change
You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times: Return the maximum binary string you can obtain after any number of operations. Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.","Replace all '0's with '1's except for the first '0', then move that '0' to the end.","Count the number of '0's and '1's. Create a string with all '1's, followed by a single '0', and then pad with remaining '1's.",Sort the string in descending order.,Replace all '1's with '0's and all '0's with '1's.,"Count the number of zeros. If there are no zeros, return the original string. Otherwise, construct a string of all ones except for a single zero at the (number of zeros)-th position.",Medium,algorithms,"String,Greedy"
1805,"Minimum Adjacent Swaps for K Consecutive Ones
You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values. Return the minimum number of moves required so that nums has k consecutive 1's.","Greedily swap the closest zeros to ones until k consecutive ones are formed, prioritizing swaps near the center.",Calculate the prefix sum of the array and use dynamic programming to find the minimum cost of forming k consecutive ones.,Use a sliding window of size k and calculate the number of swaps needed to move all ones within the window to the center position.,Sort the array and count the number of swaps required to bring the k largest elements to adjacent positions.,"Find the indices of ones, calculate prefix sums of these indices, and use a sliding window of size k to minimize the cost of moving the ones to a consecutive range centered around the median of the window.",Hard,algorithms,"Array,Greedy,Sliding Window,Prefix Sum"
1823,"Determine if String Halves Are Alike
You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false.",Use regular expressions to count vowels in each half.,Convert the string to lowercase and compare each character to the other half.,Use a HashMap to store vowel counts for the first half and subtract from the second half.,Check if the ASCII values of the first half's characters are within the vowel ranges.,"Iterate through both halves, counting vowels in each, and compare the counts.",Easy,algorithms,"String,Counting"
1824,"Maximum Number of Eaten Apples
There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0. You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days. Given two integer arrays days and apples of length n, return the maximum number of apples you can eat.","Use a greedy approach, eating apples with the earliest expiration date first, iterating through each day and available apples","Sort the 'apples' array in descending order and eat the largest available quantity of apples first, regardless of expiration","Maintain a fixed-size buffer to store the number of apples available for each day, updating it daily and eating the first available apple","Simulate the process for a fixed number of days (e.g., 1000) and return the number of apples eaten within that period",Employ a priority queue (min-heap) to store the expiration dates and corresponding number of apples; eat one apple from the earliest expiring batch each day.,Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
1324,"Where Will the Ball Fall
You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides. Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left. We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a ""V"" shaped pattern between two boards or if a board redirects the ball into either wall of the box. Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.",Depth-first search (DFS),Greedy algorithm,Dynamic programming,Divide and conquer,Simulation,Medium,algorithms,"Array,Dynamic Programming,Depth-First Search,Matrix,Simulation"
1826,"Maximum XOR With an Element From Array
You are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi]. The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1. Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.",A Bloom filter's false positive rate decreases as the number of elements increases.,Bloom filters guarantee that an element is in the set if the 'contains' method returns true.,Deleting elements from a Bloom filter is a straightforward operation.,The optimal number of hash functions for a Bloom filter is independent of the desired false positive rate.,A Bloom filter is a probabilistic data structure that can tell you if an element might be in a set or is definitely not in the set.,Hard,data structures,"Array,Bit Manipulation,Trie"
1829,"Maximum Units on a Truck
You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]: You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize. Return the maximum total number of units that can be put on the truck.",Prioritize boxes with the least units first until the truck is full.,"Randomly select boxes until the truck is full, then calculate the total units.","Put one of each type of box on the truck, then fill the remaining space with the box type having the most boxes available.",Use dynamic programming to find the optimal combination of boxes.,Sort box types by units per box in descending order and greedily add boxes until the truck is full.,Easy,algorithms,"Array,Greedy,Sorting"
1830,"Count Good Meals
A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two. You can pick any two different foods to make a good meal. Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7. Note that items with different indices are considered different even if they have the same deliciousness value.",Use a nested loop to check every pair and count those summing to a power of two,Sort the array and use binary search to find complements that sum to a power of two for each element,Use a hash map to store the counts of each deliciousness value and iterate through powers of two to find complements,"Calculate the sum of all elements, divide by two, and check if the result is a power of two",Iterate through powers of two and use a hash map to count pairs that sum to each power of two,Medium,algorithms,"Array,Hash Table"
1831,"Ways to Split Array Into Three Subarrays
A split of an integer array is good if: Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.",Find all possible split points and check if they satisfy the condition.,Precompute prefix sums and use binary search to find valid split points for each possible first split.,Use a sliding window to find the optimal split points.,Recursively split the array and count the number of valid splits in each subproblem.,"Compute prefix sums, iterate through possible first split points, and use binary search to efficiently find the range of valid second split points.",Medium,algorithms,"Array,Two Pointers,Binary Search,Prefix Sum"
1832,"Minimum Operations to Make a Subsequence
You are given an array target that consists of distinct integers and another integer array arr that can have duplicates. In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array. Return the minimum number of operations needed to make target a subsequence of arr. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.",Sort both arrays and compare elements linearly to find the longest common subsequence,"Use dynamic programming to find the length of the longest common subsequence, and subtract it from the length of `arr`","Apply a greedy algorithm, selecting elements from `arr` that match `target` in order",Compute the edit distance between the two arrays and return the number of insertion operations,"Find the longest increasing subsequence of indices of `target` elements in `arr`, and subtract its length from the length of `target`",Hard,algorithms,"Array,Hash Table,Binary Search,Greedy"
1817,"Calculate Money in Leetcode Bank
Hercy wants to save money for his first car. He puts money in the Leetcode bank every day. He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.","O(n^2), where n is the number of days.","O(n log n), where n is the number of days.","O(1), constant time.","O(sqrt(n)), square root of n.","O(n), linear time with respect to the number of days.",Easy,algorithms,Math
1818,"Maximum Score From Removing Substrings
You are given a string s and two integers x and y. You can perform two types of operations any number of times. Return the maximum points you can gain after applying the above operations on s.","Greedily remove all occurrences of the substring with the larger point value first, then remove the other substring.",Use dynamic programming to store the maximum score achievable for all substrings of s.,Try all possible combinations of substring removals and choose the one with the highest score.,"Remove substrings randomly until no more can be removed, then calculate the score.",Use a stack to keep track of potential substrings and remove them to maximize the score based on x and y.,Medium,algorithms,"String,Stack,Greedy"
1819,"Construct the Lexicographically Largest Valid Sequence
Given an integer n, find a sequence with elements in the range [1, n] that satisfies all of the following: The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|. Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution. A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.",Use dynamic programming with memoization to store previously computed subsequences and build the sequence from the smallest to the largest element.,"Start with an empty sequence and greedily add the largest available number, backtracking when constraints are violated.",Generate all possible permutations of numbers from 1 to n and select the lexicographically largest valid sequence based on the distance criteria.,"Recursively construct the sequence by placing the largest possible number at each available position, ensuring the distance constraint is met for subsequent placements.","Iterate from n down to 1, placing the number at its first occurrence, and then at the position dictated by the distance requirement if available; otherwise, backtrack and try a smaller number.",Medium,algorithms,"Array,Backtracking"
1820,"Number Of Ways To Reconstruct A Tree
You are given an array pairs, where pairs[i] = [xi, yi], and: Let ways be the number of rooted trees that satisfy the following conditions: Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.","If the graph can be reconstructed into a unique tree, return 0.","If the graph can be reconstructed into multiple trees, return 0.","If the given 'pairs' do not form a valid tree structure, return 0.",Return 2 if and only if the set of all nodes has a single possible parent assignment based on the 'pairs'.,"Return 1 if the given 'pairs' can reconstruct a unique tree, 2 if multiple trees are possible, and 0 if reconstruction is impossible.",Hard,algorithms,"Tree,Graph,Topological Sort"
1839,"Decode XORed Array
There is a hidden integer array arr that consists of n non-negative integers. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3]. You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0]. Return the original array arr. It can be proved that the answer exists and is unique.","Initialize 'arr' with 'first', then calculate arr[i] = encoded[i-1] + arr[i-1] for i > 0.","Initialize 'arr' with 'first', then calculate arr[i] = encoded[i-1] AND arr[i-1] for i > 0.","Initialize 'arr' with 'first', then calculate arr[i] = ~encoded[i-1] XOR arr[i-1] for i > 0.","Initialize 'arr' with 'first', then calculate arr[i] = encoded[i-1] OR arr[i-1] for i > 0.","Initialize 'arr' with 'first', then calculate arr[i] = encoded[i-1] XOR arr[i-1] for i > 0.",Easy,algorithms,"Array,Bit Manipulation"
528,"Swapping Nodes in a Linked List
You are given the head of a linked list, and an integer k. Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).","Create a temporary array to store the list, swap elements in the array, and create a new linked list.","Find the kth node from the beginning and end, store their node references, and swap the node references.",Find the kth node from the beginning and end and only swap the 'next' pointers of their preceding nodes.,Traverse the list and delete and re-insert the nodes at the required positions.,"Find the kth node from the beginning and end, store their values, and swap the values.",Medium,data structures,"Linked List,Two Pointers"
1840,"Minimize Hamming Distance After Swap Operations
You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order. The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed). Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.","Use a greedy approach, swapping elements that immediately minimize the Hamming distance without considering connected components.",Sort both the `source` and `target` arrays and then calculate the Hamming distance.,Calculate the Hamming distance without performing any swap operations.,"For each allowed swap, perform the swap if and only if it decreases the immediate difference at those two indices.","Use Disjoint Set Union (DSU) to find connected components in `source` based on `allowedSwaps`. Within each component, match elements in `source` with elements in `target` to minimize differences.",Medium,algorithms,"Array,Depth-First Search,Union Find"
1825,"Find Minimum Time to Finish All Jobs
You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized. Return the minimum possible maximum working time of any assignment.",Binary search on the job times directly,Sort jobs in increasing order and assign to workers greedily,Use dynamic programming with a state representing the assignment of the first i jobs to j workers,Simulate all possible job assignments and choose the one with the minimal maximum working time,"Binary search on the possible maximum working time, and use a backtracking approach to check if a valid assignment exists for each time",Hard,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
1843,"Number Of Rectangles That Can Form The Largest Square
You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi. You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4. Let maxLen be the side length of the largest square you can obtain from any of the given rectangles. Return the number of rectangles that can make a square with a side length of maxLen.",Return the total number of rectangles.,Return the maximum of the lengths and widths of all rectangles.,Return the length of the shortest side among all rectangles.,Return the number of rectangles whose length equals its width.,Return the number of rectangles that can form a square with the largest possible side length.,Easy,algorithms,Array
1364,"Tuple with Same Product
Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.",Use a brute-force approach with four nested loops to check all possible combinations.,"Sort the array first, then use binary search to find pairs that multiply to the same product.",Calculate the product of all possible pairs in the array and store the count of each product in a hash map.,Use dynamic programming to store intermediate products and avoid redundant calculations.,"Iterate through all pairs (a, b), store their product in a hash map along with frequency, and calculate the result based on the frequencies of each product.",Medium,algorithms,"Array,Hash Table"
1845,"Largest Submatrix With Rearrangements
You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.",Sort each row independently and then calculate the maximum area.,Calculate the area of all possible submatrices and return the largest.,Transpose the matrix and then sort each row to find the maximum area.,Calculate the number of ones in each column and select the columns with the maximum number of ones.,"For each column, compute the consecutive ones upwards. Then, sort each row's heights and calculate the maximum area based on these sorted heights.",Medium,algorithms,"Array,Greedy,Sorting,Matrix"
1727,"Cat and Mouse II
A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food. Mouse and Cat play according to the following rules: The game can end in 4 ways: Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.",A* search,Breadth-first search,Depth-first search,Dijkstra's algorithm,Minimax with Alpha-Beta Pruning,Hard,algorithms,"Math,Dynamic Programming,Breadth-First Search,Graph,Memoization,Game Theory"
1877,"Find Followers Count
Table: Followers  Write a solution that will, for each user, return the number of followers. Return the result table ordered by user_id in ascending order. The result format is in the following example.","SELECT user_id, COUNT(follower_id) FROM Followers GROUP BY user_id ORDER BY follower_id;","SELECT follower_id, COUNT(user_id) FROM Followers ORDER BY user_id;","SELECT user_id, SUM(follower_id) FROM Followers GROUP BY user_id ORDER BY user_id;","SELECT DISTINCT user_id, COUNT(*) OVER () FROM Followers ORDER BY user_id;","SELECT user_id, COUNT(follower_id) AS followers_count FROM Followers GROUP BY user_id ORDER BY user_id;",Easy,database systems,Database
1882,"The Number of Employees Which Report to Each Employee
Table: Employees  For this problem, we will consider a manager an employee who has at least 1 other employee reporting to them. Write a solution to report the ids and the names of all managers, the number of employees who report directly to them, and the average age of the reports rounded to the nearest integer. Return the result table ordered by employee_id. The result format is in the following example.",Use a correlated subquery in the SELECT clause to count reports and calculate the average age.,Create a recursive CTE (Common Table Expression) to traverse the employee hierarchy and aggregate the data.,Use window functions partitioned by the manager's ID to calculate the count and average age.,"Join the Employees table with itself on the condition that an employee's manager_id matches another employee's id, then group by manager_id.","Perform a self-join of the Employees table on the manager_id, group by the manager's id and name, count the employees, and calculate the average age using AVG().",Easy,database systems,Database
1833,"Find the Highest Altitude
There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0. You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.","Calculate the prefix sum array, but only store positive values",Calculate the cumulative sum but only update the maximum altitude if the current gain is positive,Sort the gain array and sum all positive values; this will represent the highest altitude,Return the sum of all elements in the gain array as the highest altitude,Calculate the prefix sum array and keep track of the maximum value encountered,Easy,algorithms,"Array,Prefix Sum"
1834,"Minimum Number of People to Teach
On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language. You are given an integer n, an array languages, and an array friendships where: You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.",Perform a depth-first search on each language to find connected components and sum the smallest components.,Compute the intersection of language sets for each friendship and teach users a language that maximizes total intersection size.,"Teach all users language 0, unless there's a friendship that requires a different one; then teach those users that other language.",Prioritize teaching the language with the fewest speakers to minimize the total number of users taught.,"Iterate through all pairs of friends; if they don't share a language, find the language that, when taught to them, minimizes the number of people taught.",Medium,algorithms,"Array,Greedy"
1835,"Decode XORed Permutation
There is an integer array perm that is a permutation of the first n positive integers, where n is always odd. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1]. Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.",XOR all elements of the encoded array to find the first element of perm,Calculate the sum of the first n positive integers and XOR it with the XOR of all elements in the encoded array.,Create a prefix XOR array from the encoded array and compare it to the expected XOR sum,Take the XOR of elements at even indices in the encoded array.,"Calculate the XOR of the first n integers, then XOR that with the XOR of encoded[1], encoded[3], ... encoded[n-2] to find perm[0]. Use perm[0] and encoded to reconstruct perm.",Medium,algorithms,"Array,Bit Manipulation"
1836,"Count Ways to Make Array With Product
You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], find the number of different ways you can place positive integers into an array of size ni such that the product of the integers is ki. As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7. Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query.","Use dynamic programming to compute the number of ways to form the product k using n integers, considering all possible divisors.","Iterate through all possible combinations of n integers and check if their product equals k, optimizing by skipping invalid combinations early.",Apply the stars and bars theorem directly with n and k without considering prime factorization of k.,"Recursively divide k by integers from 1 to k, memoizing results to avoid redundant calculations.","Factorize k into prime factors and use the stars and bars theorem on the exponents of the prime factors, calculating combinations modulo 10^9 + 7.",Hard,algorithms,"Array,Math,Dynamic Programming"
1858,"Latest Time by Replacing Hidden Digits
You are given a string time in the form of  hh:mm, where some of the digits in the string are hidden (represented by ?). The valid times are those inclusively between 00:00 and 23:59. Return the latest valid time you can get from time by replacing the hidden digits.","Greedily fill the '?' from left to right, prioritizing larger digits.","Convert the time string to an integer, increment until a valid time is found, and then convert it back to a string.",Use regular expressions to find and replace the '?' characters sequentially.,Recursively explore all possible digit combinations for '?' and return the maximum valid time.,"Iterate through the time string, prioritizing the most significant digits, making locally optimal choices to maximize the time while ensuring validity.",Easy,algorithms,"String,Greedy"
1859,"Change Minimum Characters to Satisfy One of Three Conditions
You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter. Your goal is to satisfy one of the following three conditions: Return the minimum number of operations needed to achieve your goal.","Find the most frequent character in 'a' and change all other characters in 'a' to it, then repeat for 'b'",Change all characters in both strings to 'a',"Change all characters in 'a' to 'b' and vice versa, taking the minimum of operations",Calculate the edit distance between 'a' and 'b' using dynamic programming,"Iterate through all lowercase letters, calculating the cost to satisfy each of the three conditions and taking the minimum",Medium,algorithms,"Hash Table,String,Counting,Prefix Sum"
1860,"Find Kth Largest XOR Coordinate Value
You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k. The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all the coordinates of matrix.",Use dynamic programming to calculate XOR values from the bottom-right corner and use a min-heap of size k,"Calculate all XOR values and sort the resulting array in ascending order, then return the element at index k-1","Iterate through the matrix and store all the XOR values in a hash table, then sort the keys of the hash table to find the kth largest",Use a divide and conquer approach to split the matrix into submatrices and recursively find the kth largest XOR value,Calculate prefix XOR sums for each coordinate and use a min-heap of size k to track the k largest XOR values,Medium,algorithms,"Array,Divide and Conquer,Bit Manipulation,Heap (Priority Queue),Matrix,Prefix Sum,Quickselect"
1861,"Building Boxes
You have a cubic storeroom where the width, length, and height of the room are all equal to n units. You are asked to place n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes: Given an integer n, return the minimum possible number of boxes touching the floor.",n,n * n,n * (n + 1) / 2,n * (n + 1) * (2*n + 1) / 6,int(n**(2.0/3.0) * (n**(2.0/3.0) + 1) * (n**(2.0/3.0) + 2) / 6),Hard,algorithms,"Math,Binary Search,Greedy"
1892,"Find Total Time Spent by Each Employee
Table: Employees  Write a solution to calculate the total time in minutes spent by each employee on each day at the office. Note that within one day, an employee can enter and leave more than once. The time spent in the office for a single entry is out_time - in_time. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to calculate the time spent for each entry and then group by employee and day.,Create a temporary table to store the time spent for each entry and then join it with the Employees table.,Use window functions to partition the data by employee and day and then calculate the difference between the maximum and minimum time.,Employ a recursive CTE (Common Table Expression) to iterate through each entry and calculate the cumulative time spent.,"Group the entries by employee and day, and then calculate the sum of (out_time - in_time) for each group.",Easy,database systems,Database
1844,"Maximum Number of Balls in a Box
You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1. Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.",Track frequency with an array of size 'highLimit - lowLimit + 1',Calculate the sum of digits using string conversions and store in a hashmap,Recursively compute digit sums and maintain counts in a binary search tree,Use dynamic programming to store precomputed digit sums for optimization,"Iterate from lowLimit to highLimit, calculate the digit sum for each number, and use a hash map or array to count the frequency of each digit sum. Return the maximum frequency.",Easy,algorithms,"Hash Table,Math,Counting"
1866,"Restore the Array From Adjacent Pairs
There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums. You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums. It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order. Return the original array nums. If there are multiple solutions, return any of them.","Employ a greedy algorithm, always choosing the lexicographically smallest available element.","Construct a graph where nodes are numbers and edges represent adjacency. Perform a depth-first search starting from an arbitrary node, marking visited nodes to avoid cycles. Return the path.",Sort the `adjacentPairs` array based on the first element of each pair and then flatten the sorted array to obtain the original array.,Use a hash table to count occurrences of each number in `adjacentPairs`. Sort the numbers based on their counts (least to most frequent) and return the sorted array.,Build a graph (adjacency list) from `adjacentPairs`. Find a node with degree 1 (start/end). Perform a Depth-First Search (DFS) or Breadth-First Search (BFS) from that node to reconstruct the array.,Medium,algorithms,"Array,Hash Table"
1872,"Can You Eat Your Favorite Candy on Your Favorite Day?
You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]. You play a game with the following rules: Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return the constructed array answer.",The number of candies of the favorite type is less than the favorite day.,"The cumulative sum of candies up to the favorite type, divided by the daily cap, is less than the favorite day.",The number of candies of the favorite type is greater than the daily cap multiplied by the favorite day.,"The cumulative sum of candies up to the favorite type is less than the favorite day multiplied by the daily cap, and the favorite type's candy count is less than the product of the (favorite day + 1) and daily cap.","The cumulative sum of candies up to (but not including) the favorite type is less than or equal to the favorite day multiplied by the daily cap, and the favorite type's candy count is greater than the favorite day.",Medium,algorithms,"Array,Prefix Sum"
1871,"Palindrome Partitioning IV
Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.​​​​​ A string is said to be palindrome if it the same string when reversed.","Determine if any substring from index 0 to i is a palindrome, then check if the remaining substring from i+1 can be split into two palindromes.",Check all possible combinations of three substrings and return true if all three are palindromes. This will exceed time limit.,Use dynamic programming to find all palindromic substrings and then attempt to combine three of them to form the original string.,Iterate through the string checking only for single character palindromes to optimize space complexity.,"Use dynamic programming to precompute all palindromic substrings, then iterate through all possible split points to check if three palindromes can be formed.",Hard,algorithms,"String,Dynamic Programming"
1848,"Sum of Unique Elements
You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array. Return the sum of all the unique elements of nums.",Use a hash map to store the frequency of each element and sum elements with frequency greater than 1.,"Sort the array and iterate through it, skipping adjacent duplicates while summing others.",Convert the array to a set and calculate the sum of the set elements.,Return the sum of the array elements divided by the number of unique elements.,Use a hash map to store the frequency of each element and sum elements with frequency equal to 1.,Easy,algorithms,"Array,Hash Table,Counting"
1849,"Maximum Absolute Sum of Any Subarray
You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr). Return the maximum absolute sum of any (possibly empty) subarray of nums. Note that abs(x) is defined as follows:",Use a brute-force approach calculating the absolute sum of all possible subarrays and returning the maximum,Sort the array first and then calculate the absolute sum of the entire array,Calculate the cumulative sum of the array and return the absolute value of the last element,Find the minimum and maximum elements of the array and return the absolute difference between them,Use Kadane's algorithm to find the maximum and minimum subarray sums and return the maximum of their absolute values,Medium,algorithms,"Array,Dynamic Programming"
1850,"Minimum Length of String After Deleting Similar Ends
Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times: Return the minimum length of s after performing the above operation any number of times (possibly zero times).",Use a regular expression to repeatedly remove matching ends until no more matches are found.,"Convert the string to a list, use recursion to remove matching ends, and return the list's length.",Iterate through all possible substrings and find the shortest one that remains after valid deletions.,Sort the string and remove matching characters from the beginning and end until a different character is encountered.,"Use two pointers, one at the beginning and one at the end, and move them inwards while the characters they point to are equal.",Medium,algorithms,"Two Pointers,String"
1851,"Maximum Number of Events That Can Be Attended II
You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend. You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day. Return the maximum sum of values that you can receive by attending events.","Use a greedy approach, always selecting the event with the highest value first, until k events are chosen.","Sort the events by their end days and use dynamic programming to find the optimal combination, ignoring the k constraint.",Use a recursive approach with memoization to explore all possible combinations of events without considering the k limit.,"Sort events by start day, iterating through and choosing events that do not overlap based on their end days, until k is reached.","Sort events by end day and use dynamic programming to find the maximum value achievable by attending at most k events, considering non-overlapping events.",Hard,algorithms,"Array,Binary Search,Dynamic Programming"
1878,"Check if Array Is Sorted and Rotated
Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.",Check if the array is strictly increasing or strictly decreasing.,"Count the number of inversions in the array. If the count is greater than 1, return false.","Sort the array and compare it to the original array. If they are the same, return true.",Check if the array is sorted without rotation.,"Find the number of 'inflections' (where nums[i] > nums[i+1]). If it's 0 or 1, and if the last element is less than or equal to the first element, return true.",Easy,algorithms,Array
1879,"Maximum Score From Removing Stones
You are playing a solitaire game with three piles of stones of sizes a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves). Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the maximum score you can get.",Sort the pile sizes and repeatedly remove from the two largest piles until one has zero stones.,"Divide the sum of all stones by two, rounding down to the nearest integer.",Return the sum of the three integers representing the pile sizes.,Recursively compute all possible move sequences and choose the one with the highest score.,Return the sum of the two smallest pile sizes.,Medium,algorithms,"Math,Greedy,Heap (Priority Queue)"
1880,"Largest Merge Of Two Strings
You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options: Return the lexicographically largest merge you can construct. A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, ""abcd"" is lexicographically larger than ""abcc"" because the first position they differ is at the fourth character, and d is greater than c.",Always choose the character from word1 if word1[i] >= word2[j],Compare the entire remaining substrings of word1 and word2 and choose the larger one,"Choose characters from word1 and word2 randomly until one is empty, then append the rest of the other",Greedily choose the longer word until the lengths are equal,Compare substrings word1[i:] and word2[j:] lexicographically to decide which character to append,Medium,algorithms,"Two Pointers,String,Greedy"
1881,"Closest Subsequence Sum
You are given an integer array nums and an integer goal. You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal). Return the minimum possible value of abs(sum - goal). Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.","Calculate all possible subsequence sums using dynamic programming with memoization, resulting in O(n*goal) time complexity.",Sort the input array and use a two-pointer approach to find the closest sum in O(n log n) time.,"Use a greedy approach by always including the number closest to the goal, resulting in a potentially suboptimal solution.","Employ a branch-and-bound technique to prune the search space based on the current absolute difference, which may not guarantee optimality.","Generate all possible subsequence sums for the first and second halves of the array, then use a two-pointer approach to find the closest sum in O(2^(n/2)) time.",Hard,algorithms,"Array,Two Pointers,Dynamic Programming,Bit Manipulation,Bitmask"
1908,"Recyclable and Low Fat Products
Table: Products  Write a solution to find the ids of products that are both low fat and recyclable. Return the result table in any order. The result format is in the following example.",SELECT product_id FROM Products WHERE low_fats = 'N' OR recyclable = 'N';,SELECT product_id FROM Products WHERE low_fats = 'Y' AND recyclable = 'N';,SELECT * FROM Products WHERE low_fats = 'Y' AND recyclable = 'Y';,SELECT product_id FROM Products WHERE low_fats = 'N' AND recyclable = 'Y';,SELECT product_id FROM Products WHERE low_fats = 'Y' AND recyclable = 'Y';,Easy,database systems,Database
1884,"Minimum Changes To Make Alternating Binary String
You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa. The string is called alternating if no two adjacent characters are equal. For example, the string ""010"" is alternating, while the string ""0100"" is not. Return the minimum number of operations needed to make s alternating.",Calculate the number of changes needed to make the string start with '1' and return that number.,"Recursively process the string, flipping characters as needed until an alternating pattern is achieved.",Divide the string into substrings of length 2 and count the substrings that are not alternating.,Reverse the string and apply a greedy algorithm to minimize changes.,"Calculate the number of changes needed to make the string start with '0' and the number needed to make it start with '1', then return the minimum of the two.",Easy,algorithms,String
1885,"Count Number of Homogenous Substrings
Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7. A string is homogenous if all the characters of the string are the same. A substring is a contiguous sequence of characters within a string.",The length of the longest common subsequence in s,The number of distinct characters in s multiplied by the length of s,The square of the length of s,"The length of s divided by the number of distinct characters, rounded down","The sum of lengths of all homogenous substrings, modulo 10^9 + 7",Medium,algorithms,"Math,String"
1886,"Minimum Limit of Balls in a Bag
You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations. You can perform the following operation at most maxOperations times: Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations. Return the minimum possible penalty after performing the operations.","Binary search on the number of bags, checking if we can split the bags into at most maxOperations",Sort the array and greedily split the largest bag at each step until maxOperations is exhausted.,Divide the sum of all elements in nums by maxOperations + 1.,"Use dynamic programming, storing the minimum penalty achievable with i operations for the first j bags.","Binary search on the penalty value, checking if the number of operations needed to achieve that penalty is at most maxOperations.",Medium,algorithms,"Array,Binary Search"
1887,"Minimum Degree of a Connected Trio in a Graph
You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. A connected trio is a set of three nodes where there is an edge between every pair of them. The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not. Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.",Sum the degrees of all nodes and divide by 3.,"Iterate through all possible triplets and calculate the degree of each, returning the minimum.","Use a greedy approach, always selecting the node with the lowest degree to form a trio.",Calculate the average degree of all nodes and subtract 3.,"Iterate through all possible triplets, check if they form a connected trio, calculate their degree, and return the minimum degree found.",Hard,algorithms,Graph
1873,"Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, ""abABB"" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, ""abA"" is not because 'b' appears, but 'B' does not. Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.","Iterate through the string, checking each substring for niceness using sets, and track the longest nice substring found.","Use dynamic programming to store niceness of substrings in a table, optimizing for overlapping subproblems.","Recursively check substrings, dividing the string at each index and combining results.",Sort the string alphabetically and then find the longest substring where the character at index i is the lower case and at index i+1 is the upper case.,"Use a divide-and-conquer approach: If the string is not nice, split it into substrings at characters that violate the niceness condition and recursively search for nice substrings within these substrings.",Easy,algorithms,"Hash Table,String,Bit Manipulation,Sliding Window"
1874,"Form Array by Concatenating Subarrays of Another Array
You are given a 2D integer array groups of length n. You are also given an integer array nums. You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups). Return true if you can do this task, and false otherwise. Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.","The problem requires finding all possible combinations of subarrays from nums and checking if they match groups in order, leading to exponential time complexity.",The problem can be solved efficiently using dynamic programming to track the possible matching prefixes of groups in nums.,"A greedy approach works by iterating through groups and finding the first matching subarray in nums. If a match is not found or the order is violated, return false.",The problem is NP-complete because finding disjoint subarrays that match groups is equivalent to the subset sum problem.,"The problem can be solved efficiently by iterating through groups and nums, searching for each group[i] in nums starting from the index where the previous group[i-1] ended.",Medium,algorithms,"Array,Greedy,String Matching"
1876,"Map of Highest Peak
You are given an integer matrix isWater of size m x n that represents a map of land and water cells. You must assign each cell a height in a way that follows these rules: Find an assignment of heights such that the maximum height in the matrix is maximized. Return an integer matrix height of size m x n where height[i][j] is cell (i, j)'s height. If there are multiple solutions, return any of them.","Use Depth-First Search (DFS) starting from water cells, assigning heights based on the distance from water, potentially leading to suboptimal heights.","Apply a greedy algorithm, iterating through the matrix and assigning heights based on neighboring cells without considering the overall water distribution.",Calculate the shortest distance from each land cell to all water cells individually and assign the height based on the maximum of these distances.,"Assign random heights to all cells initially and then iteratively adjust them based on neighboring cell heights until a stable state is reached, which may not be optimal.","Perform a Breadth-First Search (BFS) starting from all water cells, assigning heights based on the layer reached from the water, ensuring the maximum height is maximized and connected to water.",Medium,algorithms,"Array,Breadth-First Search,Matrix"
1875,"Tree of Coprimes
There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. Each node has a value associated with it, and the root of the tree is node 0. To represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree. Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y. An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself. Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.","Perform a Breadth-First Search (BFS) from the root, storing the path to each node and checking coprimality for all ancestors in the path.",Precompute all possible GCD values and store them in a lookup table to speed up coprimality checks during the traversal.,Sort the tree's nodes based on their values in the 'nums' array and then perform a linear search for coprime ancestors.,"For each node, perform a Depth-First Search (DFS) only up to a limited depth (e.g., 10) to find a coprime ancestor. If none is found, return -1.","Perform a Depth-First Search (DFS). Maintain a stack to track the path from the root, storing node values and depths. For each node, search for the closest coprime ancestor in the stack.",Hard,algorithms,"Math,Tree,Depth-First Search,Breadth-First Search"
1894,"Merge Strings Alternately
You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.","Use `zip` to iterate through both strings simultaneously, appending characters from each in turn, then adding any remaining characters from the longer string.",Create a new string by concatenating `word1` and `word2` and then sorting the characters alphabetically.,"Use recursion to alternately append characters from `word1` and `word2`, handling the base case where either string is empty.",Append `word2` to `word1` and then insert each character from `word1` into `word2` at alternating positions.,"Iterate through both strings using two pointers, appending characters alternately to a new string, and then appending any remaining characters from either string.",Easy,algorithms,"Two Pointers,String"
1895,"Minimum Number of Operations to Move All Balls to Each Box
You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball. In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes. Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box. Each answer[i] is calculated considering the initial state of the boxes.","Precompute prefix and suffix sums of the ball counts, then combine them for each box.",Use dynamic programming to store the minimum operations for subranges of boxes.,Simulate moving all balls to each box individually and store the number of operations.,Calculate the total number of balls and divide it evenly among the boxes.,"Calculate the initial operations to move all balls to the first box, and then iteratively update the operations count for each subsequent box by considering the difference in distance.",Medium,algorithms,"Array,String"
1896,"Maximum Score from Performing Multiplication Operations
You are given two 0-indexed integer arrays nums and multipliers of size n and m respectively, where n >= m. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (0-indexed) you will: Return the maximum score after performing m operations.",Greedily choose the largest multiplier and multiply it with the larger endpoint of nums.,Use dynamic programming with a state representing the number of operations performed so far.,Sort both arrays and then multiply corresponding elements.,Recursively try all possible combinations of multipliers and nums endpoints.,Use dynamic programming with a state representing the number of operations and the left pointer in nums.,Hard,algorithms,"Array,Dynamic Programming"
1897,"Maximize Palindrome Length From Subsequences
You are given two strings, word1 and word2. You want to construct a string in the following manner: Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0. A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters. A palindrome is a string that reads the same forward as well as backward.","Concatenate word1 and word2, then find the longest palindromic substring using dynamic programming.",Find the longest palindromic subsequence in word1 and word2 separately and return the maximum of the two.,"Check if word1 or word2 are palindromes, if not return 0. Otherwise return length of longest word.","Find the longest common subsequence of word1 and the reverse of word2, and double its length.","Find the longest palindromic subsequence within the concatenation of word1 and word2, prioritizing characters from both input strings.",Hard,algorithms,"String,Dynamic Programming"
1899,"Count Items Matching a Rule
You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue. The ith item is said to match the rule if one of the following is true: Return the number of items that match the given rule.",Check if the `ruleKey` is 'name' and `items[i][0]` equals `ruleValue`.,Iterate through `items` and increment a counter if `ruleKey` is 'type' and `items[i][1]` matches `ruleValue`.,Use a dictionary to store rule keys and apply a filter based on the dictionary lookup.,Convert the `items` array to a string before applying the rule.,"Check if `ruleKey` is 'type', 'color', or 'name' and compare `ruleValue` with the corresponding element in `items[i]`.",Easy,algorithms,"Array,String"
1900,"Closest Dessert Cost
You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert: You are given three inputs: You want to make a dessert with a total cost as close to target as possible. Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.",Use dynamic programming to minimize the absolute difference between the dessert cost and the target.,"Sort the base costs and topping costs, then greedily select toppings until the target is reached or exceeded.","Calculate all possible dessert costs by considering all combinations of base costs and toppings, then find the closest to the target.",Apply a branch and bound approach to prune the search space and find the optimal dessert cost.,"Employ a recursive approach with backtracking to explore combinations of toppings, minimizing the absolute difference from the target cost.",Medium,algorithms,"Array,Dynamic Programming,Backtracking"
1901,"Equal Sum Arrays With Minimum Number of Operations
You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive. In one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive. Return the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. Return -1​​​​​ if it is not possible to make the sum of the two arrays equal.",Sort both arrays and greedily change elements from the array with the larger sum to 1 and elements from the smaller sum to 6.,Calculate the absolute difference between the sums and divide by 5 (the maximum possible change in one operation).,Use dynamic programming to find the minimum number of operations to reach each possible intermediate sum.,Iterate through all possible combinations of changes in both arrays and find the minimum number of operations that equalize the sums.,"Count the frequency of each number in both arrays. Greedily change numbers from the array with the larger sum to 1 and numbers from the array with the smaller sum to 6, prioritizing the largest possible changes.",Medium,algorithms,"Array,Hash Table,Greedy,Counting"
1902,"Car Fleet II
There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents: For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet. Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted.",Use binary search to find the next colliding car for each car.,Simulate the car movements step-by-step until all collisions are resolved.,"Iterate through the cars from left to right, only considering collisions with the immediate next car and updating speeds directly within the input array.",Calculate the time to collision for all pairs of cars and pick the smallest time for each car.,"Use a stack to maintain the indices of potentially colliding cars and calculate collision times efficiently, popping cars from the stack when they can't collide.",Hard,algorithms,"Array,Math,Stack,Heap (Priority Queue),Monotonic Stack"
1888,"Find Nearest Point That Has the Same X or Y Coordinate
You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location. Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1. The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).",Return the index of the point with the largest Manhattan distance.,"Return the index of the first point in the array, regardless of validity or distance.",Ignore the x and y coordinates and return the point with the smallest index.,Return the index of a randomly chosen valid point.,"Calculate Manhattan distances for valid points, track the minimum distance and corresponding index, and return the smallest index among those with the minimum distance. Return -1 if no valid points exist.",Easy,algorithms,Array
1889,"Check if Number is a Sum of Powers of Three
Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false. An integer y is a power of three if there exists an integer x such that y == 3x.","Repeatedly divide n by 3 and check if the remainder is ever 2. If so, return false.",Generate all powers of three up to n and check if any combination sums to n.,"Convert n to base 2. If the digits are all 1 or 0, return true, else return false.","Check if n is divisible by 3. If so, recursively call the function with n/3.","Repeatedly divide n by 3. If the remainder is 2, return false. Otherwise, update n to n/3 until n is 0 or 1.",Medium,algorithms,Math
1890,"Sum of Beauty of All Substrings
The beauty of a string is the difference in frequencies between the most frequent and least frequent characters. Given a string s, return the sum of beauty of all of its substrings.",Use dynamic programming to store beauty values for overlapping substrings,Precompute character frequencies for all possible substring lengths to optimize calculations,"Employ a divide-and-conquer approach, recursively calculating beauty for smaller substrings and merging results",Sort the characters in the string and calculate the beauty based on the sorted string's prefixes and suffixes,"Iterate through all substrings, calculate the character frequencies for each, and sum the differences between maximum and minimum frequencies",Medium,algorithms,"Hash Table,String,Counting"
1891,"Count Pairs Of Nodes
You are given an undirected graph defined by an integer n, the number of nodes, and a 2D integer array edges, the edges in the graph, where edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. You are also given an integer array queries. Let incident(a, b) be defined as the number of edges that are connected to either node a or b. The answer to the jth query is the number of pairs of nodes (a, b) that satisfy both of the following conditions: Return an array answers such that answers.length == queries.length and answers[j] is the answer of the jth query. Note that there can be multiple edges between the same two nodes.","Perform a Depth-First Search (DFS) or Breadth-First Search (BFS) for each query value, counting pairs that meet the condition.","Precompute all possible pairs' incident values and store them in a matrix, then iterate through the matrix for each query.","Sort the degrees of each node. Then, for each query, use binary search to find the range of pairs that could possibly satisfy the condition, then filter out invalid pairs.","Calculate the degree of each node. For each query, iterate through all possible pairs of nodes and count the pairs whose sum of degrees is greater than the query value.","Calculate the degree of each node. Sort the degrees. For each query, use two pointers to count pairs whose sum of degrees is greater than the query, accounting for overcounting due to shared edges.",Hard,algorithms,"Two Pointers,Binary Search,Graph"
1910,"Check if Binary String Has at Most One Segment of Ones
Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.",Iterate through the string and count the number of transitions from '0' to '1'. Return true if the count is less than or equal to 1.,Use regular expressions to check if the string matches the pattern `0*1+0*`.,Split the string by '0' and check if the length of the resulting array is greater than 2.,Convert the binary string to an integer and check if its binary representation contains at most one contiguous segment of ones.,"Find the first occurrence of '0', then check if there are any '1's after that.",Easy,algorithms,String
1911,"Minimum Elements to Add to Form a Given Sum
You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit. Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit. Note that abs(x) equals x if x >= 0, and -x otherwise.",Use dynamic programming to find the optimal combination of elements to add.,Sort the array and greedily add the limit value until the goal is reached.,"Calculate the difference between the current sum and the goal, then divide by the limit, always rounding up.",Calculate the mean of the array and add elements equal to the mean until the goal is achieved.,"Calculate the absolute difference between the current sum and the goal, then divide by the limit, rounding up to the nearest integer.",Medium,algorithms,"Array,Greedy"
1912,"Number of Restricted Paths From First to Last Node
There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [ui, vi, weighti] denotes that there is an edge between nodes ui and vi with weight equal to weighti. A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end and there is an edge between zi and zi+1 where 0 <= i <= k-1. The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x. A restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1. Return the number of restricted paths from node 1 to node n. Since that number may be too large, return it modulo 109 + 7.",Use Breadth-First Search (BFS) to explore all possible paths from node 1 to node n,"Apply Depth-First Search (DFS) with memoization, caching the number of restricted paths for each node","Utilize the Floyd-Warshall algorithm to precompute all-pairs shortest paths, then count restricted paths","Employ a greedy algorithm, always choosing the edge with the smallest weight to reach the next node","Compute shortest distances to node n using Dijkstra's algorithm, then use Dynamic Programming to count restricted paths",Medium,algorithms,"Dynamic Programming,Graph,Topological Sort,Heap (Priority Queue),Shortest Path"
1913,"Make the XOR of All Segments Equal to Zero
You are given an array nums​​​ and an integer k​​​​​. The XOR of a segment [left, right] where left <= right is the XOR of all the elements with indices between left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right]. Return the minimum number of elements to change in the array such that the XOR of all segments of size k​​​​​​ is equal to zero.",Use dynamic programming to find the optimal assignment of values for each index,"Apply a greedy algorithm, changing elements to minimize the local XOR difference",Brute-force all possible combinations of element changes and check XOR sums,Calculate the prefix XOR array and then iterate through all possible segments,"Find the most frequent value for each index modulo k, and change other elements to that value",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation"
1942,"Primary Department for Each Employee
Table: Employee  Employees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is 'N'. Write a solution to report all the employees with their primary department. For employees who belong to one department, report their only department. Return the result table in any order. The result format is in the following example.",Use a correlated subquery to find the employee's primary department based on the earliest entry.,Use a window function partitioned by employee ID to rank departments by entry date and select the top-ranked department.,Create a temporary table to store employee-department relationships and then use a self-join to find the primary department.,Use a GROUP BY clause with the HAVING COUNT(*) = 1 condition to find employees in only one department.,"Use a CASE statement to assign the primary department based on whether an employee is in more than one department, aggregating results using GROUP BY.",Easy,database systems,Database
1915,"Check if One String Swap Can Make Strings Equal
You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",Return `true` if the number of differing indices is exactly 1.,Return `true` if the strings are identical or have a Hamming distance of 2.,Return `true` if sorting both strings results in equal strings.,Return `true` if the number of differing indices is greater than 2.,"Return `true` if the strings are initially equal or if there are exactly two indices where the characters differ, and swapping the characters at those indices in either string makes them equal.",Easy,algorithms,"Hash Table,String,Counting"
1916,"Find Center of Star Graph
There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node. You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.",Return the node with the highest degree.,Calculate the average of all node labels in the edges array.,Return the node that appears first in the input array.,Find the node with the smallest label.,Return the common node from the first two edges in the edges array.,Easy,algorithms,Graph
1917,"Maximum Average Pass Ratio
There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes. The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes. Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.","Use a greedy approach, assigning each extra student to the class with the largest current pass ratio",Distribute the extra students evenly among all classes to maintain fairness,Calculate the standard deviation of pass ratios and assign students to classes farthest from the mean,Prioritize classes with the smallest total number of students to maximize individual pass ratio increases,Use a max heap to prioritize classes based on the potential increase in average pass ratio for each additional student,Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
1918,"Maximum Score of a Good Subarray
You are given an array of integers nums (0-indexed) and an integer k. The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j. Return the maximum possible score of a good subarray.",Divide the array into two halves and recursively find the maximum score in each half.,"Iterate through all possible subarrays and calculate the score for each, keeping track of the maximum.",Sort the array and then consider subarrays centered around the element at index k.,Use dynamic programming to store the minimum value for subarrays ending at each index.,"Use two pointers, expanding outwards from index k, maintaining the minimum value encountered, and calculating the score at each step.",Hard,algorithms,"Array,Two Pointers,Binary Search,Stack,Monotonic Stack"
1948,"Rearrange Products Table
Table: Products  Write a solution to rearrange the Products table so that each row has (product_id, store, price). If a product is not available in a store, do not include a row with that product_id and store combination in the result table. Return the result table in any order. The result format is in the following example.",Use GROUP BY and aggregate all stores and prices into a JSON array.,Pivot the table using conditional aggregation (CASE statements) to create columns for each store.,Create a cross join of product_id with a table of stores and then filter based on price availability.,Use window functions to rank products within each store and then select the top-ranked product.,Use UNPIVOT or multiple UNION ALL statements to transform the store columns into rows.,Easy,database systems,Database
1904,"Second Largest Digit in a String
Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist. An alphanumeric string is a string consisting of lowercase English letters and digits.",Return the length of the string if the number of distinct digits is less than 2,"Sort the string and return the digit at index 1 if it exists, otherwise return -1",Use a hash map to count the occurrences of each digit and return the most frequent digit,Return the largest digit minus 1,"Use a set to store unique digits, remove the largest, and return the new largest, or -1 if the set has fewer than two elements",Easy,algorithms,"Hash Table,String"
1905,"Design Authentication Manager
There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime. Implement the AuthenticationManager class: Note that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.",Use a single hash table to store tokens and their creation timestamps; iterate through the entire table for each unexpired token count.,Employ a sorted list to keep tokens and their expiry times. Binary search for expired tokens for deletion; linear search for unexpired count.,Implement two separate hash tables: one for active tokens and another for expired tokens. Move tokens between tables based on time.,Store tokens and expiry times in a relational database with appropriate indexes. Use SQL queries for token operations and counting.,Maintain a hash table of tokens with expiry times; lazily remove expired tokens during renew and count operations based on the current time.,Medium,system design,"Hash Table,Design"
1930,"Maximum Number of Consecutive Values You Can Make
You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x. Return the maximum number of consecutive integer values that you can make with your coins starting from and including 0. Note that you may have multiple coins of the same value.",Sort the coins array in descending order and greedily select coins until the target value is reached or exceeded.,"Use dynamic programming to build a table of possible sums, then iterate through the table to find the maximum consecutive range.","Calculate the sum of all coins, and return that sum plus 1, assuming all values in between can be formed.",Find the smallest coin and multiply it by the number of coins.,"Sort the coins in ascending order and iteratively update the maximum reachable value, adding the next coin's value if it's within reach.",Medium,algorithms,"Array,Greedy"
1906,"Maximize Score After N Operations
You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array. In the ith operation (1-indexed), you will: Return the maximum score you can receive after performing n operations. The function gcd(x, y) is the greatest common divisor of x and y.","Use a greedy approach, always selecting the pair with the largest sum",Sort the array and then pair the largest and smallest elements in each operation,Calculate all possible pairings and store the maximum score in a hash map,Recursively explore all possible combinations of pairs without memoization,Use dynamic programming with bitmasking to memoize the maximum score for each subset of numbers chosen,Hard,algorithms,"Array,Math,Dynamic Programming,Backtracking,Bit Manipulation,Number Theory,Bitmask"
1927,"Maximum Ascending Subarray Sum
Given an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array.",Using Dijkstra's algorithm to find the shortest path,Applying Kadane's algorithm to find the maximum sum of any subarray,Sorting the array and summing elements sequentially,Calculating the sum of all possible subarrays and choosing the maximum,"Iterating through the array, tracking the current ascending subarray sum, and updating the maximum sum encountered",Easy,algorithms,Array
1928,"Number of Orders in the Backlog
You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. The orderTypei is: Note that orders[i] represents a batch of amounti independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i. There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens: Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.","Process each order by immediately executing it if a matching order of the opposite type exists, prioritizing orders with the best price, and adding any remaining amount to the backlog.","Sort the orders array by price, then process each order, executing matching orders and adding remainders to the backlog without considering order types.","Calculate the total number of buy orders and sell orders separately, and the backlog consists of the difference of buy and sell orders.","Maintain separate backlogs for buy and sell orders using priority queues, and process each incoming order by matching it against the opposite backlog's best price, updating the backlog accordingly.","Use two priority queues (min-heap for sell orders, max-heap for buy orders) to maintain the backlogs, process each order by matching it against the best price in the opposite queue, and return the sum of the remaining orders in both queues modulo 10^9 + 7.",Medium,algorithms,"Array,Heap (Priority Queue),Simulation"
1929,"Maximum Value at a Given Index in a Bounded Array
You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions: Return nums[index] of the constructed array. Note that abs(x) equals x if x >= 0, and -x otherwise.",Binary search the entire possible range for `nums[index]` linearly.,"Use dynamic programming to compute the optimal array, memoizing intermediate results.",Initialize the array with a uniform distribution and iteratively adjust elements around `index`.,Apply a greedy algorithm by always assigning the maximum possible value to `nums[index]` initially.,Use binary search on the possible values of `nums[index]` and check if the resulting array's sum is within `maxSum`.,Medium,algorithms,"Binary Search,Greedy"
1907,"Count Pairs With XOR in a Range
Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs. A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.","Use a nested loop to check XOR values for all pairs, resulting in O(n^2) time complexity.","Sort the array first, then use binary search to find the range of XOR values for each element.",Use dynamic programming to store XOR values of prefixes and suffixes of the array.,Calculate the XOR of all elements and check if it falls within the range.,Use a Trie data structure to efficiently count the number of elements within the XOR range for each element.,Hard,algorithms,"Array,Bit Manipulation,Trie"
1933,"Number of Different Integers in a String
You are given a string word that consists of digits and lowercase English letters. You will replace every non-digit character with a space. For example, ""a123bc34d8ef34"" will become "" 123  34 8  34"". Notice that you are left with some integers that are separated by at least one space: ""123"", ""34"", ""8"", and ""34"". Return the number of different integers after performing the replacement operations on word. Two integers are considered different if their decimal representations without any leading zeros are different.","Split the string by non-digit characters, then convert each resulting substring to an integer and count distinct values, ignoring leading zeros.",Replace all non-digit characters with empty strings and convert the string to an integer; count distinct characters.,"Iterate through the string and, for each digit, compute the integer value using ASCII values directly; then count the distinct digits.","Use regular expressions to extract all sequences of digits, sort them lexicographically, and count the unique strings.","Replace non-digits with spaces, split into substrings, convert to integers removing leading zeros, and count distinct values.",Easy,algorithms,"Hash Table,String"
1935,"Minimum Number of Operations to Reinitialize a Permutation
You are given an even integer n​​​​​​. You initially have a permutation perm of size n​​ where perm[i] == i​ (0-indexed)​​​​. In one operation, you will create a new array arr, and for each i: You will then assign arr​​​​ to perm. Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.",O(n log n),O(n!),O(n^2),O(log n),O(n),Medium,algorithms,"Array,Math,Simulation"
1934,"Evaluate the Bracket Pairs of a String
You are given a string s that contains some bracket pairs, with each pair containing a non-empty key. You know the values of a wide range of keys. This is represented by a 2D string array knowledge where each knowledge[i] = [keyi, valuei] indicates that key keyi has a value of valuei. You are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key keyi, you will: Each key will appear at most once in your knowledge. There will not be any nested brackets in s. Return the resulting string after evaluating all of the bracket pairs.",Use regular expressions to match bracket pairs and replace them directly using the knowledge base.,"Parse the string character by character, maintaining a stack to track bracket depth, and perform substitutions using the knowledge base.","Convert the string to a list of tokens, then iterate through the tokens, substituting bracketed tokens that are present in knowledge, else defaulting to an empty string.",Sort the 'knowledge' array alphabetically and then use binary search to locate keys in the bracket pairs for substitution.,"Iterate through the string, identify bracket pairs, look up the key in 'knowledge', and substitute with the value or ""?"" if not found.",Medium,algorithms,"Array,Hash Table,String"
1936,"Maximize Number of Nice Divisors
You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions: Return the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7. Note that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.","Decompose primeFactors into factors of 2 and 3, then calculate 2^x * 3^y modulo 10^9 + 7",Return primeFactors directly modulo 10^9 + 7,Calculate primeFactors! (factorial) modulo 10^9 + 7,Return primeFactors * 2 modulo 10^9 + 7,"Maximize the number of factors of 3 (or 2 if primeFactors < 3), and use modular exponentiation for efficiency.",Hard,algorithms,"Math,Recursion"
1920,"Determine Color of a Chessboard Square
You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.  Return true if the square is white, and false if the square is black. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.",Check if the sum of the ASCII values of the column and row is even.,Convert the coordinate string to a complex number and check its imaginary part.,Use a lookup table containing the color of all 64 squares.,"Return true if the row is even, regardless of the column.",Check if the column (letter) and row (number) are both even or both odd.,Easy,algorithms,"Math,String"
1923,"Sentence Similarity III
You are given two strings sentence1 and sentence2, each representing a sentence composed of words. A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of only uppercase and lowercase English characters. Two sentences s1 and s2 are considered similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. Note that the inserted sentence must be separated from existing words by spaces. For example, Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.","Split both strings into arrays of words, then check if one array is a substring of the other.",Compare the lengths of the sentences; the shorter sentence must be a prefix of the longer sentence for similarity.,Concatenate the sentences in both orders (sentence1 + sentence2 and sentence2 + sentence1) and check if either concatenation contains the other as a substring.,Calculate the Levenshtein distance between the two sentences and compare it to a threshold.,Compare the prefixes and suffixes of the two sentences to identify common words and potential insertion points.,Medium,algorithms,"Array,Two Pointers,String"
1925,"Count Nice Pairs in an Array
You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions: Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.",Store the frequency of nums[i] - rev(nums[i]) in a hash map and sum the frequencies,Sort the array and count pairs where nums[i] + rev(nums[i]) == nums[j] + rev(nums[j]),"Use nested loops to check every pair (i, j) if nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])",Find the minimum element in the array and subtract it from all elements before processing,"Calculate nums[i] - rev(nums[i]) for each element, count occurrences of each difference, and apply the formula n*(n-1)/2 to each count (modulo 10^9 + 7)",Medium,algorithms,"Array,Hash Table,Math,Counting"
1924,"Maximum Number of Groups Getting Fresh Donuts
There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. Each customer will get exactly one donut. When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group. You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.",Sort the groups array and then use dynamic programming to find the optimal arrangement.,"Use a greedy approach, prioritizing groups with sizes closest to batchSize.",Try all possible permutations of the groups array and count the happy groups for each permutation.,Recursively divide the groups array into smaller subproblems and solve each subproblem optimally.,Use dynamic programming to track the maximum number of happy groups for each possible remainder modulo batchSize.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Memoization,Bitmask"
1944,"Truncate Sentence
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation). You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.",Use `s.split()` with no arguments to return the original string,"Use `s.rsplit(' ', k)` to split from the right side.",Use `s.partition(' ')[0]` to get the first word,Use regular expressions to capture the first k words.,Use `s.split(' ')[:k]` to split into words and take the first k.,Easy,algorithms,"Array,String"
1945,"Finding the Users Active Minutes
You are given the logs for users' actions on LeetCode, and an integer k. The logs are represented by a 2D integer array logs where each logs[i] = [IDi, timei] indicates that the user with IDi performed an action at the minute timei. Multiple users can perform actions simultaneously, and a single user can perform multiple actions in the same minute. The user active minutes (UAM) for a given user is defined as the number of unique minutes in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it. You are to calculate a 1-indexed array answer of size k such that, for each j (1 <= j <= k), answer[j] is the number of users whose UAM equals j. Return the array answer as described above.","Use a hash table to store the logs and then iterate through the hash table to calculate UAM for each user, storing results in an array of size k","Sort the logs based on time, then iterate through them to find UAM for each user, using binary search to count active minutes","Iterate through the logs, and for each user, calculate the total number of actions performed, then divide by the integer k to find UAM","Create a matrix to store the logs, transpose the matrix, and use dynamic programming to calculate the UAM for each user","Use a hash map to store each user's active minutes in a set, then count the number of users with each UAM value from 1 to k",Medium,algorithms,"Array,Hash Table"
1946,"Minimum Absolute Sum Difference
You are given two positive integer arrays nums1 and nums2, both of length n. The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed). You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference. Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7. |x| is defined as:",Always replace the element in `nums1` that yields the largest absolute difference with the smallest element in `nums1`.,"Calculate the initial absolute sum difference and then iterate through `nums1`, replacing each element with every other element in `nums1` to find the minimum difference.","Sort `nums1` and for each element, find the closest element in the sorted `nums1` to the corresponding element in `nums2` using binary search, and update the absolute sum difference if it improves.",Replace each element in `nums1` with the corresponding element in `nums2` and calculate the absolute sum difference.,"Sort `nums1`. For each element, calculate the absolute difference. Use binary search in sorted `nums1` to find a number closest to the corresponding number in `nums2`. Update the minimum absolute sum difference.",Medium,algorithms,"Array,Binary Search,Sorting,Ordered Set"
1947,"Number of Different Subsequences GCDs
You are given an array nums that consists of positive integers. The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array. Return the number of different GCDs among all non-empty subsequences of nums.",Calculate the GCD of all possible subsequences and store them in a set,"For each number in nums, check if it's a divisor of all other numbers, and count unique such numbers","Sort nums and iterate from the largest to smallest element, checking if each element is a GCD of a subsequence",Calculate the GCD of the entire array and return it as the count,"Iterate through potential GCDs from 1 to the maximum value in nums; for each, check if a subsequence exists with that GCD",Hard,algorithms,"Array,Math,Counting,Number Theory"
1950,"Sign of the Product of an Array
Implement a function signFunc(x) that returns: You are given an integer array nums. Let product be the product of all values in the array nums. Return signFunc(product).",Divide the product by the absolute value of the product,Use bitwise XOR operations on all numbers in the array,"Return 1 if the sum of the numbers is positive, -1 if negative, and 0 otherwise","Count the number of positive numbers and return 1 if count is even, -1 otherwise","Count the number of negative numbers. If even, return 1; if odd, return -1; if any zero, return 0",Easy,algorithms,"Array,Math"
1951,"Find the Winner of the Circular Game
There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend. The rules of the game are as follows: Given the number of friends, n, and an integer k, return the winner of the game.",Use dynamic programming to precompute all possible game states and their winners.,Simulate the game using a bitset to track eliminated players and their indices.,Model the game as a graph and find the node with the highest degree after k-1 eliminations.,Recursively eliminate every k-th player until only one remains.,Apply the Josephus Problem formula after mapping the circle to a linear sequence.,Medium,algorithms,"Array,Math,Recursion,Queue,Simulation"
1952,"Minimum Sideway Jumps
There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way. You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point. The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane. Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0. Note: There will be no obstacles on points 0 and n.",Use dynamic programming with a 2D array to store the minimum jumps needed to reach each lane at each point.,"Apply Dijkstra's algorithm to the grid represented by the lanes and obstacles, treating each jump as an edge.","Employ a greedy approach, always choosing the lane with the fewest obstacles ahead.","Perform a breadth-first search (BFS) from the starting point, exploring all possible paths until reaching the end.","Use dynamic programming, where dp[i][j] stores the minimum jumps to reach point i on lane j, considering side jumps.",Medium,algorithms,"Array,Dynamic Programming,Greedy"
1953,"Finding MK Average
You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream. The MKAverage can be calculated using these steps: Implement the MKAverage class:",Use a priority queue of size m and update the average after every k elements.,Store the stream in an array and recalculate the average for every new element.,"Maintain a running sum and count, updating only when the stream size is a multiple of m and k.",Store only the last m elements and calculate the average whenever k elements have passed.,Use a sorted multiset (or similar data structure) to maintain the last 'm' elements and efficiently track the k smallest and k largest elements.,Hard,data structures,"Design,Queue,Heap (Priority Queue),Ordered Set"
1938,"Minimum Operations to Make the Array Increasing
You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1. Return the minimum number of operations needed to make nums strictly increasing. An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.",Perform pairwise comparisons and swap adjacent elements until sorted.,Sort the array first and then calculate the differences between adjacent elements.,Use dynamic programming to determine the minimum operations for increasing subsequences.,Iterate through the array and decrement elements when necessary to achieve strictly increasing order.,Iterate through the array and increment elements as needed to ensure nums[i] < nums[i+1],Easy,algorithms,"Array,Greedy"
1939,"Queries on Number of Points Inside a Circle
You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates. You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj. For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside. Return an array answer, where answer[j] is the answer to the jth query.","For each query, use a quadtree to efficiently search for points within the radius, improving performance for large datasets.",Precompute the distances between all points and all circle centers and store them in a matrix for fast lookup.,"Employ a spatial indexing technique like R-trees to group points spatially, speeding up the search within each circle's radius.","Use parallel processing by assigning each query to a separate thread, calculating point counts independently.","For each query, iterate through all points and check if the Euclidean distance between the point and the circle's center is less than or equal to the radius.",Medium,algorithms,"Array,Math,Geometry"
1940,"Maximum XOR for Each Query
You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times: Return an array answer, where answer[i] is the answer to the ith query.",Iteratively right-shift `nums[i]` and perform XOR until `maximumBit` reaches zero.,"Calculate XOR of all elements in `nums` using bitwise operators, then find the complement to `(2 ^ maximumBit) - 1`.","Sort the `nums` array in descending order before calculating the XOR sum, then find the complement.",Employ dynamic programming to determine the minimum XOR sum achievable using subsets of `nums`.,"Compute the XOR sum of all elements in `nums`, then find a value 'k' such that XOR sum ^ k = (2 ^ maximumBit) - 1.",Medium,algorithms,"Array,Bit Manipulation,Prefix Sum"
1941,"Minimum Number of Operations to Make String Sorted
You are given a string s (0-indexed)​​​​​​. You are asked to perform the following operation on s​​​​​​ until you get a sorted string: Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7.",Calculate the number of inversions using merge sort and return that value modulo 10^9 + 7.,"Generate all permutations of the string, sort them, and find the index of the original string. Return that index modulo 10^9 + 7.","Use dynamic programming to store the number of operations needed for substrings and build up to the whole string, returning the final result modulo 10^9 + 7.","Iterate through the string, swapping adjacent characters to incrementally sort it, and count the number of swaps, returning that count modulo 10^9 + 7.","Calculate the number of operations using factorials and modular arithmetic to account for repeated characters, returning the result modulo 10^9 + 7.",Hard,algorithms,"Math,String,Combinatorics"
1960,"Check if the Sentence Is Pangram
A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.",The time complexity is O(n log n) due to the sorting step.,The time complexity is O(1) because it only iterates once.,The time complexity is O(26) as it checks for all alphabet characters.,The time complexity is O(n^2) because of nested loops.,"The time complexity is O(n), where n is the length of the sentence.",Easy,algorithms,"Hash Table,String"
1961,"Maximum Ice Cream Bars
It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Note: The boy can buy the ice cream bars in any order. Return the maximum number of ice cream bars the boy can buy with coins coins. You must solve the problem by counting sort.",Apply bucket sort to group ice cream costs and iterate to maximize purchases,Sort the costs array and use binary search to find the maximum number of affordable bars,"Recursively divide the costs array, purchasing the cheapest half in each step","Calculate the average cost and buy as many bars as the average allows, adjusting for overspending","Use counting sort to count the frequency of each cost, then iterate to buy the maximum affordable bars",Medium,algorithms,"Array,Greedy,Sorting"
1962,"Single-Threaded CPU
You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing. You have a single-threaded CPU that can process at most one task at a time and will act in the following way: Return the order in which the CPU will process the tasks.",A LIFO queue that prioritizes tasks based on the shortest enqueue time,A standard FIFO queue with tasks inserted sequentially regardless of enqueue or processing time,A stack where tasks are pushed based on enqueue time and popped based on processing time,A binary search tree where nodes represent tasks and are ordered by enqueue time,"A priority queue (min-heap) that prioritizes tasks with shorter processing times, then by index for ties, among available tasks",Medium,algorithms,"Array,Sorting,Heap (Priority Queue)"
1963,"Find XOR Sum of All Pairs Bitwise AND
The XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element. You are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers. Consider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length. Return the XOR sum of the aforementioned list.","Compute the bitwise AND of all elements in arr1 and arr2 separately, then XOR the results.","Calculate the Cartesian product of arr1 and arr2, perform bitwise AND on each pair, and then XOR all the results.","Find the XOR sum of arr1 and arr2 individually, then perform a bitwise AND on the two XOR sums.","Calculate the sum of all elements in arr1 and arr2, perform bitwise AND of the sums, then calculate XOR with both array lengths.",Calculate the XOR sum of arr1 and the XOR sum of arr2. Return the bitwise AND of the two XOR sums.,Hard,algorithms,"Array,Math,Bit Manipulation"
1965,"Sum of Digits in Base K
Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k. After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.","Divide n repeatedly by k, summing the quotients","Multiply n by k until n is less than k, summing the intermediate products",Calculate k to the power of each digit of n and sum the results,"Convert n to a string, replace each digit with its equivalent in base k, then sum","Divide n repeatedly by k, summing the remainders",Easy,algorithms,Math
1966,"Frequency of the Most Frequent Element
The frequency of an element is the number of times it occurs in an array. You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1. Return the maximum possible frequency of an element after performing at most k operations.","O(n^2), where n is the length of nums, due to nested loops for frequency calculation and operation simulation.","O(n log n), dominated by the sorting of nums, with linear time for window adjustment.","O(k), where k is the maximum number of operations, as the algorithm iterates through potential increment operations.","O(n * k), where n is the length of nums and k is the maximum number of operations, due to potentially incrementing each element up to k times.","O(n log n), dominated by sorting the input array. The subsequent sliding window approach is linear.",Medium,algorithms,"Array,Binary Search,Greedy,Sliding Window,Sorting,Prefix Sum"
1967,"Longest Substring Of All Vowels in Order
A string is considered beautiful if it satisfies the following conditions: For example, strings ""aeiou"" and ""aaaaaaeiiiioou"" are considered beautiful, but ""uaeio"", ""aeoiu"", and ""aaaeeeooo"" are not beautiful. Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0. A substring is a contiguous sequence of characters in a string.","Use dynamic programming to store lengths of vowel subsequences, optimizing for space complexity.","Employ a greedy approach, expanding the substring until a vowel is out of order, then restarting.",Utilize regular expressions to identify all vowel substrings and then filter for beautiful ones.,Sort the input string and find the longest substring of unique vowels in the sorted order.,"Use a two-pointer approach to track the current vowel sequence and its length, updating the maximum length when a beautiful substring is found.",Medium,algorithms,"String,Sliding Window"
1968,"Maximum Building Height
You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n. However, there are city restrictions on the heights of the new buildings: Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array restrictions where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti. It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions. Return the maximum possible height of the tallest building.","Sort the restrictions array and greedily assign heights, increasing from left to right, then right to left, satisfying the restrictions.","Use dynamic programming to calculate the maximum height at each building, considering all possible subproblems.","Apply a binary search algorithm to find the optimal height for each building, ensuring the restrictions are met.",Simulate the building process by randomly assigning heights and adjusting them iteratively until all restrictions are satisfied.,"Sort the restrictions array, then iterate through them, adjusting heights to create a 'mountain range' profile and finding the maximum height.",Hard,algorithms,"Array,Math"
1954,"Replace All Digits with Characters
You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices. You must perform an operation shift(c, x), where c is a character and x is a digit, that returns the xth character after c. For every odd index i, you want to replace the digit s[i] with the result of the shift(s[i-1], s[i]) operation. Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'. Note that shift(c, x) is not a preloaded function, but an operation to be implemented as part of the solution.",String concatenation using the `+` operator is always the most efficient method.,"Convert the string to a character array, modify it in place, and then convert it back to a string.",Use regular expressions to identify and replace the digits.,"Create a copy of the string, modify the copy, and return the copy. This avoids in-place modifications.","Iterate through the string, replacing digits at odd indices with the shifted characters based on the previous character's value.",Easy,algorithms,String
1955,"Seat Reservation Manager
Design a system that manages the reservation state of n seats that are numbered from 1 to n. Implement the SeatManager class:","Use a binary search tree to track available seats, inserting reserved seats and searching for the smallest available seat.","Employ a bit vector to represent seat availability, using bit manipulation for reservation and unreservation.","Utilize a hash map to store the reservation status of each seat, checking for collisions during reservation.",Implement a priority queue that always holds the indices of available seats and returns the smallest available seat efficiently.,"Maintain a sorted set of available seats, using its efficient methods to find the smallest available seat and remove it upon reservation.",Medium,system design,"Design,Heap (Priority Queue)"
1956,"Maximum Element After Decreasing and Rearranging
You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions: There are 2 types of operations that you can perform any number of times: Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.","Sort the array and return arr[0] + n - 1, where n is the array length.",Return the sum of all elements in the array divided by the array length.,Find the minimum element in the array and return that value.,"Return the length of the array if the array is sorted, otherwise return 1.","Sort the array. Set arr[0] to 1. Iterate from i=1:n, setting arr[i] = min(arr[i-1] + 1, arr[i]). Return arr[n-1].",Medium,algorithms,"Array,Greedy,Sorting"
1957,"Closest Room
There is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique. You are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that: If there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1. Return an array answer of length k where answer[j] contains the answer to the jth query.",Sort the rooms by room ID and use binary search to find the closest room meeting the minimum size requirement.,"Iterate through all rooms for each query, calculating the difference between the preferred room and the room ID, selecting the minimum.","Use a hash map to store room sizes and iterate queries, checking for existence with minimal size.","Sort the queries by minimum size, and rooms by room ID, then apply a two-pointer approach to find closest rooms.","Sort the rooms by size, process queries offline after sorting them by minSize. Use a TreeSet to maintain available rooms and find the closest room.",Hard,algorithms,"Array,Binary Search,Sorting"
1975,"Minimum Distance to the Target Element
Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x. Return abs(i - start). It is guaranteed that target exists in nums.",Return the index of the first element equal to the target,Return the absolute difference between the first and last occurrence of the target,Sort the array and return the absolute difference between the index of the target and start,Return the average of the indices where the target is found,Iterate through the array and keep track of the minimum absolute difference between each index where the target is found and the start index,Easy,algorithms,Array
1976,"Splitting a String Into Descending Consecutive Values
You are given a string s that consists of only digits. Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and the difference between numerical values of every two adjacent substrings is equal to 1. Return true if it is possible to split s​​​​​​ as described above, or false otherwise. A substring is a contiguous sequence of characters in a string.","Use dynamic programming to build a table of possible splits, optimizing for space by only storing the last row.","Convert the string to an integer, and then iteratively subtract 1, checking if the remaining value is a prefix of the original string.",Sort the digits of the string and check if a descending sequence exists.,Employ a greedy algorithm that always chooses the longest possible substring that satisfies the descending condition.,"Use backtracking to explore all possible splits of the string, pruning branches that violate the descending or difference-of-one constraints.",Medium,algorithms,"String,Backtracking"
1978,"Minimum Adjacent Swaps to Reach the Kth Smallest Number
You are given a string num, representing a large integer, and an integer k. We call some integer wonderful if it is a permutation of the digits in num and is greater in value than num. There can be many wonderful integers. However, we only care about the smallest-valued ones. Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer. The tests are generated in such a way that kth smallest wonderful integer exists.","Sort the given number and generate all permutations until the kth smallest is found, counting swaps for each.","Calculate all wonderful integers and select the kth smallest, then count the adjacent swaps to obtain it from the original number.",Use dynamic programming to minimize swaps between all permutations of the number.,Apply a bubble sort algorithm to the number until it reaches the kth lexicographical permutation.,"Find the kth permutation in lexicographical order, greater than the initial number, and count swaps to reach it using a greedy approach.",Medium,algorithms,"Two Pointers,String,Greedy"
1977,"Minimum Interval to Include Each Query
You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries.",Use a binary search tree to store intervals and efficiently search for overlapping intervals,Sort the queries and intervals independently and iterate using two pointers,Precompute all possible interval sizes and use a hash map for quick lookups,Use dynamic programming to store results for subranges of queries,"Sort intervals by size, process queries offline, and use a min-heap to track relevant intervals",Hard,algorithms,"Array,Binary Search,Line Sweep,Sorting,Heap (Priority Queue)"
1983,"Maximum Population Year
You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person. The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die. Return the earliest year with the maximum population.",Use a hash map to store the population for each year and return the year with the largest value.,"Sort the logs array by birth year and then iterate through the array, incrementing a counter for each year a person is alive.","Create a prefix sum array where each index represents a year and the value represents the cumulative population up to that year. Then, find the index with the maximum value.",Apply binary search on the sorted logs array to find the year with the maximum overlap of lifespans.,Use the difference array technique to efficiently track population changes over the years and find the year with the maximum population.,Easy,algorithms,"Array,Counting"
1984,"Maximum Distance Between a Pair of Values
You are given two non-increasing 0-indexed integer arrays nums1​​​​​​ and nums2​​​​​​. A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i​​​​. Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0. An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.",Use binary search on nums2 for each element in nums1,Iterate through nums1 and nums2 using nested loops and track the maximum distance,Sort both arrays in ascending order and then find the maximum difference between corresponding elements,Reverse both arrays and find the maximum difference between corresponding elements,Use two pointers to efficiently iterate through both arrays while maintaining the validity condition,Medium,algorithms,"Array,Two Pointers,Binary Search,Greedy"
1985,"Maximum Subarray Min-Product
The min-product of an array is equal to the minimum value in the array multiplied by the array's sum. Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7. Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer. A subarray is a contiguous part of an array.",Maintain a prefix sum array and iterate through all possible subarrays to compute min-product in O(1) time each.,"Use a brute-force approach, checking every possible subarray and calculating its min-product, with early pruning if current min-product exceeds the global max.","Employ dynamic programming to store min-products of subarrays ending at each index, using previous results to optimize calculations.","Sort the array and then iterate through all possible subarrays, calculating min-product based on the sorted order to efficiently find the maximum.","Utilize a monotonic stack to efficiently find the next smaller element on the left and right for each element, thus identifying subarrays where that element is the minimum.",Medium,algorithms,"Array,Stack,Monotonic Stack,Prefix Sum"
1986,"Largest Color Value in a Directed Graph
There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1. You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj. A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.",Perform a depth-first search (DFS) starting from each node and keep track of the maximum color count encountered. Return -1 if a cycle is detected.,Use a greedy algorithm that always chooses the path with the highest immediate color value. Return -1 if the algorithm gets stuck in a loop.,Calculate the color value for all possible paths in the graph and return the maximum. Return -1 if a cycle is detected during path enumeration.,Apply Dijkstra's algorithm to find the longest path in the graph and then calculate the color value of that path. Return -1 if a cycle is detected.,"Use topological sort and dynamic programming to compute the maximum color count for each node, considering all possible incoming paths. Return -1 if a cycle is detected.",Hard,algorithms,"Hash Table,Dynamic Programming,Graph,Topological Sort,Memoization,Counting"
1970,"Sorting the Sentence
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters. A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence. Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.",Bubble Sort,Selection Sort,Insertion Sort,Merge Sort,Counting Sort,Easy,algorithms,"String,Sorting"
1971,"Incremental Memory Leak
You are given two integers memory1 and memory2 representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second. At the ith second (starting from 1), i bits of memory are allocated to the stick with more available memory (or from the first memory stick if both have the same available memory). If neither stick has at least i bits of available memory, the program crashes. Return an array containing [crashTime, memory1crash, memory2crash], where crashTime is the time (in seconds) when the program crashed and memory1crash and memory2crash are the available bits of memory in the first and second sticks respectively.","Use a greedy approach, always allocating memory to the stick with the most available space, without considering future allocations.",Simulate the memory allocation process using dynamic programming to optimize memory usage and prevent crashing.,"Use binary search to find the crash time, assuming the crash time always exists within a reasonable range.",Pre-calculate the total memory required up to a certain time and check if it exceeds the available memory.,"Simulate the memory allocation process step-by-step until either memory1 or memory2 becomes negative, indicating a crash.",Medium,algorithms,Simulation
1972,"Rotating the Box
You are given an m x n matrix of characters boxGrid representing a side-view of a box. Each cell of the box is one of the following: The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions. It is guaranteed that each stone in boxGrid rests on an obstacle, another stone, or the bottom of the box. Return an n x m matrix representing the box after the rotation described above.",The obstacles will fall to the bottom,The stones will remain in place,The empty cells will be filled with stones,The stones will float to the top,"The stones will fall to the right, filling empty spaces until they hit an obstacle or the edge",Medium,algorithms,"Array,Two Pointers,Matrix"
1326,"Sum of Floored Pairs
Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for all pairs of indices 0 <= i, j < nums.length in the array. Since the answer may be too large, return it modulo 109 + 7. The floor() function returns the integer part of the division.",Sort the input array and use binary search to find the range of 'j' values for each 'i',Use dynamic programming to store and reuse the results of floor divisions,"Iterate through all pairs (i, j) and directly calculate floor(nums[i] / nums[j]) without optimization",Precompute all possible floor values and store them in a hash map for quick lookup,Count the frequency of each number and iterate through possible quotient values to optimize the calculation,Hard,algorithms,"Array,Math,Binary Search,Prefix Sum"
1993,"Sum of All Subset XOR Totals
The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty. Given an array nums, return the sum of all XOR totals for every subset of nums. Note: Subsets with the same elements should be counted multiple times. An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.",Calculate the XOR total of the entire array and multiply by the number of elements,"Generate all permutations of the array, calculate the XOR total for each, and sum the results",Calculate the XOR total of each element individually and sum the results.,"For each element, calculate XOR total with the running result. Divide final answer by the array length.",Multiply the XOR of all elements by 2^(n-1) where n is the number of elements in the array.,Easy,algorithms,"Array,Math,Backtracking,Bit Manipulation,Combinatorics"
1994,"Minimum Number of Swaps to Make the Binary String Alternating
Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible. The string is called alternating if no two adjacent characters are equal. For example, the strings ""010"" and ""1010"" are alternating, while the string ""0100"" is not. Any two characters may be swapped, even if they are not adjacent.","Calculate the number of misplaced 0s assuming the string starts with 1, then calculate the number of misplaced 1s assuming the string starts with 0, and return the minimum.","Calculate the number of misplaced 0s assuming the string starts with 0, then return that value if it's smaller than the string length divided by 2; otherwise, return -1.","Count the number of 0s and 1s in the string. If the absolute difference is greater than 1, return -1. Otherwise, return the number of swaps needed to make the string alternating by considering all possible pairs.","Sort the string and count the number of differing positions from the alternating patterns ""0101..."" and ""1010..."", then return the smaller value.","Count the number of 0s in even positions and 1s in even positions. Return the minimum of these counts if the difference between the number of 0s and 1s is at most 1; otherwise, return -1.",Medium,algorithms,"String,Greedy"
1995,"Finding Pairs With a Certain Sum
You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types: Implement the FindSumPairs class:",Use nested loops to iterate through all possible pairs and count those that sum to the target value.,"Sort both arrays and use two pointers, one starting from the beginning of nums1 and the other from the end of nums2, adjusting pointers based on the sum.",Store all possible sums in a set and check if the target value exists in this set.,Create a hash table to store elements of nums1 with their frequency and iterate through nums2 to find the complement.,Maintain a count of each number in nums2 and efficiently update counts after modifications. Use these counts to calculate pairs summing to the target.,Medium,algorithms,"Array,Hash Table,Design"
1996,"Number of Ways to Rearrange Sticks With K Sticks Visible
There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. A stick is visible from the left if there are no longer sticks to the left of it. Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7.",Use Stirling Numbers of the First Kind directly with memoization.,"Calculate all permutations and count visible sticks for each, modulo 10^9 + 7.",Employ dynamic programming with states representing the number of sticks placed and the last stick's length.,Apply Catalan numbers to count visible sticks from both ends.,Utilize dynamic programming with states representing the number of sticks placed and the number of visible sticks.,Hard,algorithms,"Math,Dynamic Programming,Combinatorics"
1999,"Longer Contiguous Segments of Ones than Zeros
Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise. Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.","If the string consists of all 0s, return true.",Compare the total number of 1s to the total number of 0s in the string.,Return true if the first character is '1' and false otherwise.,Return the result of comparing the counts of '1's and '0's at even indices.,"Iterate through the string, tracking the lengths of the longest contiguous segments of 1s and 0s, and compare them.",Easy,algorithms,String
2000,"Minimum Speed to Arrive on Time
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time. Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",Binary search on the distance array to find the minimum speed.,Use dynamic programming to store the minimum time to reach each train station and find the optimal speed.,Iterate through all possible speeds and check if the condition is met; return -1 if the speed exceeds 10^7.,Calculate the average speed required and round up to the nearest integer.,Use binary search on the possible speed range to find the minimum speed that satisfies the time constraint.,Medium,algorithms,"Array,Binary Search"
2001,"Jump Game VII
You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled: Return true if you can reach index s.length - 1 in s, or false otherwise.",Dynamic Programming: Build a DP table where dp[i] indicates if index i is reachable. Iterate through possible jump lengths.,"Greedy: Always jump to the farthest reachable index within [minJump, maxJump].","Breadth-First Search (BFS): Explore reachable indices using a queue, stopping when the destination is found or the queue is empty.","Depth-First Search (DFS): Recursively explore reachable indices, backtracking when a dead end is reached.","Sliding Window with BFS: Optimize BFS using a sliding window to avoid redundant checks within [minJump, maxJump].",Medium,algorithms,"Two Pointers,String,Prefix Sum"
2002,"Stone Game VIII
Alice and Bob take turns playing a game, with Alice starting first. There are n stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following: The game stops when only one stone is left in the row. The score difference between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference. Given an integer array stones of length n where stones[i] represents the value of the ith stone from the left, return the score difference between Alice and Bob if they both play optimally.",A greedy approach of always taking the maximum prefix sum.,Using dynamic programming with a state representing the current player and the index.,A backtracking algorithm to explore all possible game states.,Calculating all possible prefix sums and choosing the one that maximizes Alice's score in the first turn.,Using dynamic programming where the state represents the starting index and stores the maximum score difference achievable from that point.,Hard,algorithms,"Array,Math,Dynamic Programming,Prefix Sum,Game Theory"
2024,"Calculate Special Bonus
Table: Employees  Write a solution to calculate the bonus of each employee. The bonus of an employee is 100% of their salary if the ID of the employee is an odd number and the employee's name does not start with the character 'M'. The bonus of an employee is 0 otherwise. Return the result table ordered by employee_id. The result format is in the following example.",Use a correlated subquery to check the conditions for each employee,"Create a temporary table to store the employee names starting with 'M', then join it with the Employees table.","Use a CASE statement that only checks the employee ID, ignoring the name condition",Use a WHILE loop to iterate through the Employees table and calculate the bonus.,"Use a CASE statement to check both the employee ID and the first character of the name, multiplying the salary by 1 if the conditions are met and 0 otherwise.",Easy,database systems,Database
1987,"Substrings of Size Three with Distinct Characters
A string is good if there are no repeated characters. Given a string s​​​​​, return the number of good substrings of length three in s​​​​​​. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A substring is a contiguous sequence of characters in a string.",Use regular expressions to find all substrings of length three and then check each for distinct characters.,Sort the string and then count the number of substrings of length three; sorting helps identify duplicates faster.,Keep a sliding window of length three and increment a counter if the first character is different from the other characters in the entire string.,"Generate all possible three-letter substrings and cross-reference them with the input string, counting matches without considering distinct characters.","Use a sliding window of size three and a hash set to check for distinct characters within each window, incrementing a counter for each 'good' substring.",Easy,algorithms,"Hash Table,String,Sliding Window,Counting"
1988,"Minimize Maximum Pair Sum in Array
The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs. Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that: Return the minimized maximum pair sum after optimally pairing up the elements.",Sort the array and find the difference between the largest and smallest element.,Calculate the sum of all elements and divide by n/2.,Pair elements randomly and keep track of the minimum maximum pair sum found.,Sort the array and pick the first n/2 elements.,Sort the array and pair the i-th element with the (n-1-i)-th element. Return the minimum of the maximum pair sum.,Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
1990,"Get Biggest Three Rhombus Sums in a Grid
You are given an m x n integer matrix grid​​​. A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid​​​. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum: Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner. Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.","Calculate sums of all possible rhombus shapes using brute force, then sort and take the top three distinct values.","Compute prefix sums of the grid to optimize rhombus sum calculation, then use a heap to track the largest three sums.",Employ dynamic programming to store intermediate rhombus sums and retrieve the largest three without redundant calculations.,"Use a sliding window approach to scan the grid and identify rhombus shapes, keeping track of the three largest sums using a set.","Iterate through each cell as the center of a potential rhombus, calculate rhombus sums for increasing sizes, and maintain a set of the top three distinct sums.",Medium,algorithms,"Array,Math,Sorting,Heap (Priority Queue),Matrix,Prefix Sum"
1989,"Minimum XOR Sum of Two Arrays
You are given two integer arrays nums1 and nums2 of length n. The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed). Rearrange the elements of nums2 such that the resulting XOR sum is minimized. Return the XOR sum after the rearrangement.",Solve using a greedy approach by pairing the smallest elements of nums1 and nums2.,"Apply dynamic programming with a bitmask representing used elements of nums2, minimizing the XOR sum recursively.",Sort both arrays and then calculate the XOR sum; this always gives the minimum.,"Use a backtracking approach, exploring all possible permutations of nums2 and choosing the one with the minimum XOR sum.",Model the problem as a minimum-cost perfect matching in a bipartite graph and solve using the Hungarian algorithm.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
2010,"Check if Word Equals Summation of Two Words
The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.). The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer. You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters 'a' through 'j' inclusive. Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise.",Return `true` if `len(firstWord) + len(secondWord) == len(targetWord)`,Check if the ASCII sum of `firstWord` + `secondWord` equals that of `targetWord`,Compare the first characters of the three words,Pad shorter words with 'a' characters to equal lengths before numerical conversion,Convert each word to its numerical representation and check if `firstWord + secondWord == targetWord`,Easy,algorithms,String
2011,"Maximum Value after Insertion
You are given a very large integer n, represented as a string,​​​​​​ and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number. You want to maximize n's numerical value by inserting x anywhere in the decimal representation of n​​​​​​. You cannot insert x to the left of the negative sign. Return a string representing the maximum value of n​​​​​​ after the insertion.",Insert x at the end of n regardless of the sign or digit values.,"Convert n to an integer, add x (also treated as an integer), and convert the result back to a string.","Insert x at the beginning of n after the negative sign if n is negative; otherwise, insert x at the beginning.",Insert x into every possible position in n and return the lexicographically largest string.,"Iterate through n and insert x at the first position where x will result in a larger number, considering the sign of n.",Medium,algorithms,"String,Greedy"
2012,"Process Tasks Using Servers
You are given two 0-indexed integer arrays servers and tasks of lengths n​​​​​​ and m​​​​​​ respectively. servers[i] is the weight of the i​​​​​​th​​​​ server, and tasks[j] is the time needed to process the j​​​​​​th​​​​ task in seconds. Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty. At second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, and in case of a tie, it is assigned to a free server with the smallest index. If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above. A server that is assigned task j at second t will be free again at second t + tasks[j]. Build an array ans​​​​ of length m, where ans[j] is the index of the server the j​​​​​​th task will be assigned to. Return the array ans​​​​.","Use a priority queue to store available servers and iterate through tasks, assigning each to the server that becomes available first based on weight and index.","Simulate the task assignment process using nested loops, checking for available servers and assigning tasks in order of server index.","Maintain a list of busy servers and their finish times, iterating through tasks and assigning each to the first available server regardless of weight or index.","Pre-sort the servers based on weight and index, then iterate through tasks and assign each to the next available server in the sorted list.","Employ a min-heap to track available servers and their weights; for each task, assign it to the server from the heap, updating the server's availability time.",Medium,algorithms,"Array,Heap (Priority Queue)"
2013,"Minimum Skips to Arrive at Meeting On Time
You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through n roads. The road lengths are given as an integer array dist of length n, where dist[i] describes the length of the ith road in kilometers. In addition, you are given an integer speed, which is the speed (in km/h) you will travel at. After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting. However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks. Return the minimum number of skips required to arrive at the meeting on time, or -1 if it is impossible.","Use a greedy approach, skipping rests at the longest roads first and see if it satisfies hoursBefore",Apply binary search to find the number of skips that enables arrival before hoursBefore.,Solve using dynamic programming where dp[i][j] represents the minimum time to reach road i with j skips.,Calculate the total travel time without any skips and then incrementally reduce the number of skips until the total travel time is less than or equal to hoursBefore.,"Use dynamic programming where dp[i][j] represents the minimum time to reach road i with j skips, handling floating-point precision carefully.",Hard,algorithms,"Array,Dynamic Programming"
2031,"Egg Drop With 2 Eggs and N Floors
You are given two identical eggs and you have access to a building with n floors labeled from 1 to n. You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves. Return the minimum number of moves that you need to determine with certainty what the value of f is.","Binary search the floors, adjusting the search space after each drop. This may not guarantee the minimum number of moves in the worst case.","Drop the first egg at floor n/2. If it breaks, linearly search floors 1 to n/2 - 1 with the second egg. Otherwise, repeat the process on floors n/2 + 1 to n.","Start dropping the first egg from floor 1, then floor 2, and so on until it breaks. Then, use the second egg to linearly search the floors below where the first egg broke.","Drop the first egg from floor sqrt(n), then 2*sqrt(n), then 3*sqrt(n), and so on. If it breaks at k*sqrt(n), linearly search floors (k-1)*sqrt(n) + 1 to k*sqrt(n) - 1 with the second egg.",Find the smallest x such that x + (x-1) + (x-2) + ... + 1 >= n.  x is the minimum number of moves.,Medium,algorithms,"Math,Dynamic Programming"
2015,"Determine Whether Matrix Can Be Obtained By Rotation
Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.","Check if `mat` equals `target` directly; if not, return `false` immediately.","Compare the sum of all elements in `mat` and `target`; if they differ, return `false`.","Rotate `mat` only once and compare it with `target`; if they match, return `true`, otherwise return `false`.","Compute the determinant of both `mat` and `target`; if the determinants are equal return `true`, else `false`.","Rotate `mat` up to 3 times (90, 180, 270 degrees), comparing it to `target` after each rotation. If a match is found, return `true`. If no match is found after 3 rotations and the initial comparison, return `false`.",Easy,algorithms,"Array,Matrix"
2016,"Reduction Operations to Make the Array Elements Equal
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps: Return the number of operations to make all elements in nums equal.",Use a max heap to repeatedly merge the two largest elements until they are equal,Sort the array in ascending order and count the number of elements greater than the smallest element,Iterate through the array and find the mode; the number of operations is the array size minus the mode's frequency,"Recursively divide the array into halves and count the operations needed to make each half equal, then sum the results","Sort the array in descending order and for each element, count the number of larger distinct elements",Medium,algorithms,"Array,Sorting"
2017,"Minimum Number of Flips to Make the Binary String Alternating
You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence: Return the minimum number of type-2 operations you need to perform such that s becomes alternating. The string is called alternating if no two adjacent characters are equal.",Greedily flip characters based on the majority in the entire string.,Recursively check substrings and memoize the minimum flips needed.,Calculate the number of 0s and 1s and take the minimum as the number of flips.,Sort the string and count the differences between adjacent characters.,Calculate the number of flips required for both '0101...' and '1010...' alternating patterns and return the minimum.,Medium,algorithms,"String,Greedy"
2018,"Minimum Space Wasted From Packaging
You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box. The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces. You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes. Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 109 + 7.",Choose the supplier with the smallest maximum box size.,"Sort the packages and boxes, then greedily match each package with the smallest box that fits it from each supplier.","For each supplier, calculate the average box size and choose the supplier with the smallest average box size greater than the largest package.",Select the supplier with the fewest number of different box sizes.,"For each supplier, sort their boxes. Then, sort the packages. Iterate through the packages and for each package, find the smallest box from the supplier that can fit the package. Calculate the wasted space and take the minimum among all suppliers.",Hard,algorithms,"Array,Binary Search,Sorting,Prefix Sum"
2041,"The Latest Login in 2020
Table: Logins  Write a solution to report the latest login for all users in the year 2020. Do not include the users who did not login in 2020. Return the result table in any order. The result format is in the following example.",Use GROUP BY user_id and select MAX(login_date) without filtering for the year 2020,Use a subquery to find the latest login date and then join it back to the Logins table,Employ a window function to rank login dates and then filter for the rank 1 logins,Select all login dates from 2020 and use DISTINCT to get unique dates,"Use a WHERE clause to filter for the year 2020, then GROUP BY user_id and select MAX(login_date)",Easy,database systems,Database
2005,"Check if All the Integers in a Range Are Covered
You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi. Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise. An integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.",Check if 'left' and 'right' fall within the minimum and maximum values in 'ranges'.,"Sort 'ranges' by start value, then iterate from 'left' to 'right', checking for overlap with each range.",Create a boolean array of size 'right' and mark covered indices based on intervals in 'ranges'.,Calculate the total length of all intervals in 'ranges' and compare it to the range 'right' - 'left' + 1.,"Create a boolean array of size 'right' - 'left' + 1, mark covered indices based on intervals, and check if all are true.",Easy,algorithms,"Array,Hash Table,Prefix Sum"
2006,"Find the Student that Will Replace the Chalk
There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again. You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk. Return the index of the student that will replace the chalk pieces.","Divide k by the sum of the chalk array, and the remainder is the index.",Return the index i where k is first less than chalk[i] without updating k.,Iterate through the chalk array and find the minimum value. The index of this value is the answer.,Sort the chalk array. The index of the first element is the answer.,"Calculate the prefix sum of the chalk array, then use the modulo operator to find the index.",Medium,algorithms,"Array,Binary Search,Simulation,Prefix Sum"
1078,"Remove Outermost Parentheses
A valid parentheses string is either empty """", ""("" + A + "")"", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",Use a regular expression to find and replace all occurrences of '( )' with an empty string.,Recursively remove the first and last characters until the string is no longer a valid parentheses string.,Keep track of the parentheses balance. Increment for '(' and decrement for ')'. Remove parentheses when the balance is 0.,"Split the string into individual characters and rebuild it, skipping every other '(' and ')'",Maintain a counter to track the open parentheses. Append characters to the result string only when the counter is greater than 1 for '(' and greater than 0 for ')'.,Easy,algorithms,"String,Stack"
1079,"Sum of Root To Leaf Binary Numbers
You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer.","Perform a depth-first traversal, multiplying the current path value by 2 and adding the node's value. Return the sum of all leaf path values.",Convert the binary tree into an array and then sum the binary numbers represented by consecutive elements.,Calculate the decimal value of the entire tree treated as a single large binary number.,"Use a breadth-first traversal, summing node values at each level and returning the final level's sum.","Perform a depth-first traversal, accumulating the binary number along each path and summing the resulting numbers at the leaf nodes.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
1080,"Camelcase Matching
Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.",Brute-force: Check every possible subsequence of the query against the pattern.,Use dynamic programming to find the longest common subsequence.,Precompute all possible camelCase variations of the pattern and compare against each query.,Check if pattern is a substring of the query.,"Iterate through the query and pattern, advancing the pattern pointer only when a matching uppercase character is found in the query.",Medium,algorithms,"Two Pointers,String,Trie,String Matching"
1081,"Video Stitching
You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi. We can cut these clips into segments freely. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.",Sort the clips by end time in descending order and greedily select clips that cover the most remaining time.,Use dynamic programming to find the shortest path through a graph where nodes are clip start times and edges are clip durations.,"Sort clips by start time and then iterate through them, selecting the clip that extends farthest beyond the current coverage.",Recursively explore all possible combinations of clips and return the minimum number needed to cover the entire time range.,"Sort the clips by start time, and then greedily select the clip that extends the farthest, updating the current coverage. Repeat until the entire time range is covered.",Medium,algorithms,"Array,Dynamic Programming,Greedy"
1086,"Divisor Game
Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of: Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.",Alice wins only if n is a prime number,"Alice always loses, regardless of the value of n",Alice wins if and only if n is odd,Alice wins if and only if n is a power of 2,Alice wins if and only if n is even,Easy,algorithms,"Math,Dynamic Programming,Brainteaser,Game Theory"
1311,"Largest Magic Square
A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square. Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.","Dynamic Programming, storing max square sizes ending at each cell.","Brute force, checking every possible square subgrid.","Binary search for the maximum size, checking feasibility with prefix sums.","Greedy approach, starting from the largest possible square and shrinking.","Prefix sums to efficiently calculate row, column and diagonal sums for each subgrid.",Medium,algorithms,"Array,Matrix,Prefix Sum"
2008,"Minimum Cost to Change the Final Value of Expression
You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'. Return the minimum cost to change the final value of the expression. The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows: Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.","Convert the expression to postfix notation and use a stack to evaluate it, tracking changes.",Use dynamic programming to store the minimum cost to change the value of each subexpression.,"Recursively evaluate the expression, flipping operators based on probability.","Apply a greedy algorithm, changing the most impactful operator at each step.",Parse the expression tree and use dynamic programming to compute minimum cost for each node to evaluate to 0 or 1.,Hard,algorithms,"Math,String,Dynamic Programming,Stack"
2025,"Redistribute Characters to Make All Strings Equal
You are given an array of strings words (0-indexed). In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j]. Return true if you can make every string in words equal using any number of operations, and false otherwise.",Return true if the length of the input array is 0,Return true if the array contains only one string,Calculate the average string length and check if all strings have that length,Concatenate all strings and check if the length is a perfect square,Count character frequencies; return true if all counts are divisible by the number of words,Easy,algorithms,"Hash Table,String,Counting"
2027,"Maximum Number of Removable Characters
You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed). You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence. Return the maximum k you can choose such that p is still a subsequence of s after the removals. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",Greedily remove characters based on frequency analysis of 's' and 'p',Use dynamic programming to find the longest common subsequence between 's' and 'p',Sort the 'removable' array and iteratively check subsequences,Always remove characters from the beginning of 's' based on 'removable',Binary search on 'k' in 'removable' to find the maximum valid prefix for subsequence check,Medium,algorithms,"Array,String,Binary Search"
2026,"Merge Triplets to Form Target Triplet
A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain. To obtain target, you may apply the following operation on triplets any number of times (possibly zero): Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",Check if any triplet is element-wise less than or equal to the target and return false if none exist.,Sort the triplets array and the target array and compare them for equality.,Return true if the target triplet exists in the triplets array without any modification.,Return true if the sum of all triplets equals the target triplet.,"Iterate through triplets, and if a triplet[i] allows each element of target to be formed independently without exceeding it, then it's possible.",Medium,algorithms,"Array,Greedy"
2028,"The Earliest and Latest Rounds Where Players Compete
There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order). The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round. Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.",The earliest round is always 1 and the latest round is always n/2,"Calculate the minimum and maximum number of rounds required for each player to reach the final round, then derive the earliest and latest meeting points",Simulate all possible tournament outcomes using recursion and memoization to find the earliest and latest rounds where the two players meet,The earliest round is always log2(n) and the latest round is always n-1,"Model the tournament as a series of pairings and use dynamic programming to explore the possible advancement paths of the two players, minimizing and maximizing the meeting round",Hard,algorithms,"Dynamic Programming,Memoization"
2047,"Find a Peak Element II
A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom. Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j]. You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell. You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.","Binary search on rows to find the maximum element in each row, then check its neighbors",Iterate through each element and compare it with all its neighbors until a peak is found,Sort the entire matrix and return the largest element's coordinates,Randomly select an element and check if it is a peak; repeat until a peak is found,Perform binary search on the column with the maximum element of each row,Medium,algorithms,"Array,Binary Search,Divide and Conquer,Matrix"
2032,"Largest Odd Number in String
You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string """" if no odd integer exists. A substring is a contiguous sequence of characters within a string.","Iterate through the string from left to right, keeping track of the longest odd number found so far.","Convert the string to an integer and repeatedly divide by 2 until an odd number is reached, then convert back to a string.","Generate all possible substrings and check each one for oddness, returning the largest one found.",Sort the digits of the string in descending order and return the first substring that is odd.,"Iterate through the string from right to left, returning the substring up to the first odd digit encountered.",Easy,algorithms,"Math,String,Greedy"
2033,"The Number of Full Rounds You Have Played
You are participating in an online chess tournament. There is a chess round that starts every 15 minutes. The first round of the day starts at 00:00, and after every 15 minutes, a new round starts. You are given two strings loginTime and logoutTime where: If logoutTime is earlier than loginTime, this means you have played from loginTime to midnight and from midnight to logoutTime. Return the number of full chess rounds you have played in the tournament. Note: All the given times follow the 24-hour clock. That means the first round of the day starts at 00:00 and the last round of the day starts at 23:45.",Add the difference between logoutTime and loginTime directly.,Round both loginTime and logoutTime to the nearest hour and then calculate the difference.,Multiply the difference between logoutTime and loginTime by 4 since each round is 15 minutes.,"Convert loginTime and logoutTime to seconds, find the difference, and divide by 900.","Convert loginTime and logoutTime to minutes since 00:00, calculate the difference, handle the midnight wrap-around, and divide by 15 (integer division).",Medium,algorithms,"Math,String"
2035,"Count Sub Islands
You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells. An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2. Return the number of islands in grid2 that are considered sub-islands.","Check if grid2[i][j] == 1 and grid1[i][j] == 0, if so, mark the entire island in grid2 as invalid","For each island in grid2, check if any of its cells are 0 in grid1. If so, it's not a sub-island",Count all islands in both grids and return the difference.,Perform a bitwise AND operation between grid1 and grid2. The number of islands in the result is the answer.,"For each island in grid2, check if all corresponding cells in grid1 are 1. If yes, increment the sub-island count.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
2034,"Minimum Absolute Difference Queries
The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If all elements of a are the same, the minimum absolute difference is -1. You are given an integer array nums and the array queries where queries[i] = [li, ri]. For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive). Return an array ans where ans[i] is the answer to the ith query. A subarray is a contiguous sequence of elements in an array. The value of |x| is defined as:",Calculate the minimum absolute difference by comparing each element with every other element in the subarray.,Precompute all possible absolute differences within the entire array and then use a lookup table for each query.,Sort the subarray and then iterate through adjacent elements to find the minimum absolute difference.,"Return -1 if the subarray contains only unique elements; otherwise, return 0.",Maintain a frequency count of elements in the subarray and iterate through possible differences from smallest to largest.,Medium,algorithms,"Array,Hash Table"
2057,"Count Salary Categories
Table: Accounts  Write a solution to calculate the number of bank accounts for each salary category. The salary categories are: The result table must contain all three categories. If there are no accounts in a category, return 0. Return the result table in any order. The result format is in the following example.",Use a single SQL query with multiple COUNT aggregate functions and CASE statements to categorize salaries.,Create temporary tables for each salary category and then count the accounts in each table using separate SELECT COUNT(*) statements.,Implement a stored procedure to iterate through each account and update counters for each category using procedural logic.,Use a cross join with a table containing salary categories and then filter using a WHERE clause.,Use a single SQL query with a GROUP BY clause on a derived salary category column calculated using CASE statements and then count the accounts in each group.,Medium,database systems,Database
2020,"Remove One Element to Make the Array Strictly Increasing
Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true. The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).",Check if removing nums[i] results in a strictly increasing array for all i,Sort the array and check if the difference between consecutive elements is 1,Recursively check subarrays after removing elements until a strictly increasing array is found or all elements are removed,Count the number of inversions in the array. Return true if the count is less than or equal to 1,"Iterate through the array, and if nums[i] >= nums[i+1], try removing either nums[i] or nums[i+1] and check for strict increasing property",Easy,algorithms,Array
2021,"Remove All Occurrences of a Substring
Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed: Return s after removing all occurrences of part. A substring is a contiguous sequence of characters in a string.",Use dynamic programming to find the longest common subsequence and remove it,Employ regular expressions to match and replace all occurrences of the substring,"Split the string into an array of characters and iterate, removing the substring with array manipulation","Recursively search for the substring and remove it, memoizing already processed substrings",Repeatedly find the starting index of 'part' in 's' and remove it using string slicing or similar methods,Medium,algorithms,String
2022,"Maximum Alternating Subsequence Sum
The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices. Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence). A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.","Use a greedy approach, always including the largest element if it improves the alternating sum.",Sort the array in descending order and then calculate the alternating sum of the sorted array.,"Recursively explore all possible subsequences and calculate their alternating sums, memoizing results.",Divide the array into positive and negative numbers and maximize their sums separately.,Use dynamic programming to track the maximum alternating sum ending with a positive or negative sign.,Medium,algorithms,"Array,Dynamic Programming"
2023,"Design Movie Rental System
You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies. Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. Each shop carries at most one copy of a movie moviei. The system should support the following functions: Implement the MovieRentingSystem class: Note: The test cases will be generated such that rent will only be called if the shop has an unrented copy of the movie, and drop will only be called if the shop had previously rented out the movie.","Use a relational database with tables for shops, movies, and rentals, enforcing constraints with foreign keys and triggers.",Implement a distributed hash table where keys are movie IDs and values are lists of shops with available copies and prices.,"Utilize a graph database where nodes represent shops and movies, and edges represent rental relationships with associated prices.","Employ a simple in-memory data structure like nested dictionaries for shops, movies, and rental status, without persistence.","Create a class with internal data structures (e.g., sets, maps) to track movie availability, prices, and rental status for efficient lookups and updates.",Hard,system design,"Array,Hash Table,Design,Heap (Priority Queue),Ordered Set"
2042,"Maximum Product Difference Between Two Pairs
The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d). Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized. Return the maximum such product difference.",Sort the array in ascending order and compute (nums[n-1] * nums[n-2]) - (nums[1] * nums[2]),"Iterate through all possible combinations of four distinct indices and calculate the product difference, keeping track of the maximum.",Sort the array in descending order and compute (nums[0] * nums[1]) - (nums[n-2] * nums[n-3]),"Find the maximum and minimum elements of the array, then calculate their product difference.",Sort the array and compute (nums[n-1] * nums[n-2]) - (nums[0] * nums[1]),Easy,algorithms,"Array,Sorting"
2043,"Cyclically Rotating a Grid
You are given an m x n integer matrix grid​​​, where m and n are both even integers, and an integer k. The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:  A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below: Return the matrix after applying k cyclic rotations to it.",Process each layer independently by shifting elements within the layer using array slicing.,Transpose the entire matrix and then rotate it by 90 degrees k times.,"Flatten the matrix into a 1D array, perform rotations on the array, and reshape back into a matrix.",Apply a series of individual element swaps across the entire grid without considering layers.,"Extract each layer into a list, rotate the list k times, and then reconstruct the matrix with rotated layers.",Medium,algorithms,"Array,Matrix,Simulation"
2044,"Number of Wonderful Substrings
A wonderful string is a string where at most one letter appears an odd number of times. Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately. A substring is a contiguous sequence of characters in a string.",Use a brute-force approach checking every substring's character counts individually.,"Employ a sliding window technique, expanding and shrinking the window based on character counts.",Precompute all possible substrings and store them in a hash set to avoid redundant calculations.,Sort the string and count wonderful substrings in the sorted string. This strategy reduces complexity because similar characters are grouped together,Use a prefix XOR sum to track odd/even counts of characters and efficiently count wonderful substrings.,Medium,algorithms,"Hash Table,String,Bit Manipulation,Prefix Sum"
1313,"Count Ways to Build Rooms in an Ant Colony
You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0. You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built. Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.",Compute the factorial of n and divide by the product of subtree sizes modulo 10^9 + 7,"Use dynamic programming to calculate the number of ways to build rooms up to a certain index, then multiply the results",Perform a topological sort of the rooms and count the number of valid orderings of the sorted rooms,Recursively explore all possible build orders using backtracking and count valid sequences,Use DFS to calculate subtree sizes and combine counts using modular arithmetic and inverse factorials.,Hard,algorithms,"Math,Dynamic Programming,Tree,Graph,Topological Sort,Combinatorics"
2048,"Build Array from Permutation
Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it. A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).","Construct a hash table to store the mapping of index to value, then iterate and apply the permutation.","Sort the input array before applying the permutation, then build the output.",Create a deep copy of the array before applying the permutation to avoid side effects.,"Reverse the input array, apply the permutation, then reverse the result.","Iterate through the array, calculating ans[i] = nums[nums[i]] in each step to construct the new array.",Easy,algorithms,"Array,Simulation"
2049,"Eliminate Maximum Number of Monsters
You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city. The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute. You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start. You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon. Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.",Sort the arrival times in descending order and eliminate monsters from the farthest to the nearest,Use a priority queue to track the monsters and eliminate the fastest approaching monster first,Eliminate monsters in the order they appear in the input arrays without considering their arrival times,"Simulate the game minute by minute, eliminating a random monster each turn","Calculate arrival times, sort them, and eliminate monsters if arrival time is greater than the current minute",Medium,algorithms,"Array,Greedy,Sorting"
2050,"Count Good Numbers
A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7). Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7. A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.","Multiply 5 raised to the power of (n+1)/2 with 4 raised to the power of n/2, without modulo at any step.",Multiply 5 raised to the power of (n+1)/2 with 5 raised to the power of n/2 modulo 10^9 + 7.,"Add 5 raised to the power of (n+1)/2 and 4 raised to the power of n/2, taking the modulo at the very end.",Multiply (n+1)/2 with n/2 modulo 10^9 + 7.,"Multiply 5 raised to the power of (n+1)/2 with 4 raised to the power of n/2 modulo 10^9 + 7, using modular exponentiation.",Medium,algorithms,"Math,Recursion"
2051,"Longest Common Subpath
There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities. There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively. Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all. A subpath of a path is a contiguous sequence of cities within that path.","Use dynamic programming to build a table of common subpath lengths with O(N*M) space complexity, where N and M are the lengths of the longest and shortest paths respectively.",Sort all paths and then iterate to find common sequences. This would not guarantee the *longest* common subpath.,Calculate all possible subpaths for each friend and then find the intersection of these subpath sets.,Use a sliding window technique on each path to compare subpaths of a fixed length without any optimization for finding the *longest* length.,"Use binary search to find the length of the longest common subpath, combined with a rolling hash (e.g., Rabin-Karp) to efficiently check if a subpath of a given length is common to all paths.",Hard,algorithms,"Array,Binary Search,Rolling Hash,Suffix Array,Hash Function"
2037,"Count Square Sum Triples
A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2. Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.","Brute-force search: Iterate through all possible triples (a, b, c) and check the square sum condition.",Optimize with a hash table: Precompute squares up to n and check for matches by looking up c² - a² for each a and c.,Use recursion: Define a recursive function to check triples and prune branches based on intermediate results.,Apply dynamic programming: Store intermediate sums in a table to avoid redundant calculations.,"Iterate through possible 'a' and 'b' values, calculate 'c' as the square root of (a² + b²), and check if 'c' is an integer within the range [1, n].",Easy,algorithms,"Math,Enumeration"
2038,"Nearest Exit from Entrance in Maze
You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at. In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit. Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.",Use Depth-First Search (DFS) and return the path length of the first exit found.,Calculate the Manhattan distance from the entrance to every empty cell and return the minimum.,"Apply the A* search algorithm, prioritizing cells closest to the center of the maze.",Randomly explore paths from the entrance until an exit is found; return the shortest path length discovered.,"Employ Breadth-First Search (BFS) to explore the maze, tracking steps until an exit is found.",Medium,algorithms,"Array,Breadth-First Search,Matrix"
2039,"Sum Game
Alice and Bob take turns playing a game, with Alice starting first. You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num: The game ends when there are no more '?' characters in num. For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal. Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.",Alice always wins if the number of '?' is odd,Bob always wins if the difference between the sums of known digits is zero,Alice wins if the absolute difference between the sums of the known digits is greater than half the number of question marks,Bob always wins by maximizing the difference between the two halves.,"Alice wins if (number of '?' in first half) != (number of '?' in second half) AND (optimal moves lead to unequal sums), or (number of '?' in first half) == (number of '?' in second half) AND (initial sums are unequal)",Medium,algorithms,"Math,Greedy,Game Theory"
2040,"Minimum Cost to Reach Destination in Time
There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n where passingFees[j] is the amount of dollars you must pay when you pass through city j. In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities). Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.","Use Dijkstra's algorithm without considering time constraints, then penalize paths exceeding maxTime","Use a greedy approach, always choosing the shortest path until the time limit is reached, then calculate the cost","Apply depth-first search to explore all possible paths, pruning branches when cost exceeds the current minimum","Calculate shortest paths irrespective of time, then apply binary search on possible costs",Use Dijkstra's algorithm with time as a constraint to find the minimum cost path within maxTime,Hard,algorithms,"Dynamic Programming,Graph"
2058,"Concatenation of Array
Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed). Specifically, ans is the concatenation of two nums arrays. Return the array ans.","Create a new array with size n, copy elements of nums into it, and return the first n elements",Use a hash map to store the frequency of each number in nums and return the keys as the concatenated array,"Create two copies of nums, reverse one of them, and concatenate them",Sort the original array and then duplicate it,"Create a new array of size 2n, copy the elements of nums into the first n positions, and then copy nums again into the next n positions",Easy,algorithms,Array
2059,"Unique Length-3 Palindromic Subsequences
Given a string s, return the number of unique palindromes of length three that are a subsequence of s. Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once. A palindrome is a string that reads the same forwards and backwards. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",Use dynamic programming to store counts of all possible length-2 subsequences.,"Iterate through the string and build a set of all length-3 subsequences, then filter for palindromes.",Create a hash map to store the frequency of each character in the string.,Sort the string and then count palindromes of length 3.,"For each unique character, find its first and last occurrences, then count unique characters within that range.",Medium,algorithms,"Hash Table,String,Prefix Sum"
2061,"Painting a Grid With Three Different Colors
You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted. Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.","Use dynamic programming to store the number of valid colorings for subgrids ending at each column, considering all possible color combinations for the last two columns.","Apply recursion with memoization, where the recursive function explores possible colorings for each cell, avoiding adjacent cells with the same color, and stores results in a cache.",Calculate the total number of possible colorings (3^(m*n)) and subtract the number of invalid colorings where at least one pair of adjacent cells has the same color.,"Employ a greedy approach, assigning colors to cells one by one, prioritizing the least frequent color among its neighbors to minimize conflicts.","Use dynamic programming to store the number of valid colorings for each column, considering only valid color combinations for the last column, and transition based on valid combinations for the previous column.",Hard,algorithms,Dynamic Programming
2060,"Merge BSTs to Create Single BST
You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can: Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: A leaf is a node that has no children.","Recursively merge BSTs using an inorder traversal approach, checking for validity at each step.","Convert each BST to a sorted array, merge the arrays, and then rebuild a BST from the merged array.","Merge BSTs by repeatedly finding the smallest root and attaching the other trees to it, rebalancing as necessary.",Sort the roots based on their node values and connect each tree to the previous one in the sorted order.,"Use an inorder traversal on each BST to collect all node values, sort them, and construct a new BST.",Hard,algorithms,"Hash Table,Binary Search,Tree,Depth-First Search,Binary Tree"
2087,"Confirmation Rate
Table: Signups  Table: Confirmations  The confirmation rate of a user is the number of 'confirmed' messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places. Write a solution to find the confirmation rate of each user. Return the result table in any order. The result format is in the following example.","Use a LEFT JOIN from Signups to Confirmations, then calculate the rate using COUNT() and IFNULL(AVG(), 0)","Use a RIGHT JOIN from Signups to Confirmations, then calculate the rate using COUNT() and COALESCE(AVG(), 0)","Use a FULL OUTER JOIN from Signups to Confirmations, then calculate the rate using COUNT() and AVG()","Use a UNION ALL to combine Signups and Confirmations, then calculate the rate using SUM()","Use a LEFT JOIN from Signups to Confirmations, then calculate the rate using SUM(CASE WHEN confirmations.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(signups.user_id)",Medium,database systems,Database
1264,"Maximum Number of Words You Can Type
There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly. Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.",Split the text into words and return the count of words that do not contain characters present in brokenLetters.,"Iterate through the text and count the number of characters that are not in brokenLetters, then return this number.","Replace all occurrences of brokenLetters with an empty string in the text, then split the text into words and return the word count.","Iterate through each word in the text and, if a word contains a broken letter, remove it from the text; return the length of the processed text.","Split the text into words. For each word, check if it contains any characters from brokenLetters. Count the words that don't.",Easy,algorithms,"Hash Table,String"
2066,"Add Minimum Number of Rungs
You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung. You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there. Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.",Use binary search to find the insertion points for new rungs.,Divide the difference between consecutive rungs by 'dist' and round down.,Add a new rung at the midpoint between consecutive rungs if the distance exceeds 'dist'.,Sort the 'rungs' array after inserting new elements.,Calculate the number of rungs to add between each pair of consecutive rungs based on the given 'dist'.,Medium,algorithms,"Array,Greedy"
2067,"Maximum Number of Points with Cost
You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix. To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score. Return the maximum number of points you can achieve. abs(x) is defined as:","Use a greedy approach, always selecting the highest point in each row without considering the cost of moving between columns.","Apply dynamic programming with a state representing the row and column index, but only consider moving to adjacent columns (c-1, c, c+1) in the next row.","Calculate the maximum points for each row independently and sum them, ignoring the cost between rows.","Employ a divide-and-conquer strategy, splitting the matrix into submatrices and solving them recursively.","Use dynamic programming to store the maximum points achievable at each cell, considering the cost of moving from all possible columns in the previous row.",Medium,algorithms,"Array,Dynamic Programming"
2068,"Maximum Genetic Difference Query
There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, where parents[i] is the parent for node i. If node x is the root of the tree, then parents[x] == -1. You are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi. Return an array ans where ans[i] is the answer to the ith query.",Use a depth-first search (DFS) to traverse the path from the node to the root for each query and compute the XOR sum.,Precompute all paths from each node to the root and store them in a lookup table for efficient query processing.,Sort the genetic values of all nodes along the path from the query node to the root and select the largest value for XOR.,Convert the tree to a graph and apply Dijkstra's algorithm to find the shortest path with the maximum XOR sum.,Employ a Trie data structure to store genetic values on paths and efficiently search for the maximum XOR value for each query.,Hard,algorithms,"Array,Bit Manipulation,Trie"
2053,"Check if All Characters Have Equal Number of Occurrences
Given a string s, return true if s is a good string, or false otherwise. A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).",Use a hash map to store character counts and check if all values are the same in O(n^2) time.,"Sort the string and then iterate through, checking if adjacent characters have the same counts.",Calculate the frequency of each character using nested loops and compare the first frequency to all others.,Use a sliding window to compare character counts within substrings of varying lengths.,Use a hash map to store character counts and then check if all values are the same in O(n) time.,Easy,algorithms,"Hash Table,String,Counting"
2054,"The Number of the Smallest Unoccupied Chair
There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number. When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair. You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct. Return the chair number that the friend numbered targetFriend will sit on.",A hash table that maps arrival times to chair numbers.,A min-heap prioritized by leaving times.,A binary search tree sorted by arrival times.,A fixed-size array representing occupied chairs.,A priority queue (min-heap) of available chair numbers and a hash map of friend to assigned chair.,Medium,algorithms,"Array,Heap (Priority Queue),Ordered Set"
2055,"Describe the Painting
There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. You are given a 2D integer array segments, where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color. The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a set of mixed colors. For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set. You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj. Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order. A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b.","Use a hash table to store the colors and their corresponding segments, then iterate through the number line and calculate the mixed colors for each segment.",Sort the segments by their start points and then merge overlapping segments with the same color.,"Create a boolean array representing the number line, mark the painted segments with their colors, and then iterate through the array to find the mixed colors.","Discretize the number line into individual points, calculate the mixed color at each point, and then combine adjacent points with the same mixed color.","Use a difference array to track the color changes along the number line, then iterate through the array to reconstruct the painted segments with mixed colors.",Medium,algorithms,"Array,Prefix Sum"
1305,"Number of Visible People in a Queue
There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person. A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]). Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.",Use dynamic programming to store visibility counts for subsegments of the queue.,Sort the heights array and perform a binary search for each person to find visible people.,"Iterate through the array, and for each person, iterate through the rest of the array to count visible people without optimization.","Employ a divide-and-conquer approach, recursively splitting the queue and merging visibility counts.",Use a stack to maintain a decreasing order of heights to efficiently determine visibility for each person.,Hard,algorithms,"Array,Stack,Monotonic Stack"
2076,"Sum of Digits of String After Convert
You are given a string s consisting of lowercase English letters, and an integer k. Your task is to convert the string into an integer by a special process, and then transform it by summing its digits repeatedly k times. More specifically, perform the following steps: For example, if s = ""zbax"" and k = 2, then the resulting integer would be 8 by the following operations: Return the resulting integer after performing the operations described above.","Calculate the sum using modulo arithmetic and string manipulation, converting characters to their alphabet position.",Use recursion to repeatedly sum the digits until k iterations are complete or the number becomes a single digit.,"Convert the string to an integer, then represent the integer as a binary number and sum the binary digits.",Employ dynamic programming to store intermediate sums of digits for optimization across k iterations.,"Convert each character to its numerical value (a=1, b=2,...), sum the values, and repeat the digit summation k times.",Easy,algorithms,"String,Simulation"
2077,"Largest Number After Mutating Substring
You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d]. You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]). Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num. A substring is a contiguous sequence of characters within the string.","Greedily replace digits from left to right as long as change[num[i]] > num[i], then stop.",Always mutate the entire string num by applying the change array to every digit.,"Iterate through all possible substrings, mutate each one, and choose the substring that yields the largest resulting number.",Sort the change array in descending order and replace the smallest digits in num with the largest mappings.,"Iterate through num, mutating while change[num[i]] >= num[i]. Stop mutating at the first instance of change[num[i]] < num[i].",Medium,algorithms,"Array,String,Greedy"
2078,"Maximum Compatibility Score Sum
There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes). The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed). Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor. You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores. Given students and mentors, return the maximum compatibility score sum that can be achieved.",Use a greedy approach by always pairing the student and mentor with the highest compatibility score at each step.,Calculate the compatibility score matrix and apply Dijkstra's algorithm to find the maximum weighted matching.,"Employ a branch and bound technique, pruning pairings that are unlikely to lead to the maximum sum.","Sort both the students and mentors arrays based on some heuristic, then pair them linearly.",Use backtracking to explore all possible student-mentor pairings and choose the one with the maximum compatibility score sum.,Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
2079,"Delete Duplicate Folders in System
Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system. Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders. Once all the identical folders and their subfolders have been marked, the file system will delete all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted. Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order.","Use a hash table to store the frequency of each path, then delete paths with frequency greater than 1","Convert each path to a string, sort the strings, and then remove adjacent duplicates",Compare paths pairwise and delete a path if it's a substring of another path,Create a graph where nodes are folders and edges represent parent-child relationships. Detect cycles and remove paths belonging to cycles,"Serialize folder structures into strings, use a hash table to detect duplicates, and mark for deletion during a depth-first traversal",Hard,algorithms,"Array,Hash Table,String,Trie,Hash Function"
2083,"Three Divisors
Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false. An integer m is a divisor of n if there exists an integer k such that n = k * m.",Return true if n is prime itself.,Return true if the square root of n is an integer and also a prime number.,Check if n has at least three odd divisors.,Check if n is a perfect cube.,Return true if the square root of n is a prime number.,Easy,algorithms,Math
2084,"Maximum Number of Weeks for Which You Can Work
There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has. You can work on the projects following these two rules: Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints. Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.","Return the sum of all elements in the milestones array divided by 2, rounded down.",Return the largest element in the milestones array.,Return the number of elements in the milestones array.,Return the sum of all elements in the milestones array.,"Return twice the sum of the array minus the maximum element, all incremented by one if the max is larger than the remaining sums.",Medium,algorithms,"Array,Greedy"
1295,"Minimum Garden Perimeter to Collect Enough Apples
In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it. You will buy an axis-aligned square plot of land that is centered at (0, 0). Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot. The value of |x| is defined as:","Calculate the number of apples in each layer using an approximation formula, potentially leading to underestimation.","Iterate the perimeter size linearly until the apple count exceeds neededApples, which is inefficient for large inputs.","Use binary search on the side length of the square plot, checking if the apple count is sufficient. However, the apple counting method is flawed by not accounting for duplicate apples along the axes.","Compute the apple count based only on the perimeter trees, neglecting the trees inside the square, and increase the perimeter by 2 until the condition is met.","Use binary search on the side length of the square plot, calculating the exact number of apples within the square and on its perimeter. Then return 8 times the side length.",Medium,algorithms,"Math,Binary Search"
2086,"Count Number of Special Subsequences
A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s. Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7. A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are different if the set of indices chosen are different.","Use a greedy approach to select the minimum number of 0s, 1s, and 2s to form subsequences.","Recursively explore all possible subsequences and count the special ones, using memoization to avoid redundant calculations.",Calculate the total number of subsequences (2^n) and subtract the number of non-special subsequences.,"Sort the array and then iterate through it, counting the number of 0s, 1s, and 2s, and multiplying them together.","Use dynamic programming to track the number of subsequences ending with 0, 1, and 2, updating counts as you iterate through the array.",Hard,algorithms,"Array,Dynamic Programming"
1302,"Delete Characters to Make Fancy String
A fancy string is a string where no three consecutive characters are equal. Given a string s, delete the minimum possible number of characters from s to make it fancy. Return the final string after the deletion. It can be shown that the answer will always be unique.",Use a regular expression to replace sequences of three or more identical characters with two characters,"Iterate through the string and keep track of the last two characters. If the current character matches both, skip it; otherwise, append it to the result.","Sort the string lexicographically first, then remove any character that has two identical neighbors.",Recursively remove characters from the string until no three consecutive characters are equal.,"Iterate through the string, maintaining a count of consecutive identical characters. If the count exceeds 2, skip the character; otherwise, append it to the result and reset the count if necessary.",Easy,algorithms,String
2080,"Check if Move is Legal
You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'. Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal). A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below: Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.","Only check adjacent cells to (rMove, cMove) in the four cardinal directions (up, down, left, right)","A legal move only requires two cells of the opposite color adjacent to (rMove, cMove)","The board is only legal if all cells are either 'W' or 'B', ignoring '.'",A move is always legal regardless of the surrounding cells,"Check all eight directions (horizontal, vertical, and diagonals) from (rMove, cMove) for a 'good line' after the move is made",Medium,algorithms,"Array,Matrix,Enumeration"
2081,"Minimum Total Space Wasted With K Resizing Operations
You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. In addition, you are given an integer k, the maximum number of times you can resize the array (to any size). The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length. Return the minimum total space wasted if you can resize the array at most k times. Note: The array can have any size at the start and does not count towards the number of resizing operations.","Greedily resize whenever the current element exceeds the array's capacity, up to k times.",Calculate the wasted space for each possible subarray without resizing and sum them.,Try all combinations of k resize operations using brute force and choose the one with minimum wasted space.,Resize the array to the maximum value in `nums` and perform no other resizing operations.,"Use dynamic programming to find the minimum wasted space with at most k resizes, considering all possible split points.",Medium,algorithms,"Array,Dynamic Programming"
1336,"Maximum Product of the Length of Two Palindromic Substrings
You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.",Calculate the longest palindromic substring centered at each index and use brute force to check all pairs,Use dynamic programming to precompute all palindromic substrings and then iterate to find the maximum product of non-intersecting odd length substrings,Employ Manacher's algorithm to find all palindromic substrings and then select the two longest non-overlapping odd length substrings,"Apply a greedy approach, selecting the longest odd length palindrome and then searching for the next longest non-overlapping palindrome","Expand around each center to find the longest odd-length palindromes to the left and right, then iterate to find the maximum product of non-intersecting pairs",Hard,algorithms,"String,Rolling Hash,Hash Function"
2093,"Check If String Is a Prefix of Array
Given a string s and an array of strings words, determine whether s is a prefix string of words. A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length. Return true if s is a prefix string of words, or false otherwise.",Use dynamic programming to build all possible prefixes and compare against s,Sort the 'words' array lexicographically and then check if the first element is s,Calculate the combined hash of strings in 'words' and compare it with the hash of 's',Use regular expressions to match 's' against all possible concatenated prefixes of 'words',"Iterate through 'words', concatenating strings until the length equals or exceeds the length of 's', then compare",Easy,algorithms,"Array,String"
2094,"Remove Stones to Minimize the Total
You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times: Notice that you can apply the operation on the same pile more than once. Return the minimum possible total number of stones remaining after applying the k operations. ceil(x) is the smallest integer that is greater than or equal to x (i.e., rounds x up).",Use dynamic programming to compute the minimum stones remaining for each k and pile index.,Sort the piles array in ascending order and repeatedly remove stones from the smallest pile.,Apply the operation to each pile proportionally to its size to ensure fairness.,Binary search for the optimal value of the operation applied to each pile.,"Use a max heap (priority queue) to store the piles, repeatedly remove the largest pile, apply the operation, and re-insert.",Medium,algorithms,"Array,Heap (Priority Queue)"
2095,"Minimum Number of Swaps to Make the String Balanced
You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'. A string is called balanced if and only if: You may swap the brackets at any two indices any number of times. Return the minimum number of swaps to make s balanced.",Count the number of mismatched pairs and return that count directly.,Sort the string and then count the number of elements that are out of place.,Use dynamic programming to compute the minimum swaps for all possible substrings.,"Randomly swap brackets until the string is balanced, then return the number of swaps.","Count the number of unbalanced pairs and divide by 2, rounding up if necessary.",Medium,algorithms,"Two Pointers,String,Stack,Greedy"
2096,"Find the Longest Valid Obstacle Course at Each Position
You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.","Dynamic programming with binary search to find the smallest obstacle greater than the current one, updating the DP table with the current obstacle's index.",Greedily select the smallest obstacle at each position to build the longest course.,Recursively explore all possible obstacle course combinations and return the length of the longest valid one at each position.,Sort the obstacles array and use binary search to find the longest obstacle course within the sorted array.,"Use dynamic programming to maintain the longest obstacle course ending at each index, employing binary search to find the correct position to update the course with the current obstacle.",Hard,algorithms,"Array,Binary Search,Binary Indexed Tree"
2110,"Employees With Missing Information
Table: Employees  Table: Salaries  Write a solution to report the IDs of all the employees with missing information. The information of an employee is missing if: Return the result table ordered by employee_id in ascending order. The result format is in the following example.",Use a LEFT JOIN on Employees to Salaries and filter for NULL values in Salaries columns.,Use a RIGHT JOIN on Salaries to Employees and filter for NULL values in Employee columns.,Use a FULL OUTER JOIN to combine Employees and Salaries and then filter out records where either name or salary is NULL.,Select employee_id from Employees where employee_id NOT IN (SELECT employee_id FROM Salaries) INTERSECT Select employee_id from Salaries where employee_id NOT IN (SELECT employee_id FROM Employees).,"Combine results of two SELECT statements using UNION: one finding employee_ids in Employees missing salary in Salaries, the other finding employee_ids in Salaries missing name in Employees.",Easy,database systems,Database
2099,"Number of Strings That Appear as Substrings in Word
Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word. A substring is a contiguous sequence of characters within a string.",Brute force: Check every possible substring of `word` against each pattern.,Use regular expressions to search for each pattern within `word`.,Precompute all possible substrings of `word` and then check for the presence of each pattern.,Use dynamic programming to build a table indicating substring matches.,Iterate through the patterns array and use the `in` operator (or a similar substring search function) to check if each pattern is a substring of the word.,Easy,algorithms,String
2085,"Array With Elements Not Equal to Average of Neighbors
You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors. More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i]. Return any rearrangement of nums that meets the requirements.",Sort the array and then swap adjacent elements to satisfy the condition.,Randomly shuffle the array until the condition is met for all elements.,"Iterate through the array and if an element equals the average of its neighbors, swap it with the next element.","Reverse the array, which ensures no element is equal to the average of its original neighbors.",Sort the array and place elements alternately from the beginning and end to ensure the average condition is not met.,Medium,algorithms,"Array,Greedy,Sorting"
2100,"Minimum Non-Zero Product of the Array Elements
You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times: For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001. Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7. Note: The answer should be the minimum product before the modulo operation is done.","Multiply (2p-1 - 1) by itself (2p-1 - 2) times modulo 10^9 + 7, then multiply by 1 modulo 10^9 + 7.",The minimum product is always (2p-1 - 1)! modulo 10^9 + 7 because swapping operations lead to this arrangement.,Multiply all numbers from 1 to 2p - 1 and take the result modulo 10^9 + 7. Swapping won't change the product.,Calculate (2p-1 - 1)^(2^(p-1) -1) * 1 modulo (10^9 + 7),"Calculate pow(2p-1 - 1, 2p-1 - 1, 10^9 + 7) * 1 % (10^9 + 7). Utilize binary exponentiation for the power calculation.",Medium,algorithms,"Math,Greedy,Recursion"
2101,"Last Day Where You Can Still Cross
There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively. Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1). You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down). Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.","Depth-First Search (DFS) from top row, marking visited land cells; return the last day DFS reaches the bottom row","Binary search on days; for each day, flood cells up to that day and use Breadth-First Search (BFS) to check connectivity from top to bottom","Iterate through days; after each day's flooding, check if the top and bottom rows are disconnected using a disjoint set data structure (Union-Find)",Simulate flooding day by day and stop when the number of land cells falls below a threshold calculated using row and col,"Binary search on days; for each day, create a matrix representing flooding up to that day, and use DFS/BFS to check if a path exists from top to bottom through land cells",Hard,algorithms,"Array,Binary Search,Depth-First Search,Breadth-First Search,Union Find,Matrix"
2121,"Find if Path Exists in Graph
There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. You want to determine if there is a valid path that exists from vertex source to vertex destination. Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.",Use Dijkstra's algorithm to find the shortest path and check if a path exists.,Perform a topological sort and check if the destination appears after the source.,Iterate through all possible paths and check if any connect source to destination.,Check if source and destination are in the same connected component using Kruskal's algorithm.,"Use Depth-First Search or Breadth-First Search to traverse the graph starting from the source, and check if the destination is visited.",Easy,algorithms,"Depth-First Search,Breadth-First Search,Graph"
2088,"Minimum Time to Type Word Using Special Typewriter
There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'. Each second, you may perform one of the following operations: Given a string word, return the minimum number of seconds to type out the characters in word.",Use dynamic programming to precompute distances between all pairs of letters and then find the optimal path.,Calculate the absolute difference in ASCII values between consecutive letters in the word.,Iterate through the word and use a hash map to store the shortest distance from 'a' to each character.,Multiply the length of the word by the average distance between letters in the alphabet.,"Calculate the minimum clockwise or counter-clockwise distance between consecutive characters in the word and sum these distances, adding the length of the word.",Easy,algorithms,"String,Greedy"
2089,"Maximum Matrix Sum
You are given an n x n integer matrix. You can do the following operation any number of times: Two elements are considered adjacent if and only if they share a border. Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.","Calculate the absolute sum of all elements, regardless of sign.",Multiply the sum of all positive elements by the number of positive elements.,"Find the minimum element, negate it if negative, and add it to the total sum of absolute values.","Calculate the sum of absolute values of each row, then sum these row sums.",Calculate the absolute sum of all elements and subtract twice the minimum absolute value if the number of negative numbers is odd.,Medium,algorithms,"Array,Greedy,Matrix"
2090,"Number of Ways to Arrive at Destination
You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time. Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.",Dijkstra's algorithm with an incorrect tie-breaking rule favoring paths with fewer edges,"Bellman-Ford algorithm to find the shortest path, but without tracking the number of shortest paths",A* search algorithm using a heuristic that underestimates the remaining time to the destination and not tracking path counts,Breadth-first search (BFS) to explore all possible paths simultaneously and tracking only the first shortest path found,"Dijkstra's algorithm to find the shortest time, and simultaneously maintaining a count of shortest paths to each node",Medium,algorithms,"Dynamic Programming,Graph,Topological Sort,Shortest Path"
2091,"Number of Ways to Separate Numbers
You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was non-decreasing and that no integer had leading zeros. Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 109 + 7.",O(n^3),O(n log n),O(2^n),O(n!),O(n^2),Hard,algorithms,"String,Dynamic Programming,Suffix Array"
2127,"Employees Whose Manager Left the Company
Table: Employees  Find the IDs of the employees whose salary is strictly less than $30000 and whose manager left the company. When a manager leaves the company, their information is deleted from the Employees table, but the reports still have their manager_id set to the manager that left. Return the result table ordered by employee_id. The result format is in the following example.",Use a self-join on the Employees table where the manager_id matches an employee_id with a salary greater than or equal to $30000,Perform a subquery to select employee_ids with salaries less than $30000 and then filter those employees based on the absence of their manager_id in the employee_id column,Select employee_ids where the salary is less than $30000 and the manager_id exists in the employee_id column with a salary greater than $30000,Select employee_ids where the salary is less than $30000 and the manager_id is NULL,Select employee_ids where the salary is less than $30000 and the manager_id is NOT present in the employee_id column,Easy,database systems,Database
2106,"Find Greatest Common Divisor of Array
Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums. The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.","Return the largest number in the array directly, as it's always divisible by itself.",Calculate the product of the smallest and largest numbers and return that product.,"Return 1, as the greatest common divisor is always at least 1.",Find the absolute difference between the smallest and largest numbers and return that difference.,"Find the smallest and largest numbers in the array, then use the Euclidean algorithm to find their GCD.",Easy,algorithms,"Array,Math,Number Theory"
2107,"Find Unique Binary String
Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.",Create a truth table of all possible binary strings and then negate the diagonal,"Convert each binary string to its integer representation and find the smallest unused integer, then convert it back to binary",Sort the input strings lexicographically and then generate a new string that is lexicographically between two existing strings,Calculate the parity of each string and construct a string with alternating parities,"For each string at index i, flip the i-th bit, constructing a new string",Medium,algorithms,"Array,String,Backtracking"
2108,"Minimize the Difference Between Target and Chosen Elements
You are given an m x n integer matrix mat and an integer target. Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized. Return the minimum absolute difference. The absolute difference between two numbers a and b is the absolute value of a - b.","Use a greedy approach, always selecting the element closest to target/m in each row.","Apply dynamic programming, storing minimum absolute differences for subproblems with memoization, iterating through each row and possible sum.","Calculate all possible sums and find the minimum absolute difference with the target, ignoring the efficiency concerns with large input sizes.","Sort each row and then use a branch and bound approach, pruning branches that exceed the current minimum absolute difference.",Utilize dynamic programming to store achievable sums for each row and minimize the absolute difference to target in a bottom-up manner.,Medium,algorithms,"Array,Dynamic Programming,Matrix"
2109,"Find Array Given Subset Sums
You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order). Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them. An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0. Note: Test cases are generated such that there will always be at least one correct answer.",Sort the 'sums' array and return the differences between consecutive elements,"Calculate the mean of the 'sums' array and create an array with 'n' elements, each equal to the mean divided by 'n'",Return the first 'n' elements of the sorted 'sums' array,Return an array of 'n' random numbers between the minimum and maximum values in 'sums',"Iteratively identify the smallest positive difference between sums, add it to the result array, and remove it and its complement from the 'sums' array",Hard,algorithms,"Array,Divide and Conquer"
2112,"Minimum Difference Between Highest and Lowest of K Scores
You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k. Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized. Return the minimum possible difference.",Use a heap data structure to efficiently maintain the k largest elements seen so far.,"Sort the array and then iterate through all possible k-sized sub-arrays, calculating the difference.","Find the min and max values in the entire array, then return their difference if k > 1.",Use dynamic programming to store the minimum difference for subproblems of smaller sizes.,Sort the array and use a sliding window of size k to find the minimum difference between the highest and lowest scores.,Easy,algorithms,"Array,Sliding Window,Sorting"
2113,"Find the Kth Largest Integer in the Array
You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros. Return the string that represents the kth largest integer in nums. Note: Duplicate numbers should be counted distinctly. For example, if nums is [""1"",""2"",""2""], ""2"" is the first largest integer, ""2"" is the second-largest integer, and ""1"" is the third-largest integer.","Use a min-heap of size k to store the k largest numbers, then return the root.",Sort the array lexicographically and return the element at index k-1.,"Convert each string to an integer, sort the resulting array of integers, and return the element at index nums.length - k as a string.",Use a hash map to count the frequency of each number and then iterate to find the kth largest.,"Use a max-heap of size k to store the k smallest numbers; after processing all elements, the root is the kth largest.",Medium,algorithms,"Array,String,Divide and Conquer,Sorting,Heap (Priority Queue),Quickselect"
2114,"Minimum Number of Work Sessions to Finish the Tasks
There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. A work session is when you work for at most sessionTime consecutive hours and then take a break. You should finish the given tasks in a way that satisfies the following conditions: Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above. The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i].","Greedily assign tasks to sessions until a session is full, then start a new session. This may not always yield the minimum.","Sort the tasks in descending order of time and then apply a greedy approach, which might reduce the number of sessions but isn't guaranteed optimal.",Use dynamic programming to store the minimum number of sessions needed to complete a subset of tasks. This can be computationally expensive.,Recursively try all possible combinations of tasks in each session and backtrack to find the minimum number of sessions. This will have exponential time complexity.,Use bitmasking and dynamic programming to explore all possible subsets of tasks in each session to find the optimal solution.,Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
2115,"Number of Unique Good Subsequences
You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of ""0""). Find the number of unique good subsequences of binary. Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","Use dynamic programming to count subsequences, distinguishing between those ending in '0' and '1', but without handling duplicates","Calculate all possible subsequences (2^n), then subtract the number of invalid subsequences (those with leading zeros) without accounting for uniqueness","Iterate through the binary string and for each '1', add 1 to the count, and for each '0', double the count, modulo 10^9 + 7","Treat the binary string as a number and convert it to decimal, then count the number of its divisors","Employ dynamic programming to track the counts of subsequences ending in '0' and '1', adding 1 if '0' is present to account for the '0' subsequence, all modulo 10^9 + 7",Hard,algorithms,"String,Dynamic Programming"
2102,"Find the Middle Index in Array
Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones). A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]. If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0. Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",Calculate prefix and suffix sums in separate loops and compare at each index.,Use binary search to find the middle index by comparing sums.,Sort the array and check if the median is the middle index.,Recursively divide the array into halves and check if the middle index is present in either half.,"Calculate the total sum and iterate through the array, maintaining left and right sums.",Easy,algorithms,"Array,Prefix Sum"
2103,"Find All Groups of Farmland
You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland. To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group. land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2]. Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.",Iterate through the land matrix and use a disjoint-set data structure to identify connected components and their bounding boxes.,"Perform a depth-first search on the land matrix, but only mark the top-left and bottom-right corners of each group as visited to avoid infinite loops.","Convert the matrix into a graph representation and use Dijkstra's algorithm to find the shortest paths between farmland cells, grouping those within a threshold distance.",Use dynamic programming to store the sizes of rectangular farmland regions and backtrack to find the corners.,"Iterate through the land matrix and use depth-first search or breadth-first search to find connected components of farmland, recording the top-left and bottom-right coordinates for each.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix"
2104,"Operations on Tree
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree. The data structure should support the following functions: Implement the LockingTree class:",Check only the node itself for being locked or unlocked.,"Implement locking and unlocking with a simple boolean array, ignoring the tree structure.","Use a global lock for the entire tree, preventing concurrent operations.",Locking is done using atomic operations on node values directly.,Use a separate lock status array and efficiently traverse ancestors and descendants to validate upgrade operations.,Medium,data structures,"Hash Table,Tree,Breadth-First Search,Design"
2105,"The Number of Good Subsets
You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers. Return the number of different good subsets in nums modulo 109 + 7. A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",Use dynamic programming where dp[i][mask] represents the number of subsets ending at index i with prime factor mask 'mask',Iterate through all possible subsets and check if the product is a product of distinct primes using trial division,Precompute all products of subsets and then filter out the ones which are the product of distinct primes,Use a greedy approach by always selecting the smallest number that doesn't violate the distinct prime condition,Use dynamic programming with a mask representing the set of prime factors and handle the presence of 1 separately,Hard,algorithms,"Array,Math,Dynamic Programming,Bit Manipulation,Bitmask"
2122,"Count Special Quadruplets
Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:","Use four nested loops to iterate through all possible quadruplets and check the condition, resulting in O(n^4) time complexity.","Sort the array first, then use three nested loops to find triplets that sum to a value that, when subtracted from an element later in the array, equals zero, resulting in O(n^3 log n) time complexity.","Use a hash map to store the counts of each number in the array and then use three nested loops to find combinations that satisfy the condition, resulting in O(n^3) time complexity but high space complexity.","Precompute all possible sums of pairs of elements and store them in a hash map. Then, iterate through the remaining pairs and check if the negative of their sum exists in the hash map. Avoids duplicates but still O(n^2) space.","Iterate through all possible quadruplets, checking the condition. Use early exit conditions to optimize but still maintain O(n^4) time complexity. Avoids unnecessary computations.",Easy,algorithms,"Array,Enumeration"
2123,"The Number of Weak Characters in the Game
You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei. Return the number of weak characters.",Sort the characters by attack in ascending order and then iterate through them to count weak characters based on defense.,"Use a nested loop to compare each character's properties against all other characters, incrementing a counter for each weak character found.",Sort the characters by defense in descending order and track the maximum attack seen so far to identify weak characters.,"Calculate the average attack and defense for all characters, then count characters with both values below the averages as weak.",Sort the characters by attack in descending order (or attack in ascending order and defense in descending order if attacks are equal) and maintain the maximum defense seen so far to count weak characters.,Medium,algorithms,"Array,Stack,Greedy,Sorting,Monotonic Stack"
2124,"First Day Where You Have Been in All the Rooms
There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day. Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n: Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.",Use dynamic programming to calculate the earliest visit day for each room based on `nextVisit`.,"Sort the `nextVisit` array to determine an optimal visiting order, then simulate the process.","Employ a greedy approach, always visiting the room with the smallest `nextVisit` value first.","Calculate the total number of rooms and use that to estimate the final day, then refine with binary search.","Simulate the room visiting process day by day, keeping track of visited rooms and the current day.",Medium,algorithms,"Array,Dynamic Programming"
2125,"GCD Sort of an Array
You are given an integer array nums, and you can perform the following operation any number of times on nums: Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.",Uses Depth-First Search to check connectivity based on prime factors.,Performs a bubble sort and checks if the number of swaps exceeds n/2.,Calculates the product of all numbers in the array and checks if it is a perfect square.,Verifies if the array is already sorted using a single pass.,Applies the Union-Find algorithm to check if indices of equal values are connected to their sorted positions via GCD relationships.,Hard,algorithms,"Array,Math,Union Find,Sorting"
2128,"Reverse Prefix of Word
Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing. Return the resulting string.","Modify the string in-place using a two-pointer approach, swapping characters until the middle is reached.","Create a new string by iterating backwards from the found character's index to the beginning, then appending the rest of the original string.",Use the `std::reverse` function from the `<algorithm>` header on a substring view of the `word` up to the index of `ch`.,"Split the string into two substrings at the index of `ch`, reverse the first substring, and then concatenate both substrings.","Find the index of 'ch', then reverse the substring from 0 to that index (inclusive) using a temporary string or character array, and concatenate with the remaining substring.",Easy,algorithms,"Two Pointers,String"
2129,"Number of Pairs of Interchangeable Rectangles
You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle. Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division). Return the number of pairs of interchangeable rectangles in rectangles.",O(n^2) by comparing each rectangle's ratio with every other rectangle.,O(n log n) by sorting the rectangles based on their ratios and then counting adjacent equal ratios.,O(n) by storing ratios in a set and then counting occurrences using the set's methods.,O(n log n) by using a heap data structure to maintain sorted ratios and efficiently count duplicates.,O(n) by using a hash map (dictionary) to store the count of each unique ratio.,Medium,algorithms,"Array,Hash Table,Math,Counting,Number Theory"
2130,"Maximum Product of the Length of Two Palindromic Subsequences
Given a string s, find two disjoint palindromic subsequences of s such that the product of their lengths is maximized. The two subsequences are disjoint if they do not both pick a character at the same index. Return the maximum possible product of the lengths of the two palindromic subsequences. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is palindromic if it reads the same forward and backward.","Use dynamic programming to find all palindromic subsequences and then check for disjointedness, maximizing the product.",Greedily pick the longest palindromic subsequence and then the longest disjoint palindromic subsequence from the remaining characters.,"Employ a recursive approach to generate all possible subsequences, filter for palindromes, check for disjointedness, and compute the product.",Sort the string and then find the two longest palindromic subsequences.,"Use bit masking to represent subsequences, check for palindromes and disjointedness, then maximize the product of lengths.",Medium,algorithms,"String,Dynamic Programming,Backtracking,Bit Manipulation,Bitmask"
2131,"Smallest Missing Genetic Value in Each Subtree
There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. Since node 0 is the root, parents[0] == -1. There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i. Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i. The subtree rooted at a node x contains node x and all of its descendant nodes.",Use Depth-First Search (DFS) to traverse each subtree and then iterate through genetic values from 1 to 10^5 to find the smallest missing value.,Precompute the set of all genetic values and then use a constant-time lookup to determine the smallest missing value for each subtree.,"For each node, collect all genetic values in the entire tree and remove the values in the subtree to find the smallest missing value.",Sort the nums array and find the smallest gap between two consecutive elements.,"Use DFS to find the node with genetic value 1, then expand the subtree from that node, tracking seen genetic values with a set, and incrementing a missing value counter until it's not in the set.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Union Find"
2116,"Count Number of Pairs With Absolute Difference K
Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k. The value of |x| is defined as:",Use nested loops to compare each pair and count if the absolute difference equals k. This approach has O(n^2) time complexity.,Sort the array and then use binary search for each element to find pairs with the desired difference. This optimizes the search to O(n log n).,Employ a hash map to store the frequency of each number and then iterate through the map to find pairs by checking for num + k and num - k.,Divide the array into sub-arrays and recursively find pairs in each sub-array. Combine the results to get the total count.,"Utilize a frequency array (or hash map) to count occurrences of each number. Iterate through the input, checking for nums[i] + k in the frequency array.",Easy,algorithms,"Array,Hash Table,Counting"
2117,"Find Original Array From Doubled Array
An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array. Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.",Sort the 'changed' array and use two pointers to identify pairs of numbers where one is twice the other.,Iterate through the 'changed' array and store each number and its double in a hash table. Return the keys.,"Calculate the sum of all elements in 'changed'. Divide the sum by two. If the result is an integer, return an array with that single element.",Find the minimum element in 'changed'. Return an array containing only this element.,"Use a frequency map to count occurrences of each number in 'changed'. Iterate through the sorted keys. If count[key] > count[2*key] at any point, return an empty array. Otherwise, build the original array.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting"
2117,"Find Original Array From Doubled Array
An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array. Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.",Sort the 'changed' array and use two pointers to identify pairs of numbers where one is twice the other.,Iterate through the 'changed' array and store each number and its double in a hash table. Return the keys.,"Calculate the sum of all elements in 'changed'. Divide the sum by two. If the result is an integer, return an array with that single element.",Find the minimum element in 'changed'. Return an array containing only this element.,"Use a frequency map to count occurrences of each number in 'changed'. Iterate through the sorted keys. If count[key] > count[2*key] at any point, return an empty array. Otherwise, build the original array.",Medium,algorithms,"Array,Hash Table,Greedy,Sorting"
2118,"Maximum Earnings From Taxi
There are n points on a road you are driving your taxi on. The n points on the road are labeled from 1 to n in the direction you are going, and you want to drive from point 1 to point n to make money by picking up passengers. You cannot change the direction of the taxi. The passengers are represented by a 0-indexed 2D integer array rides, where rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride from point starti to point endi who is willing to give a tipi dollar tip. For each passenger i you pick up, you earn endi - starti + tipi dollars. You may only drive at most one passenger at a time. Given n and rides, return the maximum number of dollars you can earn by picking up the passengers optimally. Note: You may drop off a passenger and pick up a different passenger at the same point.","Use dynamic programming with a 1D array to store the maximum earnings up to each point, iterating through rides in their original order.","Sort the rides by end point and use a greedy approach, always picking the ride with the highest tip.","Employ recursion, exploring all possible combinations of rides and choosing the one that yields the maximum earnings.","Create a graph where nodes represent points and edges represent rides, then find the longest path from point 1 to point n.","Sort the rides by end point and use dynamic programming to store the maximum earnings up to each end point, considering whether to take each ride or not.",Medium,algorithms,"Array,Binary Search,Dynamic Programming,Sorting"
2119,"Minimum Number of Operations to Make Array Continuous
You are given an integer array nums. In one operation, you can replace any element in nums with any integer. nums is considered continuous if both of the following conditions are fulfilled: For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous. Return the minimum number of operations to make nums continuous.",O(n^2) - Iterate through each element and compare with every other element to find the longest continuous sequence.,"O(n log n) - Sort the array, then use a sliding window approach to find the longest continuous sequence.",O(n) - Use dynamic programming to store the lengths of continuous sub-sequences ending at each index.,"O(1) - Since the problem guarantees a solution, it can be found in constant time.",O(n log n) - Sort the array and use binary search or a two-pointer approach to find the longest continuous subsequence after removing duplicates.,Hard,algorithms,"Array,Binary Search"
2137,"Final Value of Variable After Performing Operations
There is a programming language with only four operations and one variable X: Initially, the value of X is 0. Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.",Using bubble sort with early stopping optimization,Employing a selection sort algorithm,Applying insertion sort in place,Implementing quicksort with random pivot selection,"Leveraging counting sort, assuming a limited range of characters",Easy,algorithms,"Array,String,Simulation"
2138,"Sum of Beauty in the Array
You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals: Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.","Calculate the sum of the array using dynamic programming, storing intermediate sums.","Iterate through the array and for each element, compute beauty by comparing with the maximum and minimum of the entire array.","Sort the array first, then iterate and calculate beauty based on sorted order.","Compute the beauty of each element based only on its immediate neighbors, ignoring the rest of the array.","Iterate through the array from index 1 to length - 2 and for each element, determine its beauty based on the specified conditions, accumulating the sum.",Medium,algorithms,Array
2139,"Detect Squares
You are given a stream of points on the X-Y plane. Design an algorithm that: An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis. Implement the DetectSquares class:","Store all points and iterate through them to find potential squares, resulting in O(n^3) complexity.","Use a hash map to store points and check for squares using brute force, giving O(n^2) complexity.","Sort the points and use binary search to find potential corners of a square, with O(n log n) pre-processing time.",Keep a running sum of x and y coordinates to identify points that might form a square,"Use a hash map to count point occurrences and efficiently check for squares using the count of points forming the other corners, in O(1) per query.",Medium,algorithms,"Array,Hash Table,Design,Counting"
2140,"Longest Subsequence Repeated k Times
You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times. Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.",Use dynamic programming to find all possible subsequences and check their repetition,Employ a greedy algorithm that iteratively selects the most frequent characters,Sort the string and then look for repeating substrings of length k,Recursively generate all possible subsequences and check for repetition k times,Use a frequency analysis and backtracking to find the longest lexicographically largest repeated subsequence,Hard,algorithms,"String,Backtracking,Greedy,Counting,Enumeration"
2144,"Maximum Difference Between Increasing Elements
Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j]. Return the maximum difference. If no such i and j exists, return -1.",O(n^2) by comparing every pair of elements in the array.,O(n log n) by sorting the array first and then finding the difference between the largest and smallest elements.,O(n) by keeping track of the maximum element seen so far and calculating the difference with the current element.,O(1) by assuming the first and last elements always represent the maximum difference.,"O(n) by iterating through the array, maintaining a minimum element seen so far, and updating the maximum difference.",Easy,algorithms,Array
2145,"Grid Game
You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix. Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another. The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",Always select the row with fewer remaining points at each step.,Choose a random path for the first robot to minimize the other robot's choices.,Calculate all possible paths for both robots and choose the optimal paths with dynamic programming.,"The first robot always moves along the top row first, then the bottom row.","Calculate prefix and suffix sums for each row, and for each possible path of the first robot, calculate the maximum points the second robot can collect, then minimize over these maximums.",Medium,algorithms,"Array,Matrix,Prefix Sum"
2146,"Check if Word Can Be Placed In Crossword
You are given an m x n matrix board, representing the current state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells. A word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if: Given a string word, return true if word can be placed in board, or false otherwise.","Employ backtracking, exploring all possible placements and pruning branches that violate the crossword constraints.",Convert the matrix and word into regular expressions and check for a match.,"Use dynamic programming to store the results of subproblems, such as fitting parts of the word.","Perform a brute-force search, checking every possible position and orientation without considering constraints early.","Iterate through the board, identifying potential starting points for the word, then verifying if the word fits given the crossword's constraints and orientations.",Medium,algorithms,"Array,Matrix,Enumeration"
2147,"The Score of Students Solving Math Expression
You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations: You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules: Return the sum of the points of the students.","Evaluate the expression strictly from left to right, ignoring operator precedence.","Evaluate the expression strictly from right to left, ignoring operator precedence.","Evaluate multiplication before addition only for adjacent operands, otherwise left to right.",Convert the expression to postfix notation and then evaluate it without considering precedence.,"Evaluate the expression strictly from left to right, summing the result modulo 1000 to prevent overflow.",Hard,algorithms,"Array,Math,String,Dynamic Programming,Stack,Memoization"
2132,"Convert 1D Array Into 2D Array
You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.","Use a sliding window of size 'n' across the 1D array, appending each window as a row to the 2D array.",Create a 2D array of size m x n filled with zeros and then populate it by iterating the 1D array row-wise.,"Reshape the 1D array using numpy's reshape function if the product of 'm' and 'n' equals the array length, otherwise return an empty array.",Recursively divide the 1D array into sub-arrays of size 'n' and append them as rows to the 2D array.,"Check if m * n equals the length of the 1D array. If so, iterate through the 1D array and populate the 2D array based on row and column indices calculated from the 1D array index.",Easy,algorithms,"Array,Matrix,Simulation"
2133,"Number of Pairs of Strings With Concatenation Equal to Target
Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.","Iterate through all possible pairs and concatenate them, then compare with the target string.","Convert each number string in 'nums' to an integer, then generate pairs and check if the sum equals the target.",Use a hash map to store the frequency of each string in 'nums' and efficiently count pairs that concatenate to the target.,"Sort the 'nums' array lexicographically, then use binary search to find pairs that concatenate to the target.",Use nested loops to iterate through all distinct pairs of strings in 'nums' and check if their concatenation equals the target string.,Medium,algorithms,"Array,String"
2134,"Maximize the Confusion of an Exam
A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation: Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.","Use dynamic programming to calculate the longest consecutive sequence without considering the 'k' constraint, then adjust based on 'k'.","Iterate through all possible substrings of 'answerKey' and count the 'T's and 'F's, applying the 'k' operation to maximize the consecutive counts.",Sort the 'answerKey' string alphabetically and count the longest consecutive 'T's and 'F's sequences.,Recursively divide the 'answerKey' string into smaller subproblems and find the maximum consecutive 'T's and 'F's in each subproblem.,"Use a sliding window approach, expanding the window until the number of 'T's or 'F's to be flipped exceeds 'k', then shrink the window from the left.",Medium,algorithms,"String,Binary Search,Sliding Window,Prefix Sum"
2135,"Maximum Number of Ways to Partition an Array
You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions: You are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged. Return the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.","Use dynamic programming to track the prefix and suffix sums, optimizing for space by using a single array.","Calculate prefix and suffix sums, then iterate through the array, checking for valid partitions without considering the change to 'k'.","Sort the array, then calculate prefix and suffix sums to quickly find potential partition points.",Use a hash map to store all possible prefix sums and efficiently check for valid partitions.,"Compute prefix and suffix sums, then iterate, considering the original array and the modified array (with one element changed to 'k') separately to maximize valid partitions.",Hard,algorithms,"Array,Hash Table,Counting,Enumeration,Prefix Sum"
2154,"Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'. A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same. Return the minimum number of moves required so that all the characters of s are converted to 'O'.","Recursively check all possible combinations of moves, pruning branches that exceed a known minimum","Iterate through the string, applying a move whenever an 'X' is encountered, regardless of consecutive 'X's","Count the total number of 'X' characters and divide by 3, rounding up to the nearest integer",Use dynamic programming to store the minimum moves needed to convert prefixes of the string,"Iterate through the string; if an 'X' is found, increment the move count and skip the next two characters",Easy,algorithms,"String,Greedy"
2155,"Find Missing Observations
You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls. You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n. Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array. The average value of a set of k numbers is the sum of the numbers divided by k. Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.",Use dynamic programming to minimize the difference between the target sum and the achievable sum with each roll,Return an array of n ones if the calculated total sum is within a valid range,"Calculate the required total sum and distribute it evenly across the n missing rolls, rounding if necessary",Check if the required average is within the possible range (1-6) and return an empty array if not,"Calculate the total sum of missing rolls, check for feasibility (between n and 6n), and distribute the sum into an array of length n",Medium,algorithms,"Array,Math,Simulation"
2156,"Stone Game IX
Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the ith stone. Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn). Assuming both players play optimally, return true if Alice wins and false if Bob wins.",Alice wins if there are more stones with value 1 modulo 3 than stones with value 2 modulo 3,Bob wins if the number of stones is even and the sum of stones is not divisible by 3,"Alice wins if the count of stones with value 0 modulo 3 is greater than 1, and the counts of other stones are balanced",Bob always wins if the total number of stones is less than 5,"Alice wins if the number of stones with value 0 modulo 3 is even, and the absolute difference between the number of stones with value 1 and 2 modulo 3 is greater than 2",Medium,algorithms,"Array,Math,Greedy,Counting,Game Theory"
2157,"Smallest K-Length Subsequence With Occurrences of a Letter
You are given a string s, an integer k, a letter letter, and an integer repetition. Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.","Use a greedy approach, always selecting the lexicographically smallest character that satisfies the repetition count of 'letter'.",Sort the string 's' and take the first k characters. Replace the last characters with 'letter' to satisfy the repetition count if needed.,"Generate all possible subsequences of length k, filter those that meet the repetition criteria, and then find the lexicographically smallest one.","Iterate through 's', maintaining a sliding window of size k, and greedily replace characters with 'letter' to satisfy repetition count.","Maintain a stack of candidate characters, iterating through 's' and popping larger characters if it allows for a smaller subsequence while ensuring 'letter' appears enough times and the length is k.",Hard,algorithms,"String,Stack,Greedy,Monotonic Stack"
2160,"Minimum Operations to Make a Uni-Value Grid
You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid. A uni-value grid is a grid where all the elements of it are equal. Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.",Calculate the median of the grid elements and sum the absolute differences divided by x,"Calculate the mean of the grid elements and sum the absolute differences divided by x, rounding up",Find the mode of the grid elements and sum the absolute differences divided by x,"Sort the grid elements, then iterate through the sorted elements and greedily equalize them to the first element","Sort the grid elements, find the median, and sum the absolute differences between each element and the median, divided by x. Return -1 if any difference isn't divisible by x.",Medium,algorithms,"Array,Math,Sorting,Matrix"
2161,"Stock Price Fluctuation
You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp. Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream correcting the price of the previous wrong record. Design an algorithm that: Implement the StockPrice class:","Use a heap to store timestamps and their prices, updating the heap on each new record.","Store timestamps and prices in a sorted array. On each new record, binary search for the timestamp and update the price.","Maintain two separate arrays: one sorted by timestamp and another sorted by price, updating both on each new record.","Use a simple array to store all records. When a query arrives, iterate through the array to find the latest price for each timestamp.","Use a hash map to store the latest price for each timestamp, and a sorted set to track all prices for efficient min/max retrieval.",Medium,data structures,"Hash Table,Design,Heap (Priority Queue),Data Stream,Ordered Set"
2162,"Partition Array Into Two Arrays to Minimize Sum Difference
You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays. Return the minimum possible absolute difference.",Use a greedy approach by always selecting the element that minimizes the immediate difference.,Sort the array and then iteratively place elements into the array with the smaller sum.,"Generate all possible subsets of size 'n', calculate the sums, and find the minimum difference.",Employ dynamic programming to store the sums achievable with 'k' elements from the first 'i' elements.,Use meet-in-the-middle to generate all possible sums for both halves of the input array and find the closest pairs.,Hard,algorithms,"Array,Two Pointers,Binary Search,Dynamic Programming,Bit Manipulation,Ordered Set,Bitmask"
2148,"Minimum Number of Moves to Seat Everyone
There are n availabe seats and n students standing in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student. You may perform the following move any number of times: Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat. Note that there may be multiple seats or students in the same position at the beginning.",Sort both arrays and calculate the sum of the absolute differences between corresponding elements after sorting.,Calculate the average position of seats and students and then minimize movements towards those averages.,Use a greedy approach where each student moves to the closest available seat without considering other students.,Generate all possible seat assignments to students and choose the assignment with the minimum total movement.,Sort both arrays and sum the absolute difference between the ith student and the ith seat to find the minimum moves.,Easy,algorithms,"Array,Sorting"
2149,"Remove Colored Pieces if Both Neighbors are the Same Color
There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece. Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first. Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.","If the number of 'A' moves possible is greater than the number of 'B' moves possible, Bob wins.",The player with the most pieces of their color at the start of the game always wins.,"If the string 'colors' contains more 'A's than 'B's, Alice wins; otherwise, Bob wins.",The winner is determined by who has the most consecutive pieces of their color at the beginning of the game.,"If the number of moves Alice can make is strictly greater than the number of moves Bob can make, Alice wins.",Medium,algorithms,"Math,String,Greedy,Game Theory"
2151,"The Time When the Network Becomes Idle
There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n. All servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels. The server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through. At the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server: The network becomes idle when there are no messages passing between servers or arriving at servers. Return the earliest second starting from which the network becomes idle.",Sum the patience values of all servers and multiply by 2,Find the maximum patience value and multiply it by the number of servers,Calculate the average patience value and multiply it by the network diameter,"Calculate the shortest path from each server to the master, double it, and use patience to determine resend times.","Calculate the shortest path from each server to the master (0), double it, and account for re-sends based on patience to find the latest return time.",Medium,algorithms,"Array,Breadth-First Search,Graph"
2168,"Check if Numbers Are Ascending in a Sentence
A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters. Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s). Return true if so, or false otherwise.","Split the string into words and use a stack to store the numbers encountered, comparing each number with the top of the stack.",Use regular expressions to extract all numbers and sort them to ensure they are ascending.,Convert the sentence into an array of integers and directly compare adjacent elements.,"Keep track of the previous number and current number, converting each token as needed, immediately returning `false` if the current is not greater.","Iterate through tokens, check if each is a number. If it is, compare it to the previous number seen, returning `false` if not ascending.",Easy,algorithms,String
2169,"Simple Bank System
You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i]. Execute all the valid transactions. A transaction is valid if: Implement the Bank class:","Transactions are processed in a single thread, potentially leading to race conditions if multiple transactions target the same account simultaneously.","The system relies solely on client-side validation to ensure transaction validity, making it vulnerable to manipulation.","Account balances are stored as floating-point numbers, which can lead to precision issues during financial calculations.","Transaction logs are written to a volatile memory location and not persisted to disk, resulting in data loss upon system failure.","The system lacks proper authorization checks, allowing any user to initiate transactions on any account.",Medium,security,"Array,Hash Table,Design,Simulation"
2170,"Count Number of Maximum Bitwise-OR Subsets
Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR. An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different. The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",Calculate the bitwise OR of all possible subsets and count those equal to the maximum OR value.,"Sort the array, calculate the bitwise OR of the entire sorted array, and return 1 if the result is the maximum possible OR, otherwise 0.",Use dynamic programming to store the bitwise OR of all subsets and count the occurrences of the maximum value.,"Find the largest element in the array and return its count, as it is likely to contribute the most to the bitwise OR.","Use recursion or backtracking to generate all possible subsets, compute their bitwise OR, and count subsets matching the maximum OR value.",Medium,algorithms,"Array,Backtracking,Bit Manipulation"
2171,"Second Minimum Time to Reach Destination
A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes. Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green. The second minimum value is defined as the smallest value strictly larger than the minimum value. Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n. Notes:",Use Dijkstra's algorithm and keep track of the two shortest distances to each node.,Use Depth-First Search (DFS) to find all possible paths and then determine the shortest and second shortest.,Calculate the shortest path and then multiply it by two to estimate the second shortest.,Use Breadth-First Search (BFS) ignoring traffic signals and then adjust the time by adding a constant representing signal delays.,"Use Breadth-First Search (BFS) keeping track of the two shortest times to reach each node, considering signal changes.",Hard,algorithms,"Breadth-First Search,Graph,Shortest Path"
2173,"Number of Valid Words in a Sentence
A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '. A token is a valid word if all three of the following are true: Examples of valid words include ""a-b."", ""afad"", ""ba-c"", ""a!"", and ""!"". Given a string sentence, return the number of valid words in sentence.",Use regular expressions to find all tokens and then validate them using a complex regex pattern.,"Split the sentence into tokens, convert each token into a list of characters, and manually check each condition.","Iterate through the sentence, keeping track of the current token, and use a series of if/else statements to validate.",Use a finite state machine to parse the sentence and identify valid tokens based on state transitions.,Split the sentence into tokens and implement a validation function that checks each token against the given rules.,Easy,algorithms,String
2174,"Next Greater Numerically Balanced Number
An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numerically balanced number strictly greater than n.",Brute force: Check all numbers greater than n until a balanced number is found.,Heuristic Search: Start with n and explore numbers formed by swapping digits.,Dynamic Programming: Build a table of balanced numbers up to a certain limit and search.,Greedy Approach: Incrementally build a balanced number from the most significant digit.,"Backtracking: Generate balanced numbers systematically, pruning branches that are less than or equal to n.",Medium,algorithms,"Math,Backtracking,Enumeration"
2175,"Count Nodes With the Highest Score
There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1. Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees. Return the number of nodes that have the highest score.","Compute the score using depth-first search, and update the count of highest scores in a separate pass after calculating all scores.","Use dynamic programming to store subtree sizes and calculate scores in a bottom-up manner, minimizing redundant calculations.","Employ a breadth-first search approach, calculating the score of each node as it is visited and updating the maximum score count.",Calculate node scores independently using recursive calls and store all scores in a hashmap before determining the count of the highest score.,"Perform a single depth-first search, calculating subtree sizes and node scores simultaneously, and maintaining the maximum score and its count during traversal.",Medium,algorithms,"Array,Tree,Depth-First Search,Binary Tree"
2176,"Parallel Courses III
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course. You must find the minimum number of months needed to complete all the courses following these rules: Return the minimum number of months needed to complete all the courses. Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).",Use Dijkstra's algorithm to find the shortest path between courses.,Perform a topological sort and then calculate the longest path using dynamic programming.,"Apply a greedy algorithm, always choosing the course with the shortest time.","Employ a brute-force approach, trying all possible course orderings.",Calculate the longest path in the DAG using dynamic programming and topological sorting.,Hard,algorithms,"Dynamic Programming,Graph,Topological Sort"
2163,"Kth Distinct String in an Array
A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string """". Note that the strings are considered in the order in which they appear in the array.",Use a sliding window to track the frequency of each string.,Sort the array lexicographically and then count distinct strings.,Use a trie data structure to efficiently store and count string occurrences.,"Recursively divide the array until single strings are obtained, then compare and count.","Use a hash map to count string frequencies, then iterate through the array to find the kth distinct string.",Easy,algorithms,"Array,Hash Table,String,Counting"
2164,"Two Best Non-Overlapping Events
You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized. Return this maximum sum. Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.","Use dynamic programming with a 2D array to store the maximum value achievable up to a given time, considering whether to attend the current event or not.",Sort the events by their end times and then use a greedy approach to select the events with the highest values that do not overlap.,Sort the events by their start times and use binary search to find the next non-overlapping event for each event.,Use a recursive approach to explore all possible combinations of two events and return the maximum sum of values for non-overlapping pairs.,"Sort events by end time; for each event, use binary search to find the latest non-overlapping event before it and combine values.",Medium,algorithms,"Array,Binary Search,Dynamic Programming,Sorting,Heap (Priority Queue)"
2165,"Plates Between Candles
There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring. Return an integer array answer where answer[i] is the answer to the ith query.","Calculate prefix sums of plates and candles, then use these to find the number of plates between the first and last candle within the range.",Iterate through each query range and count plates only if there is a candle to its left in the entire string s.,"For each query, iterate the substring, ignoring candles and counting all plates encountered.",Binary search the string to locate the middle plate and multiply it by the number of candles in the range.,"For each query, find the nearest candles to the left and right, then count the plates between those candles using prefix sums.",Medium,algorithms,"Array,String,Binary Search,Prefix Sum"
2166,"Number of Valid Move Combinations On Chessboard
There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard. When making a move for a piece, you choose a destination square that the piece will travel toward and stop on. You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square. Return the number of valid move combinations​​​​​. Notes:","The rook can't move diagonally, the queen only horizontally, vertically and diagonally, and the bishop only moves vertically","The rook can move diagonally, the queen only horizontally, vertically and diagonally, and the bishop can move horizontally and vertically","The rook can't move, the queen moves randomly, and the bishop moves as rook or queen","The rook and bishop cannot move, and the queen moves to the nearest edge","The rook can only move horizontally and vertically, the queen can move horizontally, vertically and diagonally, and the bishop can only move diagonally",Hard,algorithms,"Array,String,Backtracking,Simulation"
2166,"Number of Valid Move Combinations On Chessboard
There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard. When making a move for a piece, you choose a destination square that the piece will travel toward and stop on. You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square. Return the number of valid move combinations​​​​​. Notes:","The rook can't move diagonally, the queen only horizontally, vertically and diagonally, and the bishop only moves vertically","The rook can move diagonally, the queen only horizontally, vertically and diagonally, and the bishop can move horizontally and vertically","The rook can't move, the queen moves randomly, and the bishop moves as rook or queen","The rook and bishop cannot move, and the queen moves to the nearest edge","The rook can only move horizontally and vertically, the queen can move horizontally, vertically and diagonally, and the bishop can only move diagonally",Hard,algorithms,"Array,String,Backtracking,Simulation"
2181,"Smallest Index With Equal Value
Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist. x mod y denotes the remainder when x is divided by y.",Implement a binary search algorithm.,Use a hash table to store previously encountered indices.,Sort the array and check the first element.,Check only even indices to improve performance.,Iterate through the array and check if i % 10 equals nums[i].,Easy,algorithms,Array
2182,"Find the Minimum and Maximum Number of Nodes Between Critical Points
A critical point in a linked list is defined as either a local maxima or a local minima. A node is a local maxima if the current node has a value strictly greater than the previous node and the next node. A node is a local minima if the current node has a value strictly smaller than the previous node and the next node. Note that a node can only be a local maxima/minima if there exists both a previous node and a next node. Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].",O(1),O(n log n),O(n^2),O(log n),O(n),Medium,algorithms,Linked List
2183,"Minimum Operations to Convert Number
You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x: If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following: Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward. Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.",Use a greedy approach by always choosing the operation that brings x closest to the goal,Employ dynamic programming to store the minimum operations for each possible value of x,Sort the nums array and then use a binary search to find the optimal operations,Recursively explore all possible operation combinations until the goal is reached or a maximum depth is exceeded,"Use Breadth-First Search (BFS) to explore possible values of x, keeping track of the number of operations",Medium,algorithms,"Array,Breadth-First Search"
2184,"Check if an Original String Exists Given Two Encoded Strings
An original string, consisting of lowercase English letters, can be encoded by the following steps: For example, one way to encode an original string ""abcdefghijklmnop"" might be: Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false. Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.",Decompress both strings into their original forms and compare the resulting strings.,"Compare the lengths of the encoded strings. If they are different, return false. Otherwise, return true.",Use dynamic programming to determine the length of the shortest possible original string that could produce both encoded strings.,"Check if the sum of the lengths of the digits in s1 equals the sum of the lengths of the digits in s2. If not, return false. Otherwise return true.","Use two pointers to iterate through both strings simultaneously, handling characters and digit sequences, backtracking when mismatches occur to explore all possible interpretations.",Hard,algorithms,"String,Dynamic Programming"
data structures,2186,"Count Vowel Substrings of a String
A substring is a contiguous (non-empty) sequence of characters within a string. A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given a string word, return the number of vowel substrings in word.",Stack,Queue,Linked List,Tree,,"['string', 'substring', 'vowels']",Set
algorithms,2187,"Vowels of All Substrings
Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word. A substring is a contiguous (non-empty) sequence of characters within a string. Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.",Use dynamic programming to store the count of vowels in prefixes and calculate substrings from that.,"Iterate through the string and for each character, iterate through all possible substring lengths and count vowels.",Use regular expressions to find all substrings and then count the vowels in each substring.,Precompute the number of vowels in the entire string and then subtract vowels outside the substring range.,,"['string', 'substring', 'vowels']","For each vowel, calculate the number of substrings it appears in by multiplying its index+1 by the remaining length of the string."
algorithms,2188,"Minimized Maximum of Products Distributed to Any Store
You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type. You need to distribute all products to the retail stores following these rules: Return the minimum possible x.","Binary search on the range [1, max(quantities)] to find the minimum maximum allocation, checking feasibility by dividing each quantity by the mid-point and summing the results.","Sort the `quantities` array and greedily allocate the largest quantities to stores until all stores are full, then repeat with remaining quantities.",Use dynamic programming to determine the optimal distribution by considering all possible combinations of product assignments to stores.,"Allocate each product type to the store with the fewest products currently allocated, iterating until all products are assigned.",,"['binary search', 'optimization', 'greedy']","Perform a binary search on the possible range of the minimized maximum (1 to max(quantities)). For each mid-point, check if it's possible to distribute all products to the n stores such that no store receives more than mid-point products of any one type."
algorithms,2189,"Maximum Path Quality of a Graph
There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime. A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum). Return the maximum quality of a valid path. Note: There are at most four edges connected to each node.",Use Dijkstra's algorithm to find the shortest path and calculate the quality,"Perform a depth-first search (DFS) without tracking visited nodes, potentially leading to infinite loops and incorrect quality calculation","Calculate the sum of all node values and return it if maxTime is non-negative, otherwise return 0",Employ a breadth-first search (BFS) to find all possible paths and select the one with the maximum quality without considering time constraints,,"['graph', 'DFS', 'pathfinding']","Use a depth-first search (DFS) to explore all valid paths within the time limit, tracking visited nodes and their values to compute the maximum quality"
algorithms,2177,"Check Whether Two Strings are Almost Equivalent
Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3. Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise. The frequency of a letter x is the number of times it occurs in the string.",Use nested loops to compare the frequency of each character in word1 with every character in word2.,Create a single frequency map for both strings combined and check if any count exceeds 3.,Sort both strings alphabetically and then compare them character by character.,"Use a sliding window approach on both strings, comparing the characters within the window.",,"['string', 'frequency map', 'hash map']",Create frequency maps for both strings and check if the absolute difference in frequencies for each character is at most 3.
2178,"Walking Robot Simulation II
A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (""North"", ""East"", ""South"", and ""West""). A robot is initially at cell (0, 0) facing direction ""East"". The robot can be instructed to move for a specific number of steps. For each step, it does the following. After the robot finishes moving the number of steps required, it stops and awaits the next instruction. Implement the Robot class:",Use a boolean matrix to mark visited cells and backtrack if a cycle is detected during movement,"Store the robot's path as a string of direction characters (N, E, S, W) and analyze the string for errors",Precompute all possible robot positions and directions for every number of steps to allow for O(1) lookups,Simulate the robot's movement using modulo arithmetic on the grid dimensions to handle boundary conditions,"Maintain the robot's current position and direction, updating them based on the remaining steps and boundary constraints",Medium,algorithms,"Design,Simulation"
2179,"Most Beautiful Item for Each Query
You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively. You are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0. Return an array answer of the same length as queries where answer[j] is the answer to the jth query.",Use binary search on the unsorted 'items' array for each query.,"Sort 'queries' and 'items' by price independently, then iterate linearly through both.","Iterate through 'items' for each query, keeping track of the maximum beauty encountered so far.",Calculate the cumulative product of beauties for each price point and use that for queries.,"Sort 'items' by price, precompute the maximum beauty for each price, and use binary search for each query.",Medium,algorithms,"Array,Binary Search,Sorting"
2180,"Maximum Number of Tasks You Can Assign
You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]). Additionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill. Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.",Sort both `tasks` and `workers` and greedily assign workers to tasks without considering pills.,"Use dynamic programming to determine the optimal assignment of workers to tasks with and without pills, maximizing completed tasks.",Iterate through all possible combinations of assigning pills to workers and then check for maximum task completion.,Only assign pills to workers with the lowest strength and then attempt to complete tasks in ascending order of strength.,"Sort `tasks` and `workers`, and use a binary search approach to find the maximum number of tasks that can be completed, optimally using the pills.",Hard,algorithms,"Array,Binary Search,Greedy,Queue,Sorting,Monotonic Queue"
2195,"Time Needed to Buy Tickets
There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line. Return the time taken for the person initially at position k (0-indexed) to finish buying tickets.","O(n^2), where n is the total number of tickets across all people, due to repeated array slicing","O(n log n), where n is the number of people, due to sorting operations","O(sum(tickets)), representing the sum of all values in the tickets array, reflecting the total tickets bought","O(n*k), where n is the number of people and k is the target person's index, due to the nested loops","O(max(tickets[0...k]) + sum(min(tickets[i], tickets[k])) for i in 0...n-1), accurately representing time complexity by considering how many times person k loops",Easy,algorithms,"Array,Queue,Simulation"
2196,"Reverse Nodes in Even Length Groups
You are given the head of a linked list. The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers (1, 2, 3, 4, ...). The length of a group is the number of nodes assigned to it. In other words, Note that the length of the last group may be less than or equal to 1 + the length of the second to last group. Reverse the nodes in each group with an even length, and return the head of the modified linked list.","Use a stack to store each group, reverse if even, and then reconstruct the list","Recursively process the list, reversing even-length groups in each recursive call","Convert the linked list to an array, reverse even length subarrays, and reconstruct the linked list","Create a dummy head, iterate using two pointers (slow/fast) to identify groups, and reverse in-place if even","Iteratively process the linked list, tracking group length, and reversing even-length groups using pointer manipulation",Medium,algorithms,Linked List
2197,"Decode the Slanted Ciphertext
A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows. originalText is placed first in a top-left to bottom-right manner. The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText. encodedText is then formed by appending all characters of the matrix in a row-wise fashion. The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if originalText = ""cipher"" and rows = 3, then we encode it in the following manner: The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = ""ch ie pr"". Given the encoded string encodedText and number of rows rows, return the original string originalText. Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.","Divide the length of the encoded text by the number of rows to determine the number of columns, and then fill a matrix diagonally.",The original text cannot be uniquely determined without knowing the number of columns; return an error.,Create a square matrix with side length equal to the number of rows and fill it diagonally to recover the original text.,Append the encoded string to itself 'rows' times and then extract characters from the resulting string.,"Calculate the number of columns, create a matrix, fill it row-wise with the encoded text, and then read it diagonally to obtain the original text.",Medium,algorithms,"String,Simulation"
2198,"Process Restricted Friend Requests
You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1. You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people. Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj. A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests. Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not. Note: If uj and vj are already direct friends, the request is still successful.",A cycle would be created in the graph if the merge occurs.,The number of nodes exceeds the maximum allowed.,The two people already have a direct connection.,There are more restrictions than people in the network.,Adding the edge between the two people would indirectly connect two restricted people.,Hard,algorithms,"Union Find,Graph"
2199,"Two Furthest Houses With Different Colors
There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house. Return the maximum distance between two houses with different colors. The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.","Start from both ends and shrink until different colors are found, returning the initial difference.","Iterate through all pairs of houses and calculate the distance if the colors are different, keeping track of the maximum.",Sort the colors array and then find the distance between the first and last houses.,"Use binary search to find the furthest houses with different colors, optimizing the search process.","Iterate from the left to find the furthest house on the right with a different color and iterate from the right to find the furthest house on the left with a different color, then return the maximum of the two distances.",Easy,algorithms,"Array,Greedy"
1310,"Watering Plants
You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. There is a river at x = -1 that you can refill your watering can at. Each plant needs a specific amount of water. You will water the plants in the following way: You are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis. Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.",Depth-First Search (DFS),Greedy Algorithm,Dynamic Programming,Divide and Conquer,Simulation,Medium,algorithms,Array
1294,"Range Frequency Queries
Design a data structure to find the frequency of a given value in a given subarray. The frequency of a value in a subarray is the number of occurrences of that value in the subarray. Implement the RangeFreqQuery class: A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).","Use a hash map to store element frequencies in the entire array, then iterate through the subarray to count",Sort the entire array and use binary search to find the first and last occurrences of the value in the subarray,Precompute frequency counts for all possible subarrays to answer queries in O(1) time,Use a binary search tree to store the array elements and their indices for efficient searching within the subarray,"Use a hash map to store the indices of each value, and then perform binary searches within the index lists corresponding to the given subarray range",Medium,data structures,"Array,Hash Table,Binary Search,Design,Segment Tree"
2202,"Sum of k-Mirror Numbers
A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k. Given the base k and the number n, return the sum of the n smallest k-mirror numbers.",Use dynamic programming to store already computed palindromes and extend them.,Employ a brute-force approach by checking every integer for being a palindrome in base-10 and base-k.,"Generate palindromes only in base-k, then convert them to base-10 and check if they are base-10 palindromes.",Generate all base-10 palindromes up to a certain limit and only check if they are also base-k palindromes.,"Generate palindromes in both base-10 and base-k simultaneously, optimizing for efficiency.",Hard,algorithms,"Math,Enumeration"
2190,"Count Common Words With One Occurrence
Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.",Use nested loops to compare each word in words1 with every word in words2 and count matches.,Convert both arrays into sets and find the intersection of the sets. The size of the intersection is the answer.,"Create a frequency map for words1 and words2 separately, then count words with frequency > 1 in both maps.","Sort both arrays lexicographically, then iterate and count common words.","Create frequency maps for both arrays, and then iterate through the maps to count words appearing exactly once in each.",Easy,algorithms,"Array,Hash Table,String,Counting"
2192,"Minimum Cost Homecoming of a Robot in a Grid
There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol). The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n. Return the minimum total cost for this robot to return home.",Recursively explore all possible paths and select the one with minimum cost,Use Dijkstra's algorithm to find the shortest path from start to home,Apply the A* search algorithm using Manhattan distance as the heuristic,Always move towards the home cell in each step without considering costs,"Iterate through rows and columns, summing costs until reaching the home position",Medium,algorithms,"Array,Greedy,Matrix"
2193,"Count Fertile Pyramids in a Land
A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren. A pyramidal plot of land can be defined as a set of cells with the following criteria: An inverse pyramidal plot of land can be defined as a set of cells with similar criteria: Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells. Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.","Brute-force search all possible submatrices and check for pyramid conditions, leading to O(m^3 * n^3) complexity.","Use dynamic programming to precompute the maximum height of a pyramid ending at each cell, but fail to consider overlapping pyramids correctly.","Calculate the area of all 1's in the grid and assume pyramids can only exist within this area, underestimating the count.","Iterate through the grid and greedily form pyramids whenever a '1' is encountered, which might not form the largest possible pyramid.","Use dynamic programming to compute the maximum height of a pyramid and inverse pyramid ending at each cell, summing the valid heights.",Hard,algorithms,"Array,Dynamic Programming,Matrix"
2210,"Find Target Indices After Sorting Array
You are given a 0-indexed integer array nums and a target element target. A target index is an index i such that nums[i] == target. Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.","Use bubble sort and then linearly search for the target, storing indices.","Use a hash map to count occurrences of each number, then reconstruct the sorted array and identify target indices.",Apply binary search repeatedly to find each occurrence of the target after partially sorting the array.,Return the indices of the target in the original unsorted array.,"Sort the array using an efficient algorithm (e.g., merge sort, quicksort) and then linearly scan to find target indices.",Easy,algorithms,"Array,Binary Search,Sorting"
2211,"K Radius Subarray Averages
You are given a 0-indexed array nums of n integers, and an integer k. The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1. Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i. The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.","Using a sliding window of size 'k', calculate the sum for each window",Iterate through the array and calculate the average using brute force for each index 'i',Precompute prefix sums and use them to calculate the sum of elements within the radius 'k',Use dynamic programming to store and reuse subarray sums,"Calculate a cumulative sum array, and then compute averages using windowed differences from the cumulative sums",Medium,algorithms,"Array,Sliding Window"
2212,"Removing Minimum and Maximum From Array
You are given a 0-indexed array of distinct integers nums. There is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array. A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array. Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.","Remove from the front, then remove from the front again.","Remove from the back, then remove from the back again.","Remove from the front, then remove from the back.",Sort the array and remove the first and last elements.,Consider all combinations of removing from front/back and return the minimum.,Medium,algorithms,"Array,Greedy"
2213,"Find All People With Secret
You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson. Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa. The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.","Use a depth-first search (DFS) to traverse the meeting graph, starting from person 0 and firstPerson, and mark visited nodes as having the secret.","Sort the meetings by time, then iterate through them. For each meeting, if either person has the secret, share it with the other, storing the secret holders in a set.",Use a priority queue to process meetings in chronological order. Only share the secret if at least one person in the meeting already has it.,"Maintain a disjoint set data structure representing connected components. For each meeting time, union the sets of people who met. Then, check if person 0's set contains the secret.",Sort meetings by time. Use a Union-Find data structure to track who knows the secret at each time. Reset the Union-Find for each time to only propagate secrets forward.,Hard,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph,Sorting"
2215,"Finding 3-Digit Even Numbers
You are given an integer array digits, where each element is a digit. The array may contain duplicates. You need to find all the unique integers that follow the given requirements: For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements. Return a sorted array of the unique integers.",Use a hash table to store the counts of each digit and generate all permutations,Sort the input array and use recursion to generate all possible 3-digit numbers,Iterate through all possible 3-digit numbers and check if they can be formed using the digits array,Convert the digits array to a string and use string manipulation to find the numbers,"Count the occurrences of each digit, then iterate through all possible 3-digit even numbers, checking if the digits are available",Easy,algorithms,"Array,Hash Table,Sorting,Enumeration"
2216,"Delete the Middle Node of a Linked List
You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list. The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.",Deleting the node by setting the `next` pointer of the node before the middle to point to the node after the middle node,"Finding the middle node using a single pass with two pointers, where one pointer moves twice as fast as the other",Determining the length of the list and then iterating to the middle node to delete it,Setting the value of the middle node to the next node's value and then removing the next node,Finding the middle node using the Tortoise and Hare algorithm and updating the `next` pointer of the node before the middle node,Medium,data structures,"Linked List,Two Pointers"
2217,"Step-By-Step Directions From a Binary Tree Node to Another
You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t. Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction: Return the step-by-step directions of the shortest path from node s to node t.","Perform a breadth-first search from 'startValue' to 'destValue', recording the path.","Find the lowest common ancestor (LCA) of 'startValue' and 'destValue'. Path: start to LCA (U's), LCA to dest (L/R's).",Calculate the depths of 'startValue' and 'destValue' and use depth-first search from the root.,"Use Dijkstra's algorithm on the tree, treating each edge as having a weight of 1.",Find the paths from the root to 'startValue' and 'destValue'. The path from 'startValue' to 'destValue' goes up to the LCA and then down.,Medium,algorithms,"String,Tree,Depth-First Search,Binary Tree"
2201,"Valid Arrangement of Pairs
You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any valid arrangement of pairs. Note: The inputs will be generated such that there exists a valid arrangement of pairs.","Employ a greedy algorithm, picking pairs with the smallest start value first.",Sort the pairs based on their end values in ascending order.,Represent the pairs as a directed graph and search for a Hamiltonian path.,"Randomly shuffle the pairs and check if the arrangement is valid, repeating until a valid arrangement is found.","Construct a directed graph where each pair is an edge, find an Eulerian path, and return the corresponding arrangement.",Hard,algorithms,"Depth-First Search,Graph,Eulerian Circuit"
2204,"Find Subsequence of Length K With the Largest Sum
You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum. Return any such subsequence as an integer array of length k. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",Sort the input array and select the first k elements.,Randomly pick k elements; the expected value will be correct.,Use dynamic programming to find all possible subsequences of length k and select the largest sum.,Iterate through all possible combinations of k elements and compare their sums.,"Create an array to store indices sorted by value, pick the largest k values from the sorted indices array.",Easy,algorithms,"Array,Hash Table,Sorting,Heap (Priority Queue)"
2205,"Find Good Days to Rob the Bank
You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time. The ith day is a good day to rob the bank if: More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]. Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.",Use dynamic programming to find the longest increasing and decreasing subsequences ending at each day.,Iterate through the security array and check if the time window around each day satisfies the increasing/decreasing conditions using nested loops.,Sort the security array and then check if the condition holds for the original indices of the sorted elements.,Maintain a heap of size 2*time and update it as you iterate to quickly find the minimum and maximum security values within the window.,"Precompute the number of consecutive non-increasing and non-decreasing days from both ends, and check if both are at least 'time' for each day.",Medium,algorithms,"Array,Dynamic Programming,Prefix Sum"
2206,"Detonate the Maximum Bombs
You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb. The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range. You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges. Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.",Use dynamic programming to compute the maximum detonated bombs for each bomb as the starting point.,"Employ a greedy algorithm, always detonating the bomb with the largest radius first.",Sort the bombs based on their radius and detonate the bomb that would detonate all the smaller ones,"Randomly select a bomb and use that as a starting point, repeating many times to estimate the max.",Use a graph representation to model bomb detonation relationships and perform a Depth-First Search (DFS) from each bomb to find the maximum reachable bombs.,Medium,algorithms,"Array,Math,Depth-First Search,Breadth-First Search,Graph,Geometry"
data structures,2207,"Sequentially Ordinal Rank Tracker
A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system. Implement the SORTracker class:","Hash table, for fast lookups by location name","Array, for storing locations in the order they are added","Stack, for maintaining a LIFO ordering of locations","Singly linked list, for easy insertion of new locations",,"['data structures', 'binary search tree', 'ranking']","Self-balancing binary search tree (e.g., AVL or Red-Black tree), for efficient insertion and retrieval of the k-th smallest element"
algorithms,2226,"Rings and Rods
There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9. You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where: For example, ""R3G2B1"" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return the number of rods that have all three colors of rings on them.","Use a single bitmask to represent the presence of colors on each rod, shifting bits for each color",Create a dictionary where keys are rod numbers and values are lists of colors,Utilize a set data structure for each rod to store unique colors and count rods with three elements in their set,"Employ a 3D array to represent rods and colors, incrementing counts as rings are processed",,"['hash map', 'string manipulation', 'bit manipulation']","Maintain a dictionary where keys are rod numbers and values are strings containing unique colors, returning the count of strings with length 3"
algorithms,2227,"Sum of Subarray Ranges
You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray. Return the sum of all subarray ranges of nums. A subarray is a contiguous non-empty sequence of elements within an array.","Calculate the range of all subarrays using brute force, resulting in O(n^3) time complexity.",Sort the entire array first and then compute the sum of subarray ranges which will give incorrect results.,Use dynamic programming to store the minimum and maximum values seen so far.,Only consider subarrays of size 1 and size n to reduce computation time,,"['monotonic stack', 'subarray', 'range']","Use a monotonic stack to efficiently find the next smaller and greater elements for each element, calculating their contribution to the total sum."
algorithms,2228,"Watering Plants II
Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way: Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",Divide the total water needed by the combined capacity of Alice and Bob's watering cans.,"Simulate Alice and Bob watering from opposite ends, and if they meet at the same plant, only refill the one with less water.","Always refill both watering cans at the midpoint plant if n is odd, regardless of current water level.","Refill Alice's can if her current water is less than Bob's capacity, and vice versa, regardless of plant needs.",,"['arrays', 'simulation', 'two pointers']","Simulate Alice and Bob watering from opposite ends, refilling their cans when needed and counting the refills."
algorithms,2229,"Maximum Fruits Harvested After at Most K Steps
Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique. You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return the maximum total number of fruits you can harvest.","Use a greedy approach, always moving towards the fruit with the highest amount.",Apply dynamic programming to store the maximum fruits harvestable for each position and remaining steps.,Simulate all possible paths recursively and choose the path with the maximum fruit harvested.,Sort the fruits array by amount and always pick the fruits with the highest amount first.,,"['sliding window', 'prefix sum', 'optimization']",Use a sliding window technique with prefix sums to efficiently calculate the fruits harvested within the reachable range.
2231,"Find First Palindromic String in the Array
Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string """". A string is palindromic if it reads the same forward and backward.",Iterate through the array and return the first string whose reverse equals itself using slicing.,Sort the array lexicographically and return the first string if it's equal to its reverse.,Use regular expressions to identify palindromes and return the first match in the array.,Reverse the entire array of strings and return the first element if it matches the original first element.,"Iterate through the array; for each string, check if it's a palindrome and return it immediately if it is.",Easy,algorithms,"Array,Two Pointers,String"
2232,"Adding Spaces to a String
You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. Return the modified string after the spaces have been added.",Use the `replace` method iteratively to insert spaces at given indices.,Create a new string by iterating through the original string and inserting spaces at the specified indices using string concatenation.,Split the string into substrings based on the `spaces` array and then join them with spaces.,Modify the `spaces` array to include the accumulating space offsets and then insert spaces based on these modified indices.,"Use a two-pointer approach, one for the string and one for the `spaces` array, inserting spaces as needed.",Medium,algorithms,"Array,String,Simulation"
2233,"Number of Smooth Descent Periods of a Stock
You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day. A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule. Return the number of smooth descent periods.",Use dynamic programming to store the length of the longest smooth descent period ending at each index and sum those lengths.,"Iterate through the prices array and, for each index, iterate backwards to find the longest smooth descent period starting at that index.","Sort the array and then iterate through it, counting consecutive elements that differ by 1.",Calculate the moving average of the prices and count periods where the moving average is decreasing smoothly.,"Iterate through the prices array, keeping track of the current smooth descent period's length; if the current price is not one less than the previous, reset the period length.",Medium,algorithms,"Array,Math,Dynamic Programming"
2234,"Minimum Operations to Make the Array K-Increasing
You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k. The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1. In one operation, you can choose an index i and change arr[i] into any positive integer. Return the minimum number of operations required to make the array K-increasing for the given k.",Use dynamic programming to find the longest non-decreasing subsequence in each K-subarray and sum their lengths.,Greedily replace elements in each K-subarray to minimize differences between adjacent elements.,Sort each K-subarray and count the number of misplaced elements.,Calculate the average of each K-subarray and replace all elements in the subarray with the average.,"For each K-subarray, find the longest non-decreasing subsequence and subtract its length from the subarray's length.",Hard,algorithms,"Array,Binary Search"
2219,"Maximum Number of Words Found in Sentences
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences, where each sentences[i] represents a single sentence. Return the maximum number of words that appear in a single sentence.",Sort the array of sentences based on length and return the length of the longest sentence.,Use a regular expression to match all words in each sentence and then find the maximum count.,Calculate the average length of all sentences and return that value.,Return the length of the input array 'sentences'.,"Iterate through each sentence, split it into words, count the words, and keep track of the maximum count encountered.",Easy,algorithms,"Array,String"
2220,"Find All Possible Recipes from Given Supplies
You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. A recipe can also be an ingredient for other recipes, i.e., ingredients[i] may contain a string that is in recipes. You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them. Return a list of all the recipes that you can create. You may return the answer in any order. Note that two recipes may contain each other in their ingredients.","Use Depth-First Search (DFS) to find all recipes reachable from the initial supplies, marking recipes as created during traversal.",Use Breadth-First Search (BFS) to discover all recipes that can be made in the shortest number of steps from the supplies.,Sort the recipes and supplies alphabetically and then linearly check if each recipe's ingredients are in the supplies.,"Recursively check each recipe to see if its ingredients are available, creating the recipe if they are, but without memoization.","Use topological sort to determine the order in which recipes can be made, starting with available supplies and iteratively creating recipes whose ingredients are satisfied.",Medium,algorithms,"Array,Hash Table,String,Graph,Topological Sort"
2221,"Check if a Parentheses String Can Be Valid
A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked, Return true if you can make s a valid parentheses string. Otherwise, return false.",Use dynamic programming to determine the minimum number of flips required to make the string valid.,"Employ a greedy approach, always flipping the 'locked' characters to balance the parentheses count.",Recursively check all possible combinations of flipping 'unlocked' parentheses to find a valid arrangement.,"Utilize backtracking to explore different flipping scenarios, pruning branches that lead to invalid states early.","Count open and close parentheses, use the locked string to decide which characters can be flipped and if a valid string is possible.",Medium,algorithms,"String,Stack,Greedy"
2222,"Abbreviating the Product of a Range
You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right]. Since the product may be very large, you will abbreviate it following these steps: Return a string denoting the abbreviated product of all integers in the inclusive range [left, right].","Calculate the full product and then truncate the result based on a fixed number of significant digits, padding with zeros and an 'e' notation.","Use Stirling's approximation for the factorial function to estimate the product, and then format the estimate using scientific notation.",Calculate the prime factorization of each number in the range and then combine the exponents to determine the product's leading digits and scale.,"Recursively divide the range in half, calculate the products of the sub-ranges, and then multiply those results, truncating at each step.","Compute the product iteratively, tracking the number of trailing zeros and significant digits, formatting the output string with 'e' notation.",Hard,algorithms,Math
2238,"A Number After a Double Reversal
Reversing an integer means to reverse all its digits. Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.",String.format(),"StringBuilder.insert(0, value)",Integer.toString(),StringBuffer.append(value).reverse(),new StringBuilder(String.valueOf(num)).reverse().toString(),Easy,algorithms,Math
2239,"Execution of All Suffix Instructions Staying in a Grid
There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol). You are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down). The robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met: Return an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.",The robot stops if it moves out of the grid,The robot stops if it reaches the end of the instructions,The robot's initial position is outside the grid,The robot executes an invalid instruction,The robot stops if it moves out of the grid or reaches the end of the instructions,Medium,algorithms,"String,Simulation"
2240,"Intervals Between Identical Elements
You are given a 0-indexed array of n integers arr. The interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|. Return an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i]. Note: |x| is the absolute value of x.",Use nested loops to iterate through the array and calculate the sum of intervals for each element.,"Sort the array and then calculate intervals only for unique elements, duplicating results for identical elements.",Use a hash map to store the first occurrence of each element and calculate intervals based on that.,Calculate the total sum of all indices in the array and subtract it from each element's index to get intervals.,Use a hash map to store indices of each value and then iterate through the array to compute the sum of intervals using the stored indices.,Medium,algorithms,"Array,Hash Table,Prefix Sum"
2241,"Recover the Original Array
Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner: Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array. Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array. Note: The test cases are generated such that there exists at least one valid array arr.","Use dynamic programming to determine the optimal values, but this is computationally expensive.",Iterate through all possible k values and check which one produces the given nums array; complexity O(n^2).,Sort nums and construct the original array by taking the smallest n elements as the lower array and deducing arr.,Use a hash table to count the occurrences of each number and deduce k.,Sort nums. The first element of arr is (nums[0] + nums[n]) / 2. Recursively determine other elements.,Hard,algorithms,"Array,Hash Table,Sorting,Enumeration"
2243,"Check if All A's Appears Before All B's
Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.",The string is invalid if it contains characters other than 'a' or 'b',The string is valid if the count of 'a' is greater than the count of 'b',The string is valid if it is empty or contains only 'a's or only 'b's,The string is valid if it is alphabetically sorted,The string is invalid if the last occurrence of 'a' appears after the first occurrence of 'b',Easy,algorithms,String
2244,"Number of Laser Beams in a Bank
Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device. There is one laser beam between any two security devices if both conditions are met: Laser beams are independent, i.e., one beam does not interfere nor join with another. Return the total number of laser beams in the bank.",Calculate the total number of security devices in the bank and return (totalDevices * (totalDevices - 1)) / 2,"Multiply the number of rows by the number of columns, then subtract the count of '0's to get the number of laser beams",Count the number of security devices in each row and sum them all up,Iterate through the bank and count only the adjacent '1's in each row to find the number of lasers,"Count devices per row, multiply the counts of non-empty adjacent rows, and sum the products",Medium,algorithms,"Array,Math,String,Matrix"
2245,"Destroying Asteroids
You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid. You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed. Return true if all asteroids can be destroyed. Otherwise, return false.",Sort the asteroids array in descending order and check if the planet's mass is always greater than the asteroids.,"Calculate the sum of all asteroid masses. If the planet's mass is greater or equal to the sum, return true; otherwise, return false.",Use dynamic programming to determine the optimal order of asteroid collisions to maximize the planet's mass.,Iterate through the asteroids array and only add the mass of asteroids smaller than the planet's current mass.,"Sort the asteroids array in ascending order. Iterate and update the planet's mass. If at any point, the planet's mass is less than the current asteroid's mass, return false. Otherwise, return true.",Medium,algorithms,"Array,Greedy,Sorting"
2246,"Maximum Employees to Be Invited to a Meeting
A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees. The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself. Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.",Find the length of the longest chain where each employee favors the next in the chain.,Count the number of employees who are their own favorite person.,Calculate the average favorite person index and invite employees closest to this index.,Identify cycles of length greater than 2 and invite all members of the largest cycle.,Find cycles of length 2 and longest non-intersecting chains leading into these cycles. Sum the lengths of the chains and longest cycle to find the maximum.,Hard,algorithms,"Depth-First Search,Graph,Topological Sort"
2235,"Capitalize the Title
You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that: Return the capitalized title.","Remove spaces, sort characters alphabetically, and rejoin the string.","Convert the entire string to lowercase, then capitalize the first letter.",Capitalize the first letter of each word regardless of its length.,Convert the entire string to uppercase.,"Convert words longer than 2 letters to Title Case; otherwise, lowercase.",Easy,algorithms,String
2236,"Maximum Twin Sum of a Linked List
In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1. The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list.","Use a hash table to store node values and their indices, then iterate to find the maximum twin sum.",Recursively traverse the linked list to calculate twin sums and maintain a global maximum.,"Iterate through the linked list, storing each node's value in an array. Then, iterate through the array to calculate twin sums.","Split the linked list into two halves, reverse the second half, and then iterate through both halves simultaneously to find the maximum twin sum.","Use a stack to store the first half of the linked list, then iterate through the second half, calculating twin sums with the values from the stack.",Medium,data structures,"Linked List,Two Pointers,Stack"
2237,"Longest Palindrome by Concatenating Two Letter Words
You are given an array of strings words. Each element of words consists of two lowercase English letters. Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once. Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0. A palindrome is a string that reads the same forward and backward.",Use dynamic programming to find all possible palindromic substrings and choose the longest one.,Sort the words array and greedily pick pairs that form palindromes.,Consider each word as a node in a graph and find the longest path that forms a palindrome.,Create a trie to store the words and efficiently search for reverse pairs to form palindromes.,"Use a hash map to count word frequencies, then pair words with their reverses, and handle potential middle palindromes formed by words that are their own reverse.",Medium,algorithms,"Array,Hash Table,String,Greedy,Counting"
2200,"Stamping the Grid
You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied). You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements: Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.",Use dynamic programming to compute prefix sums and then check for valid stamp placements by iterating through all possible stamp locations.,Apply a greedy algorithm by placing stamps in the top-left corner of every empty rectangle without considering overlaps.,"Simulate the stamping process by brute-force, attempting to place stamps at every possible location and checking for valid coverage.","Utilize a backtracking algorithm to explore all possible stamp placements, pruning branches when an invalid placement is detected.","Compute prefix sums to identify regions where stamps can be placed, then use difference arrays to track coverage and determine if all '0' cells are covered.",Hard,algorithms,"Array,Greedy,Matrix,Prefix Sum"
2254,"Check if Every Row and Column Contains All Numbers
An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive). Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",Use nested loops to compare each element against all other elements in its row and column.,Check only the main diagonal and anti-diagonal for the presence of numbers 1 to n.,Sort each row and column independently and check if they are equal to the sorted sequence 1 to n.,Verify that the sum of each row and each column equals n*(n+1)/2.,Use sets to track the numbers present in each row and column; return false if any set does not contain all numbers from 1 to n.,Easy,algorithms,"Array,Hash Table,Matrix"
2255,"Minimum Swaps to Group All 1's Together II
A swap is defined as taking two distinct positions in an array and swapping the values in them. A circular array is defined as an array where we consider the first element and the last element to be adjacent. Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.",Sort the array and count the number of misplaced 1's.,"Calculate the total number of 1's, then iterate through all possible subarrays of that length and count the minimum number of 0's in those subarrays.",Use a greedy approach to swap adjacent elements until all 1's are grouped together.,Apply dynamic programming to find the optimal arrangement of 1's and 0's.,"Calculate the total number of 1's, then use a sliding window of that size to find the minimum number of 0's within the window after concatenating the array with itself.",Medium,algorithms,"Array,Sliding Window"
2256,"Count Words Obtained After Adding a Letter
You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only. For each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords. The conversion operation is described in the following two steps: Return the number of strings in targetWords that can be obtained by performing the operations on any string of startWords. Note that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.",Use nested loops to iterate through each target word and compare it with all possible combinations of adding a letter to each start word.,Sort both arrays and then use a two-pointer approach to check if each target word can be generated by adding a single letter to a start word.,Convert each word into its ASCII representation and check if the sum of ASCII values of a target word is exactly one more than that of a start word.,Use dynamic programming to store all possible combinations of adding letters to start words and then check if each target word exists in the stored combinations.,Represent each word as a bitmask of present characters. Iterate through targetWords and check if removing one bit results in a bitmask present in a set of bitmasks from startWords.,Medium,algorithms,"Array,Hash Table,String,Bit Manipulation,Sorting"
2257,"Earliest Possible Day of Full Bloom
You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each: From the beginning of day 0, you can plant the seeds in any order. Return the earliest possible day where all seeds are blooming.",Sort plantTime in ascending order and growTime in descending order and calculate the bloom day.,Sort plantTime and growTime in ascending order and calculate the bloom day using a greedy approach.,Calculate the sum of plantTime and growTime arrays directly and return the result.,Use dynamic programming to determine the optimal planting order for the seeds.,Sort the seeds based on growTime in descending order to minimize the overall bloom time.,Hard,algorithms,"Array,Greedy,Sorting"
2260,"Divide a String Into Groups of Size k
A string s can be partitioned into groups of size k using the following procedure: Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.",The length of each string in the returned array will be less than or equal to k.,The returned array will have a length equal to k.,"The last string in the returned array may have a length less than k if the length of s is not a multiple of k, and it won't be padded with the fill character.","The returned array will contain only one string, which is the original string s.","If the length of s is not a multiple of k, the last group should be padded with the fill character until it has a length of k.",Easy,algorithms,"String,Simulation"
1303,"Minimum Moves to Reach Target Score
You are playing a game with integers. You start with the integer 1 and you want to reach the integer target. In one move, you can either: You can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times. Given the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.","Recursively double the current value until it exceeds the target, then increment the rest of the way.","Always increment until the target is even, then double if maxDoubles is greater than zero, repeating until the target is reached.","Start by doubling as many times as possible, then use increment operations to fill the gap.","Calculate the difference between the target and 1, then divide that difference by 2^(maxDoubles).","Greedily divide the target by 2 as many times as possible (up to maxDoubles), and then use increment operations for the remaining difference.",Medium,algorithms,"Math,Greedy"
2262,"Solving Questions With Brainpower
You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri]. The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question. Return the maximum points you can earn for the exam.","Use a greedy approach, always choosing the question with the highest points, and skipping based on its brainpower.","Apply dynamic programming with a bottom-up approach, iterating backwards through the questions.",Recursively explore all possible combinations of solving and skipping questions and pick the maximum points.,"Sort the questions based on the ratio of points to brainpower, then solve in that order.",Apply dynamic programming with a top-down approach using memoization to avoid redundant calculations.,Medium,algorithms,"Array,Dynamic Programming"
2263,"Maximum Running Time of N Computers
You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries. Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time. Note that the batteries cannot be recharged. Return the maximum number of minutes you can run all the n computers simultaneously.",Return the sum of all batteries divided by the number of computers.,Sort the batteries in descending order and return the value of the nth battery.,"Perform a binary search on the possible running times, checking if the sum of batteries is sufficient.",Return the average of the largest and smallest battery life multiplied by the number of computers.,"Use binary search on the time. For each time, check if sum(min(battery, time)) >= n * time.",Hard,algorithms,"Array,Binary Search,Greedy,Sorting"
2248,"Minimum Cost of Buying Candies With Discount
A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free. The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought. Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.",Sort the cost array in ascending order and apply the discount from the cheapest candies.,Apply a greedy approach by always choosing the most expensive candies for the discount.,Divide the total cost by 3 to estimate the discount and subtract from the total cost.,Sort the cost array in a random order to simulate different discount scenarios and choose the minimum.,Sort the cost array in descending order and apply the discount by skipping every third candy.,Easy,algorithms,"Array,Greedy,Sorting"
2249,"Count the Hidden Sequences
You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i]. You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain. Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.","Calculate the prefix sum of `differences`, find the minimum and maximum prefix sums, and check if `upper - lower` is less than the difference between the maximum and minimum prefix sums.","Sort the `differences` array, and check if `upper - lower` is greater than the sum of all differences multiplied by `n`.","Check if `differences` contains only zeros. If so, return `upper - lower + 1`; otherwise, return 0.","Recursively generate all possible hidden sequences within the given range, and count the valid ones.","Calculate the prefix sum of `differences`, find the minimum and maximum possible values of the hidden sequence, and return `max(0, upper - lower - (max_prefix_sum - min_prefix_sum) + 1)`.",Medium,algorithms,"Array,Prefix Sum"
2250,"K Highest Ranked Items Within a Price Range
You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following: It takes 1 step to travel between adjacent grid cells. You are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k. You are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different: Return the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.",Depth-First Search (DFS),Greedy Algorithm,Dynamic Programming,Divide and Conquer,Breadth-First Search (BFS),Medium,algorithms,"Array,Breadth-First Search,Sorting,Heap (Priority Queue),Matrix"
2251,"Number of Ways to Divide a Long Corridor
Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant. One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed. Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way. Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.","Use dynamic programming to calculate the number of ways by considering all possible placements of dividers, ignoring the two-seat constraint","Greedily place dividers after every pair of seats, and if the last section doesn't have two seats, return 0","Calculate the total number of seats. If it's odd or zero, return 0. Otherwise, calculate n! / (number of plants)!",Count all possible combinations of divider placements using combinatorics without considering the seat placements,"Count the number of seats. If not divisible by two, return 0. Multiply the number of plant placements between seat pairs modulo 10^9 + 7.",Hard,algorithms,"Math,String,Dynamic Programming"
2269,"Count Elements With Strictly Smaller and Greater Elements
Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.","Sort the array and return the length minus 2 if the array has more than two distinct elements, otherwise return 0.",Iterate through the array and count elements that are neither the minimum nor the maximum value.,Use a hash map to store the frequency of each element and then count elements that are not the smallest or largest key.,Calculate the average of the array and count elements that are not equal to the average.,"Find the minimum and maximum elements in the array. Then, count elements that are strictly greater than the minimum and strictly smaller than the maximum.",Easy,algorithms,"Array,Sorting"
2271,"Rearrange Array Elements by Sign
You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers. You should return the array of nums such that the the array follows the given conditions: Return the modified array after rearranging the elements to satisfy the aforementioned conditions.","Sort the array, placing positive numbers first, then negative numbers.","Create two new arrays, one for positive and one for negative numbers, then alternate appending elements.",Iterate through the array and swap elements until positive and negative numbers alternate correctly.,"Use a hash map to count positive and negative numbers, then rebuild the array based on the counts.","Create separate lists for positive and negative numbers, then merge them alternatingly into a new list.",Medium,algorithms,"Array,Two Pointers,Simulation"
2270,"Find All Lonely Numbers in the Array
You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array. Return all lonely numbers in nums. You may return the answer in any order.",Use a hash map to store the frequency of each number and then iterate through the map to find lonely numbers.,"Sort the array and then iterate through it, checking if each number's adjacent numbers exist using binary search.","Iterate through the array and for each number, check if it exists in the array without its adjacent numbers using array slicing.",Convert the array into a set and remove any number that has an adjacent number also present in the set; return the remaining numbers.,Use a hash map to count the frequency of each number. Iterate through the map and check for each number if its adjacent numbers also exist in the map. Return the numbers that appear only once and whose adjacent numbers do not exist.,Medium,algorithms,"Array,Hash Table,Counting"
2272,"Maximum Good People Based on Statements
There are two types of persons: You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following: Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n. Return the maximum number of people who can be good based on the statements made by the n people.",Use dynamic programming to find the largest consistent subset of statements.,"Employ a greedy approach, always choosing the person who makes the most consistent statements first.",Formulate the problem as a linear program and use an optimization solver.,"Apply a depth-first search to explore all possible combinations of good people, pruning branches when inconsistencies arise.",Use bit manipulation to represent each person's 'good' or 'bad' status and check statement consistency.,Hard,algorithms,"Array,Backtracking,Bit Manipulation,Enumeration"
2274,"Keep Multiplying Found Values by Two
You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums. You then do the following steps: Return the final value of original.","If 'original' is not found, return 'original' immediately.",Sort the 'nums' array and then linearly search for 'original'.,Multiply 'original' by 2 to the power of the length of 'nums'.,Return the sum of all elements in 'nums' that are multiples of 'original'.,"While 'original' exists in 'nums', multiply 'original' by 2.",Easy,algorithms,"Array,Hash Table,Sorting,Simulation"
2261,"All Divisions With the Highest Score of a Binary Array
You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright: The division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright. Return all distinct indices that have the highest possible division score. You may return the answer in any order.","Calculate prefix sums of zeros and suffix sums of ones separately, then iterate to find the maximum score.",Use dynamic programming to store the best score at each division point.,Apply a sliding window approach to maximize the number of zeros and ones in the respective subarrays.,Sort the array and then check divisions at 0 and 1 boundaries.,"Iterate through all possible division points, calculate the score for each, and track the maximum score and corresponding indices.",Medium,algorithms,Array
2275,"Find Substring With Given Hash Value
The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function: Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26. You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue. The test cases will be generated such that an answer always exists. A substring is a contiguous non-empty sequence of characters within a string.","Incrementally update the hash value by removing the contribution of the leftmost character and adding the contribution of the new rightmost character, all modulo m",Calculate the hash value of every k-length substring and compare it with hashValue,"Use a rolling hash, updating it by subtracting power^(k-1) * val(s[i]) and adding val(s[i+k]) without using modulo",Precompute all powers of p modulo m and use them to calculate hashes of all possible substrings,"Use a rolling hash, updating it by subtracting val(s[i]) and adding val(s[i+k]) * power^(k-1) and taking modulo m at each step, checking for hashValue.",Hard,algorithms,"String,Sliding Window,Rolling Hash,Hash Function"
2276,"Groups of Strings
You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words. Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations: The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true: Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique. Return an array ans of size 2 where:",Depth-First Search,Dynamic Programming,Greedy Algorithm,Divide and Conquer,Disjoint Set Union (DSU),Hard,algorithms,"String,Bit Manipulation,Union Find"
2264,"Minimum Sum of Four Digit Number After Splitting Digits
You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used. Return the minimum possible sum of new1 and new2.",Sort the digits in descending order and pair the largest two as tens digits and the smallest two as units digits.,Split the number into two equal halves and directly sum those halves.,"Take the square root of the number and round down, then multiply by two.",Arrange digits randomly and pick the arrangement yielding the smallest sum.,"Sort the digits in ascending order, then form two numbers by pairing the smallest two digits as tens digits and the largest two as units digits.",Easy,algorithms,"Math,Greedy,Sorting"
2265,"Partition Array According to Given Pivot
You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied: Return nums after the rearrangement.","Use a stable sorting algorithm like merge sort to sort elements less than pivot, equal to pivot, and greater than pivot, then concatenate.","Create three separate arrays: less than pivot, equal to pivot, and greater than pivot. Concatenate these arrays.","Use Python's `collections.Counter` to count occurrences of numbers less than, equal to, and greater than pivot, then reconstruct the array.",Iterate through `nums` and swap elements to partition around the pivot without considering relative order within partitions.,"Iterate through `nums` twice. First, place elements less than `pivot`. Then, place elements equal to `pivot`. Finally, place elements greater than `pivot`.",Medium,algorithms,"Array,Two Pointers,Simulation"
2266,"Minimum Cost to Set Cooking Time
A generic microwave supports cooking times for: To set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example, You are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue. There can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost. Return the minimum cost to set targetSeconds seconds of cooking time. Remember that one minute consists of 60 seconds.","Always use the shortest possible time representation (e.g., represent 61 seconds as '0061' instead of '0101')",Calculate cost using only minutes and always convert seconds to minutes by dividing by 60,"Consider only representing the time as MMSS without leading zeros, and directly compute cost",Only consider the case where all digits are pushed sequentially starting from 'startAt',Explore all possible MMSS representations of targetSeconds and choose the one with the minimum cost,Medium,algorithms,"Math,Enumeration"
2267,"Minimum Difference in Sums After Removal of Elements
You are given a 0-indexed integer array nums consisting of 3 * n elements. You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts: The difference in sums of the two parts is denoted as sumfirst - sumsecond. Return the minimum difference possible between the sums of the two parts after the removal of n elements.",Use dynamic programming to track the minimum and maximum sums achievable with 'n' elements removed from prefixes and suffixes of the array,Sort the array and greedily remove the 'n' smallest and 'n' largest elements to minimize the difference between the remaining sums,Consider all possible combinations of 'n' elements to remove using recursion and calculate the difference in sums for each combination,Calculate the total sum of the array and subtract the average value of 'n' elements to approximate the minimum difference,Use two priority queues (min-heap and max-heap) to efficiently track the smallest and largest 'n' elements for prefix and suffix sums,Hard,algorithms,"Array,Dynamic Programming,Heap (Priority Queue)"
2283,"Sort Even and Odd Indices Independently
You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules: Return the array formed after rearranging the values of nums.","Sort even-indexed elements in ascending order and odd-indexed elements in descending order, then combine.",Sort the entire array in ascending order.,Sort the entire array in descending order.,Reverse the array and then sort even-indexed elements in descending order and odd-indexed elements in ascending order.,"Sort even-indexed elements in ascending order and odd-indexed elements in descending order, placing them back into their original indices.",Easy,algorithms,"Array,Sorting"
2284,"Smallest Value of the Rearranged Number
You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros. Return the rearranged number with minimal value. Note that the sign of the number does not change after rearranging the digits.","Sort the digits in ascending order, placing '0' at the beginning, and return the resulting number.","Convert the number to its absolute value, sort the digits in descending order, and return the negative of the resulting number if the original number was negative.",Sort the digits in ascending order and return the result directly.,"Count the occurrences of each digit, arrange the non-zero digits in ascending order, followed by the zeros, and prepend the sign if the original number was negative.","Count the occurrences of each digit, arrange the non-zero digits in ascending order, placing the smallest non-zero digit first, followed by the zeros, and prepend the sign if the original number was negative.",Medium,algorithms,"Math,Sorting"
2285,"Design Bitset
A Bitset is a data structure that compactly stores bits. Implement the Bitset class:","Use a hash table to track set bits, trading space for O(1) access",Employ a sparse matrix representation to minimize memory usage,Store the bitset as a string of '0's and '1's for simplicity,Represent the bitset using a bloom filter to approximate membership,"Use an array of integers (e.g., unsigned long) where each integer stores multiple bits",Medium,data structures,"Array,Hash Table,Design"
2286,"Minimum Time to Remove All Cars Containing Illegal Goods
You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods. As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times: Return the minimum time to remove all the cars containing illegal goods. Note that an empty sequence of cars is considered to have no cars containing illegal goods.","Employ a greedy algorithm, prioritizing removing consecutive '1's from the beginning and end.","Use dynamic programming with the state representing the index and the last operation performed (remove one, remove prefix, remove suffix).",Calculate the number of '1's and multiply by 2 if removing individual cars is more efficient than removing prefixes/suffixes.,"Apply a branch and bound approach, exploring all possible combinations of removing prefixes, suffixes, and individual cars.",Use dynamic programming where dp[i] represents the minimum time to remove illegal goods up to index i.,Hard,algorithms,"String,Dynamic Programming"
2288,"Count Operations to Obtain Zero
You are given two non-negative integers num1 and num2. In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2. Return the number of operations required to make either num1 = 0 or num2 = 0.",Divide `num1` by `num2` (or vice versa) and return the quotient.,Calculate the absolute difference between `num1` and `num2` and return that value.,Return the maximum of `num1` and `num2`.,"Use recursion, subtracting the smaller number from the larger until one reaches zero, incrementing a counter at each step.",Implement the Euclidean algorithm to efficiently find the greatest common divisor (GCD) and use it to calculate the number of operations.,Easy,algorithms,"Math,Simulation"
2289,"Minimum Operations to Make the Array Alternating
You are given a 0-indexed array nums consisting of n positive integers. The array nums is called alternating if: In one operation, you can choose an index i and change nums[i] into any positive integer. Return the minimum number of operations required to make the array alternating.",Sort the array and replace elements at even indices with the smallest element and odd indices with the second smallest.,Calculate the frequency of each number. The minimum operations equal to the array size minus the maximum frequency.,Replace all even-indexed elements with the most frequent element at even indices and odd-indexed elements with the most frequent element at odd indices.,Calculate the number of distinct elements in the array and subtract it from the array size.,"Find the two most frequent elements at even and odd indices. Calculate operations needed if the most frequent elements are the same or different, then return the minimum of those.",Medium,algorithms,"Array,Hash Table,Greedy,Counting"
2290,"Removing Minimum Number of Magic Beans
You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag. Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags. Return the minimum number of magic beans that you have to remove.",Find the median and remove beans to match the median value.,Remove all the beans from the bag with the maximum number of beans.,Calculate the average number of beans and remove beans to match this average.,Sort the array and remove beans from each bag to match the number of beans in the first bag.,"Sort the array and for each element, calculate the removal cost if all remaining bags are reduced to that element's size, then take the minimum cost.",Medium,algorithms,"Array,Sorting,Prefix Sum"
2291,"Maximum AND Sum of Array
You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots. You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number. Return the maximum possible AND sum of nums given numSlots slots.","Use a greedy approach, placing the largest numbers into the slots with the highest slot numbers",Sort the nums array and iterate through all possible permutations of slot assignments to maximize the AND sum,"Apply dynamic programming with memoization, where the state represents the numbers placed and the current slot","Ignore the constraint that each slot has at most two numbers, place each number i in slot i, and calculate the sum",Utilize dynamic programming with bitmasking to represent the numbers placed in slots and their counts,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
2278,"Find Three Consecutive Integers That Sum to a Given Number
Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integers, return an empty array.","Return [num - 1, num, num + 1] if num is divisible by 2, otherwise return []","Return [num / 3 - 2, num / 3 - 1, num / 3] if num is divisible by 3, otherwise return []","Return [num / 2 - 1, num / 2, num / 2 + 1] if num is even, otherwise return []","Start from 1, check if (num - i) is divisible by 2. If it is, return [i, (num - i)/2, (num - i)/2 + 1]","Return [num / 3 - 1, num / 3, num / 3 + 1] if num is divisible by 3, otherwise return []",Medium,algorithms,"Math,Simulation"
2279,"Maximum Split of Positive Even Integers
You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers. Return a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for finalSum, return an empty list. You may return the integers in any order.",Final sum must be odd to allow for a valid split,Start with the largest possible even integer and work downwards,Use dynamic programming to find all possible combinations of even integers,The maximum number of integers is always finalSum / 2,Start with the smallest even integer and greedily add unique even integers until the sum equals finalSum or exceeds it,Medium,algorithms,"Math,Greedy"
2280,"Count Good Triplets in an Array
You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of good triplets.",O(n),O(n log n),O(n^2),O(n^3),O(n log n),Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
2298,"Count Integers With Even Digit Sum
Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even. The digit sum of a positive integer is the sum of all its digits.",Calculate the digit sum of all numbers from 1 to num and count even sums. This approach uses O(n) time.,"Divide num by 2. If num is even, return num/2. If num is odd, return (num-1)/2. This is always incorrect.",Return num - (num % 10). This only considers the last digit and is generally incorrect.,"Calculate the sum of digits of num. If the sum is even return num; otherwise, return num - 1. This is also flawed.",Iterate from 1 to num and count numbers with an even digit sum. Optimize by observing patterns in digit sums.,Easy,algorithms,"Math,Simulation"
2299,"Merge Nodes in Between Zeros
You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0. For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's. Return the head of the modified linked list.","Use a temporary array to store values between zeros, sum them, and create a new node with the sum. Repeat for all segments.","Convert the linked list into a string representation, split by '0', calculate sums of substrings, and reconstruct the list.","Create two new linked lists, one containing the starting zeros, and the other containing the sum of values between corresponding zeros.","Remove all nodes with value 0, then calculate the sum of the entire linked list and assign this single value to the head.","Iterate through the list, summing values between zeros. When encountering a zero, update the previous zero's node value with the sum and remove intermediate nodes.",Medium,data structures,"Linked List,Simulation"
2300,"Construct String With Repeat Limit
You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s. Return the lexicographically largest repeatLimitedString possible. A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.","Greedily pick the largest character available, appending it up to the repeat limit, then move to the next largest if necessary, without tracking character counts.","Sort the string in ascending order, then reverse it and apply the repeat limit. This approach may result in smaller characters appearing earlier than necessary.",Iterate through the string and remove the highest frequency characters if they exceed the repeat limit. This might leave suboptimal string constructions.,Construct the string by randomly selecting characters while respecting the repeat limit. This approach may not be lexicographically largest.,"Count character frequencies, then greedily construct the result from largest to smallest characters, respecting the repeat limit and moving to the next largest when necessary.",Medium,algorithms,"String,Greedy,Heap (Priority Queue),Counting"
2301,"Count Array Pairs Divisible by K
Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:",Calculate the greatest common divisor (GCD) of each pair and check if the product of the pair divided by their GCD is divisible by k,"Check divisibility of nums[i] * nums[j] by k directly without optimization, resulting in O(n^2) complexity",Maintain a hash map of remainders modulo k and count pairs where the product of remainders is 0,Sort the array and use binary search to find pairs that satisfy the condition,Count the frequency of each number modulo k and then calculate pairs based on these frequencies and k's divisors,Hard,algorithms,"Array,Math,Number Theory"
2292,"Counting Words With a Given Prefix
You are given an array of strings words and a string pref. Return the number of strings in words that contain pref as a prefix. A prefix of a string s is any leading contiguous substring of s.",Use a hash table to store the frequency of each word and then check if the prefix exists as a key,Iterate through the words array and use string slicing to compare the prefix with each word,Use regular expressions to find the words that start with the given prefix,Sort the words array alphabetically and then use binary search to find the range of words starting with the prefix,"Iterate through the words array and for each word, check if it starts with the given prefix using the `startsWith()` method",Easy,algorithms,"Array,String"
2293,"Minimum Number of Steps to Make Two Strings Anagram II
You are given two strings s and t. In one step, you can append any character to either s or t. Return the minimum number of steps to make s and t anagrams of each other. An anagram of a string is a string that contains the same characters with a different (or the same) ordering.",Calculate the difference in lengths between the strings.,Find the longest common subsequence and subtract its length from the sum of the string lengths.,Compute the edit distance between the strings.,Determine the number of distinct characters in each string.,Count character frequencies in both strings and sum the absolute differences of corresponding frequencies.,Medium,algorithms,"Hash Table,String,Counting"
2294,"Minimum Time to Complete Trips
You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip. Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus. You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",Use dynamic programming to calculate the minimum time by considering all possible combinations of trips for each bus.,Sort the 'time' array and iteratively assign trips to the fastest bus until 'totalTrips' is reached.,Calculate the average time per trip and multiply it by 'totalTrips' to get an approximate minimum time.,Divide 'totalTrips' equally among all buses and calculate the maximum time taken by any bus to complete its assigned trips.,Use binary search on the time range to find the minimum time required to complete at least 'totalTrips'.,Medium,algorithms,"Array,Binary Search"
2295,"Minimum Time to Finish the Race
You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds. You are also given an integer changeTime and an integer numLaps. The race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds. Return the minimum time to finish the race.",Greedily choose the tire that minimizes the time for each individual lap.,Use dynamic programming with a state representing the current lap and the tire being used.,Sort the tires by their initial time (fi) and always use the fastest tire.,Calculate the time for each possible combination of tire changes using recursion.,"Use dynamic programming to calculate the minimum time to complete 'i' laps, considering changing tires after a certain number of laps with a single tire.",Hard,algorithms,"Array,Dynamic Programming"
2312,"Most Frequent Number Following Key In an Array
You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums. For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that: Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.","Use a hash map to store counts of numbers preceding the key, then find the max",Sort the array and count consecutive occurrences of each number following the key,Iterate through the array and keep track of the highest number encountered after the key,Calculate the average of numbers following the key and return the closest integer,"Iterate through the array, counting occurrences of numbers immediately following the key using a hash map, and return the number with the maximum count",Easy,algorithms,"Array,Hash Table,Counting"
1333,"Sort the Jumbled Numbers
You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system. The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9. You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements. Notes:","Sort nums based on their original values, ignoring the mapping.","Convert each number in nums to its mapped value, store them in a separate array, sort the mapped array, and then look up the original numbers based on the sorted mapped values.",Sort nums using a comparison function that directly compares the string representations of the numbers after mapping.,Calculate the sum of all mapped values and return a new array containing that sum repeated nums.length times.,Sort nums using a custom comparison function that maps the numbers and compares the mapped values.,Medium,algorithms,"Array,Sorting"
1333,"Sort the Jumbled Numbers
You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system. The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9. You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements. Notes:","Sort nums based on their original values, ignoring the mapping.","Convert each number in nums to its mapped value, store them in a separate array, sort the mapped array, and then look up the original numbers based on the sorted mapped values.",Sort nums using a comparison function that directly compares the string representations of the numbers after mapping.,Calculate the sum of all mapped values and return a new array containing that sum repeated nums.length times.,Sort nums using a custom comparison function that maps the numbers and compares the mapped values.,Medium,algorithms,"Array,Sorting"
1431,"All Ancestors of a Node in a Directed Acyclic Graph
You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph. Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order. A node u is an ancestor of another node v if u can reach v via a set of edges.",Depth-First Search (DFS) starting from the node and tracking visited nodes.  This is repeated for each node.,Breadth-First Search (BFS) starting from the node and tracking visited nodes. This is repeated for each node.,Calculate the transitive closure using Warshall's algorithm and extract ancestors from the resulting matrix.,Perform a topological sort of the graph and use dynamic programming to determine the ancestors of each node.,"Perform a Depth-First Search (DFS) from each node to identify all reachable nodes, which represent its descendants. Invert the relationships to determine ancestors.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
1356,"Minimum Number of Moves to Make Palindrome
You are given a string s consisting only of lowercase English letters. In one move, you can select any two adjacent characters of s and swap them. Return the minimum number of moves needed to make s a palindrome. Note that the input will be generated such that s can always be converted to a palindrome.","Greedily swap the outermost characters until the string becomes a palindrome, minimizing swaps at each step.",Sort the string and then calculate the number of swaps needed to revert it back to its original state.,Use dynamic programming to calculate the minimum swaps needed for all possible substrings.,Reverse the string and calculate the Levenshtein distance between the original and reversed strings.,"Iterate through the string, and for each misplaced character, find its correct position and swap it to the center.",Hard,algorithms,"Two Pointers,String,Greedy,Binary Indexed Tree"
2304,"Cells in a Range on an Excel Sheet
A cell (r, c) of an excel sheet is represented as a string ""<col><row>"" where: You are given a string s in the format ""<col1><row1>:<col2><row2>"", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2. Return the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.",Use recursion to find the cell range.,"Return a list of strings with the format ""<col1><row1>:<col2><row2>"".",Iterate columns and rows simultaneously with nested while loops.,Use string splitting without converting column letters to numbers.,"Iterate through column letters and row numbers using nested for loops, converting characters to integers where necessary.",Easy,algorithms,String
2305,"Append K Integers With Minimal Sum
You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum. Return the sum of the k integers appended to nums.",Use a priority queue (min-heap) to efficiently find the smallest available integers and calculate their sum.,"Sort the input array and iterate through it, summing the gaps between numbers to find missing integers up to k.",Calculate the sum of the first 'k' positive integers and subtract the sum of elements in 'nums' that are less than or equal to k.,"Create a boolean array representing all positive integers up to a large limit, mark integers in 'nums', and then sum the first 'k' unmarked integers.","Iterate, keeping track of the current smallest missing positive integer. If the current number in 'nums' is smaller than or equal to that, increment the missing integer.",Medium,algorithms,"Array,Math,Greedy,Sorting"
2306,"Create Binary Tree From Descriptions
You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore, Construct the binary tree described by descriptions and return its root. The test cases will be generated such that the binary tree is valid.",Use a hash table to store child-parent relationships and find the root by identifying the node with no parent entry.,Sort the 'descriptions' array based on parent values and reconstruct the tree iteratively.,Create a directed graph from the descriptions and perform a topological sort to determine the tree structure.,Recursively build subtrees by partitioning the 'descriptions' array based on 'isLeft' values.,Build a map of nodes and their parents. Find the root by identifying the node not present as a child. Construct the tree bottom-up.,Medium,data structures,"Array,Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
2307,"Replace Non-Coprime Numbers in Array
You are given an array of integers nums. Perform the following steps: Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result. The test cases are generated such that the values in the final array are less than or equal to 108. Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.",Use dynamic programming to store intermediate GCD values for optimization.,"Employ a divide-and-conquer approach, merging coprime sub-arrays.",Sort the array and then iteratively replace non-coprime numbers.,Convert the array to a set to remove duplicates before processing.,Use a stack to keep track of the numbers and merge adjacent non-coprime numbers iteratively.,Hard,algorithms,"Array,Math,Stack,Number Theory"
2320,"Find All K-Distant Indices in an Array
You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key. Return a list of all k-distant indices sorted in increasing order.",Use a sliding window of size k and check for the presence of 'key' in each window.,"Create a boolean array marking indices within distance k of 'key', then filter for the indices that are true.","Iterate through the array and for each element, compute the absolute difference with 'key' and only include those indices.",Sort the input array and then search for 'key' using binary search to optimize the search process.,Iterate through each index 'i' and check if there's a 'j' within distance 'k' where nums[j] equals key.,Easy,algorithms,Array
1312,"Count Artifacts That Can Be Extracted
There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where: You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it. Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract. The test cases are generated such that:",Use a disjoint-set data structure to track connected excavated cells and check if an artifact's area forms a connected component after excavation.,Iterate through each artifact and check if any cell within its bounds is not in the dig array using nested loops and conditional breaks.,Sort the dig array based on row and column indices and perform a binary search for each cell within each artifact's bounds.,"Create a boolean matrix representing the grid and mark excavated cells as true; then, iterate through artifacts and check if all corresponding cells are true.","For each artifact, iterate through all cells it occupies; if all these cells are in the dig array, increment the count.",Medium,algorithms,"Array,Hash Table,Simulation"
1346,"Maximize the Topmost Element After K Moves
You are given a 0-indexed integer array nums representing the contents of a pile, where nums[0] is the topmost element of the pile. In one move, you can perform either of the following: You are also given an integer k, which denotes the total number of moves to be made. Return the maximum value of the topmost element of the pile possible after exactly k moves. In case it is not possible to obtain a non-empty pile after k moves, return -1.",nums[k] if k < nums.length else -1,max(nums[:k-1]) if k > 1 else -1,nums[0] if k % 2 == 0 else -1,nums[k-1] if k <= nums.length else max(nums),"max(nums[:min(k-1, nums.length)]) if k > 0 and nums.length > 1 else (nums[0] if k % 2 == 1 and nums.length == 1 else (nums[1] if k > 0 and nums.length > 1 and k==1 else (nums[0] if nums.length==1 else -1)))",Medium,algorithms,"Array,Greedy"
2321,"Minimum Weighted Subgraph With the Required Paths
You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1. You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti. Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph. Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1. A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.","Dynamic programming to calculate shortest paths from src1 and src2 to all nodes, then iteratively combine the results towards dest.",Greedily select edges with the lowest weights originating from src1 and src2 until dest is reachable.,"Apply Dijkstra's algorithm independently from src1 and src2 to dest and sum the path weights; if a node is visited twice, only count it once.","Use a breadth-first search from src1 and src2 simultaneously, summing edge weights, stopping when dest is reached by both.","Calculate shortest paths from src1, src2, and dest (reversed graph) to all nodes using Dijkstra's algorithm, then minimize src1[i] + src2[i] + dest[i] across all nodes i.",Hard,algorithms,"Graph,Shortest Path"
2308,"Divide Array Into Equal Pairs
You are given an integer array nums consisting of 2 * n integers. You need to divide nums into n pairs such that: Return true if nums can be divided into n pairs, otherwise return false.",Use a hash set to track unique elements; return true if the set is empty at the end.,"Sort the array; if any adjacent elements are different, return false.","Iterate through the array and count the occurrences of each number; if any count is odd, return false.",Calculate the sum of the array and check if the sum is even.,"Use a hash map to count occurrences of each number; return false if any count is odd, otherwise true.",Easy,algorithms,"Array,Hash Table,Bit Manipulation,Counting"
2309,"Maximize Number of Subsequences in a String
You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters. You can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text. Return the maximum number of times pattern can occur as a subsequence of the modified text. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.","Calculate the number of subsequences of `pattern` in `text` without modification, then add 1 if adding `pattern[0]` or `pattern[1]` increases the count.","Try adding `pattern[0]` to the beginning and end of `text`, and `pattern[1]` to the beginning and end of `text`, then return the maximum subsequence count.",Count occurrences of `pattern[0]` and `pattern[1]` in `text` and add the larger count to the length of `text` as the result.,Sort the characters in `text` and `pattern` and calculate the number of matching characters.,"Calculate the number of subsequences of `pattern` in `text` without modification. Then, calculate the number of subsequences after adding `pattern[0]` at the beginning and end of `text`, and after adding `pattern[1]` at the beginning and end of `text`. Return the maximum of these counts.",Medium,algorithms,"String,Greedy,Prefix Sum"
2310,"Minimum Operations to Halve Array Sum
You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.) Return the minimum number of operations to reduce the sum of nums by at least half.",Use dynamic programming to find the optimal subset of numbers to halve.,Sort the array and greedily halve the largest numbers until the sum is reduced by half.,Recursively halve each number in the array until the sum is reduced by half.,Halve all numbers in the array and then double the smallest ones until the condition is met.,"Use a max heap (priority queue) to store the numbers, repeatedly halve the largest number, and track the operations.",Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
2311,"Minimum White Tiles After Covering With Carpets
You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor: You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another. Return the minimum number of white tiles still visible.","Use a greedy approach, placing carpets from left to right covering the longest contiguous white tile sections.","Apply dynamic programming, where dp[i][j] represents the minimum white tiles visible up to index i using j carpets, and consider overlapping carpets.",Iterate through all possible carpet placements using recursion and backtracking to find the arrangement with the fewest visible white tiles.,Divide the floor into segments of length 'carpetLen' and determine the segments with the highest white tile count to cover.,"Employ dynamic programming where dp[i][j] represents the minimum white tiles visible up to index i using j carpets, deciding whether to cover index i or not.",Hard,algorithms,"String,Dynamic Programming,Prefix Sum"
2316,"Count Hills and Valleys in an Array
You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums.",Identify local maxima by comparing each element to its immediate neighbors,Sort the array and count the occurrences of plateaus that are higher or lower than their surroundings,Calculate the derivative of the array and count the number of times it changes sign,Iterate through the array and maintain separate counts for hills and valleys based on comparisons with the absolute maximum and minimum values seen so far,"Iterate through the array, ignoring consecutive duplicate elements, and check if each unique element is greater than or less than its non-equal neighbors",Easy,algorithms,Array
2317,"Count Collisions on a Road
There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point. You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed. The number of collisions can be calculated as follows: After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion. Return the total number of collisions that will happen on the road.",Ignore all 'S' cars and count the number of 'L' cars to the right of 'R' cars.,"Simulate the movement of each car step-by-step until no more collisions occur, tracking each collision.","Only count collisions between 'L' and 'R' cars, ignoring 'S' cars completely.","Count the total number of 'L' and 'R' cars, as each will eventually collide.","Iterate through the directions, updating collision counts based on encounters of 'R' followed by 'L' or 'S', and 'L' preceded by 'R' or 'S', appropriately changing car states after collisions.",Medium,algorithms,"String,Stack"
2318,"Maximum Points in an Archery Competition
Alice and Bob are opponents in an archery competition. The competition has set the following rules: For example, if Alice and Bob both shot 2 arrows on the section with score 11, then Alice takes 11 points. On the other hand, if Alice shot 0 arrows on the section with score 11 and Bob shot 2 arrows on that same section, then Bob takes 11 points. You are given the integer numArrows and an integer array aliceArrows of size 12, which represents the number of arrows Alice shot on each scoring section from 0 to 11. Now, Bob wants to maximize the total number of points he can obtain. Return the array bobArrows which represents the number of arrows Bob shot on each scoring section from 0 to 11. The sum of the values in bobArrows should equal numArrows. If there are multiple ways for Bob to earn the maximum total points, return any one of them.","Use a greedy approach, always maximizing points from higher-scoring sections first without considering the total arrow constraint.",Calculate the maximum possible score Bob can achieve and then distribute the arrows evenly across all sections to reach that score.,"Iterate through all possible combinations of arrow distributions for Bob and select the distribution that yields the highest score, ignoring the arrow limit.",Sort Alice's arrows in descending order and match each section with the same number of arrows for Bob to minimize her score.,Use dynamic programming to find the optimal arrow distribution for Bob that maximizes his score while respecting the total arrow constraint.,Medium,algorithms,"Array,Bit Manipulation,Recursion,Enumeration"
2319,"Longest Substring of One Repeating Character
You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries. The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i]. Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed.",Sliding window technique with character frequency tracking and window resizing.,Dynamic programming approach where dp[i] stores the longest repeating character substring ending at index i.,Greedy approach: iteratively expand the current substring until a different character is encountered.,Using a suffix tree to store all substrings and then querying for the longest substring with a single character.,Segment tree or interval tree to efficiently maintain the longest repeating character substrings.,Hard,algorithms,"Array,String,Segment Tree,Ordered Set"
1392,"Find the Difference of Two Arrays
Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: Note that the integers in the lists may be returned in any order.",Use nested loops to compare each element of nums1 with every element of nums2 and vice versa.,Convert both arrays to sets and use set difference operations to find the unique elements.,"Sort both arrays, then iterate with two pointers to identify elements present in one but not the other.",Concatenate both arrays and remove duplicate elements to find the difference.,Use hash sets to store elements of each array and efficiently find the elements present in one but not the other.,Easy,algorithms,"Array,Hash Table"
1355,"Minimum Deletions to Make Array Beautiful
You are given a 0-indexed integer array nums. The array nums is beautiful if: Note that an empty array is considered beautiful. You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged. Return the minimum number of elements to delete from nums to make it beautiful.","Use dynamic programming to track the minimum deletions up to each index, considering both deletion and non-deletion options.",Sort the array and greedily delete elements from the end until the condition is met.,Iterate through the array and delete elements at odd indices if they are equal to the element at the next even index.,Recursively partition the array and count deletions needed for each partition.,"Iterate through the array, maintaining a counter for deletions. If nums[i] == nums[i+1] and (i - deletions) is even, increment deletions and skip nums[i+1].",Medium,algorithms,"Array,Stack,Greedy"
1375,"Find Palindrome With Fixed Length
Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists. A palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.","If intLength is even, the number of possible palindromes is 9 * 10^(intLength/2 - 1). If queries[i] exceeds this, return -1. Construct the palindrome by reflecting the first half.","Generate all possible palindromes of length intLength and store them in a sorted list. Return the element at queries[i] - 1, or -1 if the list is too short.","Start with the smallest palindrome of length intLength (e.g., 1001 for intLength = 4) and increment it queries[i] times, checking if the result is a palindrome after each increment.","Precompute a table of all palindromes up to a certain length. Look up the queries[i]th palindrome of length intLength in this table, or return -1 if it's out of bounds.","The queries[i]th palindrome can be generated by taking the queries[i]th number of length (intLength+1)/2 and mirroring it appropriately, after checking for out-of-bounds.",Medium,algorithms,"Array,Math"
1393,"Maximum Value of K Coins From Piles
There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.",Greedily pick the largest k coins from all piles.,"Use dynamic programming with a state representing (pile index, coins taken).","Apply a greedy approach, always picking from the pile with the highest average coin value.",Sort all coins in descending order and pick the top k.,"Use dynamic programming with a state representing (pile index, coins taken), considering all possible numbers of coins taken from the current pile.",Hard,algorithms,"Array,Dynamic Programming,Prefix Sum"
2323,"Minimum Bit Flips to Convert Number
A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0. Given two integers start and goal, return the minimum number of bit flips to convert start to goal.",Use dynamic programming to build a table of minimum flips for all possible sub-problems.,"Convert both numbers to strings, pad with leading zeros to equalize length, and count differing characters.",Calculate the absolute difference between the numbers and then count the set bits in the result.,Use a lookup table pre-computed with the minimum flips required for all numbers up to the maximum possible input.,Calculate the XOR of the two numbers and count the set bits in the result.,Easy,algorithms,Bit Manipulation
2324,"Find Triangular Sum of an Array
You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive). The triangular sum of nums is the value of the only element present in nums after the following process terminates: Return the triangular sum of nums.","Divide the array into two halves and recursively calculate the triangular sum of each half, then add the results.","Sort the array and then repeatedly sum adjacent elements, taking the modulo 10.","Calculate the prefix sum of the array modulo 10, then take the last element.","Repeatedly sum adjacent elements modulo 10 until only one element remains in-place, modifying the original array.",Repeatedly create a new array by summing adjacent elements modulo 10 until only one element remains.,Medium,algorithms,"Array,Math,Simulation,Combinatorics"
2325,"Number of Ways to Select Buildings
You are given a 0-indexed binary string s which represents the types of buildings along a street where: As a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type. Return the number of valid ways to select 3 buildings.","O(n^3), where n is the length of the string","O(n log n), where n is the length of the string","O(1), constant time complexity","O(2^n), exponential time complexity","O(n), where n is the length of the string",Medium,algorithms,"String,Dynamic Programming,Prefix Sum"
2326,"Sum of Scores of Built Strings
You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si. The score of si is the length of the longest common prefix between si and sn (Note that s == sn). Given the final string s, return the sum of the score of every si.","Calculate the score of each prefix by iterating through all possible prefixes and comparing them with the final string, resulting in O(n^2) complexity.","Precompute all possible prefixes and store them in a hash table for quick lookups during score calculation, but this increases memory usage.","Use binary search to find the longest common prefix for each prefix string, which assumes a sorted order of characters, not applicable here.","Employ dynamic programming to store and reuse the longest common prefixes calculated so far, but this requires significant memory overhead.","Utilize the Z algorithm or Knuth-Morris-Pratt (KMP) algorithm to efficiently find the longest common prefix between each prefix and the entire string, achieving O(n) time complexity.",Hard,algorithms,"String,Binary Search,Rolling Hash,Suffix Array,String Matching,Hash Function"
2345,"Minimum Number of Operations to Convert Time
You are given two strings current and correct representing two 24-hour times. 24-hour times are formatted as ""HH:MM"", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59. In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times. Return the minimum number of operations needed to convert current to correct.",Use dynamic programming to build a table of minimum operations from 00:00 to correct time,"Convert both times to total minutes, find the difference, and greedily subtract the largest possible operation values",Recursively try all possible combinations of operations and return the minimum count,Calculate the difference in hours and minutes separately and add them directly,"Convert both times to total minutes, find the difference, and apply a greedy algorithm prioritizing larger increments",Easy,algorithms,"String,Greedy"
1354,"Find Players With Zero or One Losses
You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match. Return a list answer of size 2 where: The values in the two lists should be returned in increasing order. Note:","Use a hash table to store the counts of losses for each player, then iterate through the matches array.","Sort the matches array by winner and loser, then iterate to count losses.",Maintain two separate sets: one for players with zero losses and one for players with one loss.,"Iterate through the matches array, removing players from a master set if they lose and adding them to a loss set.","Use a hash map to count losses for each player. Filter for players with zero and one loss separately, then sort.",Medium,algorithms,"Array,Hash Table,Sorting,Counting"
1335,"Maximum Candies Allocated to K Children
You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together. You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can be allocated candies from only one pile of candies and some piles of candies may go unused. Return the maximum number of candies each child can get.",Linear search through the candies array to find the largest pile and distribute from there,"Divide the total number of candies by k, rounding down to the nearest integer",Sort the candies array in ascending order and greedily allocate candies from the smallest piles first,Use dynamic programming to compute the optimal allocation for each child iteratively,"Binary search on the possible number of candies each child can receive, checking if k children can receive that amount",Medium,algorithms,"Array,Binary Search"
1433,"Encrypt and Decrypt Strings
You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string. A string is encrypted with the following process: Note that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string """" is returned. A string is decrypted with the following process: Implement the Encrypter class:","A hash table with 'values' as keys and 'keys' as values for O(n) lookup, followed by dictionary validation using linear search.",A tree-based structure storing all possible decrypted strings for fast prefix matching.,"A sorted array of decrypted strings, allowing binary search for validation but requiring O(n log n) initial sorting.",A linked list of all decrypted strings for linear search during validation.,"A hash table (dictionary) with 'values' as keys and 'keys' as values for O(1) lookup during decryption, coupled with a set for O(1) dictionary validation.",Hard,data structures,"Array,Hash Table,String,Design,Trie"
2327,"Largest Number After Digit Swaps by Parity
You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits). Return the largest possible value of num after any number of swaps.",Sort the digits in ascending order based on their parity.,"Treat the number as a string, and use a single sorting algorithm on the entire string.","Separate even and odd digits, sort them independently in ascending order, and reconstruct the number.","Convert the number to a binary string, sort, and convert back to decimal.","Separate even and odd digits, sort them independently in descending order, and reconstruct the number while maintaining original digit positions.",Easy,algorithms,"Sorting,Heap (Priority Queue)"
2328,"Minimize Result by Adding Parentheses to Expression
You are given a 0-indexed string expression of the form ""<num1>+<num2>"" where <num1> and <num2> represent positive integers. Add a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'. Return expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them. The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.",Evaluate all possible parenthesized expressions using regular expressions and select the minimum.,Employ dynamic programming to store intermediate results of sub-expressions.,"Use a greedy approach, always placing parentheses to minimize the immediate product.",Randomly insert parentheses and perform evaluations until a minimum is found.,"Iterate through all valid parenthesis placements, evaluate the resulting expressions, and return the expression with the minimum value.",Medium,algorithms,"String,Enumeration"
2329,"Maximum Product After K Increments
You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1. Return the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo.",Use a greedy approach by always incrementing the largest number in the array.,Sort the array in descending order and increment the smallest element 'k' times.,"Increment each element of the array by k/n, where n is the length of the array.",Increment all numbers to the average of the array and then distribute the remaining k operations.,Use a min-heap to store the numbers and repeatedly increment the smallest number until k is exhausted.,Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
2330,"Maximum Total Beauty of the Gardens
Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens. You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial. A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following: Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.",Prioritize maximizing the number of full gardens and then distribute remaining flowers evenly among partial gardens.,Greedily plant flowers in the garden with the smallest number of existing flowers until newFlowers is exhausted.,Binary search for the optimal number of full gardens and use a greedy approach for partial gardens.,Calculate the beauty of all possible combinations of full and partial gardens and choose the maximum.,"Sort the gardens, binary search for the minimum flower count in partial gardens, and calculate beauty based on full and partial gardens.",Hard,algorithms,"Array,Two Pointers,Binary Search,Greedy,Sorting"
2384,"Root Equals Sum of Children
You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child. Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.",The root's value equals the average of its children's values.,The root's value is greater than or equal to the sum of its children's values.,The root's value is less than or equal to the sum of its children's values.,The root's value is the product of its children's values.,The root's value equals the sum of its children's values.,Easy,data structures,"Tree,Binary Tree"
2310,"Sum of Numbers With Units Digit K
Given two integers num and k, consider a set of positive integers with the following properties: Return the minimum possible size of such a set, or -1 if no such set exists. Note:",Always choose the largest possible numbers with unit digit 'k' until 'num' is reached or exceeded.,"Return -1 if 'k' is greater than 'num', otherwise return 1.","Start with a set of size 1 and incrementally increase the size until a valid combination is found, or a maximum size is reached.",Calculate the number of integers ending in 'k' up to 'num' and return that count.,"Iterate from 1 to 10, checking if (num - i*k) is non-negative and divisible by 10. Return the smallest such i, or -1 if none exist.",Medium,algorithms,"Math,Dynamic Programming,Greedy,Enumeration"
2311,"Longest Binary Subsequence Less Than or Equal to K
You are given a binary string s and a positive integer k. Return the length of the longest subsequence of s that makes up a binary number less than or equal to k. Note:","Greedily include all '0's and as many least significant '1's as possible without exceeding k, prioritizing '0's.","Convert the binary string to an integer, check if it's less than or equal to k, and return the length of the string if it is, otherwise return 0.","Generate all possible subsequences, convert them to integers, and find the length of the longest one that's less than or equal to k. (Brute force approach)",Sort the binary string in descending order and take the prefix substring whose integer value is less than or equal to k.,Iterate through the string from right to left. Always include '0's. Include '1's only if adding its value (2^position) to the current subsequence's value doesn't exceed k.,Medium,algorithms,"String,Dynamic Programming,Greedy,Memoization"
2316,"Count Unreachable Pairs of Nodes in an Undirected Graph
You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi. Return the number of pairs of different nodes that are unreachable from each other.",Use Depth-First Search (DFS) starting from node 0 and count the nodes visited. The remaining nodes are unreachable from node 0.,Apply Dijkstra's algorithm to find the shortest path between all pairs of nodes. Count the pairs with infinite distance.,"Sort the edges array and iterate through it. If two nodes are not connected, they are unreachable.",Perform a topological sort of the graph and count the number of nodes that appear before a specific node.,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to find connected components. For each component of size k, the number of unreachable nodes is k * (n - k). Sum these values for all components.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
2317,"Maximum XOR After Operations
You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x). Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation. Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.","The bitwise AND operation always results in zero, so the answer is always zero.","The maximum XOR is achieved when all elements are as small as possible, so return the XOR of the original array.",Calculate the sum of all elements in the array and return that sum.,Find the minimum element in the array and return it.,The maximum XOR is achieved when each bit position has at least one element with a 1 in that position. Return the bitwise OR of all elements in the array.,Medium,algorithms,"Array,Math,Bit Manipulation"
2318,"Number of Distinct Roll Sequences
You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied: Return the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7. Two sequences are considered distinct if at least one element is different.",O(n^6),O(6^n),O(n),O(n log n),O(n*36),Hard,algorithms,"Dynamic Programming,Memoization"
2319,"Check if Matrix Is X-Matrix
A square matrix is said to be an X-Matrix if both of the following conditions hold: Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false.",All elements outside the diagonals must be non-zero.,"Elements on the main diagonal must be 0, and elements on the anti-diagonal must be non-zero.",The sum of elements on both diagonals must be equal to n*n.,All elements must be positive integers.,"All elements in the diagonals must be non-zero, and all other elements must be 0.",Easy,algorithms,"Array,Matrix"
2325,"Decode the Message
You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows: Return the decoded message.",Ignore characters in 'key' that appear more than once.,Substitute characters from 'key' into 'message' based on their index.,"Use a hash map with characters from 'message' as keys, mapped to characters from 'key'.",Shift the characters in 'message' by an amount determined by the length of 'key'.,Create a mapping from 'key' characters to the alphabet and use this mapping to decode 'message'.,Easy,algorithms,"Hash Table,String"
2326,"Spiral Matrix IV
You are given two integers m and n, which represent the dimensions of a matrix. You are also given the head of a linked list of integers. Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1. Return the generated matrix.",Use a stack to keep track of visited elements during the spiral traversal.,Recursively fill the matrix by processing concentric squares.,Sort the linked list before filling the matrix.,Create a temporary array to store the spiral order indices and then fill the matrix.,Simulate the spiral traversal using four loops for each direction and update boundaries after each loop.,Medium,algorithms,"Array,Linked List,Matrix,Simulation"
2327,"Number of People Aware of a Secret
On day 1, one person discovers a secret. You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards. Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.","The number of people who know the secret can be represented as a Fibonacci sequence, adjusted by the delay and forget parameters.","Use a recursive function to simulate the daily spread, memoizing the number of people aware each day to avoid recomputation.","Maintain a counter representing the total number of people, incremented daily based on the difference between the number of people sharing and forgetting.","Employ dynamic programming, where dp[i] stores the number of people sharing the secret on day i, and the answer is the sum of dp[i] from n - forget + 1 to n.","Use a sliding window approach with a queue to track the number of people sharing the secret each day, considering both delay and forget factors.",Medium,algorithms,"Dynamic Programming,Queue,Simulation"
2328,"Number of Increasing Paths in a Grid
You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions. Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7. Two paths are considered different if they do not have exactly the same sequence of visited cells.",Use Dijkstra's algorithm to find the longest path from each cell and sum the lengths.,Apply dynamic programming with a 1D array to store the lengths of increasing paths in each row.,Sort the entire grid and count paths by iterating from smallest to largest values.,"Perform a brute-force search, recursively exploring all possible paths from each cell, without memoization.",Apply dynamic programming with memoization to count increasing paths starting from each cell.,Hard,algorithms,"Array,Dynamic Programming,Depth-First Search,Breadth-First Search,Graph,Topological Sort,Memoization,Matrix"
2331,"Evaluate Boolean Binary Tree
You are given the root of a full binary tree with the following properties: The evaluation of a node is as follows: Return the boolean result of evaluating the root node. A full binary tree is a binary tree where each node has either 0 or 2 children. A leaf node is a node that has zero children.",Evaluate the tree using a breadth-first search (BFS) approach.,Return the value of the root node without any evaluation.,"Evaluate the tree using a depth-first search (DFS) approach, but only traverse the left subtree.",Evaluate the tree by summing the values of all nodes.,"Evaluate the tree recursively, applying the OR operation for nodes with value 2 and the AND operation for nodes with value 3.",Easy,algorithms,"Tree,Depth-First Search,Binary Tree"
2332,"The Latest Time to Catch a Bus
You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. All bus departure times are unique. All passenger arrival times are unique. You are given an integer capacity, which represents the maximum number of passengers that can get on each bus. When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first. More formally when a bus arrives, either: Return the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger. Note: The arrays buses and passengers are not necessarily sorted.",The minimum arrival time among all passengers.,The departure time of the last bus.,The arrival time of the last passenger.,The median arrival time of all passengers.,"The latest time you can arrive without coinciding with a passenger and still catch a bus, considering bus capacity and passenger arrival order.",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
2333,"Minimum Sum of Squared Difference
You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n. The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n. You are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times. Return the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times. Note: You are allowed to modify the array elements to become negative integers.",Use dynamic programming to store the minimum SSD for all possible values of k1 and k2.,Apply a greedy approach by always reducing the largest difference between elements until k1 and k2 are exhausted.,Sort both arrays and then iteratively reduce the differences starting from the smallest.,Use a brute-force approach by trying all possible combinations of modifications and selecting the minimum SSD.,Use a heap (priority queue) to store the absolute differences and iteratively reduce the largest difference until k1 + k2 modifications are exhausted.,Medium,algorithms,"Array,Binary Search,Greedy,Sorting,Heap (Priority Queue)"
2334,"Subarray With Elements Greater Than Varying Threshold
You are given an integer array nums and an integer threshold. Find any subarray of nums of length k such that every element in the subarray is greater than threshold / k. Return the size of any such subarray. If there is no such subarray, return -1. A subarray is a contiguous non-empty sequence of elements within an array.",Divide each element by the threshold and check if the result is greater than k,Sort the array and check subarrays of increasing size starting from 1,Check every possible subarray and return the size of the first one that meets the criteria or -1 if none exist,Binary search for the optimal k value and then verify if such subarray exists,"Iterate through the array, for each possible subarray length k, check if all elements in at least one subarray of length k are greater than threshold/k. Return k if found, otherwise -1.",Hard,algorithms,"Array,Stack,Union Find,Monotonic Stack"
2337,"Move Pieces to Obtain a String
You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where: Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.",The number of 'L' and 'R' characters must be equal in both strings,"The 'L' characters must appear in the same relative order in both strings, and the 'R' characters must appear in reversed order",Check if the number of non-'_' characters is equal and their indices are the same,The string 'target' must be a substring of the string 'start',"Ignoring '_', the 'L' and 'R' characters must appear in the same order, and an 'L' cannot move right, nor an 'R' left.",Medium,algorithms,"Two Pointers,String"
2338,"Count the Number of Ideal Arrays
You are given two integers n and maxValue, which are used to describe an ideal array. A 0-indexed integer array arr of length n is considered ideal if the following conditions hold: Return the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.","Calculate combinations of prime factors less than maxValue, raised to powers summing to n.","Dynamically program the count of ideal arrays for lengths up to n, considering factors of maxValue.","Recursively compute ideal arrays by appending numbers from 1 to maxValue, pruning invalid branches.",Simulate the generation of all possible arrays and filter those satisfying the ideal conditions.,"Use stars and bars to count non-decreasing arrays, combined with prime factorization of numbers up to maxValue.",Hard,algorithms,"Math,Dynamic Programming,Combinatorics,Number Theory"
2341,"Maximum Number of Pairs in Array
You are given a 0-indexed integer array nums. In one operation, you may do the following: The operation is done on nums as many times as possible. Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.","O(n^2), where n is the size of the array","O(n log n), where n is the size of the array","O(k), where k is the number of unique elements in the array",O(1),"O(n), where n is the size of the array",Easy,algorithms,"Array,Hash Table,Counting"
2342,"Max Sum of a Pair With Equal Sum of Digits
You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j]. Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions. If no such pair of indices exists, return -1.",O(n^2) - Iterate through all pairs and calculate the digit sum for each pair.,"O(n log n) - Sort the array, then iterate and check adjacent elements for equal digit sums.","O(n * k) - For each number, calculate its digit sum and store the numbers with the same digit sum in a list, then find the maximum sum. (where k is the average number of digits)",O(n) - Maintain a running sum of all numbers and check the differences.,"O(n) - Use a hash map to store the maximum number for each digit sum, then iterate through the array and update the maximum sum.",Medium,algorithms,"Array,Hash Table,Sorting,Heap (Priority Queue)"
2343,"Query Kth Smallest Trimmed Number
You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits. You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to: Return an array answer of the same length as queries, where answer[i] is the answer to the ith query. Note:",Sort the trimmed numbers using a radix sort based on the entire string.,Maintain a min-heap of size k for each query and extract the minimum k times after trimming.,Use a selection algorithm to find the kth smallest element after each trim operation.,Apply quicksort on the trimmed list to partition it into smaller segments and locate the kth element.,"For each query, trim the strings, create a list of (trimmed_string, original_index) tuples, sort the list, and return the original_index of the kth element.",Medium,algorithms,"Array,String,Divide and Conquer,Sorting,Heap (Priority Queue),Radix Sort,Quickselect"
2344,"Minimum Deletions to Make Array Divisible
You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums. Return the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1. Note that an integer x divides y if y % x == 0.",Find the Greatest Common Divisor (GCD) of `numsDivide` and return the count of numbers in `nums` smaller than the largest element of `nums`.,"Sort `nums` and iterate through it. For each element, check if it divides all elements in `numsDivide`. If so, return its index. Otherwise return -1.",Return the difference between the length of `nums` and the length of `numsDivide` if the smallest element of `numsDivide` is present in `nums`.,"Calculate the product of elements in `numsDivide`. Find the smallest element in `nums`. Check divisibility of product with this smallest element. Return 0 if divisible, else -1.","Sort `nums` in ascending order. Find the GCD of `numsDivide`. Iterate through `nums` and return the index of the first element that divides the GCD. If no such element exists, return -1.",Hard,algorithms,"Array,Math,Sorting,Heap (Priority Queue),Number Theory"
2347,"Best Poker Hand
You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i]. The following are the types of poker hands you can make from best to worst: Return a string representing the best type of poker hand you can make with the given cards. Note that the return values are case-sensitive.",Flush,Two Pair,Straight,One Pair,Three of a Kind,Easy,algorithms,"Array,Hash Table,Counting"
2348,"Number of Zero-Filled Subarrays
Given an integer array nums, return the number of subarrays filled with 0. A subarray is a contiguous non-empty sequence of elements within an array.",Calculate the product of all numbers then divide by zero-count factorial.,Sum all elements and multiply by the number of zeros.,Count the total number of subarrays and subtract the ones that contain non-zero elements.,Multiply the number of zeros by the array length.,"Iterate through the array, tracking consecutive zeros and summing the counts of subarrays formed by each consecutive sequence.",Medium,algorithms,"Array,Math"
2349,"Design a Number Container System
Design a number container system that can do the following: Implement the NumberContainers class:",Use a hash map to store numbers and their positions. Update the map directly when inserting.,Store the numbers in a sorted array and use binary search for insertion. Update the array with linear shifting.,"Employ a self-balancing tree for managing numbers and their indices, guaranteeing logarithmic time complexity.",Maintain two separate arrays: one for numbers and one for indices. Search linearly in both during insertion.,Utilize two hash maps: one mapping index to number and another mapping number to index. Maintain consistency across both.,Medium,system design,"Hash Table,Design,Heap (Priority Queue),Ordered Set"
2350,"Shortest Impossible Sequence of Rolls
You are given an integer array rolls of length n and an integer k. You roll a k sided dice numbered from 1 to k, n times, where the result of the ith roll is rolls[i]. Return the length of the shortest sequence of rolls so that there's no such subsequence in rolls. A sequence of rolls of length len is the result of rolling a k sided dice len times.",k * n,n / k,log_k(n),n - k,ceil(log_k(n + 1)),Hard,algorithms,"Array,Hash Table,Greedy"
2351,"First Letter to Appear Twice
Given a string s consisting of lowercase English letters, return the first letter to appear twice. Note:","Use a bitset to track character occurrences, shifting bits for each character",Sort the string and check for adjacent identical characters,Utilize a hash function to map characters to indices and detect collisions,Maintain a sliding window of size two and check for matching characters,"Iterate through the string, storing character counts in a hash map and returning the first character with a count of 2",Easy,algorithms,"Hash Table,String,Bit Manipulation,Counting"
2352,"Equal Row and Column Pairs
Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal. A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).",Compute the determinant of the matrix and check if it's zero.,Compare the sum of elements in each row with the sum of elements in each column.,Use a hash table to store the frequency of each element and check for identical frequencies between rows and columns.,"Sort each row and each column independently, then compare the sorted rows and columns.","Iterate through each row and column, comparing them element by element to identify equal pairs.",Medium,algorithms,"Array,Hash Table,Matrix,Simulation"
2353,"Design a Food Rating System
Design a food rating system that can do the following: Implement the FoodRatings class: Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.","Use a single hash table to store food ratings and cuisines, updating entries directly for changeRating, and iterating to find the highest-rated food for getHighestRated","Employ separate arrays for food names, cuisines, and ratings, using linear search for updates and sorting for retrieving the highest-rated food.","Utilize a relational database (e.g., SQLite) to store the data, employing SQL queries for both updating ratings and finding the highest-rated food based on cuisine.",Store all food items in a single string and use the index to get food rating and cuisine,"Employ a hash table (cuisine to a sorted set of foods) and a hash table (food to its rating and cuisine). Sorted set supports efficient retrieval of highest-rated food, and the other hash table provides quick access for updating ratings.",Medium,system design,"Array,Hash Table,String,Design,Heap (Priority Queue),Ordered Set"
2354,"Number of Excellent Pairs
You are given a 0-indexed positive integer array nums and a positive integer k. A pair of numbers (num1, num2) is called excellent if the following conditions are satisfied: Return the number of distinct excellent pairs. Two pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct. Note that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the array.","Count pairs where the sum is greater than or equal to k, without considering bitwise operations.",Count pairs where both numbers are greater than or equal to k.,Iterate through all pairs and check only the 'AND' condition.,Iterate through all pairs and check only the 'OR' condition.,"Precompute the number of set bits for each number, then iterate, checking both 'AND' and 'OR' conditions using bit manipulation.",Hard,algorithms,"Array,Hash Table,Binary Search,Bit Manipulation"
2356,"Number of Unique Subjects Taught by Each Teacher
Table: Teacher  Write a solution to calculate the number of unique subjects each teacher teaches in the university. Return the result table in any order. The result format is shown in the following example.",Use GROUP BY Teacher.teacher_id ORDER BY COUNT(DISTINCT Teacher.subject),Use a subquery to find the number of subjects and then join it back to the Teacher table,Apply a window function to partition by teacher_id and count the subjects,Use a correlated subquery that counts the subjects for each teacher.,"SELECT teacher_id, COUNT(DISTINCT subject) AS cnt FROM Teacher GROUP BY teacher_id",Easy,database systems,Database
2357,"Make Array Zero by Subtracting Equal Amounts
You are given a non-negative integer array nums. In one operation, you must: Return the minimum number of operations to make every element in nums equal to 0.",Find the largest element in the array and subtract it from all other elements repeatedly until all elements are zero.,Sort the array in descending order and subtract each element from the one preceding it.,Calculate the average of the array and subtract this average from each element in each operation.,"Calculate the sum of all positive numbers, and divide it by the length of the array.",Find the number of distinct non-zero elements in the array.,Easy,algorithms,"Array,Hash Table,Greedy,Sorting,Heap (Priority Queue),Simulation"
2358,"Maximum Number of Groups Entering a Competition
You are given a positive integer array grades which represents the grades of students in a university. You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions: Return the maximum number of groups that can be formed.","Use a greedy approach, always selecting the smallest available group size until no more groups can be formed",Sort the grades array and use dynamic programming to determine the optimal group sizes,Calculate the average grade and divide the total number of students by this average to estimate the number of groups,Recursively divide the grades array into halves and count the number of groups that can be formed in each half,Iteratively increment the group size and subtract the required number of students until there are insufficient students left,Medium,algorithms,"Array,Math,Binary Search,Greedy"
2359,"Find Closest Node to Given Two Nodes
You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge. The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1. You are also given two integers node1 and node2. Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1. Note that edges may contain cycles.","Breadth-First Search (BFS) from both nodes, stopping at the first common node found.","Depth-First Search (DFS) from both nodes, returning the lowest-indexed common ancestor.",Dijkstra's algorithm to find the shortest paths from both nodes and then check for the node with the minimum combined distance.,Calculate the distance from each node to node1 and node2 independently using a loop until -1 is reached and return node with minimal distance.,"Calculate the distance from node1 and node2 to all reachable nodes, then find the common reachable node with the minimum of the maximum distances.",Medium,algorithms,"Depth-First Search,Graph"
2360,"Longest Cycle in a Graph
You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge. The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1. Return the length of the longest cycle in the graph. If no cycle exists, return -1. A cycle is a path that starts and ends at the same node.","Use Depth-First Search (DFS) to explore each node and keep track of visited nodes in the current path; if a cycle is found, update the maximum cycle length.",Apply Breadth-First Search (BFS) to find the shortest path from each node to all other nodes and identify cycles based on path lengths.,Employ Dijkstra's algorithm to find the shortest path between all pairs of nodes; a cycle exists if the shortest path from a node to itself is non-infinite.,Represent the graph as an adjacency matrix and calculate its transitive closure using the Floyd-Warshall algorithm; a cycle exists if any diagonal element is true.,"For each unvisited node, perform a DFS; keep track of the path length and detect cycles by checking if a visited node is encountered again in the same path.",Hard,algorithms,"Depth-First Search,Breadth-First Search,Graph,Topological Sort"
2363,"Merge Similar Items
You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties: Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei. Note: ret should be returned in ascending order by value.","Use a hash map to store the values and weights from both arrays and then iterate through the map to create the result, sorting at the end.","Iterate through both arrays simultaneously, using binary search to locate matching values and sum their weights, adding new entries as needed, then sort.","Convert both arrays into single, flattened arrays and then perform a single pass to aggregate weights, sorting the result afterward.","Iterate through the first array and for each element, iterate through the second array to check if the value exists and perform the summation","Use a hash map to store values and weights from both arrays, summing weights for matching values. Then, convert the hash map into a sorted array.",Easy,algorithms,"Array,Hash Table,Sorting,Ordered Set"
2364,"Count Number of Bad Pairs
You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i]. Return the total number of bad pairs in nums.","O(n log n), due to sorting the input array","O(n^2), due to nested loops comparing all pairs","O(1), because it only uses constant extra space","O(n), because the space used grows linearly with input size","O(n), due to iterating through the array once",Medium,algorithms,"Array,Hash Table,Math,Counting"
2365,"Task Scheduler II
You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task. You are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed. Each day, until all tasks have been completed, you must either: Return the minimum number of days needed to complete all tasks.",Use a priority queue to schedule tasks based on their earliest available time.,Employ dynamic programming to minimize the total execution time.,Sort the tasks array and process them in ascending order of task type.,"Greedily schedule tasks, always picking the task with the smallest index.",Use a hash map to store the last execution day for each task type and calculate the minimum completion time based on the space constraint.,Medium,algorithms,"Array,Hash Table,Simulation"
2366,"Minimum Replacements to Sort the Array
You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it. Return the minimum number of operations to make an array that is sorted in non-decreasing order.","Process the array from left to right, greedily splitting elements to match the next element's constraints.","Sort the array first, and then count the number of elements that are out of order.",Divide each element by the average value of the array and count the number of divisions.,"Recursively divide the array in half and solve each half independently, then merge the results.","Iterate from right to left, and greedily split each element to be no larger than the next element, minimizing the number of splits.",Hard,algorithms,"Array,Math,Greedy"
2367,"Number of Arithmetic Triplets
You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met: Return the number of unique arithmetic triplets.","Nested loops iterating through all possible triplets, with O(n^3) time complexity.","Using binary search to find the second and third elements of a potential arithmetic triplet for each element, with O(n log n) complexity.","Maintaining a hash set of the numbers, and checking for the existence of the other two numbers in the triplet, resulting in O(n) space complexity.",Sorting the array first and then iterating through it to find the triplets.,"Iterate through the array once, using a hash map (or array if the range of numbers is limited) to track seen numbers for O(n) time and space.",Easy,algorithms,"Array,Hash Table,Two Pointers,Enumeration"
2368,"Reachable Nodes With Restrictions
There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes. Return the maximum number of nodes you can reach from node 0 without visiting a restricted node. Note that node 0 will not be a restricted node.",Use Breadth-First Search (BFS) and mark restricted nodes as visited only after the initial traversal from node 0.,Transform the graph into a directed graph and then perform Depth-First Search (DFS) avoiding restricted nodes.,"Employ a shortest path algorithm, such as Dijkstra's, penalizing restricted nodes with a very high weight.","Apply a greedy approach, always selecting the path with the fewest restricted nodes at each step.","Use Depth-First Search (DFS) or Breadth-First Search (BFS) starting from node 0, avoiding restricted nodes and marking visited nodes.",Medium,algorithms,"Array,Hash Table,Tree,Depth-First Search,Breadth-First Search,Union Find,Graph"
2369,"Check if There is a Valid Partition For The Array
You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays. We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions: Return true if the array has at least one valid partition. Otherwise, return false.",Check if the entire array forms a single valid subarray according to the conditions.,Recursively explore all possible partitions and backtrack if an invalid subarray is found.,Sort the array and then greedily create valid subarrays from the beginning.,"Use dynamic programming, where dp[i] represents whether the prefix of length i has a valid partition and attempt to build all subarrays at once","Use dynamic programming, where dp[i] indicates if the prefix of length i has a valid partition and iterate, checking for valid subarray extensions.",Medium,algorithms,"Array,Dynamic Programming"
2370,"Longest Ideal Subsequence
You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied: Return the length of the longest ideal string. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",Greedily select characters that minimize the absolute difference with the last selected character.,"Use dynamic programming, storing the length of the longest ideal subsequence ending at each index.",Sort the string and then find the longest increasing subsequence.,"Recursively explore all possible subsequences and check if they are ideal, returning the length of the longest one.",Use dynamic programming to track the longest ideal subsequence ending with each character of the alphabet.,Medium,algorithms,"Hash Table,String,Dynamic Programming"
2373,"Largest Local Values in a Matrix
You are given an n x n integer matrix grid. Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that: In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid. Return the generated matrix.","Brute-force: For each (i, j) in maxLocal, find the maximum in the 3x3 subgrid using nested loops.",Use dynamic programming to precompute sums of all subgrids and then find the max for each 3x3.,"Employ a sliding window approach, maintaining a sorted list of elements in each 3x3 subgrid.",Divide and conquer: Recursively find the maxLocal in smaller subgrids and merge the results.,"Iterate through the grid, and for each possible 3x3 subgrid, find the maximum value within that subgrid to populate maxLocal.",Easy,algorithms,"Array,Matrix"
2374,"Node With Highest Edge Score
You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge. The graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i]. The edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i. Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",Return the node with the largest outdegree.,Return the node with the smallest indegree.,Return the node with the largest label.,Return the node with the smallest label.,"Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",Medium,algorithms,"Hash Table,Graph"
2375,"Construct Smallest Number From DI String
You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing. A 0-indexed string num of length n + 1 is created using the following conditions: Return the lexicographically smallest possible string num that meets the conditions.","Use a greedy approach, always choosing the smallest available digit at each step without backtracking.","Generate all possible permutations of digits and filter the ones that satisfy the pattern, then select the lexicographically smallest.",Start with a random string and use a local search algorithm to iteratively improve it until a valid solution is found.,"Recursively explore possible digit assignments, pruning branches that violate the increasing/decreasing constraints.","Maintain a range of available digits and dynamically choose the next digit based on the pattern, backtracking when necessary to explore other possibilities within the range.",Medium,algorithms,"String,Backtracking,Stack,Greedy"
2376,"Count Special Integers
We call a positive integer special if all of its digits are distinct. Given a positive integer n, return the number of special integers that belong to the interval [1, n].","Hash each digit of the number and check for collisions during insertion, returning false if a duplicate is found","Convert the integer to a string, sort the string, and check if adjacent characters are equal",Recursively generate all possible numbers with distinct digits up to the length of 'n' and filter those less than or equal to 'n',"Count all integers from 1 to n, and for each number, divide repeatedly by 10 and check the remainders for duplicates using a nested loop","Use dynamic programming to count special integers of different lengths, considering the digits used so far",Hard,algorithms,"Math,Dynamic Programming"
2379,"Minimum Recolors to Get K Consecutive Black Blocks
You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively. You are also given an integer k, which is the desired number of consecutive black blocks. In one operation, you can recolor a white block such that it becomes a black block. Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.",Use dynamic programming to calculate the minimum recolors ending at each index.,"Greedily select the first k blocks and recolor white blocks until they are all black, then shift the window one block at a time.",Calculate the total number of white blocks and subtract k to find the answer.,Sort the blocks array and count the number of white blocks among the first k elements.,Use a sliding window of size k to track the number of white blocks within the window and minimize the count.,Easy,algorithms,"String,Sliding Window"
2380,"Time Needed to Rearrange a Binary String
You are given a binary string s. In one second, all occurrences of ""01"" are simultaneously replaced with ""10"". This process repeats until no occurrences of ""01"" exist. Return the number of seconds needed to complete this process.","O(n^2), where n is the length of the string","O(n log n), where n is the length of the string","O(1), the rearrangement happens instantaneously","O(2^n), where n is the length of the string","O(n), where n is the length of the string",Medium,algorithms,"String,Dynamic Programming,Simulation"
2381,"Shifting Letters II
You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0. Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z'). Return the final string after all such shifts to s are applied.","Use a brute-force approach, iterating through shifts and updating the string for each shift operation directly.","Convert the string to an array of character codes, perform the shifts using modular arithmetic on the codes, and then convert back to a string.",Create a prefix sum array representing the net shift at each index and apply those shifts in a separate pass.,Sort the shifts array and apply the shifts in the sorted order to optimize the shifting process.,"Use a difference array to track the shifts, calculate cumulative shifts, and then apply those shifts to the original string using modular arithmetic.",Medium,algorithms,"Array,String,Prefix Sum"
2382,"Maximum Segment Sum After Removals
You are given two 0-indexed integer arrays nums and removeQueries, both of length n. For the ith query, the element in nums at the index removeQueries[i] is removed, splitting nums into different segments. A segment is a contiguous sequence of positive integers in nums. A segment sum is the sum of every element in a segment. Return an integer array answer, of length n, where answer[i] is the maximum segment sum after applying the ith removal. Note: The same index will not be removed more than once.","Using a doubly linked list to track segments and their sums, updating after each removal.",Sorting the `removeQueries` array and processing removals in ascending order of index.,Maintaining a cumulative sum array of `nums` to calculate segment sums efficiently.,Iterating through `removeQueries` and recalculating all segment sums from scratch after each removal.,Employing a disjoint set data structure to efficiently track segments and merge adjacent segments after removals.,Hard,algorithms,"Array,Union Find,Prefix Sum,Ordered Set"
2383,"Minimum Hours of Training to Win a Competition
You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively. You are also given two 0-indexed integer arrays energy and experience, both of length n. You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available. Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i]. Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one. Return the minimum number of training hours required to defeat all n opponents.","Use dynamic programming to calculate the minimum hours needed at each opponent encounter, considering only the energy requirement.",Calculate the total energy and experience required by summing the respective arrays and subtract initial values.,"Employ a greedy approach, maximizing energy gain first, then experience.",Train only in energy until all opponents' energy levels are surpassed.,"Calculate the minimum energy and experience required separately, summing the differences between current values and opponent values where needed.",Easy,algorithms,"Array,Greedy"
2386,"Find the K-Sum of an Array
You are given an integer array nums and a positive integer k. You can choose any subsequence of the array and sum all of its elements together. We define the K-Sum of the array as the kth largest subsequence sum that can be obtained (not necessarily distinct). Return the K-Sum of the array. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Note that the empty subsequence is considered to have a sum of 0.",Use a greedy approach by repeatedly selecting the largest element,Calculate all possible subsequence sums and then use a sorting algorithm with complexity O(n log n),"Employ dynamic programming to store intermediate sums, optimizing for memory usage",Recursively explore all subsequences and maintain a min-heap of size k to track the kth largest sum,"Transform negative numbers to positive, store the absolute values in a min-heap. Precompute the total sum, and iteratively subtract the smallest absolute value from the total sum while keeping track of the k-th largest sum.",Hard,algorithms,"Array,Sorting,Heap (Priority Queue)"
2389,"Longest Subsequence With Limited Sum
You are given an integer array nums of length n, and an integer array queries of length m. Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i]. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",Sort `nums` in descending order and greedily select elements until the sum exceeds `queries[i]`,"For each `queries[i]`, iterate through all possible subsequences of `nums` and check their sums.",Use dynamic programming to build a table of all possible subsequence sums and their corresponding lengths.,Calculate the prefix sum array of `nums` and use binary search to find the longest subsequence sum less than or equal to `queries[i]`.,"Sort `nums` in ascending order. For each `queries[i]`, iterate through the sorted `nums` and greedily take elements until the sum exceeds `queries[i]`. Count the number of elements taken.",Easy,algorithms,"Array,Binary Search,Greedy,Sorting,Prefix Sum"
2390,"Removing Stars From a String
You are given a string s, which contains stars *. In one operation, you can: Return the string after all stars have been removed. Note:",Replace each star with a space and then trim the string.,Recursively remove the first star encountered along with the character immediately preceding it.,Use a regular expression to remove all occurrences of a character followed by a star.,"Iterate through the string and build a new string, skipping any characters preceding a star.","Use a stack; push characters onto the stack unless a star is encountered, then pop the last character.",Medium,algorithms,"String,Stack,Simulation"
2391,"Minimum Amount of Time to Collect Garbage
You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute. You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1. There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house. Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything. Return the minimum number of minutes needed to pick up all the garbage.","Calculate the total garbage and travel times independently, then add them.",Calculate garbage collection time for each truck separately and sum the individual times plus all travel times.,Use dynamic programming to find the optimal path for each truck and sum the results.,"Find the truck that needs to travel the furthest and calculate its time, then add the other trucks' garbage collection times.","Find the last house each truck visits, calculate travel time to that house, and add it to the total garbage collection time for each truck.",Medium,algorithms,"Array,String,Prefix Sum"
2392,"Build a Matrix With Conditions
You are given a positive integer k. You are also given: The two arrays contain integers from 1 to k. You have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0. The matrix should also satisfy the following conditions: Return any matrix that satisfies the conditions. If no answer exists, return an empty matrix.",Create an adjacency matrix representing the row and column constraints and perform a topological sort.,Use a backtracking algorithm to explore all possible matrix configurations until a valid one is found.,"Apply a greedy algorithm, filling the matrix cell by cell, prioritizing the numbers with the fewest remaining constraints.","Employ a randomized algorithm, randomly assigning numbers to cells and iteratively improving the matrix until it satisfies the conditions.",Model the problem as a bipartite matching problem and use the maximum flow algorithm to find a valid assignment of numbers to rows and columns.,Hard,algorithms,"Array,Graph,Topological Sort,Matrix"
2395,"Find Subarrays With Equal Sum
Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices. Return true if these subarrays exist, and false otherwise. A subarray is a contiguous non-empty sequence of elements within an array.","Check for duplicate elements in the array. If duplicates exist, return true.","Calculate the sum of all possible subarrays of length 2 and compare them. If any two sums are equal, return true.","Sort the array and check if any adjacent elements have the same value. If so, return true.","Use a sliding window of size 2 and compare the sum of the current window with the sum of the previous window. If they are equal, return true.","Use a hash set to store the sums of all subarrays of length 2. If a sum is already in the set, return true.",Easy,algorithms,"Array,Hash Table"
2396,"Strictly Palindromic Number
An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic. Given an integer n, return true if n is strictly palindromic and false otherwise. A string is palindromic if it reads the same forward and backward.",Any number less than 4 is strictly palindromic.,Only prime numbers can be strictly palindromic.,"Numbers of the form 2^k + 1, where k is an integer, are always strictly palindromic.",A number is strictly palindromic if its base 2 representation is a palindrome.,No number is strictly palindromic for n > 3.,Medium,algorithms,"Math,Two Pointers,Brainteaser"
2397,"Maximum Rows Covered by Columns
You are given an m x n binary matrix matrix and an integer numSelect. Your goal is to select exactly numSelect distinct columns from matrix such that you cover as many rows as possible. A row is considered covered if all the 1's in that row are also part of a column that you have selected. If a row does not have any 1s, it is also considered covered. More formally, let us consider selected = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row i is covered by selected if: Return the maximum number of rows that can be covered by a set of numSelect columns.",Greedily select columns with the most 1s until numSelect is reached.,Use dynamic programming to store the maximum covered rows for each subset of columns.,"Randomly select numSelect columns and repeat many times, keeping track of the best result.",Use a backtracking approach to explore all possible combinations of numSelect columns.,Iterate through all combinations of columns of size numSelect and check how many rows are covered by each combination.,Medium,algorithms,"Array,Backtracking,Bit Manipulation,Matrix,Enumeration"
2398,"Maximum Number of Robots Within Budget
You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget. The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots. Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.","Using a binary search approach, iteratively test different window sizes. For each size, calculate the cost using brute force and check if it exceeds the budget.","Precompute prefix sums for both `chargeTimes` and `runningCosts`. Then, for each window size, use the prefix sums to calculate the cost and check against the budget.",Maintain a priority queue of `chargeTimes` within the sliding window and update the maximum charge time accordingly.  Update the running cost sum by adding the new element and removing the element leaving the window. Track the maximum valid window size.,"Sort both the `chargeTimes` and `runningCosts` arrays independently. Iterate through them simultaneously, choosing the minimum charge time and running cost at each step, until the budget is exceeded.",Use a sliding window approach with a deque to maintain the maximum `chargeTime` in the window and track the sum of `runningCosts`. Update the window boundaries to satisfy the budget constraint.,Hard,algorithms,"Array,Binary Search,Queue,Sliding Window,Heap (Priority Queue),Prefix Sum,Monotonic Queue"
2399,"Check Distances Between Same Letters
You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26. Each letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25). In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored. Return true if s is a well-spaced string, otherwise return false.","Use a hash map to store the first occurrence of each character and check the distances during the second occurrence, returning true only if all distances match.","Iterate through the string and for each character, calculate the distance between its two occurrences. If any distance doesn't match distance[i], return true; otherwise, return false.",Check if the length of the string s is equal to the sum of the distance array. Return true if they are equal and false otherwise.,"Sort the string alphabetically. Create a temporary array to track occurrences of each character. If the calculated distance doesn't match, return false; otherwise, return true.","Iterate through the string and for each character, calculate the distance between its two occurrences. If any distance doesn't match distance[i], return false; otherwise, return true after checking all characters.",Easy,algorithms,"Array,Hash Table,String"
2400,"Number of Ways to Reach a Position After Exactly k Steps
You are given two positive integers startPos and endPos. Initially, you are standing at position startPos on an infinite number line. With one step, you can move either one position to the left, or one position to the right. Given a positive integer k, return the number of different ways to reach the position endPos starting from startPos, such that you perform exactly k steps. Since the answer may be very large, return it modulo 109 + 7. Two ways are considered different if the order of the steps made is not exactly the same. Note that the number line includes negative integers.",Use dynamic programming with a 1D array representing positions and iterate 'k' times.,"Recursively explore all possible paths, pruning branches that exceed 'k' steps; memoize results to avoid recomputation.",Apply the stars and bars theorem to count combinations of left and right moves without considering path validity.,"Calculate the binomial coefficient C(k, (k + endPos - startPos)/2) directly if (k + endPos - startPos) is even; otherwise, return 0.","Use dynamic programming with a 2D array, dp[i][j] representing the number of ways to reach position 'j' in 'i' steps, considering boundaries and modulo.",Medium,algorithms,"Math,Dynamic Programming,Combinatorics"
2401,"Longest Nice Subarray
You are given an array nums consisting of positive integers. We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0. Return the length of the longest nice subarray. A subarray is a contiguous part of an array. Note that subarrays of length 1 are always considered nice.",O(n^3) due to nested loops checking all possible subarray combinations.,O(n log n) because the optimal algorithm involves sorting the array.,O(n*k) where n is the length of nums and k is the number of bits in the largest number in nums,O(2^n) as it explores all possible subarrays using recursion.,O(n) because the algorithm uses a sliding window technique where each element is visited at most twice.,Medium,algorithms,"Array,Bit Manipulation,Sliding Window"
2402,"Meeting Rooms III
You are given an integer n. There are n rooms numbered from 0 to n - 1. You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique. Meetings are allocated to rooms in the following manner: Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number. A half-closed interval [a, b) is the interval between a and b including a and not including b.",Use a hash map to track the number of meetings in each room and update it after each meeting.,Sort the meetings by their start times and use a greedy algorithm to assign each meeting to the earliest available room.,Simulate the meeting scheduling process using a priority queue to manage available rooms based on their availability.,"Assign each meeting to a random available room, and then correct the room assignments in a later cleanup phase","Maintain an array representing the usage count of each room and a priority queue to track available rooms, allocating meetings to the smallest available room.",Hard,algorithms,"Array,Hash Table,Sorting,Heap (Priority Queue),Simulation"
2404,"Most Frequent Even Element
Given an integer array nums, return the most frequent even element. If there is a tie, return the smallest one. If there is no such element, return -1.",Thread safety is automatically guaranteed,Context switching overhead is minimized,Resource contention is eliminated entirely,Code becomes inherently more readable and maintainable,The overall throughput of the application can potentially increase by parallelizing tasks,Easy,system design,"Array,Hash Table,Counting"
2405,"Optimal Partition of String
Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition.","Use a greedy approach, always starting a new substring at the first repeating character.","Sort the string first, then partition based on sorted character runs.",Create a frequency map of all characters in the string and partition based on character frequency.,Recursively divide the string into halves and find the optimal partition for each half.,"Iterate through the string, keeping track of characters in the current substring. Start a new substring when a repeating character is encountered.",Medium,algorithms,"Hash Table,String,Greedy"
2406,"Divide Intervals Into Minimum Number of Groups
You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti]. You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other. Return the minimum number of groups you need to make. Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.","Sort intervals by start time and greedily assign intervals to existing groups if non-overlapping, otherwise create a new group.","Iterate through the intervals, merging overlapping intervals into larger intervals and counting the final number of merged intervals.",Create a graph where each interval is a node and edges connect overlapping intervals; then find the maximum clique size.,Use a recursive algorithm to explore all possible groupings and select the grouping with the fewest groups.,"Sort intervals by start time; use a priority queue to track the end times of intervals in each group, minimizing group count.",Medium,algorithms,"Array,Two Pointers,Greedy,Sorting,Heap (Priority Queue),Prefix Sum"
2407,"Longest Increasing Subsequence II
You are given an integer array nums and an integer k. Find the longest subsequence of nums that meets the following requirements: Return the length of the longest subsequence that meets the requirements. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",Use dynamic programming with a binary search tree to store the smallest end element for each length of subsequence.,"Apply a greedy approach, always selecting the smallest element greater than the previous element in the subsequence.",Sort the input array and then find the longest increasing subsequence in the sorted array.,"Employ a brute-force method, generating all possible subsequences and checking if each one is increasing and satisfies the k-difference constraint.",Utilize dynamic programming with a segment tree or binary indexed tree to efficiently find the maximum length of the subsequence ending with a value less than or equal to nums[i].,Hard,algorithms,"Array,Divide and Conquer,Dynamic Programming,Binary Indexed Tree,Segment Tree,Queue,Monotonic Queue"
2409,"Count Days Spent Together
Alice and Bob are traveling to Rome for separate business meetings. You are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format ""MM-DD"", corresponding to the month and day of the date. Return the total number of days that Alice and Bob are in Rome together. You can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].",Use a hash map to store the arrival and departure dates and then calculate the intersection.,Convert all dates to the number of days since the beginning of the year and then compare the ranges.,"Calculate the difference between the arrival dates and departure dates independently, then subtract the smaller difference from the larger.",Compare the dates lexicographically without considering the number of days in each month.,"Find the latest arrival date and the earliest departure date, then calculate the difference in days if the arrival is before the departure.",Easy,algorithms,"Math,String"
2410,"Maximum Matching of Players With Trainers
You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer. The ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player. Return the maximum number of matchings between players and trainers that satisfy these conditions.",Sort both arrays and use binary search for each player to find a suitable trainer.,Use dynamic programming to build a table of possible matchings.,Iterate through all possible combinations of players and trainers to find the maximum matching.,Create a bipartite graph and apply the Ford-Fulkerson algorithm.,Sort both arrays and use a two-pointer approach to greedily match players with trainers.,Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
2411,"Smallest Subarrays With Maximum Bitwise OR
You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR. The bitwise OR of an array is the bitwise OR of all the numbers in it. Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR. A subarray is a contiguous non-empty sequence of elements within an array.",The first occurrence of the maximum bitwise OR is always at index 0.,The length of the smallest subarray is always 1.,The length of the smallest subarray is always n.,The length of the smallest subarray is always the same for all indices.,"For each index i, iterate through subarrays starting at i, calculate the bitwise OR, and track the smallest length that achieves the maximum bitwise OR seen so far.",Medium,algorithms,"Array,Binary Search,Bit Manipulation,Sliding Window"
2412,"Minimum Money Required Before Transactions
You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki]. The array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of money. In order to complete transaction i, money >= costi must hold true. After performing a transaction, money becomes money - costi + cashbacki. Return the minimum amount of money required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.","Sum the costs and cashbacks separately, then return the difference between the total cost and the maximum cashback.","Return the sum of all costs, assuming no cashbacks are used.",Sort transactions by cost-cashback difference and sum the costs.,Calculate the maximum cost among all transactions and return that value.,Iterate through all possible transaction orders to find the minimum starting money required.,Hard,algorithms,"Array,Greedy,Sorting"
2414,"Length of the Longest Alphabetical Continuous Substring
An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string ""abcdefghijklmnopqrstuvwxyz"". Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.",Use dynamic programming to build a table of all possible substrings and their lengths.,"Sort the string and then iterate through it, keeping track of the longest consecutive sequence.","Use a sliding window approach, shrinking the window if the alphabetical order is broken, and expanding otherwise.",Recursively check each substring to determine if it is alphabetical and update the maximum length found.,"Iterate through the string, tracking the current consecutive alphabetical substring length, and updating the maximum length when a longer sequence is found or the sequence breaks.",Medium,algorithms,String
2415,"Reverse Odd Levels of Binary Tree
Given the root of a perfect binary tree, reverse the node values at each odd level of the tree. Return the root of the reversed tree. A binary tree is perfect if all parent nodes have two children and all leaves are on the same level. The level of a node is the number of edges along the path between it and the root node.",Perform an in-order traversal and reverse the values in the resulting list,Perform a level-order traversal and reverse the values at each level independently using an auxiliary array,"Perform a depth-first search, reversing the nodes' pointers instead of their values at odd levels",Use a stack to store node values and reverse on pop,"Use a modified level-order traversal with two queues, swapping values at corresponding positions on odd levels",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Binary Tree"
2416,"Sum of Prefix Scores of Strings
You are given an array words of size n consisting of non-empty strings. We define the score of a string term as the number of strings words[i] such that term is a prefix of words[i]. Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i]. Note that a string is considered as a prefix of itself.",Hash Map,Linked List,Binary Search Tree,Queue,Trie,Hard,data structures,"Array,String,Trie,Counting"
2418,"Sort the People
You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n. For each index i, names[i] and heights[i] denote the name and height of the ith person. Return names sorted in descending order by the people's heights.",Use a bubble sort algorithm directly on the names array based on corresponding heights.,"Create a hash map to store names and heights, then sort the hash map keys by value.","Sort the heights array, then iterate through the sorted heights to find the corresponding name in the original names array using linear search.",Use a min-heap data structure to keep track of the smallest height and its corresponding name.,"Create an array of indices and sort it based on the values in the heights array using a custom comparator, then use these indices to access the names array in sorted order.",Easy,algorithms,"Array,Hash Table,String,Sorting"
2419,"Longest Subarray With Maximum Bitwise AND
You are given an integer array nums of size n. Consider a non-empty subarray from nums that has the maximum possible bitwise AND. Return the length of the longest such subarray. The bitwise AND of an array is the bitwise AND of all the numbers in it. A subarray is a contiguous sequence of elements within an array.",O(n log n) due to sorting the subarray after calculating the bitwise AND.,O(n^2) due to nested loops for considering all possible subarrays.,O(n) because you might need to iterate through the entire array in the worst case to find the longest subarray.,O(1) because the bitwise AND operation is a constant-time operation.,O(n) because you iterate through the array once to find the maximum bitwise AND and then iterate again to find the longest subarray with that AND.,Medium,algorithms,"Array,Bit Manipulation,Brainteaser"
2420,"Find All Good Indices
You are given a 0-indexed integer array nums of size n and a positive integer k. We call an index i in the range k <= i < n - k good if the following conditions are satisfied: Return an array of all good indices sorted in increasing order.",Use dynamic programming to store the minimum steps to reach each index,Apply a sliding window of size k to check the condition at each index,Sort the array and then iterate through to find good indices,Use binary search to find potential good indices,Precompute increasing and decreasing sequences of length k to determine good indices,Medium,algorithms,"Array,Dynamic Programming,Prefix Sum"
2421,"Number of Good Paths
There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi. A good path is a simple path that satisfies the following conditions: Return the number of distinct good paths. Note that a path and its reverse are counted as the same path. For example, 0 -> 1 is considered to be the same as 1 -> 0. A single node is also considered as a valid path.",Use Depth-First Search (DFS) and count paths where all node values are equal,Use Dijkstra's algorithm to find the shortest path between all pairs of nodes,Use dynamic programming to compute the longest increasing subsequence in the tree,Use Kruskal's algorithm to find the minimum spanning tree,"Use Disjoint Set Union (DSU) to merge nodes with values less than or equal to the current value, then count paths within each component",Hard,algorithms,"Array,Hash Table,Tree,Union Find,Graph,Sorting"
2423,"Remove Letter To Equalize Frequency
You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal. Return true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise. Note:","If all characters have the same frequency, return true. If all characters occur once, return true. Otherwise, return false.","Sort the frequency counts. If the first frequency count is 1 and all other frequencies are equal, or if all frequencies are equal except for one that is 1 greater, return true. Otherwise, return false.","Calculate the mean frequency of all characters. If removing any one character results in all frequencies being equal to the original mean, return true. Otherwise, return false.","Check if removing the first character results in equal frequencies. If not, return false. Otherwise, return true.","Count character frequencies. If all are equal, return true. Otherwise, if removing one instance of the highest frequency makes all equal, or the lowest frequency is 1 and can be removed to equalize the rest, return true. Otherwise, return false.",Easy,algorithms,"Hash Table,String,Counting"
2424,"Longest Uploaded Prefix
You are given a stream of n videos, each represented by a distinct number from 1 to n that you need to ""upload"" to a server. You need to implement a data structure that calculates the length of the longest uploaded prefix at various points in the upload process. We consider i to be an uploaded prefix if all videos in the range 1 to i (inclusive) have been uploaded to the server. The longest uploaded prefix is the maximum value of i that satisfies this definition.

Implement the LUPrefix class:",Use a hash table to store uploaded videos and iterate from 1 to n to find the longest prefix.,Maintain a sorted array of uploaded videos and perform a binary search to find the largest prefix.,Keep a counter for uploaded videos and increment it if the current video is the next expected video.,"Utilize a bitset where the i-th bit represents whether video i is uploaded, then find the longest consecutive sequence of set bits from the beginning.","Use a boolean array of size n+1 where index i represents video i. Initially, all values are false. Upon uploading video i, set the i-th element to true. Iterate the array from index 1 to find the longest prefix.",Medium,data structures,"Hash Table,Binary Search,Union Find,Design,Binary Indexed Tree,Segment Tree,Heap (Priority Queue),Ordered Set"
2425,"Bitwise XOR of All Pairings
You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. Let there be another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once). Return the bitwise XOR of all integers in nums3.","XOR all elements of nums1 and nums2 individually, then XOR the results.",Multiply the XOR of nums1 by the XOR of nums2.,"If either array has an even number of elements, return 0; otherwise, XOR all elements of both arrays.","XOR all elements of nums1, then XOR this result with the count of elements in nums2.","If either array has an even number of elements, XOR all elements of the other array; otherwise, XOR all elements of both arrays.",Medium,algorithms,"Array,Bit Manipulation,Brainteaser"
2426,"Number of Pairs Satisfying Inequality
You are given two 0-indexed integer arrays nums1 and nums2, each of size n, and an integer diff. Find the number of pairs (i, j) such that: Return the number of pairs that satisfy the conditions.",Use brute-force nested loops comparing all pairs with O(n^2) complexity,Sort both arrays independently and then count pairs using binary search for each element in nums1,"Apply a divide-and-conquer approach, recursively splitting the arrays and merging the counts",Calculate the difference array (nums1[i] - nums2[i]) and find pairs where the index difference is less than or equal to diff,Calculate the difference array (nums1[i] - nums2[i]) and use merge sort with an inversion count modification to count valid pairs,Hard,algorithms,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set"
2427,"Number of Common Factors
Given two positive integers a and b, return the number of common factors of a and b. An integer x is a common factor of a and b if x divides both a and b.","Iterate from 1 to min(a, b) and count divisors using the modulo operator, but skip even numbers for optimization.",Find prime factorizations of 'a' and 'b' and calculate the common factors from the intersection of their prime factors.,"Calculate the greatest common divisor (GCD) using the Euclidean algorithm, then iterate from 1 to a fixed constant (e.g., 100) and check divisibility against the GCD.","Store all factors of 'a' and 'b' in separate hash sets, then compute the size of the intersection of the two sets.","Iterate from 1 to min(a, b) and increment a counter for each number that divides both 'a' and 'b' without a remainder.",Easy,algorithms,"Math,Enumeration,Number Theory"
2428,"Maximum Sum of an Hourglass
You are given an m x n integer matrix grid. We define an hourglass as a part of the matrix with the following form: Return the maximum sum of the elements of an hourglass. Note that an hourglass cannot be rotated and must be entirely contained within the matrix.",Calculate the sum of all possible hourglasses and return the minimum.,"Iterate through the grid, skipping rows and columns to calculate partial hourglass sums.",Use a sliding window approach with a fixed hourglass pattern to calculate sums.,Precompute the sum of all submatrices of size 3x3 and then subtract the appropriate elements to form the hourglass.,"Iterate through the grid, calculating the sum of each possible hourglass and tracking the maximum sum encountered.",Medium,algorithms,"Array,Matrix,Prefix Sum"
2429,"Minimize XOR
Given two positive integers num1 and num2, find the positive integer x such that: Note that XOR is the bitwise XOR operation. Return the integer x. The test cases are generated such that x is uniquely determined. The number of set bits of an integer is the number of 1's in its binary representation.",Maximize the number of common set bits between x and num1.,Minimize the number of set bits in x while ensuring it's greater than num1.,"Start with x = num1, and flip bits to match the set bits in num2.",Find the smallest x such that x XOR num1 equals num2.,"Find x with the same number of set bits as num2, minimizing x XOR num1.",Medium,algorithms,"Greedy,Bit Manipulation"
1529,"Max Difference You Can Get From Changing an Integer
You are given an integer num. You will apply the following steps to num two separate times: Let a and b be the two results from applying the operation to num independently. Return the max difference between a and b. Note that neither a nor b may have any leading zeros, and must not be 0.","Greedily replace the leftmost non-9 digit with 9, and the leftmost digit with 1 if it's not already 1 or 0; otherwise, replace the next smallest digit with 0.","Find the largest digit, replace all occurrences with 9; find the smallest digit, replace all occurrences with 0. Calculate the difference.","Sort the digits of the number in ascending and descending order, then convert back to integers and subtract. Handle leading zeros.","Replace all odd digits with 9 and all even digits with 0. Then, replace all even digits with 0 and all odd digits with 9. Take the absolute difference.","Find the leftmost digit. If not 9, replace all occurrences of it with 9 to maximize. Find the leftmost digit. If not 1, replace all occurrences of it with 1; otherwise, replace the next distinct digit with 0 to minimize. Return the difference.",Medium,algorithms,"Math,Greedy"
1530,"Check If a String Can Break Another String
Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. In other words s2 can break s1 or vice-versa. A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.",Return True if the sorted s1 is lexicographically greater than or equal to the sorted s2.,Check if the ASCII sum of s1 is greater than or equal to the ASCII sum of s2.,"Compare the lengths of the strings after removing duplicate characters, returning True if s1's length is greater than or equal to s2's.",Return True only if the strings are identical after sorting.,Sort both strings. Return True if every character in sorted s1 is greater than or equal to the corresponding character in sorted s2 OR vice versa.,Medium,algorithms,"String,Greedy,Sorting"
1531,"Number of Ways to Wear Different Hats to Each Other
There are n people and 40 types of hats labeled from 1 to 40. Given a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person. Return the number of ways that n people can wear different hats from each other. Since the answer may be too large, return it modulo 109 + 7.","Use dynamic programming with a state representing the people assigned hats and a bitmask of used hats, iterating through possible hat assignments for each person.","Employ a greedy algorithm, assigning each person their least favorite hat first to minimize conflicts.","Apply backtracking to explore all possible hat assignments, pruning branches when a conflict arises or a solution is found.",Sort the hats array based on the number of people preferring each hat and assign hats in that order using a recursive approach.,Utilize dynamic programming with a state representing the hat being considered and a bitmask indicating which people have been assigned a hat.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
1547,"Destination City
You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",Use Depth-First Search (DFS) to explore all possible paths and identify the city with no outgoing edges.,Sort the paths lexicographically and choose the last city in the sorted list of destination cities.,Count the occurrences of each city in the 'paths' array. The city with the fewest occurrences is the destination.,Create a graph data structure from the 'paths' array and find the node with an outdegree of 0.,Identify all starting cities and then iterate through all destinations. The destination not found in the starting cities is the answer.,Easy,algorithms,"Hash Table,String"
1548,"Check If All 1's Are at Least Length K Places Away
Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other, otherwise return false.",Ensure that the count of 0's between each 1 is exactly equal to k.,Maintain a sliding window of size k and check if it contains more than one 1.,"Count the total number of 1's and divide the array length by this count; if the result is greater than k, return true.",Replace all 1's with 0's if they are closer than k places.,"Keep track of the index of the last 1 encountered; if the current 1 is less than k places away from the last 1, return false.",Easy,algorithms,Array
2207,"Sequentially Ordinal Rank Tracker
A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system. Implement the SORTracker class:","Use a simple array and sort it after each addition, then return the element at the specified index.",Store locations in a hash table and recalculate the ranking using a sorting algorithm upon each rank request.,"Utilize a self-balancing binary search tree, inserting based on score and name, and use an in-order traversal to determine rank.","Maintain two separate sorted arrays, one for scores and one for names, merging them for ranking.","Employ two sets, one ordered set for tracking all locations and another ordered set for tracking the already retrieved locations.",Hard,data structures,"Design,Heap (Priority Queue),Data Stream,Ordered Set"
2226,"Rings and Rods
There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9. You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where: For example, ""R3G2B1"" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return the number of rods that have all three colors of rings on them.",Use a hash map to store the rod colors and then iterate to find rods with all three colors,Sort the input string and then iterate to count rods with all three colors in sequence,Use bit manipulation to encode the colors and then check if the bitmask for each rod is equal to a specific value,Employ dynamic programming to determine the optimal number of rods with all three colors,Create an array of sets to store the colors for each rod and count sets containing all three colors,Easy,algorithms,"Hash Table,String"
2227,"Sum of Subarray Ranges
You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray. Return the sum of all subarray ranges of nums. A subarray is a contiguous non-empty sequence of elements within an array.","Calculate the range for each subarray independently and sum them, leading to potential redundant calculations.","Use a min-heap and max-heap to track the minimum and maximum elements in each subarray, updating them as the window slides.","Sort the entire array first, then iterate through all possible subarrays, which disrupts the original subarray order.","Precompute all possible subarray sums, then find the min and max for each sum to calculate the range.",Use two nested loops to iterate through all possible subarrays and efficiently track the minimum and maximum elements within each subarray.,Medium,algorithms,"Array,Stack,Monotonic Stack"
2228,"Watering Plants II
Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way: Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",The person with the larger capacity always waters the current plant,"If either person has enough water, they water the plant; otherwise, they both refill","Alice waters from left to right, Bob from right to left, and they refill only when necessary",Always refill both cans before watering each plant to ensure they have enough,"Alice waters from left, Bob from right, refilling if needed, and if they meet at the middle plant, the person with more water waters it (or Alice if equal)",Medium,algorithms,"Array,Two Pointers,Simulation"
2229,"Maximum Fruits Harvested After at Most K Steps
Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique. You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return the maximum total number of fruits you can harvest.",Use dynamic programming with a 2D table where dp[i][j] represents the maximum fruits harvested using at most i steps and ending at position j.,Sort the fruits array based on the distance from startPos and greedily pick fruits until k steps are exhausted.,"Perform a binary search to find the closest fruit position, then move in that direction until k steps are exhausted, repeating the search.","Simulate all possible paths using recursion, pruning branches that exceed k steps or visit the same position multiple times.",Use a sliding window approach to efficiently calculate the maximum fruits harvested by considering moving left then right or right then left from the start position.,Hard,algorithms,"Array,Binary Search,Sliding Window,Prefix Sum"
2430,"Maximum Deletions on a String
You are given a string s consisting of only lowercase English letters. In one operation, you can: For example, if s = ""ababc"", then in one operation, you could delete the first two letters of s to get ""abc"", since the first two letters of s and the following two letters of s are both equal to ""ab"". Return the maximum number of operations needed to delete all of s.",Greedily delete the longest possible matching prefixes without memoization.,"Use dynamic programming with a bottom-up approach, considering all possible prefix lengths.","Recursively delete prefixes, caching the results to avoid recomputation.","Apply a greedy approach, always deleting the shortest possible matching prefixes.",Use dynamic programming with a top-down (memoized) approach to find the optimal solution.,Hard,algorithms,"String,Dynamic Programming,Rolling Hash,String Matching,Hash Function"
2432,"The Employee That Worked on the Longest Task
There are n employees, each with a unique id from 0 to n - 1. You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where: Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0. Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.",Calculate the work time for each employee using a min-heap.,Sort the logs array by employee ID and then calculate work times.,Use recursion to iterate through the logs and find the maximum work time.,Calculate the average work time and return the employee with the ID closest to the average.,"Iterate through the logs array, tracking the total work time for each employee and returning the employee with the maximum work time and smallest ID in case of ties.",Easy,algorithms,Array
2433,"Find The Original Array of Prefix Xor
You are given an integer array pref of size n. Find and return the array arr of size n that satisfies: Note that ^ denotes the bitwise-xor operation. It can be proven that the answer is unique.","Calculate arr[i] as pref[i] ^ pref[0] for all i > 0, and arr[0] = pref[0]","Calculate arr[i] as pref[0] ^ pref[i] for all i > 0, and arr[0] = pref[0]","Calculate arr[i] as pref[i] + pref[i-1] for all i > 0, and arr[0] = pref[0]",Calculate arr[i] as the bitwise AND of pref[i] and pref[i-1] for i > 0; arr[0] = pref[0],"Calculate arr[i] as pref[i] ^ pref[i-1] for all i > 0, and arr[0] = pref[0]",Medium,algorithms,"Array,Bit Manipulation"
2434,"Using a Robot to Print the Lexicographically Smallest String
You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty: Return the lexicographically smallest string that can be written on the paper.","Greedily move characters from 's' to the paper, prioritizing smaller characters directly from 's'.","Move all characters from 's' to 't', sort 't', then move 't' to the paper.","Move characters from 's' to 't' only if they are smaller than the last character on the paper. Otherwise, move them to the paper directly.","Recursively move the smallest character from 's' to the paper, removing it from 's' until 's' is empty.","Iterate through 's'. If 's[i]' is the smallest character in s[i:], move it to the paper and remove it from 's'. Otherwise, move 's[i]' to 't'. When 's' is empty or 's[i]' is the smallest remaining, move 't' to paper.",Medium,algorithms,"Hash Table,String,Stack,Greedy"
2435,"Paths in Matrix Whose Sum Is Divisible by K
You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right. Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.",Use Dijkstra's algorithm to find the shortest path and check divisibility by k.,"Apply a greedy approach, always choosing the path with the smallest immediate value.",Calculate the sum of all elements in the grid and divide by k to check for divisibility.,Compute all possible paths and check if the product of the elements is divisible by k.,Employ dynamic programming to store the number of paths with a specific sum modulo k at each cell.,Hard,algorithms,"Array,Dynamic Programming,Matrix"
2437,"Number of Valid Clock Times
You are given a string of length 5 called time, representing the current time on a digital clock in the format ""hh:mm"". The earliest possible time is ""00:00"" and the latest possible time is ""23:59"". In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9. Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9.",6,12,18,24,36,Easy,algorithms,"String,Enumeration"
2438,"Range Product Queries of Powers
Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array. You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti. Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.","Precompute the powers array, then for each query, iterate through the subarray and calculate the product modulo 10^9 + 7",Precompute all possible range products modulo 10^9 + 7 and store them in a lookup table for O(1) query time,"Calculate the product of all elements in the powers array modulo 10^9 + 7, and then divide by the elements outside the query range","Use dynamic programming to store the cumulative product of the powers array modulo 10^9 + 7, then use this to calculate range products","Precompute prefix products modulo 10^9 + 7, then for each query calculate (prefix[right] * modInverse(prefix[left-1])) mod (10^9 + 7)",Medium,algorithms,"Array,Bit Manipulation,Prefix Sum"
2439,"Minimize Maximum of Array
You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Return the minimum possible value of the maximum integer of nums after performing any number of operations.","Binary search on the range [0, sum(nums)] and check if a maximum value is achievable",Greedily distribute excess values from right to left until all elements are as close as possible,Sort the array and redistribute values from the largest to the smallest elements,Calculate the average of the array and round up to the nearest integer,"Iterate through the array, maintaining a running sum and updating the maximum required average",Medium,algorithms,"Array,Binary Search,Dynamic Programming,Greedy,Prefix Sum"
2440,"Create Components With Same Value
There is an undirected tree with n nodes labeled from 0 to n - 1. You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component. Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.","Recursively compute the total sum and check if it's divisible by a factor, then use DFS to partition.",Use dynamic programming to store subtree sums and efficiently determine the optimal cut.,Calculate the sum of all node values and return the total number of nodes minus 1 if the sum is not divisible by any number greater than 1.,"Iteratively try deleting each edge and checking if the resulting components have the same value, keeping track of the maximum deletions.","Calculate the total sum, find its factors, and use DFS to check if the tree can be split into components with a sum equal to one of the factors.",Hard,algorithms,"Array,Math,Tree,Depth-First Search,Enumeration"
2441,"Largest Positive Integer That Exists With Its Negative
Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1.",Use a hash table to store each number and then iterate to find the largest k such that -k exists in the hash table.,Sort the array and then iterate from the beginning to find the first positive number.,Iterate through the array and keep track of the maximum absolute value encountered.,Calculate the sum of all positive numbers and the sum of all negative numbers. Divide the sum of positive numbers by the absolute value of the sum of negative numbers.,"Iterate through the array, checking for each positive number k if -k also exists. Maintain the largest such k found.",Easy,algorithms,"Array,Hash Table,Two Pointers,Sorting"
2442,"Count Number of Distinct Integers After Reverse Operations
You are given an array nums consisting of positive integers. You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums. Return the number of distinct integers in the final array.",Use a hash set to store the integers and their reversed counterparts as strings to count distinct elements.,"Sort the array and use linear search to identify distinct numbers, reversing numbers in place.",Convert all integers to binary strings and use bitwise operations to determine distinct values after reversal.,Store all integers in a trie data structure to efficiently check for distinct numbers after reversal.,"Use a set data structure to store the original and reversed integers, then return the set's size.",Medium,algorithms,"Array,Hash Table,Math,Counting"
2443,"Sum of Number and Its Reverse
Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.",Use dynamic programming to store previously calculated sums for efficiency,Check only even numbers less than or equal to num as potential addends,Iterate through all numbers from 0 to num and check if num - i equals reverse(i),Employ a binary search approach to find the integer and its reverse,Iterate from 0 to num and verify if any i + reverse(i) == num,Medium,algorithms,"Math,Enumeration"
2444,"Count Subarrays With Fixed Bounds
You are given an integer array nums and two integers minK and maxK. A fixed-bound subarray of nums is a subarray that satisfies the following conditions: Return the number of fixed-bound subarrays. A subarray is a contiguous part of an array.","Use a sliding window approach, expanding the window until both minK and maxK are found, then counting all subarrays within that window.",Sort the array and then iterate through all possible subarrays to check if they meet the fixed bound criteria.,Recursively divide the array into smaller subarrays and count the fixed-bound subarrays in each subproblem.,"Precompute all possible subarrays and store them in a hash map, then iterate through the hash map to check the bounds.",Maintain the indices of the most recent occurrences of minK and maxK and calculate the number of valid subarrays ending at each index.,Hard,algorithms,"Array,Queue,Sliding Window,Monotonic Queue"
2446,"Determine if Two Events Have Conflict
You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where: Event times are valid 24 hours format in the form of HH:MM. A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events). Return true if there is a conflict between two events. Otherwise, return false.",Convert the start and end times of both events into minutes from midnight and check if event1's start time is after event2's end time or event2's start time is after event1's end time.,"Compare the start times of both events. If the start time of event1 is greater than the start time of event2, then there is no conflict.","Check if the start time of event1 is equal to the end time of event2 or vice versa. If they are equal, then there is a conflict.",Convert the event times to seconds and use the modulo operator to determine the overlap.,Convert the start and end times of both events into minutes from midnight and check if event1's start time is less than or equal to event2's end time AND event2's start time is less than or equal to event1's end time.,Easy,algorithms,"Array,String"
2447,"Number of Subarrays With GCD Equal to K
Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The greatest common divisor of an array is the largest integer that evenly divides all the array elements.","Brute force: Generate all subarrays and compute GCD for each, with O(n^3) complexity.","Use a sliding window approach, shrinking the window when GCD < k and expanding when GCD > k.","Employ dynamic programming, storing GCDs of subarrays ending at each index in a table.",Precompute all possible GCDs in a lookup table for O(1) access during subarray evaluation.,"Iterate through all possible start indices, compute the GCD for each subarray starting at that index, and increment a counter when GCD equals k.",Medium,algorithms,"Array,Math,Number Theory"
2448,"Minimum Cost to Make Array Equal
You are given two 0-indexed arrays nums and cost consisting each of n positive integers. You can do the following operation any number of times: The cost of doing one operation on the ith element is cost[i]. Return the minimum total cost such that all the elements of the array nums become equal.",Calculate the median of 'nums' and multiply it by the sum of 'cost',Find the average of 'nums' weighted by 'cost' and sum the absolute differences from each element multiplied by its cost,"Sort 'nums', then iterate through it and calculate the cost of making all elements equal to the current element, taking the minimum",Use dynamic programming to build a table of minimum costs for making prefixes of the array equal,"Use ternary search or binary search to find the optimal value to make all elements equal to, minimizing the total cost",Hard,algorithms,"Array,Binary Search,Greedy,Sorting,Prefix Sum"
2449,"Minimum Number of Operations to Make Arrays Similar
You are given two positive integer arrays nums and target, of the same length. In one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and: Two arrays are considered to be similar if the frequency of each element is the same. Return the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.",Sort both arrays and count the number of differing elements at each index,Calculate the sum of absolute differences between corresponding elements in the sorted arrays,"Count the number of even and odd elements in both arrays, then calculate the difference between the counts","Compare the frequency of each number in both lists, summing the differences between corresponding entries","Separate even and odd numbers into two arrays for both nums and target. Calculate the sum of absolute differences between the corresponding sorted even and odd arrays, then divide by 2.",Hard,algorithms,"Array,Greedy,Sorting"
2451,"Odd String Difference
You are given an array of equal-length strings words. Assume that the length of each string is n. Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25. All the strings in words have the same difference integer array, except one. You should find that string. Return the string in words that has different difference integer array.",Use a hash function to map each difference array to a unique key and count occurrences.,Calculate the sum of all difference arrays and divide by the number of arrays.,"Sort the input array of strings lexicographically, then compare adjacent difference arrays.",Find the median string in the array and compare its difference array with all other strings.,"Compute the difference array for each string, and return the string whose difference array appears only once.",Easy,algorithms,"Array,Hash Table,String"
2452,"Words Within Two Edits of Dictionary
You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length. In one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary. Return a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.",Use a trie data structure to store the dictionary words and efficiently search for words within two edits.,"Calculate the Levenshtein distance between each query word and dictionary word, returning matches <= 2.",Implement a sliding window approach to compare substrings between the query and dictionary words.,Employ dynamic programming to precompute edit distances between all pairs of words.,"For each query word, iterate through the dictionary words and count the differing characters, returning the query words with a count <= 2.",Medium,algorithms,"Array,String,Trie"
2453,"Destroy Sequential Targets
You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space. You have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums. Return the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.","Sort the array 'nums' and then iterate through it, calculating the frequency of each number modulo 'space'","Use a hash map to store the count of each number in 'nums'. Iterate through the map and for each number, check how many numbers of the form nums[i] + c * space exist.","Iterate through the array 'nums', and for each number, calculate the number of targets it can destroy. Return the number that destroys the most targets regardless of value.",Convert the array 'nums' into a set to remove duplicates. Iterate through the set and count multiples of 'space'.,Use a hash map to store the frequency of each number modulo 'space'. Return the minimum number with the highest frequency in the hash map.,Medium,algorithms,"Array,Hash Table,Counting"
2454,"Next Greater Element IV
You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer. The second greater integer of nums[i] is nums[j] such that: If there is no such nums[j], the second greater integer is considered to be -1. Return an integer array answer, where answer[i] is the second greater integer of nums[i].",Use a brute-force approach with nested loops to compare each element with all subsequent elements.,Sort the array first and then find the second greater element using binary search.,Utilize a hash map to store the frequency of each element and then iterate to find the second greater element.,Maintain a single stack to track potential candidates for the next greater element.,Employ two stacks: one to hold potential next greater elements and another to hold potential second greater elements.,Hard,algorithms,"Array,Binary Search,Stack,Sorting,Heap (Priority Queue),Monotonic Stack"
2455,"Average Value of Even Numbers That Are Divisible by Three
Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3. Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",Return the sum of all numbers divided by the total count of numbers,Return the sum of all even numbers divided by the total count of numbers,Return the sum of all numbers divisible by 3 divided by the total count of numbers,Return the sum of all even numbers divisible by 3 divided by the total count of all numbers,"Return the sum of all even numbers divisible by 3 divided by the total count of even numbers divisible by 3, rounded down",Easy,algorithms,"Array,Math"
2456,"Most Popular Video Creator
You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creators[i], has an id of ids[i], and has views[i] views. The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video. Note: It is possible for different videos to have the same id, meaning that ids do not uniquely identify a video. For example, two videos with the same ID are considered as distinct videos with their own viewcount. Return a 2D array of strings answer where answer[i] = [creatorsi, idi] means that creatorsi has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.","Use a hash map to store creator views, and another to store their most viewed video IDs; iterate and update, then find the maximum views","Sort the creators array alphabetically and calculate popularity for each contiguous group, then find the max",Use a priority queue to keep track of the top K creators by popularity at all times,Precompute all possible creator sums and video ID combinations and return the max,"Iterate through the arrays once, using a hash map to track creator popularity and another to track each creator's most viewed video ID; find the creator with max popularity",Medium,algorithms,"Array,Hash Table,String,Sorting,Heap (Priority Queue)"
2457,"Minimum Addition to Make Integer Beautiful
You are given two positive integers n and target. An integer is considered beautiful if the sum of its digits is less than or equal to target. Return the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.","Apply a greedy approach, incrementing the number until the digit sum condition is met","Recursively calculate the digit sum and increment the number until the condition is met, using memoization to optimize",Binary search for the optimal value of 'x' within a reasonable range of possible additions,Precompute the digit sum for all numbers up to a certain limit and then look up the required addition,"Iteratively process the digits of 'n' from right to left, adding the minimum amount to the current digit to make the sum of digits up to that point less than or equal to 'target'",Medium,algorithms,"Math,Greedy"
2458,"Height of Binary Tree After Subtree Removal Queries
You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m. You have to perform m independent queries on the tree where in the ith query you do the following: Return an array answer of size m where answer[i] is the height of the tree after performing the ith query. Note:","Calculate the height of the entire tree, then subtract 1 for each level below the removed subtree's root.",Rebuild the tree from the root without the nodes in the query subtree and then calculate the height.,Precompute the height of every possible subtree and use a lookup table to determine the new height after removal.,"Perform a breadth-first search, tracking the maximum depth reached, and then adjust the height based on the removed subtree's depth.","Calculate the height of the original tree and for each query, temporarily remove the subtree, recalculate the height, and store the result.",Hard,algorithms,"Array,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
2460,"Apply Operations to an Array
You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums: After performing all the operations, shift all the 0's to the end of the array. Return the resulting array. Note that the operations are applied sequentially, not all at once.","Perform in-place operations, shifting non-zero elements to the front and filling the rest with zeros.","Create a new array, apply operations, and then copy back to the original array.",Use a priority queue to store non-zero elements and then reconstruct the array.,"Sort the array, apply operations based on original indices, and then sort again.","Iterate through the array, apply the specified operations, and then move all zeros to the end.",Easy,algorithms,"Array,Two Pointers,Simulation"
2461,"Maximum Sum of Distinct Subarrays With Length K
You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions: Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0. A subarray is a contiguous non-empty sequence of elements within an array.",Dynamic programming approach using a 2D array to store subarray sums.,Brute-force approach iterating through all possible subarrays of length k.,Use a hash map to store the frequency of each number and update the maximum sum accordingly.,Sort the entire array and then select the first k elements.,Sliding window approach using a hash set to track distinct elements.,Medium,algorithms,"Array,Hash Table,Sliding Window"
2462,"Total Cost to Hire K Workers
You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules: Return the total cost to hire exactly k workers.","Sort the costs array, then select the k smallest costs from the entire array.","Iterate through the costs array k times, each time selecting the smallest cost among all remaining workers.",Divide the costs array into k segments and select the minimum cost from each segment.,Randomly select k workers and hope for the best (minimal total cost).,"Use two priority queues (min-heaps), one for the first 'candidates' and one for the last 'candidates' workers. Repeatedly select the minimum cost from the two heaps.",Medium,algorithms,"Array,Two Pointers,Heap (Priority Queue),Simulation"
2463,"Minimum Total Distance Traveled
There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots. The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially. All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving. At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots. Return the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired. Note that","Use a greedy approach, assigning each robot to the nearest available factory regardless of capacity.","Sort robots and factories independently, then greedily assign robots to factories in order, minimizing individual distances.",Sort both robot and factory positions and perform a linear assignment using Hungarian Algorithm,Use dynamic programming where the state is the number of assigned robots and factories considered.,"Employ dynamic programming to minimize total distance, considering all possible robot-factory assignments and factory limits.",Hard,algorithms,"Array,Dynamic Programming,Sorting"
2465,"Number of Distinct Averages
You are given a 0-indexed integer array nums of even length. As long as nums is not empty, you must repetitively: The average of two numbers a and b is (a + b) / 2. Return the number of distinct averages calculated using the above process. Note that when there is a tie for a minimum or maximum number, any can be removed.",Use a hash map to store all possible averages and count the unique entries.,"Sort the array and iterate from both ends, calculating averages and storing them in a list, then remove duplicates from the list.","Recursively calculate the average of the first and last element, then repeat the process on the remaining sub-array.","Calculate all possible pairs, store them in a set, and return the size of the set after dividing the elements by 2","Sort the array, then use two pointers to find the minimum and maximum, calculate their average, store it in a set, and move the pointers inward until they meet.",Easy,algorithms,"Array,Hash Table,Two Pointers,Sorting"
2466,"Count Ways To Build Good Strings
Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following: This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive). Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.","Use dynamic programming to store the number of good strings of length i, where i ranges from 0 to high, and return the sum of dp[i] for i from low to high.","Employ a greedy approach by always appending the shortest possible string (either '0' or '1') until the length reaches low, and then continue appending until the length reaches high, counting each valid string.","Simulate the process recursively, keeping track of the current string length. If the length is within the [low, high] range, increment a counter. Return the counter modulo 10^9 + 7.",Generate all possible binary strings of length up to high and filter out the ones with lengths less than low. Count the remaining strings modulo 10^9 + 7.,"Utilize dynamic programming, defining dp[i] as the number of good strings of length i. The transitions are dp[i+zero] += dp[i] and dp[i+one] += dp[i]. The answer is the sum of dp[i] for i from low to high, modulo 10^9 + 7.",Medium,algorithms,Dynamic Programming
2467,"Most Profitable Path in a Tree
There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents: The game goes on as follows: Return the maximum net income Alice can have if she travels towards the optimal leaf node.","Use Breadth-First Search (BFS) to find the shortest path for Alice and Bob simultaneously, updating Alice's income at each node, considering Bob's negative impact.","Calculate the distance from the root to all leaf nodes. For each leaf, determine Alice's path and Bob's path independently. The maximum difference is the result.",Simulate Alice and Bob's movements using random walks. The maximum income Alice accumulates across multiple simulations is the answer.,Apply Dijkstra's algorithm to find the longest path in the tree and assume Alice always takes this path while ignoring Bob's position.,Use Breadth-First Search (BFS) twice: once to find Alice's shortest path to each node and another to find Bob's arrival time at each node. Adjust Alice's income based on Bob's presence.,Medium,algorithms,"Array,Tree,Depth-First Search,Breadth-First Search,Graph"
2468,"Split Message Based on Limit
You are given a string, message, and a positive integer, limit. You must split message into one or more parts based on limit. Each resulting part should have the suffix ""<a/b>"", where ""b"" is to be replaced with the total number of parts and ""a"" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit. The resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible. Return the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.","Greedily pack the message into parts, recalculating the number of parts after each addition and restarting if the suffix exceeds the limit.","Use binary search to find the optimal number of parts, then divide the message evenly and adjust the lengths of the prefixes accordingly.","Recursively split the message, ensuring each split meets the length constraint, and backtracking if a valid split isn't achievable.",Prioritize shorter parts by starting with single-character prefixes and gradually increasing their length until a feasible solution is found.,"Calculate the total number of parts first, then iteratively create each part with its appropriate suffix.",Hard,algorithms,"String,Binary Search,Enumeration"
2469,"Convert the Temperature
You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius. You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10-5 of the actual answer will be accepted. Note that:","Multiply Celsius by 9/5 and add 32 for Kelvin, and add 273.15 for Fahrenheit","Add 273.15 to Celsius for Fahrenheit, and multiply Celsius by 9/5 then add 32 for Kelvin","Subtract 273.15 from Celsius for Kelvin, and multiply Celsius by 5/9 then subtract 32 for Fahrenheit",Multiply Celsius by 5/9 and subtract 32 for Fahrenheit and subtract 273.15 for Kelvin,"Add 273.15 to Celsius for Kelvin, and multiply Celsius by 9/5 then add 32 for Fahrenheit",Easy,algorithms,Math
2470,"Number of Subarrays With LCM Equal to K
Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.",Precompute LCM for all possible subarrays using dynamic programming and then count subarrays equal to k.,Sort the input array first and then iterate through all subarrays.,"Use a sliding window approach, expanding the window until the LCM exceeds k, then shrinking it.",Calculate the product of all elements in each subarray and check if the product equals k.,"Iterate through all subarrays, calculating the LCM for each and incrementing a counter if the LCM equals k.",Medium,algorithms,"Array,Math,Number Theory"
2471,"Minimum Number of Operations to Sort a Binary Tree by Level
You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order. The level of a node is the number of edges along the path between it and the root node.",Depth-First Search (DFS) with in-order traversal,Greedy algorithm sorting each level independently,Dynamic programming with memoization of swap counts,Using a heap to keep track of the smallest element at each level,"Breadth-First Search (BFS) to process each level, counting swaps for sorting",Medium,algorithms,"Tree,Breadth-First Search,Binary Tree"
2472,"Maximum Number of Non-overlapping Palindrome Substrings
You are given a string s and a positive integer k. Select a set of non-overlapping substrings from the string s that satisfy the following conditions: Return the maximum number of substrings in an optimal selection. A substring is a contiguous sequence of characters within a string.","Use dynamic programming to find all palindromic substrings and then greedily select the longest ones that don't overlap, prioritizing length.","Iterate through all possible substring combinations and use recursion to determine the maximum number of non-overlapping palindromes, pruning branches that violate the overlap constraint.","Use a sliding window approach to identify palindromes, expanding the window until a palindrome is found, then advancing the window past the palindrome.",Sort the characters of the string and then count the number of non-overlapping substrings that are palindromes.,"Iterate through the string, identifying the longest possible palindrome at each position and incrementing the count, moving the start to the end of the found palindrome.",Hard,algorithms,"Two Pointers,String,Dynamic Programming,Greedy"
2475,"Number of Unequal Triplets in Array
You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions: Return the number of triplets that meet the conditions.",O(n^3) - Iterate through all possible triplets and check the conditions.,O(n log n) - Sort the array and then count the triplets that satisfy the conditions.,"O(n^2) - Use nested loops to count pairs, then iterate through the rest of the array to find a third element.",O(1) - The number of triplets is constant regardless of array size.,"O(n^2) - Use a hash map to store counts of each number, then iterate through all possible pairs and use the map to find the third element.",Easy,algorithms,"Array,Hash Table,Sorting"
2476,"Closest Nodes Queries in a Binary Search Tree
You are given the root of a binary search tree and an array queries of size n consisting of positive integers. Find a 2D array answer of size n where answer[i] = [mini, maxi]: Return the array answer.",Perform an in-order traversal of the BST and binary search the sorted array to find the closest elements.,"Use a hash table to store all the nodes in the BST, then iterate through the queries to find the closest elements using the hash table.",Perform a pre-order traversal and compare with queries.,Maintain min and max heap during the search for nodes closest to queries,"For each query, traverse the BST, keeping track of the closest smaller and larger values seen so far.",Medium,data structures,"Array,Binary Search,Tree,Depth-First Search,Binary Search Tree,Binary Tree"
2477,"Minimum Fuel Cost to Report to the Capital
There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi. There is a meeting for the representatives of each city. The meeting is in the capital city. There is a car in each city. You are given an integer seats that indicates the number of seats in each car. A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel. Return the minimum number of liters of fuel to reach the capital city.",Calculate the shortest path from each city to the capital and sum the path lengths divided by seats (rounding up),Perform a breadth-first search (BFS) from the capital and sum the distances to each city divided by seats (rounding up),"Use Dijkstra's algorithm to find the shortest path from each city to the capital, considering the car capacity constraints","For each city, compute the number of representatives traveling and multiply that by the distance to the capital","Perform a depth-first search (DFS) from the capital, calculate the number of representatives from each subtree, and compute the fuel cost based on 'seats'",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search,Graph"
2478,"Number of Beautiful Partitions
You are given a string s that consists of the digits '1' to '9' and two integers k and minLength. A partition of s is called beautiful if: Return the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7. A substring is a contiguous sequence of characters within a string.","Recursively explore all possible partition combinations without memoization, leading to exponential time complexity.",Use dynamic programming with a 1D array to store the number of valid partitions ending at each index.,"Greedily create partitions by always choosing the shortest possible valid substring, potentially missing optimal solutions.","Iterate through the string, maintaining a count of valid partitions without considering the 'k' constraint.",Employ dynamic programming with a 2D array where dp[i][j] stores the number of beautiful partitions of s[0...i] into j parts.,Hard,algorithms,"String,Dynamic Programming"
2481,"Minimum Cuts to Divide a Circle
A valid cut in a circle can be: Some valid and invalid cuts are shown in the figures below. Given the integer n, return the minimum number of cuts needed to divide a circle into n equal slices.",n,n / 2 (rounded down),n - 1,n + 1,n / 2 (if n is even) or n (if n is odd),Easy,algorithms,"Math,Geometry"
2482,"Difference Between Ones and Zeros in Row and Column
You are given a 0-indexed m x n binary matrix grid. A 0-indexed m x n difference matrix diff is created with the following procedure: Return the difference matrix diff.",The number of 1's in row i plus the number of 0's in column j,The sum of row i index and column j index,The number of 0's in row i minus the number of 1's in column j,The number of 1's in the entire matrix,The number of 1's in row i plus the number of 1's in column j minus the number of 0's in row i minus the number of 0's in column j,Medium,algorithms,"Array,Matrix,Simulation"
2483,"Minimum Penalty for a Shop
You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y': If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows: Return the earliest hour at which the shop must be closed to incur a minimum penalty. Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.",Close the shop at the hour with the most 'N' characters before it.,Close the shop when the total count of 'Y' equals the total count of 'N'.,Always close the shop at the very last hour to avoid penalties.,Greedily close the shop at the earliest instance of consecutive 'N's.,Calculate the penalty for closing at each hour and choose the hour with the minimum penalty.,Medium,algorithms,"String,Prefix Sum"
2484,"Count Palindromic Subsequences
Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7. Note:","Return the count of all subsequences of length 5, irrespective of whether they are palindromic, modulo 10^9 + 7.","Compute the number of palindromic substrings of length 5, and return the value modulo 10^9 + 7.","Return the number of distinct characters present in the given string, modulo 10^9 + 7.",Calculate the total number of subsequences (of any length) and then take the result modulo 10^9 + 7.,Calculate the number of length-5 palindromic subsequences of the string modulo 10^9 + 7.,Hard,algorithms,"String,Dynamic Programming"
2485,"Find the Pivot Integer
Given a positive integer n, find the pivot integer x such that: Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.",n * (n + 1) / 4,sqrt(n * (n + 1) / 2),(n + 1) / 2,n / 2,sqrt(n * (n + 1) / 2),Easy,algorithms,"Math,Prefix Sum"
2486,"Append Characters to String to Make Subsequence
You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.",Initialize a counter to the length of t and decrement it for each matching character in s.,Calculate the Levenshtein distance between s and t and return the difference in lengths.,Find the longest common subsequence (LCS) of s and t and return the length of t minus the length of the LCS.,"Recursively check if t is a subsequence of s, appending characters to s until it is.",Iterate through s and t using two pointers. Increment the t pointer only when a matching character is found in s. Return the remaining length of t.,Medium,algorithms,"Two Pointers,String,Greedy"
2487,"Remove Nodes From Linked List
You are given the head of a linked list. Remove every node which has a node with a greater value anywhere to the right side of it. Return the head of the modified linked list.",Use a stack to store nodes and compare values during traversal.,"Sort the linked list first, then remove nodes based on their original position.","Recursively traverse the list, removing nodes with smaller values in each call.","Convert the linked list to an array, perform filtering, and convert back.","Traverse the list from right to left, maintaining the maximum value seen so far and removing smaller nodes.",Medium,algorithms,"Linked List,Stack,Recursion,Monotonic Stack"
2488,"Count Subarrays With Median K
You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k. Return the number of non-empty subarrays in nums that have a median equal to k. Note:","Use a sliding window approach, expanding until the median is greater than k and shrinking until it's less than k, then counting the subarrays with median k.",Sort all possible subarrays and count the ones where the middle element equals k.,Recursively divide the array into smaller subarrays and count the subarrays with median k in each subproblem.,"Iterate through all possible subarrays and, for each subarray, calculate the median by sorting it and comparing the median to k.","Transform the array into an array of -1, 0, and 1 based on comparison with k, then count subarrays with equal numbers of -1 and 1.",Hard,algorithms,"Array,Hash Table,Prefix Sum"
2490,"Circular Sentence
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different. A sentence is circular if: For example, ""leetcode exercises sound delightful"", ""eetcode"", ""leetcode eats soul"" are all circular sentences. However, ""Leetcode is cool"", ""happy Leetcode"", ""Leetcode"" and ""I like Leetcode"" are not circular sentences. Given a string sentence, return true if it is circular. Otherwise, return false.",Data encryption standard,Advanced encryption runtime,Attribute exchange standard,Authenticated exchange service,Advanced encryption standard,Easy,security,String
2491,"Divide Players Into Teams of Equal Skill
You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal. The chemistry of a team is equal to the product of the skills of the players on that team. Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.","Sort the skill array and greedily pair the smallest with the largest skill until no players remain, returning -1 if the target skill is unachievable","Use dynamic programming to explore all possible team combinations and return the maximum sum of chemistry achievable given skill constraints, or -1 if no valid arrangement is possible","Iterate through all possible team combinations using backtracking and count the total chemistry if all teams have the same total skill, returning -1 if no possible combination exists","Calculate the average skill level. If any skill is further than the average level away from the closest skill, return -1. Otherwise, return the product of all skills","Sort the skill array, verify skill[i] + skill[n-1-i] is constant for all i, and return the sum of skill[i] * skill[n-1-i] for i in range(n//2), or -1 if sums are unequal",Medium,algorithms,"Array,Hash Table,Two Pointers,Sorting"
2492,"Minimum Score of a Path Between Two Cities
You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected. The score of a path between two cities is defined as the minimum distance of a road in this path. Return the minimum possible score of a path between cities 1 and n. Note:",Dijkstra's algorithm,Kruskal's algorithm,Prim's algorithm,Bellman-Ford algorithm,Breadth-first search (BFS),Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
2493,"Divide Nodes Into the Maximum Number of Groups
You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n. You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected. Divide the nodes of the graph into m groups (1-indexed) such that: Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.","Use Breadth-First Search (BFS) to find connected components and assign groups based on component size, maximizing the number of groups.","Apply Depth-First Search (DFS) to detect cycles and assign groups based on cycle length, prioritizing larger cycles for group formation.","Employ a greedy approach, assigning nodes to groups incrementally, always choosing the group that minimizes the number of conflicting edges.","Calculate the degree of each node and assign groups based on degree centrality, starting with nodes of highest degree.","Use bipartite checking to determine if each connected component is bipartite. If not, return -1. Otherwise, calculate the maximum distance from a node in each component and return the sum of these maximum distances.",Hard,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
2496,"Maximum Value of a String in an Array
The value of an alphanumeric string can be defined as: Given an array strs of alphanumeric strings, return the maximum value of any string in strs.",Convert each string to its ASCII representation and return the maximum ASCII value.,Count the number of digits in each string and return the maximum digit count.,Return the length of the longest string in the array.,Return the sum of the lengths of all strings in the array.,"If the string is numeric, convert it to an integer; otherwise, return its length. Find the maximum among these values.",Easy,algorithms,"Array,String"
2497,"Maximum Star Sum of a Graph
There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi. A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges. The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node. The star sum is the sum of the values of all the nodes present in the star graph. Given an integer k, return the maximum star sum of a star graph containing at most k edges.",Sort the nodes based on their values and select the top k nodes along with their center,Use Dijkstra's algorithm to find the shortest path between all node pairs and sum the nodes in the shortest path with at most k edges.,"Perform a depth-first search (DFS) starting from each node and calculate the sum of the visited nodes, limiting the search depth to k.",Calculate the sum of all node values and subtract the minimum node value repeatedly until only k nodes remain connected to a center node,"Iterate through each node, calculate the sum of its value and the k largest neighbor values, and find the maximum of these sums",Medium,algorithms,"Array,Greedy,Graph,Sorting,Heap (Priority Queue)"
2498,"Frog Jump II
You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river. A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once. The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps. The cost of a path is the maximum length of a jump among all jumps in the path. Return the minimum cost of a path for the frog.",Greedily choose the next stone that minimizes the current jump length.,Use dynamic programming to store the minimum cost to reach each stone.,"Apply binary search on the possible range of costs, checking if a valid path exists for each cost.","Recursively explore all possible paths, pruning branches that exceed a certain cost threshold.","Iterate through the stones, considering jumps forward and backward, and maintain the maximum jump length seen so far, minimizing this maximum.",Medium,algorithms,"Array,Binary Search,Greedy"
2499,"Minimum Total Cost to Make Arrays Unequal
You are given two 0-indexed integer arrays nums1 and nums2, of equal length n. In one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices. Find the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations. Return the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.","Use a greedy approach, swapping elements with the lowest indices first.",Apply dynamic programming to minimize the cost of swaps iteratively.,Sort both arrays and then calculate the cost based on the sorted order.,Use a maximum flow algorithm to find the minimum cost assignment of elements.,Model the problem as a minimum cost perfect matching problem on a bipartite graph.,Hard,algorithms,"Array,Hash Table,Greedy,Counting"
2500,"Delete Greatest Value in Each Row
You are given an m x n matrix grid consisting of positive integers. Perform the following operation until grid becomes empty: Note that the number of columns decreases by one after each operation. Return the answer after performing the operations described above.","Calculate the sum of each row, then find the maximum of these sums","Sort each row independently, then take the sum of the largest element in each row","Iterate through the matrix, keeping track of the largest value seen so far","For each column, find the row with the smallest value and sum those values","For each column, find the maximum value, and sum these maximum values",Easy,algorithms,"Array,Sorting,Heap (Priority Queue),Matrix,Simulation"
2501,"Longest Square Streak in an Array
You are given an integer array nums. A subsequence of nums is called a square streak if: Return the length of the longest square streak in nums, or return -1 if there is no square streak. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",Use dynamic programming to store lengths of streaks ending at each index.,"Sort the array and iterate, checking if the square root of the current number exists in the array using a binary search for each number.",Iterate through the array and build a hash map storing the counts of each number. Then iterate and check for square root existence based on counts.,Convert all numbers to their square roots and find the longest increasing subsequence.,Sort the array and greedily build the longest streak by iteratively checking if the square of the last element in the current streak exists in the remaining array.,Medium,algorithms,"Array,Hash Table,Binary Search,Dynamic Programming,Sorting"
2502,"Design Memory Allocator
You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free. You have a memory allocator with the following functionalities: Note that: Implement the Allocator class:","Use a first-fit algorithm, searching the entire array for the smallest available block that fits.","Maintain a linked list of free blocks and always allocate from the head of the list, splitting the block if necessary.","Allocate memory using a buddy system, recursively splitting blocks until a suitable size is found.","Use a circular buffer to allocate memory sequentially, wrapping around when the end is reached.","Employ a best-fit algorithm, traversing the array to find the free block that minimizes remaining space after allocation.",Medium,system design,"Array,Hash Table,Design,Simulation"
2503,"Maximum Number of Points From Grid Queries
You are given an m x n integer matrix grid and an array queries of size k. Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process: After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times. Return the resulting array answer.","Depth-First Search (DFS) without memoization, potentially leading to Time Limit Exceeded (TLE)",Sorting the queries array and processing them in ascending order of query value.,"Breadth-First Search (BFS) without considering visited cells, leading to infinite loops.",Ignoring the constraint of starting from the top-left cell.,"Priority Queue (Min-Heap) based approach to explore cells in increasing order of value, combined with a visited set.",Hard,algorithms,"Array,Two Pointers,Breadth-First Search,Union Find,Sorting,Heap (Priority Queue),Matrix"
2506,"Count Pairs Of Similar Strings
You are given a 0-indexed string array words. Two strings are similar if they consist of the same characters. Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.",Sort each string alphabetically and compare the sorted strings.,Compare the ASCII sum of each string.,Check if one string is a substring of the other.,Count the frequency of each character in both strings and compare the frequency maps.,Create a set of characters for each string and compare the sets.,Easy,algorithms,"Array,Hash Table,String,Bit Manipulation,Counting"
2507,"Smallest Value After Replacing With Sum of Prime Factors
You are given a positive integer n. Continuously replace n with the sum of its prime factors. Return the smallest value n will take on.",Memoization of previously calculated values to avoid redundant computations,Dynamic programming with a table storing the smallest value for each number up to n,Pre-computing all prime numbers up to n and storing them in a lookup table,Using a heap data structure to keep track of the smallest prime factor found so far,Repeatedly compute the sum of prime factors until a fixed point is reached,Medium,algorithms,"Math,Simulation,Number Theory"
2508,"Add Edges to Make Degrees of All Nodes Even
There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected. You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops. Return true if it is possible to make the degree of each node in the graph even, otherwise return false. The degree of a node is the number of edges connected to it.","If the number of odd-degree nodes is odd, return false.","Add an edge between any two odd-degree nodes until all degrees are even; if more than two edges are needed, return false.",Add edges between the highest degree nodes and the lowest degree nodes.,"Check if the graph is connected first; if not, return false, otherwise, add random edges.","Count odd-degree nodes. If 0, return true. If 2, add an edge between them if none exists, or any other node if an edge does exist, and return true. If 4, try connecting pairs until one works or none is possible, return accordingly.",Hard,algorithms,"Hash Table,Graph"
2509,"Cycle Length Queries in a Tree
You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where: You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem: Note that: Return an array answer of length m where answer[i] is the answer to the ith query.","O(n*m), where n is the number of nodes and m is the number of queries","O(n + m), where n is the number of nodes and m is the number of queries","O(log n + log m), where n is the number of nodes and m is the number of queries","O(1), constant time complexity","O(m * log(2n)), where n is the integer representing the tree height, and m is the number of queries",Hard,algorithms,"Array,Tree,Binary Tree"
2511,"Maximum Enemy Forts That Can Be Captured
You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where: Now you have decided to move your army from one of your forts at position i to an empty position j such that: While moving the army, all the enemy forts that come in the way are captured. Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.","Find the longest sequence of -1s between two 1s, or the longest sequence of 1s between two -1s","Calculate the absolute difference between the indices of all -1s and 1s, and return the maximum",Count the total number of -1s and 1s in the array and return the smaller of the two counts,Return the number of zeros present in the array,"Iterate through the array, keeping track of the last fort. When encountering an empty cell, calculate the distance to the last fort of the opposite type.",Easy,algorithms,"Array,Two Pointers"
2512,"Reward Top K Students
You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative. Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1. You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique. Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.","Use a hash map to store student IDs and scores, then sort the map by score in descending order and ID in ascending order.","Create a list of tuples containing (student ID, score) and use a standard sorting algorithm with a custom comparator.",Employ a priority queue (min-heap) of size k to keep track of the top k students and their scores.,"Utilize bucket sort based on the score range, then resolve ties using student IDs.","Calculate the score for each student using positive and negative feedback, store in a dictionary, and then sort based on score (descending) and student ID (ascending).",Medium,algorithms,"Array,Hash Table,String,Sorting,Heap (Priority Queue)"
2513,"Minimize the Maximum of Two Arrays
We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions: Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.",Binary search for the answer within a fixed range without considering divisors,"Return max(divisor1 * uniqueCnt1, divisor2 * uniqueCnt2) as the answer",Greedily add numbers to the arrays without accounting for common multiples,Assume the answer is always uniqueCnt1 + uniqueCnt2 and return that value,"Use binary search to find the minimum integer X such that there are at least uniqueCnt1 integers not divisible by divisor1 and at least uniqueCnt2 integers not divisible by divisor2 within the range [1, X], considering the least common multiple",Medium,algorithms,"Math,Binary Search,Number Theory"
2514,"Count Anagrams
You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '. A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s. Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",Sort each word alphabetically and then count occurrences of identical sorted words.,Calculate the factorial of the total number of words and divide by the product of the factorials of the lengths of each unique word.,Generate all possible permutations of the input string and then remove duplicates.,Compute the number of possible arrangements for each word and multiply them together.,Calculate the number of arrangements for each word and multiply them modulo 10^9 + 7 using a hash map to store frequencies.,Hard,algorithms,"Hash Table,Math,String,Combinatorics,Counting"
2515,"Shortest Distance to Target String in a Circular Array
You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning. Starting from startIndex, you can move to either the next word or the previous word with 1 step at a time. Return the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.",Use a hash table to store visited indices and perform a breadth-first search.,"Iterate through the array only in the forward direction, wrapping around when necessary.","Recursively search the array, exploring both forward and backward directions until the target is found.",Sort the array and then perform a binary search for the target string.,"Perform two linear searches, one forward and one backward, from the start index and return the minimum distance.",Easy,algorithms,"Array,String"
2516,"Take K of Each Character From Left and Right
You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s. Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.",Use a greedy approach by always taking the character that appears least frequently in the current string.,Generate all possible combinations of taking characters from the left and right and check if any of them satisfy the condition.,"Use dynamic programming with states (left_index, right_index, a_count, b_count, c_count) to store the minimum minutes.",Sort the string and take the first 3k characters if they meet the minimum requirement; return -1 otherwise,"Use a sliding window approach to find the smallest substring that contains at least k 'a's, k 'b's, and k 'c's, and calculate the remaining characters from the left and right.",Medium,algorithms,"Hash Table,String,Sliding Window"
2517,"Maximum Tastiness of Candy Basket
You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k. The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket. Return the maximum tastiness of a candy basket.",Use dynamic programming to build a table of tastiness values for all possible combinations of candies.,"Sort the candies by price and use a greedy approach, always selecting the next candy that maximizes the average tastiness.","Iterate through all possible combinations of k candies and calculate the tastiness for each combination, then return the maximum.",Calculate the range (max - min) of candy prices and divide it by k to estimate the maximum tastiness.,Sort the candy prices and use binary search to find the maximum tastiness such that at least k candies can be selected with that minimum tastiness.,Medium,algorithms,"Array,Binary Search,Greedy,Sorting"
2518,"Number of Great Partitions
You are given an array nums consisting of positive integers and an integer k. Partition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k. Return the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7. Two partitions are considered distinct if some element nums[i] is in different groups in the two partitions.","k is larger than the sum of the array, making a great partition impossible, so return 0","There's only one possible partition, with all elements in one group and none in the other, so return 1","Return 2 raised to the power of the array's length, representing all possible partitions","If any single number in nums is greater or equal to k, then return 1, otherwise return 0","Calculate the number of subsets with a sum less than k using dynamic programming, and subtract that from the total number of possible partitions (2^n)",Hard,algorithms,"Array,Dynamic Programming"
2520,"Count the Digits That Divide a Number
Given an integer num, return the number of digits in num that divide num. An integer val divides nums if nums % val == 0.",Use dynamic programming to precompute the number of divisors for each digit,Convert the number to a string and use regular expressions to find the divisors,Iterate through all numbers from 1 to num and check for divisibility,Use bit manipulation to check if each digit is a power of 2,Iterate through the digits of the number and check if each digit divides the number,Easy,algorithms,Math
2521,"Distinct Prime Factors of Product of Array
Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums. Note that:","Calculate the product, then use trial division up to the square root of the product.",Precompute all prime numbers up to the maximum value in the array and check divisibility.,Recursively find prime factors for each number and store them in a set.,Calculate the product modulo a large prime number and find its prime factors.,"Iterate through the array, factorize each number, and add the distinct prime factors to a set.",Medium,algorithms,"Array,Hash Table,Math,Number Theory"
2522,"Partition String Into Substrings With Values at Most K
You are given a string s consisting of digits from 1 to 9 and an integer k. A partition of a string s is called good if: Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1. Note that:","Greedily create substrings until the value exceeds k, then backtrack to find a smaller substring.",Use dynamic programming to store the minimum number of substrings for each prefix of s.,Sort the digits in s and then partition into substrings based on the sorted order.,Recursively explore all possible partitions of s and choose the one with the minimum number of substrings.,"Iterate through the string, creating substrings as long as the value is less than or equal to k. If a single digit is greater than k, return -1.",Medium,algorithms,"String,Dynamic Programming,Greedy"
2523,"Closest Prime Numbers in Range
Given two positive integers left and right, find the two integers num1 and num2 such that: Return the positive integer array ans = [num1, num2]. If there are multiple pairs satisfying these conditions, return the one with the smallest num1 value. If no such numbers exist, return [-1, -1].",Using a brute-force approach and iterating through all numbers within the range to check for primality would be the most efficient method.,Pre-compute all prime numbers up to 'right' using the Sieve of Eratosthenes and then iterate through the range to find the closest pair.,Start from the middle of the range and search outwards for primes to optimize the search for the closest pair.,Sort all numbers within the range and check adjacent numbers for primality to find the closest pair.,"Use the Sieve of Eratosthenes to find all primes within the range [left, right], then iterate through the primes to find the minimum difference between adjacent primes.",Medium,algorithms,"Math,Number Theory"
2525,"Categorize Box According to Criteria
Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box. Note that the volume of the box is the product of its length, width and height.","If any dimension is greater than or equal to 10000 or the mass is greater than or equal to 100, the box is ""Bulky"".","If all dimensions are less than 10000 and the mass is less than 100, the box is ""Neither"".","The box is ""Heavy"" if its mass is greater than or equal to 100, otherwise it is ""Light"".","The box is ""Both"" if the volume is less than 1000, otherwise it is ""Neither""","If the box is bulky and heavy, return ""Both"". If the box is bulky, return ""Bulky"". If the box is heavy, return ""Heavy"". Otherwise, return ""Neither"".",Easy,algorithms,Math
2526,"Find Consecutive Integers from a Data Stream
For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value. Implement the DataStream class:",Use a sliding window to store the stream and sort it on each update.,Store the last k integers in a hash map and compare the frequencies.,Maintain a queue of size k and compare the sum of elements with k * value.,Use a Bloom filter to probabilistically check if the value exists in the stream.,Use a fixed-size circular buffer and maintain a count of occurrences of the value.,Medium,data structures,"Hash Table,Design,Queue,Counting,Data Stream"
2527,"Find Xor-Beauty of Array
You are given a 0-indexed integer array nums. The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]). The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n. Return the xor-beauty of nums. Note that:",The XOR of all the elements in the array,The sum of all the elements in the array modulo 2,The bitwise AND of all the elements in the array,The bitwise OR of all the elements in the array,The bitwise XOR of all the elements in the array,Medium,algorithms,"Array,Math,Bit Manipulation"
2528,"Maximize the Minimum Powered City
You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city. Each power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1. The power of a city is the total number of power stations it is being provided power from. The government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones. Given the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally. Note that you can build the k power stations in multiple cities.",Use dynamic programming to determine the optimal placement of power stations.,"Apply a greedy approach, always adding power stations to the city with the lowest power.",Simulate the addition of power stations and check all possible combinations.,Sort the power station array and add k to the largest element.,"Use binary search on the minimum power value, and a sliding window to simulate power distribution.",Hard,algorithms,"Array,Binary Search,Greedy,Queue,Sliding Window,Prefix Sum"
2529,"Maximum Count of Positive Integer and Negative Integer
Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers. Note that 0 is neither positive nor negative.","Perform a linear scan of the array, counting positives and negatives separately.","Use binary search to find the first positive and last negative elements, then calculate counts.","Utilize two pointers, one starting from the beginning and one from the end, to count positives and negatives simultaneously.",Sort the array and then count the positive and negative numbers.,"Employ binary search twice: once to find the index of the first positive integer and once for the last negative integer, then determine the count.",Easy,algorithms,"Array,Binary Search,Counting"
2530,"Maximal Score After Applying K Operations
You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0. In one operation: Return the maximum possible score you can attain after applying exactly k operations. The ceiling function ceil(val) is the least integer greater than or equal to val.",Calculate the sum of the `k` largest elements directly.,Sort the array and iteratively apply the operation to the smallest element.,Apply the operation to all elements and then select the `k` largest.,Recursively apply the operation to a random element `k` times.,"Use a max-heap to repeatedly extract the largest element, apply the operation, and re-insert.",Medium,algorithms,"Array,Greedy,Heap (Priority Queue)"
2531,"Make Number of Distinct Characters Equal
You are given two 0-indexed strings word1 and word2. A move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j]. Return true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.",Use bitwise operations to count distinct characters without extra memory.,Sort both strings and compare character frequencies directly.,Calculate the initial difference in distinct characters and check if a single swap can eliminate the difference.,Use dynamic programming to find the optimal sequence of swaps.,Iterate through all possible swaps between word1 and word2 and check if the number of distinct characters becomes equal after the swap.,Medium,algorithms,"Hash Table,String,Counting"
2532,"Time to Cross a Bridge
There are k workers who want to move n boxes from the right (old) warehouse to the left (new) warehouse. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [righti, picki, lefti, puti]. The warehouses are separated by a river and connected by a bridge. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker can do the following: The ith worker is less efficient than the jth worker if either condition is met: The following rules regulate the movement of the workers through the bridge: Return the elapsed minutes at which the last box reaches the left side of the bridge.",Prioritize workers based solely on the time taken to cross the bridge from right to left.,"Simulate the process using a min-heap to track available workers and assign them boxes based on a first-come, first-served basis.","Employ dynamic programming to determine the optimal assignment of workers and boxes, minimizing the total time.","Use a greedy approach, always assigning the fastest worker to the next available box, regardless of bridge congestion.","Model the process using priority queues for waiting workers on both sides of the bridge and simulate worker movements based on efficiency and box availability, considering bridge crossing times and pick/put times.",Hard,algorithms,"Array,Heap (Priority Queue),Simulation"
2535,"Difference Between Element Sum and Digit Sum of an Array
You are given a positive integer array nums. Return the absolute difference between the element sum and digit sum of nums. Note that the absolute difference between two integers x and y is defined as |x - y|.",Bubble Sort,Merge Sort,Insertion Sort,Selection Sort,Counting Sort,Easy,algorithms,"Array,Math"
2536,"Increment Submatrices by One
You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes. You are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation: Return the matrix mat after performing every query.","Use a single loop iterating `n` times, incrementing each cell in the matrix","Create a new matrix and increment values in the specified ranges in the new matrix, then copy the result to `mat`",Apply the query updates only to the diagonal elements within the given ranges,Use a recursive function to increment the matrix within the specified row and column ranges,Iterate through each query and increment the corresponding submatrix using nested loops within the specified ranges,Medium,algorithms,"Array,Matrix,Prefix Sum"
2537,"Count the Number of Good Subarrays
Given an integer array nums and an integer k, return the number of good subarrays of nums. A subarray arr is good if there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j]. A subarray is a contiguous non-empty sequence of elements within an array.",O(n),O(n log n),O(k log n),O(n!),O(n^2),Medium,algorithms,"Array,Hash Table,Sliding Window"
2538,"Difference Between Maximum and Minimum Price Sum
There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Each node has an associated price. You are given an integer array price, where price[i] is the price of the ith node. The price sum of a given path is the sum of the prices of all nodes lying on that path. The tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root. Return the maximum possible cost amongst all possible root choices.","Perform a Depth-First Search (DFS) for each possible root, calculating path sums and finding the maximum cost. This has a time complexity of O(n^2).","Compute all possible paths using dynamic programming and then, for each possible root, calculate the cost. This has a space complexity of O(n^2).",Calculate the diameter of the tree and use the endpoints of the diameter as potential roots to minimize the number of root calculations.,"Use a greedy algorithm, always selecting the node with the highest price as the root to maximize the difference between maximum and minimum path sums.","Use dynamic programming to compute, for each node, the maximum and minimum path sums starting at that node, considering the tree rooted at each of its neighbors. This allows efficient calculation for all possible roots.",Hard,algorithms,"Array,Dynamic Programming,Tree,Depth-First Search"
2540,"Minimum Common Value
Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1. Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.",Use a hash table to store elements of the first array and check for the existence of elements of the second array in the hash table.,Apply binary search on the larger array for each element of the smaller array.,"Compare the last elements of the arrays and iterate towards the start until a common element is found, or -1 is returned.",Sort both arrays and compare the last elements to determine the smallest common element.,"Use two pointers, one for each array, to traverse and compare elements until a common element is found or the end of either array is reached.",Easy,algorithms,"Array,Hash Table,Two Pointers,Binary Search"
2541,"Minimum Operations to Make Array Equal II
You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1: nums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i]. Return the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.",Use dynamic programming to find the longest common subsequence and minimize edits based on that,Sort both arrays and count the number of elements at the same index that are different,Calculate the sum of absolute differences between the arrays and divide by k,Use a hash map to store the frequencies of each element in both arrays and compare the maps,Count positive and negative differences between the arrays and check if the sum of positive differences is divisible by k and equal to the absolute value of the sum of negative differences divided by k,Medium,algorithms,"Array,Math,Greedy"
2542,"Maximum Subsequence Score
You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k. For chosen indices i0, i1, ..., ik - 1, your score is defined as: Return the maximum possible score. A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.","Sort `nums1` in descending order and `nums2` in ascending order, then multiply the first k elements of each.",Calculate the product of all possible subsequences of length k and return the maximum.,Use dynamic programming to find the maximum sum of `nums1` and the maximum minimum of `nums2` in subsequences of length k.,"Select the first k elements of both arrays, sort `nums2`, and calculate the score.","Pair corresponding elements from `nums1` and `nums2`, sort the pairs by `nums2` in descending order, select the top k pairs, calculate the sum of `nums1` values, and multiply by the minimum `nums2` value among the selected pairs.",Medium,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
2543,"Check if Point Is Reachable
There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps. In one step, you can move from point (x, y) to any one of the following points: Given two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.","If gcd(targetX, targetY) is a power of 2, return true, else false.","Return true if targetX + targetY is even, false otherwise.","Check if targetX and targetY are both greater than zero. Return true if they are, false otherwise.","If targetX and targetY are both 1, return true. Otherwise, return false.","Reduce targetX and targetY by taking the greatest common divisor (GCD) until one of them is 1. If the other is a power of 2, return true, otherwise false.",Hard,algorithms,"Math,Number Theory"
2544,"Alternating Digit Sum
You are given a positive integer n. Each digit of n has a sign according to the following rules: Return the sum of all digits with their corresponding sign.","Multiply n by (-1)^(n), then return n","Convert n to a string, sum the ASCII values of the digits, then take the absolute value",Sum the digits at even indices and subtract the sum of the digits at odd indices,Return the sum of the digits multiplied by the length of the number,"Iterate through the digits of n, alternating the sign (+/-) and summing the results",Easy,algorithms,Math
2545,"Sort the Students by Their Kth Score
There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only. You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest. Return the matrix after sorting it.",Use bubble sort on the rows based on the kth column.,Calculate the sum of all scores for each student and sort by that sum.,Sort each column independently and then reconstruct the matrix.,"Use a hash map to count the occurrences of each score in the kth column, then rebuild the matrix based on those counts.","Use a stable sorting algorithm (e.g., merge sort or Timsort) to sort the rows based on the values in the kth column.",Medium,algorithms,"Array,Sorting,Matrix"
2546,"Apply Bitwise Operations to Make Strings Equal
You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times: For example, if s = ""0110"", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = ""1110"". Return true if you can make the string s equal to target, or false otherwise.","If `s` has no '1's, it can only become `target` if `target` also has no '1's","If `target` has more '1's than `s`, it's impossible to achieve equality",The operation preserves the total number of '1's in the string,"If the lengths of `s` and `target` are different, return `false`","Equality is possible if and only if either both strings contain at least one '1', or both strings contain no '1's",Medium,algorithms,"String,Bit Manipulation"
2547,"Minimum Cost to Split an Array
You are given an integer array nums and an integer k. Split the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split. Let trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed. The importance value of a subarray is k + trimmed(subarray).length. Return the minimum possible cost of a split of nums. A subarray is a contiguous non-empty sequence of elements within an array.","Use dynamic programming with a state representing the index and the last split point, calculating cost based on the importance value of each subarray.","Employ a greedy approach, always splitting the array at the point that minimizes the immediate importance value of the next subarray.",Sort the array and then use binary search to determine optimal split points based on the distribution of unique elements.,"Recursively split the array into two halves, calculating the cost of each split independently and summing the results.","Apply dynamic programming where dp[i] stores the minimum cost to split nums[:i], transitioning by considering all possible last split points j < i.",Hard,algorithms,"Array,Hash Table,Dynamic Programming,Counting"
2549,"Count Distinct Numbers on Board
You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure: Return the number of distinct integers present on the board after 109 days have elapsed. Note:","n - 1, if n > 1, otherwise 0","Always 1, as the board converges to a single value",n / 2 (rounded down to the nearest integer),"n * 2, representing all possible pairs","n - 1, if n > 1, otherwise 1",Easy,algorithms,"Array,Hash Table,Math,Simulation"
2550,"Count Collisions of Monkeys on a Polygon
There is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices. Simultaneously, each monkey moves to a neighboring vertex. A collision happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge. Return the number of ways the monkeys can move so that at least one collision happens. Since the answer may be very large, return it modulo 109 + 7.",n^n - 2n mod (10^9 + 7),n! mod (10^9 + 7),(n-1)^n mod (10^9 + 7),(n-2)^n mod (10^9 + 7),(n^n - 2) mod (10^9 + 7),Medium,algorithms,"Math,Recursion"
2551,"Put Marbles in Bags
You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k. Divide the marbles into the k bags according to the following rules: The score after distributing the marbles is the sum of the costs of all the k bags. Return the difference between the maximum and minimum scores among marble distributions.",Sort the weights array and sum the first k-1 elements.,Calculate the prefix sum of the weights array and divide by k.,Randomly distribute the marbles into k bags and calculate the score.,Find the median of the weights array and multiply it by k.,Sort the weights array. The minimum score is the sum of the first elements and last elements. The maximum score is the sum of adjacent elements after sorting. Return the difference between the maximum and minimum scores.,Hard,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
2552,"Count Increasing Quadruplets
Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets. A quadruplet (i, j, k, l) is increasing if:",Brute-force: Use four nested loops to check all possible quadruplets for the increasing condition.,"Precompute all pairs (i,j) and (k,l) then check increasing condition for each pair.",Sort the array and then count quadruplets based on indices.,Use binary search to efficiently find elements that satisfy the increasing conditions based on fixed 'j' and 'k'.,"For each 'j' and 'k', count elements smaller than nums[k] to the left of 'j' and elements larger than nums[j] to the right of 'k'.",Hard,algorithms,"Array,Dynamic Programming,Binary Indexed Tree,Enumeration,Prefix Sum"
2553,"Separate the Digits in an Array
Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums. To separate the digits of an integer is to get all the digits it has in the same order.","Convert each number to a string, split the string into digits, and flatten the resulting list of lists.",Use recursion to extract digits from each number and append them to the result array.,Sort the input array before extracting digits to ensure the output is in ascending order.,Multiply each number by its index in the array and then extract the digits.,"Iterate through the input array, convert each number to a string, and extend the result array with the digits.",Easy,algorithms,"Array,Simulation"
2554,"Maximum Number of Integers to Choose From a Range I
You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules: Return the maximum number of integers you can choose following the mentioned rules.",Use dynamic programming to determine the optimal subset,"Greedily select integers starting from n and decreasing to 1, skipping banned numbers",Sort the banned array and perform a binary search for each integer from 1 to n,"Use a hash table to store banned numbers and iterate from 1 to n, summing until maxSum is exceeded","Iterate from 1 to n, selecting integers not in banned until the sum exceeds maxSum",Medium,algorithms,"Array,Hash Table,Binary Search,Greedy,Sorting"
2555,"Maximize Win From Two Segments
There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k. You are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect. Return the maximum number of prizes you can win if you choose the two segments optimally.",Iterate through all possible pairs of segments and calculate the number of prizes within them using brute force.,"Use a greedy approach, selecting the segment with the most prizes first, then the second best segment from the remaining prizes.",Sort the prize positions and use dynamic programming to find the optimal segments.,"Calculate the maximum prizes in a single segment, then select the segment with the median position.","Use a sliding window approach to find the maximum prizes in a single segment, then iterate through all possible positions for the second segment and maximize the combined prizes.",Medium,algorithms,"Array,Binary Search,Sliding Window"
2556,"Disconnect Path in a Binary Matrix by at Most One Flip
You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1. The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1). You can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1). Return true if it is possible to make the matrix disconnect or false otherwise. Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.","Check if the number of paths from (0,0) to (m-1, n-1) is zero.","Flip a random '1' to '0' and check if there is no path from (0,0) to (m-1, n-1).","Use a greedy approach, always flipping the '1' closest to (0,0).","Perform a BFS from (0,0) and then a DFS from (m-1, n-1) and check for common '1' cells.","Find two disjoint paths from (0,0) to (m-1, n-1) using DFS or BFS. If found, return true; otherwise, return false.",Medium,algorithms,"Array,Dynamic Programming,Depth-First Search,Breadth-First Search,Matrix"
2558,"Take Gifts From the Richest Pile
You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following: Return the number of gifts remaining after k seconds.",Use a min-heap to store pile sizes and reduce the smallest pile each time.,Sort the array in ascending order and reduce the last element by its square root k times.,Divide each pile size by k and return the sum of the results.,Calculate the average gift count and multiply by the number of piles after reducing by sqrt(average) k times.,"Use a max-heap to efficiently find the largest pile, reduce it by its square root, and repeat k times.",Easy,algorithms,"Array,Heap (Priority Queue),Simulation"
2559,"Count Vowel Strings in Ranges
You are given a 0-indexed array of strings words and a 2D array of integers queries. Each query queries[i] = [li, ri] asks us to find the number of strings present at the indices ranging from li to ri (both inclusive) of words that start and end with a vowel. Return an array ans of size queries.length, where ans[i] is the answer to the ith query. Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.",Use dynamic programming to precompute the vowel counts for all prefixes and then subtract counts for each query range.,Employ a binary search approach to quickly find the start and end indices of vowel-starting and ending strings within each query range.,"Create a boolean array indicating if a word at a given index starts and ends with a vowel, then iterate through the queries summing applicable booleans.","Precompute a matrix where each cell (i, j) stores the vowel-starting-and-ending-word count from index i to j, then retrieve results directly.","Precompute a prefix sum array of vowel-starting-and-ending-word counts, then calculate the range sum for each query using prefix sums.",Medium,algorithms,"Array,String,Prefix Sum"
2560,"House Robber IV
There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes. The capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed. You are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars. You are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses. Return the minimum capability of the robber out of all the possible ways to steal at least k houses.",Greedily select houses with the least money until k houses are robbed,Use dynamic programming to calculate the maximum stolen amount with at most k houses robbed,Binary search on the nums array and count the number of houses that can be robbed with a given capability,Sort the nums array and pick the first k elements,Binary search on the potential capability values and check if it's possible to rob at least k houses with that capability,Medium,algorithms,"Array,Binary Search,Dynamic Programming,Greedy"
2561,"Rearranging Fruits
You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want: Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets. Return the minimum cost to make both the baskets equal or -1 if impossible.",Find the smallest value present in either basket and swap other values with it to minimize cost,Calculate the difference in sums of both baskets and divide by 2 to find the minimum cost,"Determine if there is a common element in both baskets. If not, return -1. Otherwise, return 0","If the smallest value is present in both baskets, return 0. Otherwise, swap the largest values in each basket until sums are equal","Find the frequency of each fruit cost. If any cost appears an odd number of times, return -1. Otherwise, find the minimum cost to balance the baskets by swapping values greater than the smallest cost.",Hard,algorithms,"Array,Hash Table,Greedy"
2562,"Find the Array Concatenation Value
You are given a 0-indexed integer array nums. The concatenation of two numbers is the number formed by concatenating their numerals. The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty: Return the concatenation value of nums.",Multiply each number by its index and sum the results.,Sort the array and then sum adjacent elements.,Take the absolute difference between adjacent elements and add those.,Calculate the sum of all the elements in the array.,"Iterate through the array, concatenating the first and last elements in each step until the array is empty or has one element.",Easy,algorithms,"Array,Two Pointers,Simulation"
2563,"Count the Number of Fair Pairs
Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs. A pair (i, j) is fair if:",Use binary search to find the number of elements within the range for each element in the array.,"Sort the array and then iterate through it, counting pairs that satisfy the condition by comparing each element with all subsequent elements.","Use a hash map to store the frequency of each element, then iterate through the map and count pairs based on frequency counts.","Iterate through the array and for each element, iterate again from the beginning to find pairs that satisfy the condition.","Sort the array, then for each element use two pointers (or binary search) to find the range of indices that satisfy the lower and upper bound conditions, incrementing the count by the range size.",Medium,algorithms,"Array,Two Pointers,Binary Search,Sorting"
2564,"Substring XOR Queries
You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi]. For the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi. The answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti. Return an array ans where ans[i] = [lefti, righti] is the answer to the ith query. A substring is a contiguous non-empty sequence of characters within a string.",Use dynamic programming to store the XOR values of all substrings and then efficiently query the table.,"Convert the binary string to an integer, then iterate through all possible substring lengths and starting positions, calculating the XOR value for each and comparing with the query.",Build a suffix tree of the binary string and then use it to efficiently search for substrings with the desired XOR value.,"Use a sliding window approach, expanding the window until the XOR condition is met or the window reaches the end of the string.","Precompute XOR values for all possible substrings up to a certain length, store them in a hash map with their indices, and then query the hash map for each query.",Medium,algorithms,"Array,Hash Table,String,Bit Manipulation"
2565,"Subsequence With the Minimum Score
You are given two strings s and t. You are allowed to remove any number of characters from the string t. The score of the string is 0 if no characters are removed from the string t, otherwise: Then the score of the string is right - left + 1. Return the minimum possible score to make t a subsequence of s. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).","Greedily match characters from `t` in `s` from left to right, then right to left, and take the minimum score.",Recursively explore all possible subsequences of `t` and calculate the score for each valid subsequence.,"Use dynamic programming to find the longest common subsequence between `s` and `t`, then calculate the score based on the remaining characters in `t`.",Sort both strings `s` and `t` alphabetically and then find the minimum score by matching the sorted characters.,"Precompute the leftmost and rightmost indices in `s` where prefixes and suffixes of `t` can be found, and iterate through all possible splits of `t` to minimize the score.",Hard,algorithms,"Two Pointers,String,Binary Search"
2566,"Maximum Difference by Remapping a Digit
You are given an integer num. You know that Bob will sneakily remap one of the 10 possible digits (0 to 9) to another digit. Return the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num. Notes:",Replace the first occurrence of '0' with '9' to maximize and the first occurrence of '9' with '0' to minimize.,Replace all occurrences of the smallest digit with '9' to maximize and all occurrences of the largest digit with '0' to minimize.,Replace the first digit with '9' to maximize and the last digit with '0' to minimize.,Replace a randomly chosen digit with '9' to maximize and with '0' to minimize and return the absolute difference,"Replace all occurrences of the leftmost non-9 digit with '9' to maximize and all occurrences of the leftmost non-0 digit with '0' to minimize, then find the difference.",Easy,algorithms,"Math,Greedy"
2567,"Minimum Score by Changing Two Elements
You are given an integer array nums. Return the minimum score after changing two elements of nums.",Find the maximum and minimum elements and set them to the median value.,Set all elements to the average of the array.,Find the two largest elements and set them to the minimum value.,Sort the array in descending order and change the first two elements to the last element.,Sort the array in ascending order and minimize the difference between the largest and smallest elements after changing the first two elements to nums[2].,Medium,algorithms,"Array,Greedy,Sorting"
2568,"Minimum Impossible OR
You are given a 0-indexed integer array nums. We say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums. Return the minimum positive non-zero integer that is not expressible from nums.",n log n,n^2,log n,sqrt(n),n,Medium,algorithms,"Array,Bit Manipulation,Brainteaser"
2569,"Handling Sum Queries After Update
You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries: Return an array containing all the answers to the third type queries.",Linear search through both arrays for each query.,Rebuild the arrays from scratch for each update.,Use a hash table to store the index and value of each element.,Ignore the update queries and return the initial sum.,Use a segment tree or binary indexed tree to efficiently handle updates and sum queries.,Hard,data structures,"Array,Segment Tree"
2570,"Merge Two 2D Arrays by Summing Values
You are given two 2D integer arrays nums1 and nums2. Each array contains unique ids and is sorted in ascending order by id. Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions: Return the resulting array. The returned array must be sorted in ascending order by id.","Use nested loops to compare elements and sum values in place within nums1, then sort nums1.","Concatenate nums2 onto nums1, then iterate through the combined array, summing values with the same ID.","Convert both 2D arrays into dictionaries, then directly add the dictionary values; convert it back to a 2D array.",Sort nums1 and nums2 independently and use a merge sort variation without considering the need to sum same IDs.,"Use a two-pointer approach to iterate through both arrays, summing values for matching IDs and appending new IDs accordingly.",Easy,algorithms,"Array,Hash Table,Two Pointers"
2571,"Minimum Operations to Reduce an Integer to 0
You are given a positive integer n, you can do the following operation any number of times: Return the minimum number of operations to make n equal to 0. A number x is power of 2 if x == 2i where i >= 0.","Recursively subtract the largest power of 2 less than or equal to 'n', or add the smallest power of 2 greater than 'n', whichever yields the fewest operations","Convert 'n' to its binary representation and count the number of 1s and 0s, adding the smaller count to the result","Repeatedly divide 'n' by 2 until it becomes 0, counting the number of divisions","Iteratively subtract powers of 2 from 'n', starting with the smallest power of 2 and incrementing until 'n' becomes 0","Convert 'n' to its binary representation and count the number of consecutive 1s and 0s sequences, summing the counts",Medium,algorithms,"Dynamic Programming,Greedy,Bit Manipulation"
2572,"Count the Number of Square-Free Subsets
You are given a positive integer 0-indexed array nums. A subset of the array nums is square-free if the product of its elements is a square-free integer. A square-free integer is an integer that is divisible by no square number other than 1. Return the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7. A non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",Use dynamic programming with a state representing the current index and a mask of prime factors seen so far.,"Sort the array and then iterate through it, keeping track of the product of the selected elements and checking for square factors.",Recursively explore all subsets and use trial division to determine if each subset is square-free.,"Precompute all square numbers up to the product of the maximum value in 'nums' and the length of 'nums', then check divisibility","Employ bitmasking to represent subsets and prime factorization to efficiently determine square-free status, using dynamic programming to avoid redundant calculations",Medium,algorithms,"Array,Math,Dynamic Programming,Bit Manipulation,Bitmask"
2573,"Find the String with LCP
We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that: Given an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, ""aabd"" is lexicographically smaller than ""aaca"" because the first position they differ is at the third letter, and 'b' comes before 'c'.","Construct the string greedily, assigning the smallest possible character while ensuring consistency with all LCP values, backtracking when conflicts arise.","Start with an empty string and iteratively append characters based on the maximum LCP value in each row, ignoring inconsistencies to find any possible string.",Initialize the string with the character 'a' repeated n times and incrementally modify characters to maximize the total LCP sum.,Use dynamic programming to build all possible strings that satisfy the LCP matrix and then return the lexicographically smallest one.,"Verify that the LCP matrix is valid, construct the string greedily assigning smallest characters while respecting LCP constraints; if a conflict occurs, no such string exists.",Hard,algorithms,"Array,String,Dynamic Programming,Greedy,Union Find,Matrix"
2574,"Left and Right Sum Differences
You are given a 0-indexed integer array nums of size n. Define two arrays leftSum and rightSum where: Return an integer array answer of size n where answer[i] = |leftSum[i] - rightSum[i]|.",Use nested loops to calculate leftSum and rightSum for each index.,Precompute the total sum of the array and use it to derive leftSum and rightSum in a single pass.,"Create separate arrays for left sums and right sums, calculate each separately, then find the differences.",Sort the input array before calculating the left and right sums.,"Calculate the total sum of the array first, then iterate through the array, updating leftSum and rightSum in each step using the precomputed total sum.",Easy,algorithms,"Array,Prefix Sum"
2575,"Find the Divisibility Array of a String
You are given a 0-indexed string word of length n consisting of digits, and a positive integer m. The divisibility array div of word is an integer array of length n such that: Return the divisibility array of word.",Calculate prefix sums of the digits and check divisibility using modulo operator.,Convert the string to an integer and check if it's divisible by m.,Check the divisibility of the entire string by m using repeated subtraction.,"For each digit, check if the digit itself is divisible by m.","Iterate through the string, maintaining a running modulo, and update the divisibility array accordingly.",Medium,algorithms,"Array,Math,String"
2576,"Find the Maximum Number of Marked Indices
You are given a 0-indexed integer array nums. Initially, all of the indices are unmarked. You are allowed to make this operation any number of times: Return the maximum possible number of marked indices in nums using the above operation any number of times.",Sort the array and greedily pair the smallest element with an element greater than or equal to twice its value.,"Divide the array into two halves, sort each half, and then pair elements from the first half with elements from the second half.","Iterate through the array and mark the first half of the elements, then try to find pairs in the second half.",Use dynamic programming to find the optimal pairing of elements based on their values.,"Sort the array and use two pointers, one starting from the beginning and the other from the middle, to find pairs satisfying the condition.",Medium,algorithms,"Array,Two Pointers,Binary Search,Greedy,Sorting"
2577,"Minimum Time to Visit a Cell In a Grid
You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col]. You are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second. Return the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.",Depth-First Search (DFS),Greedy algorithm prioritizing cells with lower required times,Dynamic Programming with memoization of visited cells,A* search with heuristic based on Manhattan distance,Dijkstra's algorithm with a priority queue considering time constraints,Hard,algorithms,"Array,Breadth-First Search,Graph,Heap (Priority Queue),Matrix,Shortest Path"
2578,"Split With Minimum Sum
Given a positive integer num, split it into two non-negative integers num1 and num2 such that: Return the minimum possible sum of num1 and num2. Notes:",Sort the digits in ascending order and assign the first half to num1 and the second half to num2,Generate all possible splits of the digits and compute the sum of each split to find the minimum,"Convert the number to a string, alternate assigning digits to num1 and num2, then convert back to integers",Assign all even-indexed digits to num1 and all odd-indexed digits to num2,"Convert the number to a string, sort the digits, and assign digits alternately to num1 and num2 to minimize the sum.",Easy,algorithms,"Math,Greedy,Sorting"
2579,"Count Total Number of Colored Cells
There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes: Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3. Return the number of colored cells at the end of n minutes.",n * (n + 1) / 2,2 * n,4 * n - 3,n * n,2 * n * (n + 1) - 1,Medium,algorithms,Math
2580,"Count Ways to Group Overlapping Ranges
You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range. You are to split ranges into two (possibly empty) groups such that: Two ranges are said to be overlapping if there exists at least one integer that is present in both ranges. Return the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.",Multiply the number of ranges by 2,Calculate 2 raised to the power of the total number of ranges,Find the maximum end value among all ranges,Return the number of ranges that overlap with at least one other range,"Calculate 2 raised to the power of the number of non-overlapping groups of ranges, modulo 10^9 + 7",Medium,algorithms,"Array,Sorting"
2581,"Count Number of Possible Root Nodes
Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Alice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following: Bob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj. Alice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true. Given the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.",Dynamic Programming with memoization to avoid recomputation of subtrees.,A greedy approach selecting the node with the most correct guesses as the root.,"Depth-First Search (DFS) from an arbitrary node, counting correct guesses and propagating information about potential root nodes.","Breadth-First Search (BFS) from node 0, pruning branches that don't meet the minimum correct guess threshold.",Rooting the tree at each node and performing a DFS to check if the number of correct guesses is at least k.,Hard,algorithms,"Array,Hash Table,Dynamic Programming,Tree,Depth-First Search"
2582,"Pass the Pillow
There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction. Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.",n + time % (n - 1),time % n,n - time % (2 * n),(time + n - 1) % n + 1,1 + (time % (2 * (n - 1))) if (time % (2 * (n - 1))) <= (n - 1) else n - ((time % (2 * (n - 1))) - (n - 1)),Easy,algorithms,"Math,Simulation"
2583,"Kth Largest Sum in a Binary Tree
You are given the root of a binary tree and a positive integer k. The level sum in the tree is the sum of the values of the nodes that are on the same level. Return the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1. Note that two nodes are on the same level if they have the same distance from the root.","Depth-First Search (DFS) with in-order traversal, storing level sums in a sorted array and retrieving the kth element.","Breadth-First Search (BFS), calculating level sums using a hash map keyed by level, sorting the sums, and returning the kth largest.",Recursive post-order traversal to compute level sums and then sorting to find the kth largest.,"Perform a pre-order traversal, storing sums in a min-heap of size k, replacing the smallest when a new sum is larger, then returning the heap's root.","Breadth-First Search (BFS) level-by-level, storing level sums in a list, sorting the list in descending order, and returning the element at index k-1.",Medium,algorithms,"Tree,Breadth-First Search,Sorting,Binary Tree"
2584,"Split the Array to Make Coprime Products
You are given a 0-indexed integer array nums of length n. A split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime. Return the smallest index i at which the array can be split validly or -1 if there is no such split. Two values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.",Calculate the product of all elements and then check for coprimality with prefixes iteratively,Precompute all prime factors for each number and use a prefix-suffix set intersection approach,Sort the array and check for coprimality only at indices where the value changes,Use dynamic programming to store coprime pairs and build up to the full array,"Iterate through the array, maintaining the set of prime factors for the left and right subarrays and checking for an empty intersection",Hard,algorithms,"Array,Hash Table,Math,Number Theory"
2585,"Number of Ways to Earn Points
There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points. Return the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7. Note that questions of the same type are indistinguishable.",Greedily select the maximum number of questions from each type until the target is reached or exceeded.,"Use a backtracking algorithm to explore all possible combinations of questions, pruning branches that exceed the target.","Apply a divide-and-conquer strategy, splitting the problem into smaller subproblems and combining the results.",Sort the types array in descending order of marks and then select questions until the target is reached.,Use dynamic programming to build a table of the number of ways to reach each possible score up to the target.,Hard,algorithms,"Array,Dynamic Programming"
2586,"Count the Number of Vowel Strings in Range
You are given a 0-indexed array of string words and two integers left and right. A string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'. Return the number of vowel strings words[i] where i belongs to the inclusive range [left, right].","Use dynamic programming to precompute the number of vowel strings up to each index, then subtract to find the range.","Create a hash table to store the vowels and iterate through the given range, checking the first and last characters against the hash table.",Sort the words array lexicographically and then iterate through the specified range.,Iterate through the specified range and use regular expressions to check if each word is a vowel string.,"Iterate through the specified range, checking if each word starts and ends with a vowel character using simple string indexing.",Easy,algorithms,"Array,String,Counting"
2587,"Rearrange Array to Maximize Prefix Score
You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order). Let prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix. Return the maximum score you can achieve.",Sort the array in ascending order.,Calculate the prefix sum without rearranging the array.,Return the count of positive numbers in the original array.,Sort the array based on the absolute values of its elements.,Sort the array in descending order and calculate the prefix sum.,Medium,algorithms,"Array,Greedy,Sorting,Prefix Sum"
2588,"Count the Number of Beautiful Subarrays
You are given a 0-indexed integer array nums. In one operation, you can: A subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times (including zero). Return the number of beautiful subarrays in the array nums. A subarray is a contiguous non-empty sequence of elements within an array. Note: Subarrays where all elements are initially 0 are considered beautiful, as no operation is needed.",Calculate the prefix product modulo 2 and count subarrays with product 0.,Use dynamic programming to store the number of beautiful subarrays ending at each index.,Sort the array and count subarrays with an even number of odd numbers.,Calculate the prefix sum and count subarrays with an even sum.,Calculate the prefix XOR and count subarrays with XOR equal to 0.,Medium,algorithms,"Array,Hash Table,Bit Manipulation,Prefix Sum"
2589,"Minimum Time to Complete All Tasks
There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi]. You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle. Return the minimum time during which the computer should be turned on to complete all tasks.","Greedily schedule tasks based on earliest start time, ignoring duration constraints.","Sort tasks by duration and schedule the longest tasks first, minimizing overlap.",Recursively explore all possible scheduling combinations to find the optimal solution.,"Schedule tasks based on earliest deadline (end time), prioritizing tasks that need to be completed sooner.","Use a greedy approach along with an array to track occupied time slots, scheduling tasks to maximize utilization within their valid range.",Hard,algorithms,"Array,Binary Search,Stack,Greedy,Sorting"
2591,"Distribute Money to Maximum Children
You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to. You have to distribute the money according to the following rules: Return the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.",Greedily assign 7 dollars to each child until remaining money is less than 7,Divide the total money by 8 and return the integer quotient,Assign 8 dollars to all children possible then redistribute the remaining money equally,"Assign money sequentially, giving 1 dollar to each child, then 2, then 3, and so on until money is depleted","Distribute 8 dollars greedily until remaining children equals 1, then adjust based on the remaining money",Easy,algorithms,"Math,Greedy"
2592,"Maximize Greatness of an Array
You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing. We define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i]. Return the maximum possible greatness you can achieve after permuting nums.","Sort 'nums' in ascending order and 'perm' in descending order, then compare elements.","Use a greedy approach, always placing the smallest available number from 'nums' at each index.","Iterate through all possible permutations of 'nums' and calculate the greatness for each, then return the maximum.","Maintain a frequency map of 'nums', and for each element, find the smallest element in 'perm' that is greater, decrementing the frequency.","Sort 'nums', and for each element, find the smallest element greater than it using a two-pointer approach or binary search.",Medium,algorithms,"Array,Two Pointers,Greedy,Sorting"
2593,"Find Score of an Array After Marking All Elements
You are given an array nums consisting of positive integers. Starting with score = 0, apply the following algorithm: Return the score you get after applying the above algorithm.","Mark even numbers, then odd numbers, summing unmarked elements","Sort the array first, then mark and sum elements",Use a heap data structure to efficiently find adjacent elements,Mark elements in reverse order of their appearance,"Iterate through the array, marking the current element and its neighbors, and adding the current element to the score",Medium,algorithms,"Array,Hash Table,Sorting,Heap (Priority Queue),Simulation"
2594,"Minimum Time to Repair Cars
You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes. You are also given an integer cars representing the total number of cars waiting in the garage to be repaired. Return the minimum time taken to repair all the cars. Note: All the mechanics can repair the cars simultaneously.",Greedily assign each car to the mechanic with the lowest rank until all cars are assigned.,Calculate the time each mechanic takes to repair all cars and choose the minimum of those times.,Use dynamic programming to store the minimum time to repair 'i' cars with 'j' mechanics.,Sort the ranks array and multiply the smallest rank by the number of cars.,Apply binary search over the possible time range to find the minimum time required to repair all cars.,Medium,algorithms,"Array,Binary Search"
2595,"Number of Even and Odd Bits
You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].","Divide n by 2 until it becomes 0, counting the remainder each time.",Use a lookup table to store the parity of each number from 0 to n.,Convert n to a string and count '1's at even and odd string indices.,"Recursively call the function with n/2 until n is 0 or 1, counting 1's during the return.","Convert n to its binary representation and iterate through the bits, tracking even and odd indices with 1s.",Easy,algorithms,Bit Manipulation
2596,"Check Knight Tour Configuration
There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once. You are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed. Return true if grid represents a valid configuration of the knight's movements or false otherwise. Note that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",O(n^3) due to the nested loops and repeated calculations of valid moves.,O(n log n) because of the sorting algorithm potentially used within the validation process.,O(1) as the knight's moves are limited and independent of the board size.,O(n^2 log n) due to the need to check all possible knight paths on the board.,O(n^2) because each cell on the n x n board is visited once to verify the knight's tour.,Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Matrix,Simulation"
2597,"The Number of Beautiful Subsets
You are given an array nums of positive integers and a positive integer k. A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k. Return the number of non-empty beautiful subsets of the array nums. A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",Recursively explore all possible subsets and increment a counter if a subset is beautiful,Sort the array and use a sliding window approach to count beautiful subsets,"Employ dynamic programming, storing the number of beautiful subsets ending at each index",Calculate all possible subsets and eliminate the non-beautiful ones,Use bit manipulation to generate all subsets and check each for the beautiful property,Medium,algorithms,"Array,Hash Table,Math,Dynamic Programming,Backtracking,Sorting,Combinatorics"
2598,"Smallest Missing Non-negative Integer After Operations
You are given a 0-indexed integer array nums and an integer value. In one operation, you can add or subtract value from any element of nums. The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it. Return the maximum MEX of nums after applying the mentioned operation any number of times.",Use dynamic programming to track reachable numbers within a limited range.,"Sort the array and greedily adjust elements to fill missing values, starting from 0.",Apply binary search on the possible MEX range to find the maximum attainable value.,Iterate through the array and repeatedly apply the operation until the MEX is found.,"Count occurrences of nums[i] % value for each i, and greedily construct the MEX from 0 upwards, using the counts.",Medium,algorithms,"Array,Hash Table,Math,Greedy"
2600,"K Items With the Maximum Sum
There is a bag that consists of items, each item has a number 1, 0, or -1 written on it. You are given four non-negative integers numOnes, numZeros, numNegOnes, and k. The bag initially contains: We want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.","Return min(k, numOnes) - min(k - numOnes, numNegOnes)","Return min(k, numOnes) - (k - numOnes - numZeros)",Return numOnes - numNegOnes if k > numOnes + numZeros + numNegOnes else 0,Return numOnes + numZeros - numNegOnes,"Return min(k, numOnes) - max(0, k - numOnes - numZeros)",Easy,algorithms,"Math,Greedy"
2601,"Prime Subtraction Operation
You are given a 0-indexed integer array nums of length n. You can perform the following operation as many times as you want: Return true if you can make nums a strictly increasing array using the above operation and false otherwise. A strictly increasing array is an array whose each element is strictly greater than its preceding element.","Check if the array is initially strictly increasing; if so, return true without modifications",Always subtract the smallest prime number less than or equal to the current number if it violates the increasing order,Sort the array in ascending order and then check if it is strictly increasing,"Subtract a fixed prime number (e.g., 2) from each number that violates the strictly increasing order","Iterate through the array, and for each element that violates the strictly increasing order, subtract the largest possible prime number less than the current number to make it greater than the previous one. Return false if no such prime exists or it still violates the increasing order.",Medium,algorithms,"Array,Math,Binary Search,Greedy,Number Theory"
2602,"Minimum Operations to Make All Array Elements Equal
You are given an array nums consisting of positive integers. You are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times: Return an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i]. Note that after each query the array is reset to its original state.","O(n*m), where n is the size of nums and m is the size of queries","O(n log n + m*n), where n is the size of nums and m is the size of queries","O(n + m log m), where n is the size of nums and m is the size of queries","O(n log n + m log m), where n is the size of nums and m is the size of queries","O(n log n + m log n), where n is the size of nums and m is the size of queries",Medium,algorithms,"Array,Binary Search,Sorting,Prefix Sum"
2603,"Collect Coins in a Tree
There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i. Initially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: Find the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex. Note that if you pass an edge several times, you need to count it into the answer several times.","O(n^3), where n is the number of nodes","O(n log n), where n is the number of nodes","O(n^2), where n is the number of nodes",O(1),"O(n), where n is the number of nodes",Hard,algorithms,"Array,Tree,Graph,Topological Sort"
2606,"Find the Substring With Maximum Cost
You are given a string s, a string chars of distinct characters and an integer array vals of the same length as chars. The cost of the substring is the sum of the values of each character in the substring. The cost of an empty string is considered 0. The value of the character is defined in the following way: Return the maximum cost among all substrings of the string s.",Calculate the cost of all possible substrings and return the minimum cost.,"Calculate the cost of all possible substrings, sort them, and return the median cost.",Only consider substrings that start and end with characters present in 'chars'.,"Only consider substrings of a fixed length k, where k is the length of 'chars'.",Use Kadane's algorithm to find the maximum sum subarray.,Medium,algorithms,"Array,Hash Table,String,Dynamic Programming"
2607,"Make K-Subarray Sums Equal
You are given a 0-indexed integer array arr and an integer k. The array arr is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element. You can do the following operation any number of times: Return the minimum number of operations such that the sum of each subarray of length k is equal. A subarray is a contiguous part of the array.",Find the mode of each k-subarray and calculate the differences from the mean,"Use dynamic programming to find the minimum sum of any k-subarray, then equalize all others to that value",Apply a sliding window technique to identify the subarray with the smallest sum and normalize the remaining subarrays,Sort the array and distribute the differences between elements evenly across k-subarrays,Find the median of each cycle of length k and calculate the sum of absolute differences from the median for each cycle,Medium,algorithms,"Array,Math,Greedy,Sorting,Number Theory"
2608,"Shortest Cycle in a Graph
There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. Return the length of the shortest cycle in the graph. If no cycle exists, return -1. A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.","Use Depth-First Search (DFS) and return the minimum path length encountered while revisiting a node, ignoring the parent node in the traversal.",Apply Dijkstra's algorithm to find the shortest path between all pairs of nodes and choose the minimum self-loop distance.,"Perform a Breadth-First Search (BFS) from each node, keeping track of the distance to each node and the parent node, and return the minimum cycle length found.","Compute the Minimum Spanning Tree (MST) of the graph. If the graph has cycles, the MST will have edges that form cycles.","For each node, perform Breadth-First Search (BFS) and find the shortest path back to the starting node, excluding the edge that leads back to the parent during the BFS.",Hard,algorithms,"Breadth-First Search,Graph"
2609,"Find the Longest Balanced Substring of a Binary String
You are given a binary string s consisting only of zeroes and ones. A substring of s is considered balanced if all zeroes are before ones and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring. Return the length of the longest balanced substring of s. A substring is a contiguous sequence of characters within a string.",Count the total number of zeros and ones in the string and return twice the minimum of these counts.,"Iterate through all possible substrings and check if each is balanced, keeping track of the longest one found.",Use dynamic programming to store the lengths of balanced substrings ending at each index.,Sort the string and then find the longest prefix consisting of an equal number of zeros and ones.,"Use two pointers to expand outwards from each index, checking for balanced substrings.",Easy,algorithms,String
2610,"Convert an Array Into a 2D Array With Conditions
You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions: Return the resulting array. If there are multiple answers, return any of them. Note that the 2D array can have a different number of elements on each row.","A hash table where keys are indices and values are the elements, sorted by value","A binary search tree where nodes represent elements, guaranteeing a balanced distribution","A heap data structure that dynamically adjusts, potentially leaving gaps in rows",A single array partitioned into sub-arrays based on prime factorization of elements,A frequency-based approach distributing elements into rows based on their occurrence count,Medium,algorithms,"Array,Hash Table"
2611,"Mice and Cheese
There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse. A point of the cheese with index i (0-indexed) is: You are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k. Return the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.","Sort the differences (reward1[i] - reward2[i]) and assign the largest k differences to mouse 1, the rest to mouse 2.",Use dynamic programming to find the optimal assignment of cheese types to mice.,Greedily assign the cheese with the highest combined reward (reward1[i] + reward2[i]) to mouse 1 until mouse 1 has k cheese types.,"Randomly assign k cheese types to mouse 1 and the rest to mouse 2, repeating the process and keeping the maximum score.","Calculate the differences (reward1[i] - reward2[i]), sort them in descending order, assign the first k to mouse 1, and the rest to mouse 2. Sum the rewards accordingly.",Medium,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue)"
2612,"Minimum Reverse Operations
You are given an integer n and an integer p representing an array arr of length n where all elements are set to 0's, except position p which is set to 1. You are also given an integer array banned containing restricted positions. Perform the following operation on arr: Return an integer array answer with n results where the ith result is the minimum number of operations needed to bring the single 1 to position i in arr, or -1 if it is impossible.","Use Breadth-First Search (BFS) starting from position 'p', marking visited nodes and tracking distances, ignoring banned positions and reflection constraints.","Apply Dijkstra's algorithm treating each position as a node, the operation as an edge, and banned positions as very high cost edges.","Employ a Depth-First Search (DFS) to explore possible moves, pruning branches that lead to banned positions or exceed a depth limit based on 'n'.","Implement dynamic programming to calculate the minimum operations, storing the number of moves required to reach each position, considering only allowed transitions from previous positions.","Utilize Breadth-First Search (BFS) starting from position 'p', considering the reflection operation as a valid move, marking visited nodes and banned positions to avoid cycles.",Hard,algorithms,"Array,Breadth-First Search,Ordered Set"
2614,"Prime In Diagonal
You are given a 0-indexed two-dimensional integer array nums. Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0. Note that:  In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",Check only numbers on the primary diagonal for primality.,"Implement a primality test using trial division up to the square root, optimizing for even numbers.",Use a sieve of Eratosthenes to precompute primes up to the largest possible value in 'nums'.,Check all numbers in the array for primality and then filter for diagonals and find the largest.,"Iterate through both diagonals, testing each number for primality using an efficient primality test and keeping track of the largest prime found.",Easy,algorithms,"Array,Math,Matrix,Number Theory"
2615,"Sum of Distances
You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0. Return the array arr.","O(n) time and O(1) space, using a two-pointer approach to simultaneously traverse the array from both ends.","O(n log n) time and O(n) space, sorting the array and then computing the distances for each element.","O(n^2) time and O(1) space, iterating through all pairs of elements to compute the distances.","O(n) time and O(n) space, using a hash map to store the indices of each element and then calculating the distances.","O(n) time and O(n) space, using prefix and suffix sums to efficiently calculate the total distances.",Medium,algorithms,"Array,Hash Table,Prefix Sum"
2616,"Minimize the Maximum Difference of Pairs
You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs. Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x. Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.",Apply dynamic programming to find the optimal pairs with memoization based on subproblems.,Use a greedy approach by always selecting the smallest absolute difference available without considering the constraint of 'p' pairs.,"Sort the array and perform a binary search on the possible range of maximum differences, checking if a given difference allows for 'p' valid pairs.","Compute all possible pairs and their differences, then select the 'p' smallest differences.","Sort the array and use a binary search on the possible range of maximum differences, counting the number of valid pairs for each difference.",Medium,algorithms,"Array,Binary Search,Dynamic Programming,Greedy,Sorting"
2617,"Minimum Number of Visited Cells in a Grid
You are given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0). Starting from the cell (i, j), you can move to one of the following cells: Return the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.","Dynamic programming without memoization or tabulation, leading to redundant calculations and potential stack overflow.","A greedy approach selecting the minimum possible jump at each step, which may not lead to the optimal path.","Breadth-first search (BFS) without proper visited cell tracking, causing infinite loops in certain grids.","Depth-first search (DFS) without iterative deepening or heuristic pruning, potentially exploring very long paths before finding the shortest one.",Breadth-first search (BFS) with distance tracking and optimized jump range exploration using segment trees or similar data structures.,Hard,algorithms,"Array,Dynamic Programming,Stack,Breadth-First Search,Union Find,Heap (Priority Queue),Matrix,Monotonic Stack"
2618,"Check if Object Instance of Class
Write a function that checks if a given value is an instance of a given class or superclass. For this problem, an object is considered an instance of a given class if that object has access to that class's methods. There are no constraints on the data types that can be passed to the function. For example, the value or the class could be undefined.",Use `typeof` operator to check the value's type against the class's constructor name.,Compare the value's `__proto__` property directly with the class's prototype.,Check if `value.constructor` is strictly equal to the class constructor.,Utilize the `hasOwnProperty` method to determine if the class's properties exist in the value.,Use the `instanceof` operator to determine if the value is an instance of the class or its superclasses.,Medium,algorithms,"['instanceof', 'object', 'class']"
2619,"Array Prototype Last
Write code that enhances all arrays such that you can call the array.last() method on any array and it will return the last element. If there are no elements in the array, it should return -1. You may assume the array is the output of JSON.parse.",Return `this[this.length]`,Return `this.at(0)`,Return `this.pop()`,"Return `this.slice(-2, -1)`",Return `this.length > 0 ? this[this.length - 1] : -1`,Easy,algorithms,"['array', 'prototype', 'javascript']"
2620,"Counter
Given an integer n, return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called (n, n + 1, n + 2, etc).",Use a global variable to store the counter value.,Create a new function for each increment.,Return n + 1 directly without any state.,Use a while loop to decrement n until it reaches zero.,Use a closure to maintain the counter value in the function's scope.,Easy,algorithms,"['closure', 'higher-order function', 'state']"
2621,"Sleep
Given a positive integer millis, write an asynchronous function that sleeps for millis milliseconds. It can resolve any value. Note that minor deviation from millis in the actual sleep duration is acceptable.",Use `setTimeout` with a callback that immediately resolves the promise,Use a busy-wait loop that checks `performance.now()` until the time has elapsed,Utilize `setImmediate` in a loop until the time has elapsed,Employ a `while` loop with `Date.now()` to approximate the delay,Return a new Promise that resolves after `setTimeout` is called with millis,Easy,algorithms,"['async/await', 'promises', 'setTimeout']"
2622,"Cache With Time Limit
Write a class that allows getting and setting key-value pairs, however a time until expiration is associated with each key. The class has three public methods: set(key, value, duration): accepts an integer key, an integer value, and a duration in milliseconds. Once the duration has elapsed, the key should be inaccessible. The method should return true if the same un-expired key already exists and false otherwise. Both the value and duration should be overwritten if the key already exists. get(key): if an un-expired key exists, it should return the associated value. Otherwise it should return -1. count(): returns the count of un-expired keys.",Use a simple dictionary to store key-value pairs without any expiration mechanism.,Employ a linked list to maintain the order of insertion and delete elements after expiration.,Utilize a separate thread for each key to handle expiration independently.,Store the data in a relational database and use triggers to handle expiration.,"Use a dictionary to store key-value pairs and their expiration timestamps, along with a mechanism (e.g., lazy deletion or a background task) to remove expired entries.",Medium,system design,"['cache', 'expiration', 'data structures']"
2623,"Memoize
Given a function fn, return a memoized version of that function. A memoized function is a function that will never be called twice with the same inputs. Instead it will return a cached value. You can assume there are 3 possible input functions: sum, fib, and factorial.",Bypass the cache and always execute the original function.,"Cache only the last computed value, discarding previous results.",Use a fixed-size cache that evicts the least recently used entry.,Store the function's code in a database to prevent re-computation.,Store input arguments as keys in a cache and return precomputed values if the key exists.,Medium,algorithms,"['memoization', 'caching', 'dynamic programming']"
2624,"Snail Traversal
Write code that enhances all arrays such that you can call the snail(rowsCount, colsCount) method that transforms the 1D array into a 2D array organised in the pattern known as snail traversal order. Invalid input values should output an empty array. If rowsCount * colsCount !== nums.length, the input is considered invalid. Snail traversal order starts at the top left cell with the first value of the current array. It then moves through the entire first column from top to bottom, followed by moving to the next column on the right and traversing it from bottom to top. This pattern continues, alternating the direction of traversal with each column, until the entire current array is covered. For example, when given the input array [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15] with rowsCount = 5 and colsCount = 4, the desired output matrix is shown below. Note that iterating the matrix following the arrows corresponds to the order of numbers in the original array.",Allocate a 2D array and fill it by incrementing row and column indices sequentially.,"Sort the 1D array first, then populate the 2D array in a zig-zag pattern.",Use a temporary array to store intermediate values before assigning them to the 2D array.,"Populate the 2D array row by row, then transpose the matrix if the number of rows exceeds the number of columns.","Calculate the indices based on the current position and the dimensions, alternating the direction of column traversal.",Medium,algorithms,"['array', 'traversal', 'matrix']"
2625,"Flatten Deeply Nested Array
Given a multi-dimensional array arr and a depth n, return a flattened version of that array. A multi-dimensional array is a recursive data structure that contains integers or other multi-dimensional arrays. A flattened array is a version of that array with some or all of the sub-arrays removed and replaced with the actual elements in that sub-array. This flattening operation should only be done if the current depth of nesting is less than n. The depth of the elements in the first array are considered to be 0. Please solve it without the built-in Array.flat method.","Use a while loop with a counter to track depth and recursively call a helper function to flatten sub-arrays, modifying the original array in place.","Convert the multi-dimensional array to a string representation, then use regular expressions to remove brackets up to the specified depth.","Employ a breadth-first search (BFS) approach, using a queue to store array elements and process them layer by layer up to the depth limit.","Iterate through the array and use the `instanceof` operator to check if an element is an array. If it is, splice it into the original array n times.","Implement a recursive function that iterates through the array. If an element is an array and the current depth is less than n, recursively call the function on that element. Otherwise, add the element to the result array.",Medium,algorithms,"['recursion', 'array', 'flattening']"
2626,"Array Reduce Transformation
Given an integer array nums, a reducer function fn, and an initial value init, return the final result obtained by executing the fn function on each element of the array, sequentially, passing in the return value from the calculation on the preceding element. This result is achieved through the following operations: val = fn(init, nums[0]), val = fn(val, nums[1]), val = fn(val, nums[2]), ... until every element in the array has been processed. The ultimate value of val is then returned. If the length of the array is 0, the function should return init. Please solve it without using the built-in Array.reduce method.","Initialize result to an empty array and push elements from nums into it, then return the array.",Apply the reducer function to the first element only and return the result. Ignore the rest of the array.,"Create a new array with the same size as nums and copy the elements, then return the new array.",Return the initial value 'init' regardless of the contents of the 'nums' array.,"Iterate through the nums array, applying the reducer function sequentially and updating the accumulator value, finally returning the accumulated value.",Easy,algorithms,"['array', 'reduce', 'accumulator']"
2627,"Debounce
Given a function fn and a time in milliseconds t, return a debounced version of that function. A debounced function is a function whose execution is delayed by t milliseconds and whose execution is cancelled if it is called again within that window of time. The debounced function should also receive the passed parameters. For example, let's say t = 50ms, and the function was called at 30ms, 60ms, and 100ms. The first 2 function calls would be cancelled, and the 3rd function call would be executed at 150ms. If instead t = 35ms, The 1st call would be cancelled, the 2nd would be executed at 95ms, and the 3rd would be executed at 135ms.  The above diagram shows how debounce will transform events. Each rectangle represents 100ms and the debounce time is 400ms. Each color represents a different set of inputs. Please solve it without using lodash's _.debounce() function.","Using `setTimeout` without clearing the previous timeout, causing multiple executions.",Calling the function immediately and then setting a timeout to prevent future calls within the debounce time.,Storing all function calls in an array and executing them all after the debounce time has elapsed.,Using `setInterval` to repeatedly call the function every `t` milliseconds.,Using `setTimeout` and `clearTimeout` to delay and potentially cancel function execution based on subsequent calls within the debounce time.,Medium,algorithms,"['debounce', 'setTimeout', 'closure']"
2629,"Function Composition
Given an array of functions [f1, f2, f3, ..., fn], return a new function fn that is the function composition of the array of functions. The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))). The function composition of an empty list of functions is the identity function f(x) = x. You may assume each function in the array accepts one integer as input and returns one integer as output.","Apply functions in reverse order using a loop and accumulator, initializing with 0",Apply functions in order and return the initial function if the array is empty,Apply functions in reverse order and return the function at the array's midpoint,Apply functions in order using recursion and memoization to optimize performance,"Apply functions in reverse order using reduceRight or similar technique, handling the empty array case by returning an identity function",Easy,algorithms,"['function composition', 'higher-order functions', 'reduce']"
2630,"Memoize II
Given a function fn, return a memoized version of that function. A memoized function is a function that will never be called twice with the same inputs. Instead it will return a cached value. fn can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are === to each other.","The cache is stored within the function's scope, accessible only through closure.",The cache is stored in local storage for persistence between function calls.,"The cache is stored in the global scope, making it accessible to any function.","The cache is stored in a WeakMap, allowing garbage collection of unused entries.",The cache is stored as a property of the memoized function object.,Hard,algorithms,"['memoization', 'caching', 'closures']"
2631,"Group By
Write code that enhances all arrays such that you can call the array.groupBy(fn) method on any array and it will return a grouped version of the array. A grouped array is an object where each key is the output of fn(arr[i]) and each value is an array containing all items in the original array which generate that key. The provided callback fn will accept an item in the array and return a string key. The order of each value list should be the order the items appear in the array. Any order of keys is acceptable. Please solve it without lodash's _.groupBy function.",O(log n),O(n),O(n log n),O(1) only if you have a reference to the end of the list,O(1),Medium,data structures,"['linked list', 'time complexity', 'insertion']"
2634,"Filter Elements from Array
Given an integer array arr and a filtering function fn, return a filtered array filteredArr. The fn function takes one or two arguments: filteredArr should only contain the elements from the arr for which the expression fn(arr[i], i) evaluates to a truthy value. A truthy value is a value where Boolean(value) returns true. Please solve it without the built-in Array.filter method.",Return a new array containing only elements at even indices of the original array.,"Modify the original array in-place, removing elements for which fn returns false.",Return the original array without modification.,"Return a new array containing elements for which fn returns false, in reverse order.","Iterate through the array, applying the filtering function fn to each element. If fn returns a truthy value, add the element to a new array and return that array.",Easy,algorithms,"['array', 'filtering', 'function']"
2635,"Apply Transform Over Each Element in Array
Given an integer array arr and a mapping function fn, return a new array with a transformation applied to each element. The returned array should be created such that returnedArray[i] = fn(arr[i], i). Please solve it without the built-in Array.map method.","Modify the original array in place, potentially leading to unexpected side effects.",Create a new array of the same size and populate it with the transformed values.,Use recursion to process each element and accumulate the results in a global array.,"Return the original array without modification, as transformation is not always necessary.","Iterate through the input array using a for loop, applying the function to each element at its index, and store the result in a new array.",Easy,algorithms,"['array', 'transformation', 'iteration']"
2637,"Promise Time Limit
Given an asynchronous function fn and a time t in milliseconds, return a new time limited version of the input function. fn takes arguments provided to the time limited function. The time limited function should follow these rules:","Use `Promise.race` with `fn()` and a delayed rejection promise, returning the result or rejecting with a timeout error.",Implement a while loop that checks if `fn()` completes within time `t` using `setTimeout` and returns a resolved promise if it does.,Employ `setInterval` to continuously monitor the state of `fn()` and return a resolved promise when it completes or a rejected promise after `t`.,"Use `Promise.all` with `fn()` and a delayed resolution promise, returning the first resolved value or timing out after `t`.",Wrap `fn()` in a `Promise` and use `Promise.race` with a timeout promise. Reject with 'Time Limit Exceeded' if the timeout expires first.,Medium,algorithms,"['promise', 'asynchronous', 'timeout']"
2639,"Find the Width of Columns of a Grid
You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers. Return an integer array ans of size n where ans[i] is the width of the ith column. The length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.",Calculate the length using `len(str(abs(x)))` for each element 'x' and take the maximum.,Calculate the length using `floor(log10(abs(x)) + 1)` and then add 1 if x < 0. Take the maximum.,"Convert all integers to positive, calculate lengths, and add 1 to all columns containing a negative number.",Use string formatting to align all integers and then measure the width of the formatted strings.,Calculate the length using `len(str(x))` for each element 'x' and take the maximum for each column.,Easy,algorithms,"Array,Matrix"
2640,"Find the Score of All Prefixes of an Array
We define the conversion array conver of an array arr as follows: We also define the score of an array arr as the sum of the values of the conversion array of arr. Given a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].",Calculate the running sum and the running maximum independently and then sum them at each index.,"Compute the prefix sum array and prefix maximum array separately, then multiply the prefix maximum by 2 and subtract the prefix sum.","Use dynamic programming, storing the prefix sums and maximums in a 2D array, and calculate the score iteratively.",Recursively calculate the prefix sum and prefix maximum and sum them at each step. Ensure base cases are handled.,"Iterate through the array, maintaining a running sum and a running maximum. At each step, add the running maximum to the running sum.",Medium,algorithms,"Array,Prefix Sum"
2641,"Cousins in Binary Tree II
Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values. Two nodes of a binary tree are cousins if they have the same depth with different parents. Return the root of the modified tree. Note that the depth of a node is the number of edges in the path from the root node to it.",Store the tree in an array and iterate through it calculating sums based on index positions representing levels,"Perform a level-order traversal, and for each node, iterate through the entire tree again to find and sum the cousins",Use a recursive function that calculates the sum of all nodes at each level and subtracts the parent's values.,"Replace each node's value with the sum of all values in the tree, excluding the node's own value and the values of its children.","Perform a level-order traversal. For each level, calculate the sum of all node values at that level, then update each node's value to be the level sum minus its parent's children's values.",Medium,algorithms,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree"
2642,"Design Graph With Shortest Path Calculator
There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti. Implement the Graph class:",Use Dijkstra's algorithm with a priority queue implemented as a max heap.,Employ a breadth-first search (BFS) algorithm to find the shortest path.,Apply depth-first search (DFS) recursively to explore all possible paths.,Store the graph as an adjacency matrix and use matrix exponentiation.,Utilize Dijkstra's algorithm with a priority queue implemented as a min heap.,Hard,algorithms,"Graph,Design,Heap (Priority Queue),Shortest Path"
2643,"Row With Maximum Ones
Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row. In case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected. Return an array containing the index of the row, and the number of ones in it.",Return the index of the last row with maximum ones.,Return the row with the minimum number of zeros if multiple rows have the maximum ones.,"Return [-1, 0] if the matrix is empty.","Return the index of the row with the maximum number of elements, regardless of their value.","Return the row index with the maximum number of ones, and the number of ones in that row. If multiple rows have the same maximum, return the smallest row index.",Easy,algorithms,"Array,Matrix"
2644,"Find the Maximum Divisibility Score
You are given two integer arrays nums and divisors. The divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i]. Return the integer divisors[i] with the maximum divisibility score. If multiple integers have the maximum score, return the smallest one.","Iterate through `divisors`, count divisibility for each, and return the first divisor with the maximum count","Sort `nums` and `divisors`, then use binary search to efficiently count divisible elements",Use a hash map to store divisibility counts and return the divisor with the highest count based on the map,Compute the prime factorization of each number in `nums` and `divisors` and compare the factorizations,"Iterate through `divisors`, count the number of elements in `nums` divisible by each, and return the smallest divisor with the maximum count",Easy,algorithms,Array
2645,"Minimum Additions to Make Valid String
Given a string word to which you can insert letters ""a"", ""b"" or ""c"" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid. A string is called valid if it can be formed by concatenating the string ""abc"" several times.",Count the occurrences of each character and return the maximum count minus the minimum count.,Return the length of the string modulo 3.,Return the difference between the number of 'a's and 'c's in the string.,"Return the length of the string divided by 3, rounded up to the nearest integer.","Iterate through the string, tracking the expected character ('a', 'b', 'c'), and increment a counter for each missing character.",Medium,algorithms,"String,Dynamic Programming,Stack,Greedy"
2646,"Minimize the Total Price of the Trips
There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Each node has an associated price. You are given an integer array price, where price[i] is the price of the ith node. The price sum of a given path is the sum of the prices of all nodes lying on that path. Additionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like. Before performing your first trip, you can choose some non-adjacent nodes and halve the prices. Return the minimum total price sum to perform all the given trips.",Use a greedy algorithm to halve the prices of the nodes with the highest degree,Apply Dijkstra's algorithm to find the shortest paths for each trip and halve the prices along those paths,"Use a brute-force approach, trying all possible combinations of non-adjacent nodes to halve and finding the minimum cost",Halve the price of every other node to minimize path costs.,"Use dynamic programming on the tree, considering for each node whether its price is halved or not, to minimize the total cost of all trips, using the LCA of trip endpoints.",Hard,algorithms,"Array,Dynamic Programming,Tree,Depth-First Search,Graph"
2648,"Generate Fibonacci Sequence
Write a generator function that returns a generator object which yields the fibonacci sequence. The fibonacci sequence is defined by the relation Xn = Xn-1 + Xn-2. The first few numbers of the series are 0, 1, 1, 2, 3, 5, 8, 13.","Use memoization to store previously calculated values in a global array, improving performance for larger sequences","Employ dynamic programming by building a table bottom-up to avoid redundant calculations, optimizing space complexity","Utilize tail recursion, where the recursive call is the last operation, allowing the compiler to optimize stack usage",Employ a while loop that returns the entire sequence at once when the end condition is met,Maintain two variables to represent the previous two Fibonacci numbers and yield the next number in each iteration within the generator function,Easy,algorithms,"['generator', 'fibonacci', 'sequence']"
2649,"Nested Array Generator
Given a multi-dimensional array of integers, return a generator object which yields integers in the same order as inorder traversal. A multi-dimensional array is a recursive data structure that contains both integers and other multi-dimensional arrays. inorder traversal iterates over each array from left to right, yielding any integers it encounters or applying inorder traversal to any arrays it encounters.",Use a depth-first search algorithm with a stack to keep track of array indices.,Flatten the array into a one-dimensional list and then iterate over it.,Convert the nested array into a string representation and then parse integers from it.,Use a breadth-first search algorithm with a queue to keep track of array indices.,Implement a recursive generator function that yields integers and recursively calls itself for nested arrays.,Medium,algorithms,"['generator', 'recursion', 'array']"
2650,"Design Cancellable Function
Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function cancellable that accepts a generator object and returns an array of two values: a cancel function and a promise. You may assume the generator function will only yield promises. It is your function's responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that error back to the generator. If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string ""Cancelled"" (Not an Error object). If the error was caught, the returned promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed. When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error. An example of how your code would be used: If instead cancel() was not called or was called after t=100ms, the promise would have resolved 5.",The cancel function throws a generic error.,The returned promise resolves with the initial value of the generator.,The generator continues to execute even after cancellation.,The promise rejects immediately without executing the generator.,"The cancel function throws 'Cancelled' into the generator, and the promise resolves with the next yielded or returned value if the error is caught, or rejects with the error if not.",Hard,algorithms,"['generators', 'promises', 'cancellation']"
2651,"Calculate Delayed Arrival Time
You are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours. Return the time when the train will arrive at the station. Note that the time in this problem is in 24-hours format.",Return arrivalTime + delayedTime,Return (arrivalTime - delayedTime) % 24,Return abs(arrivalTime - delayedTime) % 24,Return arrivalTime * delayedTime % 24,Return (arrivalTime + delayedTime) % 24,Easy,algorithms,Math
2652,"Sum Multiples
Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7. Return an integer denoting the sum of all numbers in the given range satisfying the constraint.",Use dynamic programming to store multiples in a table and retrieve the sum.,"Iterate from 1 to n, and for each number, check divisibility using the modulo operator (%) only for 3 and 5, then extrapolate for 7.","Calculate the sum of multiples of 3, 5, and 7 separately using formulas for arithmetic series, then add them together directly.","Create a set of all numbers divisible by 3, 5, or 7, and then sum the elements of the set using the sum() function.","Iterate from 1 to n, and for each number, check if it's divisible by 3, 5, or 7 using the modulo operator (%). If it is, add it to a running sum.",Easy,algorithms,Math
2653,"Sliding Subarray Beauty
Given an integer array nums containing n integers, find the beauty of each subarray of size k. The beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers. Return an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array. A subarray is a contiguous non-empty sequence of elements within an array.",Using a naive bubble sort on each subarray to find the xth smallest negative number.,Maintaining a min-heap of size x containing all negative numbers encountered.,Sorting each subarray and then directly accessing the xth element if it's negative.,Calculating the average of the negative numbers in each subarray.,Using a sliding window and an ordered set/multiset to efficiently track the x smallest negative numbers.,Medium,algorithms,"Array,Hash Table,Sliding Window"
2654,"Minimum Number of Operations to Make All Array Elements Equal to 1
You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times: Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1. The gcd of two integers is the greatest common divisor of the two integers.",Find the smallest element and replace all other elements with it until all elements are 1,"Count the number of 1s. If there's at least one 1, return n - count, otherwise return -1","Calculate the product of all elements. If the product is 1, return 0, otherwise return -1",Sort the array and repeatedly replace the largest element with the smallest until all are 1,"Find the minimum operations needed to make the GCD of the entire array equal to 1. If a 1 exists, return n-count(1). Otherwise, find the shortest subarray with GCD 1.",Medium,algorithms,"Array,Math,Number Theory"
2656,"Maximum Sum With Exactly K Elements
You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score: Return the maximum score you can achieve after performing the operation exactly k times.",Divide the largest element by k and multiply the result by k to get the maximum sum.,Sort the array and multiply the kth largest element by k.,Multiply the sum of all elements in the array by k.,Find the smallest element and multiply it by k.,"Find the largest element, add it to the score, increment it by one, and repeat k times.",Easy,algorithms,"Array,Greedy"
2657,"Find the Prefix Common Array of Two Arrays
You are given two 0-indexed integer permutations A and B of length n. A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B. Return the prefix common array of A and B. A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.","Iterate through both arrays, and for each index i, iterate from 0 to i in both arrays to count common elements.","Create a set from the elements of array A up to index i and another set from the elements of array B up to index i, then return the size of their intersection.",Calculate the cumulative sum of each array independently and find the common difference between them at each index.,Sort both arrays and use binary search to find common elements up to each index i.,"Maintain a set of elements seen in array A. Iterate through array B; if an element is in the set, increment the count. Store the count at each index i in the result array.",Medium,algorithms,"Array,Hash Table,Bit Manipulation"
2658,"Maximum Number of Fish in a Grid
You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents: A fisher can start at any water cell (r, c) and can do the following operations any number of times: Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists. An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.",Use Dijkstra's algorithm to find the longest path from each water cell.,"Apply a greedy algorithm, always moving to the adjacent cell with the most fish.",Sort the entire grid and sum the values in descending order.,Randomly select water cells and sum the fish in their connected components; return the maximum found.,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore connected components of water cells and sum the fish in each, then return the maximum sum.",Medium,algorithms,"Array,Depth-First Search,Breadth-First Search,Union Find,Matrix"
2659,"Make Array Empty
You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty: Return an integer denoting the number of operations it takes to make nums empty.",O(n log n) due to sorting the array indices,O(n^2) because of nested loops for finding the minimum element,O(1) since the number of operations is constant regardless of input size,O(n!) as each permutation needs to be considered,O(n log n) due to using a binary indexed tree or segment tree,Hard,algorithms,"Array,Binary Search,Greedy,Binary Indexed Tree,Segment Tree,Sorting,Ordered Set"
2660,"Determine the Winner of a Bowling Game
You are given two 0-indexed integer arrays player1 and player2, representing the number of pins that player 1 and player 2 hit in a bowling game, respectively. The bowling game consists of n turns, and the number of pins in each turn is exactly 10. Assume a player hits xi pins in the ith turn. The value of the ith turn for the player is: The score of the player is the sum of the values of their n turns. Return","Use dynamic programming to determine the optimal strategy for each player, maximizing their score based on future turns.",Simulate each turn using a Monte Carlo method to estimate the average score for each player.,"Employ a greedy algorithm, where each player aims to knock down as many pins as possible in each turn without considering bonus turns.",Apply a machine learning model trained on historical bowling data to predict the outcome of the game.,"Iterate through both arrays, applying the bonus rule when applicable, and summing the scores for each player to determine the winner.",Easy,algorithms,"Array,Simulation"
2661,"First Completely Painted Row or Column
You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n]. Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i]. Return the smallest index i at which either a row or a column will be completely painted in mat.",The largest element in arr,The sum of m and n,m * n,The length of arr,The earliest index in arr that causes either a full row or column to be painted in mat,Medium,algorithms,"Array,Hash Table,Matrix"
2662,"Minimum Cost of a Path With Special Roads
You are given an array start where start = [startX, startY] represents your initial position (startX, startY) in a 2D space. You are also given the array target where target = [targetX, targetY] represents your target position (targetX, targetY). The cost of going from a position (x1, y1) to any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|. There are also some special roads. You are given a 2D array specialRoads where specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith special road goes in one direction from (x1i, y1i) to (x2i, y2i) with a cost equal to costi. You can use each special road any number of times. Return the minimum cost required to go from (startX, startY) to (targetX, targetY).","Use Depth-First Search (DFS) to explore all possible paths, pruning branches when the current cost exceeds the best-known cost.","Employ a greedy algorithm that always chooses the special road with the lowest cost, regardless of the overall path.",Calculate the Euclidean distance between all points and use that as the edge weight for a graph search.,Apply dynamic programming by calculating minimum costs from the target to all other reachable points.,"Use Dijkstra's algorithm, treating locations as nodes and both Manhattan distances and special roads as edges.",Medium,algorithms,"Array,Graph,Heap (Priority Queue),Shortest Path"
2663,"Lexicographically Smallest Beautiful String
A string is beautiful if: You are given a beautiful string s of length n and a positive integer k. Return the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string. A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.",Start from the beginning of the string and increment characters until a beautiful string is found.,Generate all possible beautiful strings of length n and return the smallest one larger than s.,Sort the input string s lexicographically and check if it is beautiful.,Recursively explore all possible combinations of characters to find a beautiful string.,"Iterate from the end of the string, incrementing characters while maintaining beauty constraints, stopping at the first valid solution.",Hard,algorithms,"String,Greedy"
2665,"Counter II
Write a function createCounter. It should accept an initial integer init. It should return an object with three functions. The three functions are:","Returns the current value, decrements, and returns the previous value.","Returns the current value, then sets the counter to the initial value","Resets the counter to zero, then increments and returns the initial value plus one","Always returns the initial value, regardless of increment or decrement calls.","Returns an object with increment, decrement, and reset functions.",Easy,algorithms,"['closures', 'javascript', 'functional programming']"
2666,"Allow One Function Call
Given a function fn, return a new function that is identical to the original function except that it ensures fn is called at most once.",Return the original function without modification.,"Set a flag after the first call to prevent future calls, but the flag isn't thread-safe.",Wrap the function call in a try-except block to catch errors from multiple calls.,"Use a mutex lock that is never released, effectively blocking subsequent calls after the first.","Use a closure and a flag to track if the function has been called, returning undefined or a default value on subsequent calls.",Easy,algorithms,"['closures', 'higher-order functions', 'side effects']"
2670,"Find the Distinct Difference Array
You are given a 0-indexed array nums of length n. The distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i]. Return the distinct difference array of nums. Note that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.","Use nested loops to compare each element with every other element for distinctness, resulting in O(n^2) time complexity.","Employ a sliding window approach, expanding the prefix and shrinking the suffix in each iteration to calculate distinct counts.",Precompute the distinct counts for all possible subarrays and then retrieve the prefix and suffix counts for each index.,Sort the input array before calculating the distinct difference array to improve efficiency.,"Use sets to efficiently track distinct elements in the prefix and suffix as you iterate through the array, achieving O(n) time complexity.",Easy,algorithms,"Array,Hash Table"
2671,"Frequency Tracker
Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies. Implement the FrequencyTracker class.","Use a hash table to store elements and their frequencies, updating frequencies after each operation","Maintain two separate sets: one for elements and one for frequencies, syncing them after each operation",Store elements in a sorted array and perform binary search to find frequencies,"Use a self-balancing tree to store elements and frequencies, updating them dynamically","Employ two hash maps: one to track element frequencies and another to track the frequency counts themselves, ensuring O(1) time complexity for all operations",Medium,data structures,"Hash Table,Design"
2672,"Number of Adjacent Elements With the Same Color
You are given an integer n representing an array colors of length n where all elements are set to 0's meaning uncolored. You are also given a 2D integer array queries where queries[i] = [indexi, colori]. For the ith query: Return an array answer of the same length as queries where answer[i] is the answer to the ith query.",Incrementally update a difference array representing color changes and query its values,Maintain a count of adjacent same-color elements and update it only for the directly affected indices after each query,Recompute the entire adjacent same-color count after each query by iterating through the entire array,Use a hash map to store color frequencies and update the count based on hash map contents after each query,"Simulate the coloring process directly, checking and updating the adjacent element counts only for the indexed element and its neighbors",Medium,algorithms,Array
2673,"Make Costs of Paths Equal in a Binary Tree
You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1. Each node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times. Return the minimum number of increments you need to make the cost of paths from the root to each leaf node equal. Note:","Perform a post-order traversal, incrementing each node's cost to match the maximum cost of its children, then summing the increments.","Calculate the average cost of all paths from the root to the leaves and increment each path to match this average, summing the increments.","Use dynamic programming to store the minimum cost to reach each node, then backtrack from the leaves to the root to determine the optimal increments.","Increment all costs to the maximum value found in the `cost` array, then multiply by the number of leaves.","Employ a depth-first search, tracking the maximum path cost encountered so far, and incrementing node costs to equalize path sums at each leaf.",Medium,algorithms,"Array,Dynamic Programming,Greedy,Tree,Binary Tree"
2677,"Chunk Array
Given an array arr and a chunk size size, return a chunked array. A chunked array contains the original elements in arr, but consists of subarrays each of length size. The length of the last subarray may be less than size if arr.length is not evenly divisible by size. Please solve it without using lodash's _.chunk function.",Create a new array and push 'size' elements at a time using Array.splice(),"Use Array.reduce() with an accumulator array, pushing subarrays when the accumulator reaches 'size'","Iterate using a for loop with a step of 'size', using Array.slice() to extract each chunk","Utilize recursion, splitting the array into smaller chunks until the base case of array length less than 'size' is reached","Iterate through the input array, creating subarrays of length 'size' and pushing them into a result array",Easy,algorithms,"['array', 'chunking', 'iteration']"
2678,"Number of Senior Citizens
You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that: Return the number of passengers who are strictly more than 60 years old.",Count passengers whose age string (substring from index 11) converts to an integer less than 60.,Sort the details array lexicographically and count elements appearing after the first passenger whose age is greater than 60.,Compute the average age across all passengers and return the count of passengers whose age exceeds this average.,Count passengers where the ASCII value of the age string (substring from index 11) is strictly greater than the ASCII value of '60'.,Count passengers whose age string (substring from index 11) converts to an integer greater than 60.,Easy,algorithms,"Array,String"
2679,"Sum in a Matrix
You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty: Return the final score.","Create a frequency map of all numbers, then iterate from smallest to largest, summing values at each frequency","Sort each row independently, then sum the maximum of each row in order",Calculate the sum of all elements and divide by the number of rows,"Find the median of each row, then sum the medians","Sort each row independently, then iteratively select the maximum value across all rows and sum them.",Medium,algorithms,"Array,Sorting,Heap (Priority Queue),Matrix,Simulation"
2680,"Maximum OR
You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2. Return the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times. Note that a | b denotes the bitwise or between two integers a and b.",Apply the operation to the smallest element in `nums` for all `k` operations.,Calculate the initial OR value and add 2^k to it directly.,Sort `nums` in descending order and apply the operation to the first `k` elements.,Apply the operation to a random element in `nums` for each of the `k` operations.,Apply all `k` operations to `nums[0]` and then calculate the bitwise OR of all elements.,Medium,algorithms,"Array,Greedy,Bit Manipulation,Prefix Sum"
2681,"Power of Heroes
You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows: Return the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.",Calculate the power of each individual hero and sum them up.,Sort the array and consider only groups formed by contiguous elements.,Calculate the product of all hero strengths and take the modulo.,"Use dynamic programming to store the powers of smaller groups and build up to larger groups, but only include powers of 2.","Sort the array, then for each hero, multiply its strength squared by 2^(index) and sum up the results, taking modulo 10^9 + 7.",Hard,algorithms,"Array,Math,Dynamic Programming,Sorting,Prefix Sum"
2682,"Find the Losers of the Circular Game
There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend. The rules of the game are as follows: 1st friend receives the ball. In other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction. The game is finished when some friend receives the ball for the second time. The losers of the game are friends who did not receive the ball in the entire game. Given the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.","Use a boolean array to mark friends who received the ball. After the game, iterate through the array to identify losers.","Simulate the game for a fixed number of rounds (e.g., 2 * n) and then identify losers from the friends who never received the ball.",Keep track of the number of times each friend receives the ball using a dictionary. Losers are those with a count of zero.,Pre-calculate all the positions a friend can be in and check if those positions fall into the number of friends.,"Simulate the game step-by-step, marking friends who receive the ball. The losers are those not marked after the game ends.",Easy,algorithms,"Array,Hash Table,Simulation"
2683,"Neighboring Bitwise XOR
A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n. Specifically, for each index i in the range [0, n - 1]: Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived. Return true if such an array exists or false otherwise.",The sum of elements in derived must be even.,The length of derived must be a power of 2.,All elements in derived must be the same.,The number of 1s in derived must be even.,The XOR sum of all elements in derived must be 0.,Medium,algorithms,"Array,Bit Manipulation"
2684,"Maximum Number of Moves in a Grid
You are given a 0-indexed m x n matrix grid consisting of positive integers. You can start at any cell in the first column of the matrix, and traverse the grid in the following way: Return the maximum number of moves that you can perform.",Use Dijkstra's algorithm to find the longest path from any starting cell in the first column.,Apply a greedy approach by always moving to the largest adjacent cell in the next column.,Implement a breadth-first search (BFS) starting from the last column and working backwards.,Calculate the sum of all elements in the grid and divide by the minimum element.,Use dynamic programming to store the maximum number of moves possible from each cell.,Medium,algorithms,"Array,Dynamic Programming,Matrix"
2685,"Count the Number of Complete Components
You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi. Return the number of complete connected components of the graph. A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph. A connected component is said to be complete if there exists an edge between every pair of its vertices.","Use Depth-First Search (DFS) to find connected components, then check if the number of edges in each component equals the number of vertices.","Use Breadth-First Search (BFS) to find connected components, then for each component, iterate through all possible pairs of vertices and verify the existence of an edge.","Represent the graph as an adjacency matrix, use DFS to find connected components, and verify completeness by checking all pairs in the submatrix for each component.","Employ Kruskal's algorithm to find the minimum spanning tree, and count the number of resulting trees that are complete graphs.","Use Depth-First Search (DFS) or Breadth-First Search (BFS) to identify connected components. For each component, verify if it's a complete graph by checking if the number of edges equals n*(n-1)/2, where n is the number of vertices in the component.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Union Find,Graph"
2693,"Call Function with Custom Context
Enhance all functions to have the callPolyfill method. The method accepts an object obj as its first parameter and any number of additional arguments. The obj becomes the this context for the function. The additional arguments are passed to the function (that the callPolyfill method belongs on). For example if you had the function: Calling this function like tax(10, 0.1) will log ""The cost of undefined is 11"". This is because the this context was not defined. However, calling the function like tax.callPolyfill({item: ""salad""}, 10, 0.1) will log ""The cost of salad is 11"". The this context was appropriately set, and the function logged an appropriate output. Please solve this without using the built-in Function.call method.","It overwrites the original function's prototype, causing unintended side effects for other functions using the same prototype.","It creates a closure that captures the arguments at the time of definition, leading to incorrect argument binding during the actual function call.","It uses the 'apply' method internally, which is explicitly forbidden by the prompt.","It fails to handle edge cases such as null or undefined 'this' contexts, resulting in runtime errors.",It correctly reassigns the 'this' context and passes arguments to the original function using the 'apply' method equivalent without directly using it.,Medium,algorithms,"['this binding', 'function context', 'apply']"
2694,"Event Emitter
Design an EventEmitter class. This interface is similar (but with some differences) to the one found in Node.js or the Event Target interface of the DOM. The EventEmitter should allow for subscribing to events and emitting them. Your EventEmitter class should have the following two methods:","Events are triggered synchronously, handlers are called in LIFO order",The EventEmitter can only store a maximum of 10 event listeners per event,Only string-based events are supported; numerical or object-based events will be ignored,The `emit` function returns the number of listeners that were triggered,"Events are triggered synchronously, handlers are called in FIFO order",Medium,system design,"['event emitter', 'asynchronous', 'design pattern']"
2695,"Array Wrapper
Create a class ArrayWrapper that accepts an array of integers in its constructor. This class should have two features:",Return the original array without modification.,Return the sum of the first and last elements of the array.,Return the array's length.,Return a string representation of the array's memory address.,Overload the addition operator to perform element-wise addition of two ArrayWrapper objects.,Easy,data structures,"['operator overloading', 'array', 'class']"
2696,"Minimum String Length After Removing Substrings
You are given a string s consisting only of uppercase English letters. You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings ""AB"" or ""CD"" from s. Return the minimum possible length of the resulting string that you can obtain. Note that the string concatenates after removing the substring and could produce new ""AB"" or ""CD"" substrings.","Recursively remove 'AB' and 'CD' until no more occurrences are found, then return the length.",Count the occurrences of 'AB' and 'CD' and subtract twice the minimum of those counts from the original length.,Replace all occurrences of 'AB' and 'CD' with empty strings simultaneously and return the length.,Sort the string alphabetically and then remove all occurrences of 'AB' and 'CD' iteratively.,Use a stack to simulate the string and remove 'AB' or 'CD' when encountered.,Easy,algorithms,"String,Stack,Simulation"
2697,"Lexicographically Smallest Palindrome
You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter. Your task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. Return the resulting palindrome string.","Modify characters from right to left only, prioritizing changes on the right side.",Always replace characters with 'a' when a mismatch is found.,Only consider characters in the first half of the string for modification.,"If characters don't match, replace both with the larger ASCII value character.","Iterate from both ends, replacing the larger character with the smaller one to minimize lexicographical order.",Easy,algorithms,"Two Pointers,String,Greedy"
2698,"Find the Punishment Number of an Integer
Given a positive integer n, return the punishment number of n. The punishment number of n is defined as the sum of the squares of all integers i such that:",Calculate the sum of squares of all numbers from 1 to n and return the result,"For each number i from 1 to n, square it, convert it to a string, and if it can be partitioned into numbers that sum to i, add the square to the result. Return the result.","Return n * n, as that will be the punishment number","Find all the prime numbers between 1 and n, square them and return the sum.","Iterate from 1 to n, square each number. If the square can be partitioned into numbers which sum to the original number, add the square to a running total. Return the total.",Medium,algorithms,"Math,Backtracking"
2699,"Modify Graph Edge Weights
You are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi. Some edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0). Your task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct. Return an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible. Note: You are not allowed to modify the weights of edges with initial positive weights.","Dijkstra's algorithm with a fixed weight assignment to -1 edges, repeated until the target is met or proven impossible.","Floyd-Warshall algorithm to calculate all-pairs shortest paths, adjusting -1 edge weights based on global shortest path results.","Bellman-Ford algorithm, iteratively relaxing edges to find the shortest path and modifying -1 edges to achieve the target.","A* search algorithm, prioritizing paths based on estimated distance to the target and dynamically adjusting -1 edge weights.","Binary search over the possible weights for -1 edges, using Dijkstra's to check if the target shortest path is achievable.",Hard,algorithms,"Graph,Heap (Priority Queue),Shortest Path"
2704,"To Be Or Not To Be
Write a function expect that helps developers test their code. It should take in any value val and return an object with the following two functions.",Implement a bloom filter with a low false positive rate,"Return true if the value is truthy in Javascript (e.g., not 0, '', null, undefined, NaN)",Use JSON.stringify to compare the input value with expected value.,Deeply compare the value with a global registry of expected values,Return an object with two methods: 'toBe' which checks strict equality and 'notToBe' which checks strict inequality,Easy,algorithms,"['javascript', 'testing', 'equality']"
2705,"Compact Object
Given an object or array obj, return a compact object. A compact object is the same as the original object, except with keys containing falsy values removed. This operation applies to the object and any nested objects. Arrays are considered objects where the indices are keys. A value is considered falsy when Boolean(value) returns false. You may assume the obj is the output of JSON.parse. In other words, it is valid JSON.",Use a regular expression to replace all falsy values with `null` and then stringify and parse the object again.,"Convert the object to a string, manually iterate through the string, removing the falsy values and creating new objects and arrays.",Use the `JSON.stringify` method with a replacer function that checks for falsy values and omits them during serialization.,"Iterate through the object's keys using `Object.keys`, and for each key, directly set the key's value to `undefined` if it's falsy. Then, use `JSON.parse(JSON.stringify(obj))` to remove the undefined keys.","Recursively iterate through the object's properties; if a value is falsy, delete the key. If a value is an object or array, recursively compact it.",Medium,algorithms,"['recursion', 'object manipulation', 'javascript']"
2706,"Buy Two Chocolates
You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money. You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy. Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.",Sort the prices array in descending order and subtract the two largest values from money.,"Calculate the sum of all prices and subtract it from money; if the result is negative, return money.",Find the two smallest prices using a nested loop and subtract their sum from money.,"Select two random prices, subtract their sum from money, and repeat until a non-negative result is found or all combinations are exhausted.","Sort the prices array in ascending order, select the first two prices, subtract their sum from money, and return the result (or money if the sum exceeds money).",Easy,algorithms,"Array,Greedy,Sorting"
2707,"Extra Characters in a String
You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings. Return the minimum number of extra characters left over if you break up s optimally.",Use a greedy approach by selecting the longest matching word at each step.,"Iterate through all possible substring combinations and choose the one with the fewest extra characters, without memoization.","Recursively check each possible substring, keeping track of the minimum extra characters encountered so far, without memoization.",Sort the dictionary alphabetically and then try to match the sorted words.,Use dynamic programming to store the minimum extra characters for each prefix of the string.,Medium,algorithms,"Array,Hash Table,String,Dynamic Programming,Trie"
2708,"Maximum Strength of a Group
You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik​]. Return the maximum strength of a group the teacher can create.",Return the product of all positive numbers in the array.,"Return the largest number in the array if it's positive, otherwise return 0.","Return the product of all negative numbers, unless there are an odd number of them, in which case return 0.",Return the product of the two largest numbers in the array.,"Return the product of all non-zero numbers, handling the case of all negative numbers carefully.",Medium,algorithms,"Array,Dynamic Programming,Backtracking,Greedy,Bit Manipulation,Sorting,Enumeration"
2709,"Greatest Common Divisor Traversal
You are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor. Your task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j. Return true if it is possible to traverse between all such pairs of indices, or false otherwise.",Always returning 'true' regardless of the input array.,Checking if the array is sorted and contains prime numbers.,Using Depth-First Search (DFS) to check connectivity based on coprime relationships.,"Checking only if gcd(nums[0], nums[n-1]) > 1.",Using Disjoint Set Union (DSU) to find connected components based on shared prime factors.,Hard,algorithms,"Array,Math,Union Find,Number Theory"
2710,"Remove Trailing Zeros From a String
Given a positive integer num represented as a string, return the integer num without trailing zeros as a string.",Regular expression substitution with '^0+',Iterating from the start and removing initial zeros,Converting to an integer and back to a string,String slicing with rstrip('0'),"Iterate from the end, find the last non-zero index, and slice the string",Easy,algorithms,String
2711,"Difference of Number of Distinct Values on Diagonals
Given a 2D grid of size m x n, you should find the matrix answer of size m x n. The cell answer[r][c] is calculated by looking at the diagonal values of the cell grid[r][c]: A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.  Return the matrix answer.",Calculate the absolute difference between the sum of all elements above the current cell's diagonals and the sum of all elements below,Find the number of common elements between the upper and lower diagonals,Calculate the sum of all distinct elements on both diagonals originating from the current cell,Determine the product of the lengths of the distinct value sets on the upper and lower diagonals,Calculate the absolute difference between the number of distinct values on the upper-left to bottom-right and upper-right to bottom-left diagonals for each cell,Medium,algorithms,"Array,Hash Table,Matrix"
2712,"Minimum Cost to Make All Characters Equal
You are given a 0-indexed binary string s of length n on which you can apply two types of operations: Return the minimum cost to make all characters of the string equal. Invert a character means if its value is '0' it becomes '1' and vice-versa.","Recursively divide the string and conquer each half, accumulating inversion costs.",Use dynamic programming to track the minimum cost to make the prefix equal to '0' or '1'.,Greedily invert characters from left to right to match the most frequent character.,Calculate the number of '0's and '1's and invert the less frequent character.,"Iterate through the string, considering inverting prefixes to either '0' or '1', and minimizing the cost.",Medium,algorithms,"String,Dynamic Programming,Greedy"
2713,"Maximum Strictly Increasing Cells in a Matrix
Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell. From the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves. Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell. Return an integer denoting the maximum number of cells that can be visited.","Use dynamic programming with memoization based on the matrix indices (row, col)","Sort all the matrix cells by their values and then apply a greedy approach, always picking the largest available cell","Perform a depth-first search (DFS) starting from each cell, tracking the path length and updating the maximum path found","Apply Dijkstra's algorithm treating each cell as a node and valid moves as edges, calculating the longest path from each starting cell",Utilize dynamic programming with row and column-wise maximum tracking to efficiently determine the maximum increasing path length from each cell,Hard,algorithms,"Array,Hash Table,Binary Search,Dynamic Programming,Memoization,Sorting,Matrix,Ordered Set"
2715,"Timeout Cancellation
Given a function fn, an array of arguments args, and a timeout t in milliseconds, return a cancel function cancelFn. After a delay of cancelTimeMs, the returned cancel function cancelFn will be invoked. Initially, the execution of the function fn should be delayed by t milliseconds. If, before the delay of t milliseconds, the function cancelFn is invoked, it should cancel the delayed execution of fn. Otherwise, if cancelFn is not invoked within the specified delay t, fn should be executed with the provided args as arguments.",The promise will resolve immediately without waiting for the timeout.,"The setTimeout function will not execute, and the promise will never resolve or reject.",The promise will reject with a 'TimeoutError' even if clearTimeout is called.,The clearTimeout function will throw an error if called with an invalid timeout ID.,"The setTimeout function will be cleared, preventing fn from being executed, and the promise will neither resolve nor reject if cancelFn is called before the timeout.",Easy,algorithms,"['promises', 'setTimeout', 'clearTimeout']"
2716,"Minimize String Length
Given a string s, you have two types of operation: Your task is to minimize the length of s by performing the above operations zero or more times. Return an integer denoting the length of the minimized string.",Use a hash table to store character counts and remove characters that appear more than once.,Sort the string and remove adjacent duplicates.,Recursively divide the string and merge the unique characters.,Replace repeating characters with a single instance of the character.,Count occurrences of each character and keep only one instance of each present character.,Easy,algorithms,"Hash Table,String"
2717,"Semi-Ordered Permutation
You are given a 0-indexed permutation of n integers nums. A permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation: Return the minimum number of operations to make nums a semi-ordered permutation. A permutation is a sequence of integers from 1 to n of length n containing each number exactly once.",Compute prefix and suffix sums and select the minimum,Sort the array and calculate the distance between 1 and n,Brute-force all possible swap combinations,"Find the indices of 1 and n, then sum those indices","Find the indices of 1 and n, then return the sum of their distances from the beginning and end, subtracting 1 if they are inverted",Easy,algorithms,"Array,Simulation"
2718,"Sum of Matrix After Queries
You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typei, indexi, vali]. Initially, there is a 0-indexed n x n matrix filled with 0's. For each query, you must apply one of the following changes: Return the sum of integers in the matrix after all queries are applied.","Process queries in order, updating the entire row or column with the value, resulting in O(q*n) time complexity.",Ignore duplicate queries on the same row/column and calculate the matrix sum based only on the last query for each row/column.,"Use a boolean matrix to keep track of which cells have been updated, and update only those cells, avoiding redundant operations.",Maintain a cumulative sum matrix to efficiently calculate the sum of the submatrix affected by each query.,"Use sets to track updated rows and columns, and calculate the sum by iterating through rows and columns only once.",Medium,algorithms,"Array,Hash Table"
2719,"Count of Integers
You are given two numeric strings num1 and num2 and two integers max_sum and min_sum. We denote an integer x to be good if: Return the number of good integers. Since the answer may be large, return it modulo 109 + 7. Note that digit_sum(x) denotes the sum of the digits of x.","Calculate the sum of all possible digit combinations between num1 and num2, then filter based on max_sum and min_sum","Recursively explore all possible numbers between num1 and num2, pruning branches when the digit sum falls outside the [min_sum, max_sum] range","Precompute a table of digit sums for all numbers within the range [num1, num2] and count those within the given sum bounds","Treat num1 and num2 as large integers, calculate the range size, and estimate the number of good integers based on probability distributions","Use dynamic programming to calculate the number of integers with digit sums within the range [min_sum, max_sum] between num1 and num2, modulo 10^9 + 7",Hard,algorithms,"Math,String,Dynamic Programming"
2721,"Execute Asynchronous Functions in Parallel
Given an array of asynchronous functions functions, return a new promise promise. Each function in the array accepts no arguments and returns a promise. All the promises should be executed in parallel. promise resolves: promise rejects: Please solve it without using the built-in Promise.all function.","Return a promise that resolves with an array of the results from each function, preserving order.",Return a promise that resolves only after the first function in the array resolves.,Return a promise that resolves with the result of the last function that completes.,Return a promise that immediately rejects if any function in the array rejects.,"Return a promise that resolves when all input promises resolve, or rejects immediately if any input promise rejects.",Medium,algorithms,"['promises', 'async', 'parallel']"
2722,"Join Two Arrays by ID
Given two arrays arr1 and arr2, return a new array joinedArray. All the objects in each of the two inputs arrays will contain an id field that has an integer value. joinedArray is an array formed by merging arr1 and arr2 based on their id key. The length of joinedArray should be the length of unique values of id. The returned array should be sorted in ascending order based on the id key. If a given id exists in one array but not the other, the single object with that id should be included in the result array without modification. If two objects share an id, their properties should be merged into a single object:","Use nested loops to compare IDs and merge objects, resulting in O(n*m) time complexity.","Concatenate the two arrays and then use a sorting algorithm based on ID, followed by a merge operation. This has O(n log n) time complexity.","Convert both arrays into JavaScript objects indexed by ID, then iterate through the keys, merging objects with the same ID. This avoids sorting, but may not handle large datasets well due to memory constraints.","Use Array.reduce to accumulate objects with the same ID, which mutates one of the input arrays.","Create a Map to store objects by ID, iterating through both arrays to merge objects with matching IDs. This provides O(n) time complexity on average.",Medium,algorithms,"['array', 'merge', 'hashmap']"
2724,"Sort By
Given an array arr and a function fn, return a sorted array sortedArr. You can assume fn only returns numbers and those numbers determine the sort order of sortedArr. sortedArr must be sorted in ascending order by fn output. You may assume that fn will never duplicate numbers for a given array.",Use the `map` function to apply `fn` and then sort the original array based on the mapped values' indices.,"Create a new array of tuples (original value, fn(value)) and then sort the tuple array based on the second element.",Sort the array in place using a comparison function that directly calls `fn` on the elements being compared.,"Apply `fn` to each element, store the results in a separate array, and then sort the indices based on the sorted results before rearranging the original array.",Use the `sort` method with a custom comparison function that calls `fn` to determine the order.,Easy,algorithms,"['sorting', 'higher-order function', 'array']"
2725,"Interval Cancellation
Given a function fn, an array of arguments args, and an interval time t, return a cancel function cancelFn. After a delay of cancelTimeMs, the returned cancel function cancelFn will be invoked. The function fn should be called with args immediately and then called again every t milliseconds until cancelFn is called at cancelTimeMs ms.","The function will only be called once, immediately after scheduling.",The function will be called every t milliseconds indefinitely.,"The function will be called every t milliseconds for cancelTimeMs milliseconds, then stop.",The function will be called once after cancelTimeMs milliseconds.,"The function will be called immediately, then every t milliseconds until cancelTimeMs milliseconds have passed.",Easy,algorithms,"['setInterval', 'closures', 'asynchronous']"
2726,"Calculator with Method Chaining
Design a Calculator class. The class should provide the mathematical operations of addition, subtraction, multiplication, division, and exponentiation. It should also allow consecutive operations to be performed using method chaining. The Calculator class constructor should accept a number which serves as the initial value of result. Your Calculator class should have the following methods: Solutions within 10-5 of the actual result are considered correct.",Throw an error if division by zero is attempted during chaining.,Reinitialize the 'result' to 0 at the end of each operation in the chain.,Store the intermediate results in a stack and only apply the final operation at the end.,Return a new Calculator object with the updated result for each operation.,Update the 'result' attribute directly within each operation method and return 'self' to enable chaining.,Easy,system design,"['object-oriented programming', 'method chaining', 'immutability']"
2727,"Is Object Empty
Given an object or an array, return if it is empty. You may assume the object or array is the output of JSON.parse.",The object has no own properties using `Object.keys(obj).length === 0`,"The object is falsy (null, undefined, 0, '', false, NaN)",The object has a prototype with no properties,The object's `constructor` property is undefined,"The object is null or undefined, or it has no enumerable properties using `Object.entries(obj).length === 0`",Easy,algorithms,"['object', 'javascript', 'emptiness']"
2729,"Check if The Number is Fascinating
You are given an integer n that consists of exactly 3 digits. We call the number n fascinating if, after the following modification, the resulting number contains all the digits from 1 to 9 exactly once and does not contain any 0's: Return true if n is fascinating, or false otherwise. Concatenating two numbers means joining them together. For example, the concatenation of 121 and 371 is 121371.","Check if the concatenation of n, 2n, and 3n has a length other than 9","Check if the concatenation of n, 2n, and 3n contains duplicate digits using a set",Check if n is a palindrome before concatenating with 2n and 3n,Check if the digits of n are in increasing order before concatenation,"Concatenate n, 2n, and 3n, then check if the resulting string contains digits 1-9 exactly once",Easy,algorithms,"Hash Table,Math"
2730,"Find the Longest Semi-Repetitive Substring
You are given a digit string s that consists of digits from 0 to 9. A string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, ""0010"", ""002020"", ""0123"", ""2002"", and ""54944"" are semi-repetitive while the following are not: ""00101022"" (adjacent same digit pairs are 00 and 22), and ""1101234883"" (adjacent same digit pairs are 11 and 88). Return the length of the longest semi-repetitive substring of s.",Use dynamic programming to store lengths of semi-repetitive substrings ending at each index,"Iterate through all possible substrings and check if each one is semi-repetitive, keeping track of the longest","Use a sliding window approach, expanding the window until more than one adjacent pair is found, then shrinking from the start","Sort the string first, then iterate and count consecutive, differing characters","Maintain a sliding window, tracking the count of adjacent same digit pairs; expand until the count exceeds one, then shrink from the start until the count is one or zero",Medium,algorithms,"String,Sliding Window"
2731,"Movement of Robots
Some robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second. You are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line. If two robots collide, they will start moving in opposite directions. Return the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 109 + 7. Note:","Use a brute-force approach, simulating the movement of each robot at each second and calculating distances after d seconds.","Sort the initial positions and directions, then calculate the final positions based on the movement after d seconds. Calculate distances between adjacent robots only.","Track collisions using a hash map. If a collision occurs, update the directions accordingly and proceed to the next second.",Calculate the final positions of all robots by adding or subtracting 'd' to the initial coordinates based on the direction string and find the sum of distances.,"Sort the robots by their initial positions, simulate their movements, handle collisions by swapping directions, calculate final positions, and compute the sum of distances modulo 10^9 + 7.",Medium,algorithms,"Array,Brainteaser,Sorting,Prefix Sum"
2732,"Find a Good Subset of the Matrix
You are given a 0-indexed m x n binary matrix grid. Let us call a non-empty subset of rows good if the sum of each column of the subset is at most half of the length of the subset. More formally, if the length of the chosen subset of rows is k, then the sum of each column should be at most floor(k / 2). Return an integer array that contains row indices of a good subset sorted in ascending order. If there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array. A subset of rows of the matrix grid is any matrix that can be obtained by deleting some (possibly none or all) rows from grid.",Check all subsets of rows and pick the first good one,"Sort the rows based on the sum of elements, then check for good subsets starting from the smallest rows",Use dynamic programming to store intermediate results of subset sums,"Iterate through rows and keep adding rows until the condition is met or exceeded, then remove the last row","Prioritize rows where the number of 0s is greater than or equal to the number of 1s, and iteratively add rows while maintaining the good subset property",Hard,algorithms,"Array,Hash Table,Bit Manipulation,Matrix"
2733,"Neither Minimum nor Maximum
Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number. Return the selected integer.","If the array is already sorted, return the element at index 1.",Return the average of the minimum and maximum elements.,Return the first element of the array if the array's length is greater than 2.,Return the middle element of the array (nums[len(nums) // 2]).,Iterate through the array and return the first element that is not the minimum or maximum.,Easy,algorithms,"Array,Sorting"
2734,"Lexicographically Smallest String After Substring Operation
Given a string s consisting of lowercase English letters. Perform the following operation: Return the lexicographically smallest string after performing the operation.",Replace the first non-'a' character with 'a',Sort the entire string alphabetically,Remove all occurrences of the letter 'b',Reverse the entire string,"Iterate through the string and replace the first non-'a' character with 'a'; if the string consists only of 'a' characters, leave it unchanged",Medium,algorithms,"String,Greedy"
2735,"Collecting Chocolates
You are given a 0-indexed integer array nums of size n representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index i is nums[i]. Each chocolate is of a different type, and initially, the chocolate at the index i is of ith type. In one operation, you can do the following with an incurred cost of x: Return the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.",Calculate the average cost of the array and multiply by the array length,Sort the array and return the cost of the smallest element,"Find the minimum element in the array, then return the cost of all elements using that minimum element","Calculate the sum of the array and divide by the number of operations, x",Find the minimum value in the array after each rotation and sum those minimums.,Medium,algorithms,"Array,Enumeration"
2736,"Maximum Sum Queries
You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi]. For the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no j satisfying the constraints. Return an array answer where answer[i] is the answer to the ith query.","Use a nested loop approach: for each query, iterate through all indices j and check the conditions.","Sort nums1 and nums2 independently, then use binary search to find the valid indices for each query.",Precompute all possible sums of nums1[j] + nums2[j] and store them in a hashmap for quick lookup.,Use dynamic programming to store the maximum sum seen so far for prefixes of nums1 and nums2.,"Sort the indices by nums1[j], process queries offline, and maintain a maximum nums1[j] + nums2[j] using a segment tree or similar data structure.",Hard,algorithms,"Array,Binary Search,Stack,Binary Indexed Tree,Segment Tree,Sorting,Monotonic Stack"
2739,"Total Distance Traveled
A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters. The truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank. Return the maximum distance which can be traveled. Note: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.",mainTank * 10,(mainTank + additionalTank) * 10,"min(mainTank + additionalTank, mainTank + (additionalTank / 5)) * 10","max(mainTank, additionalTank) * 10","((min(mainTank, additionalTank * 5 / 1) + additionalTank) * 10)",Easy,algorithms,"Math,Simulation"
2740,"Find the Value of the Partition
You are given a positive integer array nums. Partition nums into two arrays, nums1 and nums2, such that: The value of the partition is |max(nums1) - min(nums2)|. Here, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2. Return the integer denoting the value of such partition.",Calculate the difference between the sum of all elements and the product of all elements.,Find the maximum element of the array and subtract it from the minimum element.,Return the absolute difference between the largest and smallest elements in the sorted array.,Calculate the median of the array and use it as the partition point.,Sort the array and iterate through adjacent pairs to find the minimum absolute difference between them.,Medium,algorithms,"Array,Sorting"
2741,"Special Permutations
You are given a 0-indexed integer array nums containing n distinct positive integers. A permutation of nums is called special if: Return the total number of special permutations. As the answer could be large, return it modulo 109 + 7.",Using a greedy approach focusing on the largest numbers first.,Recursively generating all permutations and checking each one.,Sorting the array and then using a mathematical formula to compute special permutations.,Backtracking with pruning based on immediate neighbor divisibility.,Dynamic programming with bitmasking to track visited numbers and their divisibility relationships.,Medium,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
2742,"Painting the Walls
You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available: Return the minimum amount of money required to paint the n walls.","Use a greedy approach, prioritizing walls with the lowest cost-to-time ratio.",Apply dynamic programming with a state representing the walls painted so far.,"Sort the walls by cost and then by time, painting in that order.","Calculate the average cost and average time, then multiply them.",Use dynamic programming with a state representing the walls remaining and the time already spent.,Hard,algorithms,"Array,Dynamic Programming"
2744,"Find Maximum Number of String Pairs
You are given a 0-indexed array words consisting of distinct strings. The string words[i] can be paired with the string words[j] if: Return the maximum number of pairs that can be formed from the array words. Note that each string can belong in at most one pair.","Use a hash map to store the frequency of each string, then iterate through the map to find pairs with a count greater than 1.","Sort the array of strings lexicographically and then iterate through the sorted array, counting adjacent pairs that are reverses of each other.","Iterate through the array using nested loops, comparing each string with every other string to find reverse pairs and marking them as used to avoid double-counting.","Convert each string into its reverse and store it in a separate array; then, compare the original array with the reversed array to find matching pairs.","Iterate through the array using nested loops, checking if words[i] is the reverse of words[j] for i < j, and incrementing the count while marking used pairs to avoid re-counting.",Easy,algorithms,"Array,Hash Table,String,Simulation"
2745,"Construct the Longest New String
You are given three integers x, y, and z. You have x strings equal to ""AA"", y strings equal to ""BB"", and z strings equal to ""AB"". You want to choose some (possibly all or none) of these strings and concatenate them in some order to form a new string. This new string must not contain ""AAA"" or ""BBB"" as a substring. Return the maximum possible length of the new string. A substring is a contiguous non-empty sequence of characters within a string.",2 * x + 2 * y + z - 2,2 * x + 2 * y + z + 2,2 * x + 2 * y + z,x + y + z,"2 * x + 2 * y + z + min(1, max(0, (x + y + z) - (x + y))) * 2",Medium,algorithms,"Math,Dynamic Programming,Greedy,Brainteaser"
2746,"Decremental String Concatenation
You are given a 0-indexed array words containing n strings. Let's define a join operation join(x, y) between two strings x and y as concatenating them into xy. However, if the last character of x is equal to the first character of y, one of them is deleted. For example join(""ab"", ""ba"") = ""aba"" and join(""ab"", ""cde"") = ""abcde"". You are to perform n - 1 join operations. Let str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation, you can do one of the following: Your task is to minimize the length of strn - 1. Return an integer denoting the minimum possible length of strn - 1.",Use dynamic programming with a state representing the current word and the last character of the concatenated string.,Apply a greedy approach by always joining the strings with the maximum overlap.,Sort the input strings lexicographically and then perform decremental concatenation.,Reverse all strings and use longest common subsequence to merge.,Use dynamic programming with a state representing the current index and the starting/ending characters of the current string.,Medium,algorithms,"Array,String,Dynamic Programming"
2747,"Count Zero Request Servers
You are given an integer n denoting the total number of servers and a 2D 0-indexed integer array logs, where logs[i] = [server_id, time] denotes that the server with id server_id received a request at time time. You are also given an integer x and a 0-indexed integer array queries. Return a 0-indexed integer array arr of length queries.length where arr[i] represents the number of servers that did not receive any requests during the time interval [queries[i] - x, queries[i]]. Note that the time intervals are inclusive.",Use a hash map to store server request times and iterate through each query to count servers with no requests in the given range.,Sort the logs array by server ID and then use binary search for each query to find the number of requests within the time range.,Iterate through all servers for each query and linearly search the logs array to check for requests within the specified time window.,Precompute the number of requests each server received in sliding windows of size x and use that information to answer queries efficiently.,"For each query, iterate through all servers and check if they have any requests within the time interval [query[i] - x, query[i]] using binary search on the logs array for each server.",Medium,algorithms,"Array,Hash Table,Sliding Window,Sorting"
2748,"Number of Beautiful Pairs
You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <= i < j < nums.length is called beautiful if the first digit of nums[i] and the last digit of nums[j] are coprime. Return the total number of beautiful pairs in nums. Two integers x and y are coprime if there is no integer greater than 1 that divides both of them. In other words, x and y are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common divisor of x and y.",The sum of the number of set bits in each number,The product of the first and last numbers in the array,The number of even numbers in the array,The number of prime numbers in the array,The number of pairs where the first digit of nums[i] and the last digit of nums[j] are coprime,Easy,algorithms,"Array,Hash Table,Math,Counting,Number Theory"
2749,"Minimum Operations to Make the Integer Zero
You are given two integers num1 and num2. In one operation, you can choose integer i in the range [0, 60] and subtract 2i + num2 from num1. Return the integer denoting the minimum number of operations needed to make num1 equal to 0. If it is impossible to make num1 equal to 0, return -1.",Use dynamic programming with memoization to store previously computed results,Convert num1 and num2 to binary strings and perform bitwise operations,Apply a greedy approach by always choosing the largest possible power of 2,Employ a brute-force search iterating through all possible combinations of i,Analyze the binary representation of num1 + k * num2 to find the minimal k such that the number of set bits is less than or equal to k,Medium,algorithms,"Bit Manipulation,Brainteaser,Enumeration"
2750,"Ways to Split Array Into Good Subarrays
You are given a binary array nums. A subarray of an array is good if it contains exactly one element with the value 1. Return an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7. A subarray is a contiguous non-empty sequence of elements within an array.",Multiply the indices of all 1s and take the modulo,Calculate the factorial of the number of 1s in the array,Return 2 raised to the power of (number of 1s - 1),Calculate the number of zeros between each consecutive 1 and sum them up,"Calculate the number of zeros between each consecutive 1, multiply them together (modulo 10^9 + 7), returning 1 if there's only one 1",Medium,algorithms,"Array,Math,Dynamic Programming"
2751,"Robot Collisions
There are n 1-indexed robots, each having a position on a line, health, and movement direction. You are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique. All robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide. If two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line. Your task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final health of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array. Return an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur. Note: The positions may be unsorted.","Sort the robots based on their direction ('L' first, then 'R') and then iterate through them to simulate collisions.","Simulate collisions in discrete time steps, updating positions and health after each step until no collisions occur.",Model the problem as a system of differential equations representing the robots' movements and solve for collision times.,Only consider robots moving in opposite directions that are next to each other in the initial positions array.,"Use a stack to track robots moving right, resolving collisions as robots moving left encounter them.",Hard,algorithms,"Array,Stack,Sorting,Simulation"
2760,"Longest Even Odd Subarray With Threshold
You are given a 0-indexed integer array nums and an integer threshold. Find the length of the longest subarray of nums starting at index l and ending at index r (0 <= l <= r < nums.length) that satisfies the following conditions: Return an integer denoting the length of the longest such subarray. Note: A subarray is a contiguous non-empty sequence of elements within an array.",Use dynamic programming to store lengths of all possible subarrays,Sort the array and then iterate to find the longest subarray meeting the criteria,Apply binary search to find the optimal subarray length,"Utilize a sliding window, expanding it when conditions are met and shrinking it when they are violated, keeping track of the maximum length","Iterate through the array, starting a new subarray whenever nums[i] is even and <= threshold, extending it as long as the even/odd alternation and threshold conditions hold",Easy,algorithms,"Array,Sliding Window"
2761,"Prime Pairs With Target Sum
You are given an integer n. We say that two integers x and y form a prime number pair if: Return the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array. Note: A prime number is a natural number greater than 1 with only two factors, itself and 1.",Hash each number and check if (n - number) exists in the hash table in O(n) time.,Sort all numbers and use two pointers starting from the beginning and end to find pairs summing to n in O(n log n) time.,Generate all possible pairs and check if the sum equals n and both numbers are prime in O(n^2) time.,"Iterate from 2 to n/2, checking if both the current number and (n - current number) are prime.","Iterate from 2 to n/2, check primality, and store pairs; optimized primality checks improve performance.",Medium,algorithms,"Array,Math,Enumeration,Number Theory"
2762,"Continuous Subarrays
You are given a 0-indexed integer array nums. A subarray of nums is called continuous if: Return the total number of continuous subarrays. A subarray is a contiguous non-empty sequence of elements within an array.",Binary search can efficiently find the target within a sorted but rotated array by comparing the target with the middle element.,"A linear scan of the entire rotated sorted array is necessary to locate the target, regardless of array properties.",The rotated sorted array must first be fully sorted using an efficient algorithm like merge sort or quicksort before searching.,"Since the array is rotated, finding the rotation point first before applying binary search on the appropriate side optimizes the process.",Adapt binary search to handle the rotation by checking which half of the array is sorted and narrowing the search accordingly.,Medium,algorithms,"Array,Queue,Sliding Window,Heap (Priority Queue),Ordered Set,Monotonic Queue"
2763,"Sum of Imbalance Numbers of All Subarrays
The imbalance number of a 0-indexed integer array arr of length n is defined as the number of indices in sarr = sorted(arr) such that: Here, sorted(arr) is the function that returns the sorted version of arr. Given a 0-indexed integer array nums, return the sum of imbalance numbers of all its subarrays. A subarray is a contiguous non-empty sequence of elements within an array.",Calculate the imbalance number of each subarray independently and sum them up.,"Sort the entire input array and calculate the imbalance number once, then multiply by the number of subarrays.","Maintain a running sum of the imbalance numbers while iterating through the array, updating the sum only when encountering a duplicate.",Use dynamic programming to store and reuse previously computed imbalance numbers of overlapping subarrays.,"Iterate through all possible subarrays, calculate the imbalance number for each subarray, and return the sum of these imbalance numbers.",Hard,algorithms,"Array,Hash Table,Ordered Set"
2765,"Longest Alternating Subarray
You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if: Return the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists. A subarray is a contiguous non-empty sequence of elements within an array.",Find the longest subarray where all elements are positive,Find the longest subarray where the sum of elements is maximized,Find the longest subarray with an equal number of even and odd numbers,Find the longest increasing or decreasing subarray,Find the longest subarray where adjacent elements have opposite parity (even/odd),Easy,algorithms,"Array,Enumeration"
2766,"Relocate Marbles
You are given a 0-indexed integer array nums representing the initial positions of some marbles. You are also given two 0-indexed integer arrays moveFrom and moveTo of equal length. Throughout moveFrom.length steps, you will change the positions of the marbles. On the ith step, you will move all marbles at position moveFrom[i] to position moveTo[i]. After completing all the steps, return the sorted list of occupied positions. Notes:",Use a hash map to track marble counts at each position and update them iteratively.,"Simultaneously iterate through `moveFrom` and `moveTo`, directly replacing elements in `nums` without handling collisions.","Sort `nums` and then apply the moves sequentially, ensuring that elements are shifted correctly after each move.","Create a boolean array representing positions, mark initial positions as true, and update based on moves, then extract true indices.","Use a count array (or hash map) to track the number of marbles at each position, update counts based on moves, and then extract sorted occupied positions.",Medium,algorithms,"Array,Hash Table,Sorting,Simulation"
2767,"Partition String Into Minimum Beautiful Substrings
Given a binary string s, partition the string into one or more substrings such that each substring is beautiful. A string is beautiful if: Return the minimum number of substrings in such partition. If it is impossible to partition the string s into beautiful substrings, return -1. A substring is a contiguous sequence of characters in a string.",Use dynamic programming to build a table of minimum partitions for all prefixes of the string.,Greedily select the longest possible beautiful substring from the start of the string in each iteration.,Recursively try all possible partitions and memoize the results to avoid redundant calculations.,Convert the binary string to an integer and find the smallest number of powers of 5 that sum up to it.,"Use backtracking to explore all possible partitions, pruning branches when a beautiful substring cannot be formed.",Medium,algorithms,"Hash Table,String,Dynamic Programming,Backtracking"
2768,"Number of Black Blocks
You are given two integers m and n representing the dimensions of a 0-indexed m x n grid. You are also given a 0-indexed 2D integer matrix coordinates, where coordinates[i] = [x, y] indicates that the cell with coordinates [x, y] is colored black. All cells in the grid that do not appear in coordinates are white. A block is defined as a 2 x 2 submatrix of the grid. More formally, a block with cell [x, y] as its top-left corner where 0 <= x < m - 1 and 0 <= y < n - 1 contains the coordinates [x, y], [x + 1, y], [x, y + 1], and [x + 1, y + 1]. Return a 0-indexed integer array arr of size 5 such that arr[i] is the number of blocks that contains exactly i black cells.",Use a nested loop to iterate through all possible 2x2 blocks and count black cells in each,"Precompute the number of black cells for each row and column, then use these counts to determine block counts",Create a sparse matrix representation of the grid and use convolution to identify 2x2 blocks,Sort the coordinates array and then perform a single pass to count black cells in blocks,Use a hash map to store black cell coordinates and efficiently check each possible 2x2 block,Medium,algorithms,"Array,Hash Table,Enumeration"
2769,"Find the Maximum Achievable Number
Given two integers, num and t. A number x is achievable if it can become equal to num after applying the following operation at most t times: Return the maximum possible value of x.",num + t,num * t,num / t,t - num,num + 2 * t,Easy,algorithms,Math
2770,"Maximum Number of Jumps to Reach the Last Index
You are given a 0-indexed array nums of n integers and an integer target. You are initially positioned at index 0. In one step, you can jump from index i to any index j such that: Return the maximum number of jumps you can make to reach index n - 1. If there is no way to reach index n - 1, return -1.",Depth-First Search (DFS),Greedy Algorithm,Divide and Conquer,Dynamic Programming with memoization,Dynamic Programming with tabulation,Medium,algorithms,"Array,Dynamic Programming"
2771,"Longest Non-decreasing Subarray From Two Arrays
You are given two 0-indexed integer arrays nums1 and nums2 of length n. Let's define another 0-indexed integer array, nums3, of length n. For each index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i] to nums3[i]. Your task is to maximize the length of the longest non-decreasing subarray in nums3 by choosing its values optimally. Return an integer representing the length of the longest non-decreasing subarray in nums3. Note: A subarray is a contiguous non-empty sequence of elements within an array.",Use dynamic programming with a single state representing the current index.,Employ a greedy approach by always selecting the smaller value between nums1[i] and nums2[i].,Recursively explore all possible combinations of nums1[i] and nums2[i] for nums3[i] and track the maximum length.,Sort both nums1 and nums2 independently and then merge them to form nums3.,Use dynamic programming with two states representing the current index and the last chosen number.,Medium,algorithms,"Array,Dynamic Programming"
2772,"Apply Operations to Make All Array Elements Equal to Zero
You are given a 0-indexed integer array nums and a positive integer k. You can apply the following operation on the array any number of times: Return true if you can make all the array elements equal to 0, or false otherwise. A subarray is a contiguous non-empty part of an array.","Using a greedy approach, iterate through the array and repeatedly subtract k from the largest element until all elements are zero.",Sort the array in ascending order and then apply the operation to the first k elements until the array is zeroed or the first element is positive.,"Calculate the prefix sum array. If at any index i, prefix[i] < 0, return false. Apply operations based on prefix sum differences.","If any element in the array is greater than k, then the answer is false","Use a difference array to track the changes made by each operation. Iterate through nums, maintaining a current difference sum. If nums[i] + current_diff < 0, return false. Adjust current_diff for the next k elements.",Medium,algorithms,"Array,Prefix Sum"
2778,"Sum of Squares of Special Elements
You are given a 1-indexed integer array nums of length n. An element nums[i] of nums is called special if i divides n, i.e. n % i == 0. Return the sum of the squares of all special elements of nums.",Calculate the sum of elements at prime indices.,Return the square of the sum of all elements in the array.,Multiply each element by its index and return the sum.,Calculate the product of elements at indices that divide n.,"Iterate through the array, identify elements where the index divides n, square them, and add to the total sum.",Easy,algorithms,"Array,Enumeration"
2779,"Maximum Beauty of an Array After Applying Operation
You are given a 0-indexed array nums and a non-negative integer k. In one operation, you can do the following: The beauty of the array is the length of the longest subsequence consisting of equal elements. Return the maximum possible beauty of the array nums after applying the operation any number of times. Note that you can apply the operation to each index only once. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.","Sort the array and iterate, calculating the maximum frequency of any number within the range [num - k, num + k].","Use a sliding window approach, expanding the window as long as elements are within k distance of each other.","Apply dynamic programming, where dp[i] represents the maximum beauty considering elements up to index i.",Calculate the mode of the array and increment the count for elements within k distance of the mode.,"Use a frequency map and a sliding window to track the count of numbers within the range [num - k, num + k], updating the maximum beauty as you slide.",Medium,algorithms,"Array,Binary Search,Sliding Window,Sorting"
2780,"Minimum Index of a Valid Split
An element x of an integer array arr of length m is dominant if more than half the elements of arr have a value of x. You are given a 0-indexed integer array nums of length n with one dominant element. You can split nums at an index i into two arrays nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if: Here, nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j < i then nums[i, ..., j] denotes an empty subarray. Return the minimum index of a valid split. If no valid split exists, return -1.","O(n^2), where n is the length of the array, due to nested loops for dominant element checks.","O(n log n), dominated by sorting the array to find the dominant element.","O(m), where m is the number of unique elements, assuming a hash map is used to count frequencies.","O(1), as the dominant element is given and can be checked in constant time.","O(n), requiring a single pass to find the dominant element and another to check for valid splits.",Medium,algorithms,"Array,Hash Table,Sorting"
2781,"Length of the Longest Valid Substring
You are given a string word and an array of strings forbidden. A string is called valid if none of its substrings are present in forbidden. Return the length of the longest valid substring of the string word. A substring is a contiguous sequence of characters in a string, possibly empty.",Use a stack to store forbidden substrings and compare against word using a while loop.,"Recursively check each substring of word against the forbidden array, returning the maximum length found.",Sort the forbidden array and perform a binary search for each substring of word.,"Employ dynamic programming, building a table to track the validity of all substrings of word.","Use a sliding window approach, maintaining a set of forbidden substrings and adjusting the window as needed.",Hard,algorithms,"Array,Hash Table,String,Sliding Window"
2784,"Check if Array is Good
You are given an integer array nums. We consider an array good if it is a permutation of an array base[n]. base[n] = [1, 2, ..., n - 1, n, n] (in other words, it is an array of length n + 1 which contains 1 to n - 1 exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and base[3] = [1, 2, 3, 3]. Return true if the given array is good, otherwise return false. Note: A permutation of integers represents an arrangement of these numbers.",The array must be sorted in ascending order to be considered 'good'.,"The array must contain all numbers from 1 to n, each appearing exactly once.",The sum of elements in the array must be equal to n * (n + 1) / 2.,"The array's length must be equal to n, where n is the largest element in the array.","The array must have a length of n + 1, contain numbers 1 to n-1 exactly once, and the number n exactly twice.",Easy,algorithms,"Array,Hash Table,Sorting"
2785,"Sort Vowels in a String
Given a 0-indexed string s, permute s to get a new string t such that: Return the resulting string. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.",Use a hash map to store the consonants and then place the vowels in sorted order,Sort the entire string using a standard sorting algorithm and then swap consonants and vowels,"Reverse the string, sort it, and then reverse it back to maintain original consonant positions","Replace vowels with a placeholder, sort the placeholders, and then replace them back with the sorted vowels","Extract vowels, sort them, and rebuild the string, placing sorted vowels back into their original positions",Medium,algorithms,"String,Sorting"
2786,"Visit Array Positions to Maximize Score
You are given a 0-indexed integer array nums and a positive integer x. You are initially at position 0 in the array and you can visit other positions according to the following rules: Return the maximum total score you can get. Note that initially you have nums[0] points.","Use dynamic programming to store the maximum score achievable at each position, considering only even indices.","Use a greedy approach, always moving to the next position with the highest value in `nums`.",Calculate the sum of all elements in `nums` and subtract `x` for each change in parity.,Sort the `nums` array and then choose elements alternately from the beginning and end based on parity.,"Use dynamic programming to store the maximum score achievable at each position, considering both even and odd indices, and the cost `x` when switching parity.",Medium,algorithms,"Array,Dynamic Programming"
2787,"Ways to Express an Integer as Sum of Powers
Given two positive integers n and x. Return the number of ways n can be expressed as the sum of the xth power of unique positive integers, in other words, the number of sets of unique integers [n1, n2, ..., nk] where n = n1x + n2x + ... + nkx. Since the result can be very large, return it modulo 109 + 7. For example, if n = 160 and x = 3, one way to express n is n = 23 + 33 + 53.",Memoization with a 2D array indexed by current number and remaining target value,Greedy approach by repeatedly subtracting the largest possible xth power less than or equal to n,Dynamic programming using a 1D array representing the number of ways to reach each value up to n,Iterative deepening depth-first search to explore all possible combinations within a limited depth,"Recursion with backtracking, exploring including or excluding each number's xth power",Medium,algorithms,Dynamic Programming
2788,"Split Strings by Separator
Given an array of strings words and a character separator, split each string in words by separator. Return an array of strings containing the new strings formed after the splits, excluding empty strings. Notes",Use regular expressions to find all occurrences of the separator and replace them with empty strings.,Split each string based on the ASCII value of the separator character.,Concatenate all strings in the input array and then split the resulting string by the separator.,"Iterate through the array backwards, splitting each string, and inserting the results at the beginning of a new array.","Iterate through each string, split it by the separator, and add the resulting non-empty substrings to a new array.",Easy,algorithms,"Array,String"
2789,"Largest Element in an Array after Merge Operations
You are given a 0-indexed array nums consisting of positive integers. You can do the following operation on the array any number of times: Return the value of the largest element that you can possibly obtain in the final array.",Sort the array and return the first element.,Return the sum of all elements in the array.,Return the product of all elements in the array.,Use dynamic programming to find the largest element after merging all possible subarrays.,"Iterate backwards through the array, merging adjacent elements if their sum is greater than or equal to the next element, and return the last element.",Medium,algorithms,"Array,Greedy"
2790,"Maximum Number of Groups With Increasing Length
You are given a 0-indexed array usageLimits of length n. Your task is to create groups using numbers from 0 to n - 1, ensuring that each number, i, is used no more than usageLimits[i] times in total across all groups. You must also satisfy the following conditions: Return an integer denoting the maximum number of groups you can create while satisfying these conditions.","Use a greedy approach, sorting usageLimits in descending order and iteratively forming groups until no more groups can be created.",Apply binary search on the possible number of groups and check feasibility using a helper function that checks if it is possible to form that many groups.,"Calculate the sum of usageLimits and divide it by 2, rounding down to the nearest integer.","Return the length of usageLimits, since each number can form at least one group.",Sort usageLimits in ascending order and iteratively build groups by using the smallest available numbers; increment the number of groups if enough elements are available to form a new group.,Hard,algorithms,"Array,Math,Binary Search,Greedy,Sorting"
2791,"Count Paths That Can Form a Palindrome in a Tree
You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to the edge between i and parent[i]. s[0] can be ignored. Return the number of pairs of nodes (u, v) such that u < v and the characters assigned to edges on the path from u to v can be rearranged to form a palindrome. A string is a palindrome when it reads the same backwards as forwards.","Use a depth-first search (DFS) and a bitmask to track the parity of character counts along each path from the root, and check all pairs.",Perform a breadth-first search (BFS) to enumerate all possible paths between nodes and explicitly check if the path's characters can form a palindrome.,"Use dynamic programming to store whether subpaths are palindromes, building up to larger paths and counting the valid pairs.","Sort the nodes by their associated characters, then greedily pair nodes such that the characters form a palindrome.","Use a depth-first search (DFS) and a bitmask to track the parity of character counts along each path from the root, using a hash map to efficiently count valid pairs.",Hard,algorithms,"Dynamic Programming,Bit Manipulation,Tree,Depth-First Search,Bitmask"
2798,"Number of Employees Who Met the Target
There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company. The company requires each employee to work for at least target hours. You are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target. Return the integer denoting the number of employees who worked at least target hours.",Use a hash map to store the frequency of each hour and then iterate from the target hour,Sort the hours array and then perform a binary search to find the first employee who met the target,Calculate the average working hours and return the number of employees with hours greater than the average,Use dynamic programming to find the optimal number of employees who meet the target,Iterate through the hours array and increment a counter for each employee whose hours are greater than or equal to the target,Easy,algorithms,Array
2799,"Count Complete Subarrays in an Array
You are given an array nums consisting of positive integers. We call a subarray of an array complete if the following condition is satisfied: Return the number of complete subarrays. A subarray is a contiguous non-empty part of an array.",The subarray contains all the distinct values in the whole array.,The subarray has a length equal to the number of distinct elements in the original array.,"The subarray contains only unique elements, with no repetitions.",The subarray's elements sum up to a perfect square.,The subarray contains all the distinct values present in the entire array nums.,Medium,algorithms,"Array,Hash Table,Sliding Window"
2800,"Shortest String That Contains Three Strings
If there are multiple such strings, return the lexicographically smallest one. Return a string denoting the answer to the problem. Notes","Brute force all possible permutations and concatenations of the input strings, checking containment and length.","Use dynamic programming to build a table representing the shortest common superstring of all pairs of strings, then extend to three strings.","Employ a greedy algorithm, repeatedly merging the two strings with the largest overlap until only one string remains.",Concatenate all three strings in lexicographical order and remove any duplicate substrings.,"Analyze all 6 permutations of the three input strings, compute the shortest string containing each permutation, and select the lexicographically smallest result.",Medium,algorithms,"String,Greedy,Enumeration"
2801,"Count Stepping Numbers in Range
Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high]. A stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1. Return an integer denoting the count of stepping numbers in the inclusive range [low, high]. Since the answer may be very large, return it modulo 109 + 7. Note: A stepping number should not have a leading zero.",Use dynamic programming to store the number of stepping numbers of length 'i' starting with digit 'j',"Perform a breadth-first search (BFS) starting from each digit from 1 to 9, pruning branches that fall outside the range","Generate all possible numbers within the length range of low and high, and check if each is a stepping number",Use Depth First Search to exhaustively generate stepping numbers and then filter within the range,"Use Depth First Search starting with digits 1-9 and memoize counts, adjusting for range boundaries and leading zeros",Hard,algorithms,"String,Dynamic Programming"
2806,"Account Balance After Rounded Purchase
Initially, you have a bank account balance of 100 dollars. You are given an integer purchaseAmount representing the amount you will spend on a purchase in dollars, in other words, its price. When making the purchase, first the purchaseAmount is rounded to the nearest multiple of 10. Let us call this value roundedAmount. Then, roundedAmount dollars are removed from your bank account. Return an integer denoting your final bank account balance after this purchase. Notes:",Calculate the balance by truncating purchaseAmount after division by 10 and subtracting that result times 10 from 100,Return 100 - purchaseAmount,"Multiply purchaseAmount by 10, round the result to the nearest integer, and subtract from 100",Subtract purchaseAmount rounded down to the nearest ten from 100,Round purchaseAmount to the nearest ten and subtract from 100,Easy,algorithms,Math
2807,"Insert Greatest Common Divisors in Linked List
Given the head of a linked list head, in which each node contains an integer value. Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them. Return the linked list after insertion. The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.","Allocate a new linked list and copy the original elements, calculating GCD using subtraction.","Convert the linked list to an array, insert GCDs in the array, and then rebuild the linked list.","Iterate through the linked list once, replacing each node's value with the GCD of itself and the next node.",Use recursion to find the GCD and insert nodes while unwinding the call stack.,"Traverse the linked list, compute the GCD of adjacent nodes using the Euclidean algorithm, and insert a new node between them.",Medium,data structures,"Linked List,Math,Number Theory"
2808,"Minimum Seconds to Equalize a Circular Array
You are given a 0-indexed array nums containing n integers. At each second, you perform the following operation on the array: Note that all the elements get replaced simultaneously. Return the minimum number of seconds needed to make all elements in the array nums equal.","Calculate the frequency of each number, find the maximum frequency, and return half the array size minus the maximum frequency.","Sort the array, find the longest contiguous subarray of equal elements, and return the array size minus the length of that subarray.",Calculate the average of all numbers in the array and return the sum of absolute differences between each number and the average.,Find the minimum and maximum values in the array and return the difference between them.,"Calculate the frequency of each number, for each number, calculate half of the maximum distance between its occurrences. Return the maximum of these results.",Medium,algorithms,"Array,Hash Table"
2809,"Minimum Time to Make Array Sum At Most x
You are given two 0-indexed integer arrays nums1 and nums2 of equal length. Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is incremented by nums2[i]. After this is done, you can do the following operation: You are also given an integer x. Return the minimum time in which you can make the sum of all elements of nums1 to be less than or equal to x, or -1 if this is not possible.",Greedily choose the elements with the largest nums2[i] to operate on first.,Sort the elements based on nums1[i] and operate on the smallest values first.,Use binary search to find the optimal time and check if the condition is met.,Calculate the sum of nums1 and nums2 separately and divide the difference by x.,"Sort indices by nums2[i] in descending order, iterate through permutations to find minimum time.",Hard,algorithms,"Array,Dynamic Programming,Sorting"
2810,"Faulty Keyboard
Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected. You are given a 0-indexed string s, and you type each character of s using your faulty keyboard. Return the final string that will be present on your laptop screen.",The keyboard malfunction has no effect; return the original string.,Replace each 'i' with its reverse counterpart in the string.,Reverse the entire string once for each occurrence of 'i'.,Remove all occurrences of 'i' and return the modified string.,"Simulate the typing process, reversing the string whenever 'i' is encountered.",Easy,algorithms,"String,Simulation"
2811,"Check if it is Possible to Split Array
You are given an array nums of length n and an integer m. You need to determine if it is possible to split the array into n arrays of size 1 by performing a series of steps. An array is called good if: In each step, you can select an existing array (which may be the result of previous steps) with a length of at least two and split it into two arrays, if both resulting arrays are good. Return true if you can split the given array into n arrays, otherwise return false.",The sum of all elements in 'nums' is divisible by 'm',The largest element in 'nums' is less than or equal to 'm',Each element in 'nums' is less than or equal to 'm',The product of all elements in 'nums' is divisible by 'm',The number of elements in 'nums' that are divisible by 'm' is greater than or equal to the number of elements that are not,Medium,algorithms,"Array,Dynamic Programming,Greedy"
2812,"Find the Safest Path in a Grid
You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents: You are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves. The safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid. Return the maximum safeness factor of all paths leading to cell (n - 1, n - 1). An adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists. The Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.",Use Dijkstra's algorithm to find the path with the maximum sum of safeness factors of individual cells.,"Apply a greedy approach, always moving to the adjacent cell with the highest safeness factor at each step.",Calculate the average safeness factor of all cells and use that as the maximum possible safeness factor.,"Perform a depth-first search, pruning paths that fall below a certain safeness threshold.",Use binary search on the safeness factor combined with Breadth-First Search (BFS) to check if a path exists with that safeness factor.,Medium,algorithms,"Array,Binary Search,Breadth-First Search,Union Find,Heap (Priority Queue),Matrix"
2813,"Maximum Elegance of a K-Length Subsequence
You are given a 0-indexed 2D integer array items of length n and an integer k. items[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively. Let's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence. Your task is to find the maximum elegance from all subsequences of size k in items. Return an integer denoting the maximum elegance of a subsequence of items with size exactly k. Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.","Use dynamic programming to compute the maximum elegance for subsequences of lengths 1 to k, considering all possible combinations of items.","Sort the items by profit in descending order and greedily select the top k items.  If the number of distinct categories is less than k, repeatedly replace the item with the lowest profit with an item from a new category until k items are selected.","Sort the items by category and then profit. Use a sliding window to maintain a subsequence of size k, calculating the elegance for each window and returning the maximum.",Consider all possible subsequences of size k and calculate the elegance for each. Return the maximum elegance found. This is computationally feasible due to memoization.,"Sort items by profit descending. Take the top k. If distinct categories < k, remove lowest profit items and replace with items from new categories until distinct categories = k or no more items. Then calculate elegance.",Hard,algorithms,"Array,Hash Table,Stack,Greedy,Sorting,Heap (Priority Queue)"
2815,"Max Pair Sum in an Array
You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal. For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them. Return the maximum sum or -1 if no such pair exists.",Use a hash map to store the maximum number for each largest digit and then find the maximum sum,"Sort the array and then iterate through it, calculating the sum of adjacent elements with equal maximum digits",Iterate through all possible pairs in the array and return the largest sum where the maximum digits are different,"Convert each number to a string, compare the strings lexicographically, and add pairs","For each number, find its maximum digit. Store the number based on its maximum digit in a dictionary or array. Then find the largest two numbers for each digit and compute the maximum sum.",Easy,algorithms,"Array,Hash Table"
2816,"Double a Number Represented as a Linked List
You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes. Return the head of the linked list after doubling it.",Create a new linked list by shifting each digit one place to the left and filling the units place with zero,"Convert the linked list to a string, multiply the string by 2, and convert it back to a linked list","Recursively double each node's value, handling carry-over from the least significant digit to the most significant","Reverse the linked list, multiply each digit by 2, handle carry-over, and then reverse the list again","Traverse the linked list, double each digit, propagate carry to the next digit, and handle a potential carry at the most significant end by adding a new node",Medium,algorithms,"Linked List,Math,Stack"
2817,"Minimum Absolute Difference Between Elements With Constraint
You are given a 0-indexed integer array nums and an integer x. Find the minimum absolute difference between two elements in the array that are at least x indices apart. In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized. Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.","Sort the array and then iterate, comparing adjacent elements at least x indices apart.",Use a hash map to store the frequency of each number and find the minimum difference based on frequencies.,"Calculate the absolute difference between all possible pairs of elements, regardless of their index difference, and return the minimum.",Use dynamic programming to store the minimum absolute difference for sub-arrays ending at each index.,"Iterate through the array and for each element, search for the closest element at least x indices away using binary search on a sorted sub-array.",Medium,algorithms,"Array,Binary Search,Ordered Set"
2818,"Apply Operations to Maximize Score
You are given an array nums of n positive integers and an integer k. Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times: Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive. The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5. Return the maximum possible score after applying at most k operations. Since the answer may be large, return it modulo 109 + 7.",Greedily select the subarray with the highest product of prime scores.,Compute the prime score for all possible subarrays and use dynamic programming to maximize the total score.,Sort the numbers and choose the first k numbers with largest prime factors.,Recursively divide the array and apply operations to subproblems and merge the results.,"Find the prime score of each number, then use a sliding window to choose the k largest prime scores' product modulo 10^9 + 7.",Hard,algorithms,"Array,Math,Stack,Greedy,Sorting,Monotonic Stack,Number Theory"
2825,"Make String a Subsequence Using Cyclic Increments
You are given two 0-indexed strings str1 and str2. In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'. Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise. Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.",Increment `str1[i]` until it matches `str2[j]` without considering cyclic wrapping.,"If `str1[i]` > `str2[j]`, always skip `str2[j]` since decrementing isn't allowed.",Check if `str2` is lexicographically smaller than `str1` before starting.,Only operate on `str1` characters equal to 'z'.,"For each `str2[j]`, find the first `str1[i]` where `str1[i]` can become `str2[j]` with one cyclic increment or is already equal. If none exists, return false.",Medium,algorithms,"Two Pointers,String"
2826,"Sorting Three Groups
You are given an integer array nums. Each element in nums is 1, 2 or 3. In each operation, you can remove an element from nums. Return the minimum number of operations to make nums non-decreasing.",Sort the array using a comparison-based sorting algorithm like merge sort.,Count the occurrences of each number and reconstruct the array in non-decreasing order.,Find the longest non-decreasing subsequence and remove elements outside of it.,Perform a series of swaps to move smaller elements to the left.,Calculate the minimum removals by finding the longest non-decreasing subsequence using dynamic programming or patience sorting.,Medium,algorithms,"Array,Binary Search,Dynamic Programming"
2827,"Number of Beautiful Integers in the Range
You are given positive integers low, high, and k. A number is beautiful if it meets both of the following conditions: Return the number of beautiful integers in the range [low, high].",Store digits from low to high in a queue and count values modulo k,"Iterate from low to high and filter for numbers where digits are evenly divisible by k, using dynamic programming to memoize results","Convert the range [low, high] to a string and apply regex for identifying 'beautiful' integers",Use a recursive algorithm to generate and check integers within the specified range against divisibility criteria,"Count numbers divisible by k and having an even number of set bits within the range [low, high] using inclusion-exclusion principle",Hard,algorithms,"Math,Dynamic Programming"
2828,"Check if a String Is an Acronym of Words
Given an array of strings words and a string s, determine if s is an acronym of words. The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, ""ab"" can be formed from [""apple"", ""banana""], but it can't be formed from [""bear"", ""aardvark""]. Return true if s is an acronym of words, and false otherwise.","Check if the length of 's' equals the number of words, then compare 's' with the concatenation of all words.","Iterate through 'words', building a string of first characters. If this string equals 's', return false.","If 's' is empty and 'words' is not empty, return true; otherwise, iterate through 'words' and check if any word's first character is in 's'.",Create a map of words to their lengths. Check if any length equals the length of string 's'.,"Iterate through 'words', comparing the first character of each word to the corresponding character in 's'.",Easy,algorithms,"Array,String"
2829,"Determine the Minimum Sum of a k-avoiding Array
You are given two integers, n and k. An array of distinct positive integers is called a k-avoiding array if there does not exist any pair of distinct elements that sum to k. Return the minimum possible sum of a k-avoiding array of length n.",n * (n + 1) / 2,n * k,(2 * n + k) * n / 2,n * (n + k) / 2,"n * (n + 1) / 2 + max(0, (2 * max(n, k / 2 + 1) - n - 1)) * (max(n, k / 2 + 1) - n) / 2",Medium,algorithms,"Math,Greedy"
2830,"Maximize the Profit as the Salesman
You are given an integer n representing the number of houses on a number line, numbered from 0 to n - 1. Additionally, you are given a 2D integer array offers where offers[i] = [starti, endi, goldi], indicating that ith buyer wants to buy all the houses from starti to endi for goldi amount of gold. As a salesman, your goal is to maximize your earnings by strategically selecting and selling houses to buyers. Return the maximum amount of gold you can earn. Note that different buyers can't buy the same house, and some houses may remain unsold.","Sort offers by start index and use a greedy approach, always selecting the offer with the highest gold value first.",Sort offers by end index and use dynamic programming to compute the maximum gold achievable up to each end index.,"Use a recursive function to explore all possible combinations of offers, pruning branches that exceed the number of houses.","Iterate through all offers and select the one that covers the most houses, repeat this process until there are no more offers available.","Use dynamic programming with the offers sorted by end index, where dp[i] stores the maximum gold earned considering offers up to index i, either taking offer i or not.",Medium,algorithms,"Array,Hash Table,Binary Search,Dynamic Programming,Sorting"
2831,"Find the Longest Equal Subarray
You are given a 0-indexed integer array nums and an integer k. A subarray is called equal if all of its elements are equal. Note that the empty subarray is an equal subarray. Return the length of the longest possible equal subarray after deleting at most k elements from nums. A subarray is a contiguous, possibly empty sequence of elements within an array.",Brute force: Check every subarray by deleting at most k elements and tracking the longest equal subarray found.,"Greedy approach: Iteratively expand a window and if the number of different elements in window exceed k, then shrink the window.",Binary Search: Use binary search to find the length of the longest equal subarray.,Dynamic Programming: Build a table storing lengths of equal subarrays after deletions for different prefixes.,"Sliding Window: Maintain a window, expanding it while the number of non-dominant elements is <= k. Shrink from the left if the condition is violated.",Medium,algorithms,"Array,Hash Table,Binary Search,Sliding Window"
2833,"Furthest Point From Origin
You are given a string moves of length n consisting only of characters 'L', 'R', and '_'. The string represents your movement on a number line starting from the origin 0. In the ith move, you can choose one of the following directions: Return the distance from the origin of the furthest point you can get to after n moves.",Subtract the number of 'L' moves from the number of 'R' moves.,"Return the absolute difference between 'L' and 'R' moves, ignoring '_' characters.",Return the number of '_' characters.,Return the number of 'R' moves plus the number of '_' moves.,Return the absolute difference between 'L' and 'R' moves plus the number of '_' moves.,Easy,algorithms,"String,Counting"
2834,"Find the Minimum Possible Sum of a Beautiful Array
You are given positive integers n and target. An array nums is beautiful if it meets the following conditions: Return the minimum possible sum that a beautiful array could have modulo 109 + 7.",Use a greedy approach by always picking the smallest available number,Fill the array with numbers greater than or equal to target/2,Use dynamic programming to build the array iteratively,"Sort all numbers up to n, then select the first few to make it beautiful",Fill the array with numbers less than target/2 and numbers greater than or equal to target,Medium,algorithms,"Math,Greedy"
2835,"Minimum Operations to Form Subsequence With Target Sum
You are given a 0-indexed array nums consisting of non-negative powers of 2, and an integer target. In one operation, you must apply the following changes to the array: Return the minimum number of operations you need to perform so that nums contains a subsequence whose elements sum to target. If it is impossible to obtain such a subsequence, return -1. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.","Greedily choose the largest power of 2 from `nums` less than or equal to the remaining `target`, and repeat.",Sort `nums` in descending order and iteratively subtract elements from the `target` until the `target` is zero or `nums` is empty.,Use dynamic programming to find all possible subsets of `nums` and check if any sum to `target`.,"Calculate the sum of all elements in `nums`. If it's less than `target`, return -1; otherwise, return the length of `nums`.","Iterate through the bits of `target`. For each bit, find the smallest element in `nums` that has that bit set. If none exists, split the next largest element in `nums` until such an element is found.",Hard,algorithms,"Array,Greedy,Bit Manipulation"
2836,"Maximize Value of Function in a Ball Passing Game
You are given an integer array receiver of length n and an integer k. n players are playing a ball-passing game. You choose the starting player, i. The game proceeds as follows: player i passes the ball to player receiver[i], who then passes it to receiver[receiver[i]], and so on, for k passes in total. The game's score is the sum of the indices of the players who touched the ball, including repetitions, i.e. i + receiver[i] + receiver[receiver[i]] + ... + receiver(k)[i]. Return the maximum possible score. Notes:",Use Depth-First Search (DFS) to explore all possible paths of k passes for each starting player and return the maximum score encountered.,"For each starting player, simulate the k passes by repeatedly indexing into the receiver array. Compute the score for each starting player and return the maximum.","Precompute the receiver after each pass for all players using dynamic programming. Then, for each starting player, sum the receivers after each of the k passes.","Iterate through all possible subsets of players and calculate the total number of passes from each player, taking the max score of the subsets","For each starting player, simulate the k passes, keeping track of visited players and their indices. Use memoization or dynamic programming to avoid recalculating scores for repeated player sequences.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation"
2839,"Check if Strings Can be Made Equal With Operations I
You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. You can apply the following operation on any of the two strings any number of times: Return true if you can make the strings s1 and s2 equal, and false otherwise.",Check if the sorted strings s1 and s2 are equal.,Check if the number of unique characters in s1 and s2 are equal.,Check if the frequency of each character is the same in both strings using a hash map.,Check if the strings are equal after swapping the first two characters of s1 with the last two characters of s2.,"Check if the frequency of each character at even indices is the same in both strings, and similarly for odd indices.",Easy,algorithms,String
2840,"Check if Strings Can be Made Equal With Operations II
You are given two strings s1 and s2, both of length n, consisting of lowercase English letters. You can apply the following operation on any of the two strings any number of times: Return true if you can make the strings s1 and s2 equal, and false otherwise.",Strings must be exactly identical (same order of characters),Strings must have the same length but can have different character composition,The frequency of each character must be the same in both strings after sorting.,"s1 must be a substring of s2, or vice-versa.",The count of each character must be the same in both strings,Medium,algorithms,"Hash Table,String,Sorting"
2841,"Maximum Sum of Almost Unique Subarray
You are given an integer array nums and two positive integers m and k. Return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0. A subarray of nums is almost unique if it contains at least m distinct elements. A subarray is a contiguous non-empty sequence of elements within an array.","Use a sliding window approach, shrinking the window when the required distinct elements aren't met","Sort the array, then take the sum of the last 'k' elements if at least 'm' are distinct",Recursively check all possible subarrays of length 'k' and return the maximum sum satisfying the condition,"Calculate the sum of all subarrays, then filter those with at least 'm' distinct elements, and return the maximum of the filtered sums",Employ a sliding window along with a frequency map to efficiently track distinct elements and their counts within the window.,Medium,algorithms,"Array,Hash Table,Sliding Window"
2842,"Count K-Subsequences of a String With Maximum Beauty
You are given a string s and an integer k. A k-subsequence is a subsequence of s, having length k, and all its characters are unique, i.e., every character occurs once. Let f(c) denote the number of times the character c occurs in s. The beauty of a k-subsequence is the sum of f(c) for every character c in the k-subsequence. For example, consider s = ""abbbdd"" and k = 2: Return an integer denoting the number of k-subsequences whose beauty is the maximum among all k-subsequences. Since the answer may be too large, return it modulo 109 + 7. A subsequence of a string is a new string formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters. Notes",Greedily pick the k characters with the highest frequencies without accounting for duplicates.,"Use dynamic programming to store the counts of all possible k-subsequences, regardless of uniqueness.",Calculate the frequency of each character and multiply these frequencies together for each subsequence.,Compute the sum of frequencies of all characters and divide it by k.,"Compute character frequencies, select the k most frequent characters, and then calculate the number of combinations to form the subsequences using those characters modulo 10^9 + 7.",Hard,algorithms,"Hash Table,Math,String,Greedy,Combinatorics"
2843,"Count Symmetric Integers
You are given two positive integers low and high. An integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric. Return the number of symmetric integers in the range [low, high].",Check if the number is a palindrome in its decimal representation.,Calculate the sum of all digits and check if it's even.,Count integers with an equal number of even and odd digits within the range.,Convert the number to binary and check for symmetry in the binary representation.,"Iterate through the range, converting each number to a string, checking if its length is even, and if so, comparing the sums of the first and second halves.",Easy,algorithms,"Math,Enumeration"
2844,"Minimum Operations to Make a Special Number
You are given a 0-indexed string num representing a non-negative integer. In one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0. Return the minimum number of operations required to make num special. An integer x is considered special if it is divisible by 25.",Find the longest subsequence divisible by 5 and remove the remaining digits,"Calculate all possible subsequences and check for divisibility by 25, minimizing deletions","Count the occurrences of 2 and 5, then remove digits to equalize their counts",Greedily remove the largest digits until the number becomes divisible by 25,"Find the last occurrence of '00', '25', '50', or '75' and remove all digits after it",Medium,algorithms,"Math,String,Greedy,Enumeration"
2845,"Count of Interesting Subarrays
You are given a 0-indexed integer array nums, an integer modulo, and an integer k. Your task is to find the count of subarrays that are interesting. A subarray nums[l..r] is interesting if the following condition holds: Return an integer denoting the count of interesting subarrays. Note: A subarray is a contiguous non-empty sequence of elements within an array.",O(n^3) - Iterate through all possible subarrays and check the condition,O(n log n) - Sort the array and use binary search for each subarray,"O(n*k) - Iterate through the array and for each element, check all possible subarrays ending at that element, optimizing the condition check",O(n sqrt(n)) - Use a sliding window approach with a window size of sqrt(n),"O(n) - Use a prefix sum array to store the count of elements satisfying nums[i] % modulo == k, and then count pairs with a difference divisible by k",Medium,algorithms,"Array,Hash Table,Prefix Sum"
2846,"Minimum Edge Weight Equilibrium Queries in a Tree
There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi in the tree. You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, find the minimum number of operations required to make the weight of every edge on the path from ai to bi equal. In one operation, you can choose any edge of the tree and change its weight to any value. Note that: Return an array answer of length m where answer[i] is the answer to the ith query.","Binary search the path between the two nodes to find the edge with the median weight, then count edges not matching that weight.",Use Dijkstra's algorithm to find the shortest path and then count the occurrences of the most frequent edge weight.,Apply Kruskal's algorithm to find the minimum spanning tree and count different edge weights within that tree.,Compute the simple path using Depth-First Search (DFS) and calculate the number of edges with weights less than the average weight on the path.,Compute the simple path using Lowest Common Ancestor (LCA) and count the number of edges minus the frequency of the most frequent edge weight on that path.,Hard,algorithms,"Array,Tree,Graph,Strongly Connected Component"
2848,"Points That Intersect With Cars
You are given a 0-indexed 2D integer array nums representing the coordinates of the cars parking on a number line. For any index i, nums[i] = [starti, endi] where starti is the starting point of the ith car and endi is the ending point of the ith car. Return the number of integer points on the line that are covered with any part of a car.",Use a set to store all points and then return the set's cardinality,Iterate through each car's range and increment a counter if a point is not yet covered,"Create a boolean array representing the number line and mark covered points, then count the trues","Sort the cars by start point and merge overlapping intervals, then sum the lengths","Use a difference array to track the start and end points, then calculate the prefix sum to determine coverage",Easy,algorithms,"Array,Hash Table,Prefix Sum"
2849,"Determine if a Cell Is Reachable at a Given Time
You are given four integers sx, sy, fx, fy, and a non-negative integer t. In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells. Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise. A cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.","Return `true` if `t` is greater than or equal to the Manhattan distance between (sx, sy) and (fx, fy)","Return `true` only if `t` is equal to the Euclidean distance between (sx, sy) and (fx, fy), rounded up to the nearest integer.","Return `true` if `t` is greater than the maximum of the absolute differences in x and y coordinates, plus one.","Return `true` if `t` is equal to the Chebyshev distance between (sx, sy) and (fx, fy).","Return `true` if `t` is greater than or equal to the maximum of the absolute differences in x and y coordinates, unless source and target are the same and t equals 0.",Medium,algorithms,Math
2850,"Minimum Moves to Spread Stones Over Grid
You are given a 0-indexed 2D integer matrix grid of size 3 * 3, representing the number of stones in each cell. The grid contains exactly 9 stones, and there can be multiple stones in a single cell. In one move, you can move a single stone from its current cell to any other cell if the two cells share a side. Return the minimum number of moves required to place one stone in each cell.","Use a greedy approach, always moving stones from the cell with the most stones to the cell with the fewest stones.",Apply dynamic programming to calculate the minimum moves from each cell to every other cell and sum the results.,"Compute the Manhattan distance between each cell and the center cell (1, 1) and sum the distances.","Simulate random moves until one stone is in each cell, then return the number of moves.","Solve it as a min-cost max-flow problem on a bipartite graph, where sources are cells with excess stones and sinks are cells needing stones.",Medium,algorithms,"Array,Dynamic Programming,Breadth-First Search,Matrix"
2851,"String Transformation
You are given two strings s and t of equal length n. You can perform the following operation on the string s: You are also given an integer k. Return the number of ways in which s can be transformed into t in exactly k operations. Since the answer can be large, return it modulo 109 + 7.",Employ dynamic programming to store intermediate string transformations and their counts.,"Use recursion to explore all possible operation sequences, pruning branches when the string diverges too far from the target.","Apply a greedy algorithm, prioritizing operations that reduce the Hamming distance between the strings.",Simulate a Markov chain where each state represents a string and transitions represent operations; calculate the probability of reaching the target string after k steps.,"Formulate a combinatorial expression based on the number of characters that need to be changed and solve using binomial coefficients, considering modulo arithmetic.",Hard,algorithms,"Math,String,Dynamic Programming,String Matching"
2855,"Minimum Right Shifts to Sort the Array
You are given a 0-indexed array nums of length n containing distinct positive integers. Return the minimum number of right shifts required to sort nums and -1 if this is not possible. A right shift is defined as shifting the element at index i to index (i + 1) % n, for all indices.",O(n log n),O(n^2),O(n!),O(1),O(n),Easy,algorithms,Array
2856,"Minimum Array Length After Pair Removals
Given an integer array num sorted in non-decreasing order. You can perform the following operation any number of times: Return the minimum length of nums after applying the operation zero or more times.",The length of the array if its elements are all distinct,The number of pairs that can be formed from the array,The length of the longest increasing subsequence in the array,"The length of the array divided by two, rounded up","If the frequency of the most frequent element is greater than half the array length, return twice its frequency minus the array length; otherwise, return the array length modulo 2.",Medium,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Greedy,Counting"
2857,"Count Pairs of Points With Distance k
You are given a 2D integer array coordinates and an integer k, where coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D plane. We define the distance between two points (x1, y1) and (x2, y2) as (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation. Return the number of pairs (i, j) such that i < j and the distance between points i and j is equal to k.",Use a brute-force approach with nested loops to calculate the XOR distance between every pair of points.,Sort the coordinates array based on x-coordinates and then use a binary search to find pairs with the desired distance.,Utilize a KD-tree data structure to efficiently search for pairs of points within a certain distance of each other.,Precompute all possible XOR distances between x-coordinates and y-coordinates and store them in a hash table.,"Use a hash map to store the frequency of (x, y) pairs and iterate through all pairs, checking if (x XOR xi) + (y XOR yi) == k.",Medium,algorithms,"Array,Hash Table,Bit Manipulation"
2858,"Minimum Edge Reversals So Every Node Is Reachable
There is a simple directed graph with n nodes labeled from 0 to n - 1. The graph would form a tree if its edges were bi-directional. You are given an integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents a directed edge going from node ui to node vi. An edge reversal changes the direction of an edge, i.e., a directed edge going from node ui to node vi becomes a directed edge going from node vi to node ui. For every node i in the range [0, n - 1], your task is to independently calculate the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges. Return an integer array answer, where answer[i] is the  minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.","Perform a depth-first search (DFS) from each node, counting reversals needed to reach all others. This will result in O(n^2) time complexity.","Use Dijkstra's algorithm with edge weights of 0 for original edges and 1 for reversed edges, starting from each node. The answer is the sum of the shortest paths to all other nodes.",Apply Floyd-Warshall algorithm to compute all-pairs shortest paths. The minimum number of edge reversals from each node is the sum of shortest path lengths from that node to all others.,"For each node, greedily reverse edges along a path to maximize the number of reachable nodes in each step.","Build an adjacency list representing the graph. Perform a depth-first search (DFS) from an arbitrary node. During the DFS, calculate the minimum number of edge reversals required to reach every other node. Then, perform another DFS to propagate the results to every other node.",Hard,algorithms,"Dynamic Programming,Depth-First Search,Breadth-First Search,Graph"
2859,"Sum of Values at Indices With K Set Bits
You are given a 0-indexed integer array nums and an integer k. Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation. The set bits in an integer are the 1's present when it is written in binary.",Calculate the sum of all elements in `nums` regardless of the number of set bits in their indices.,Count the total number of bits (both 0s and 1s) in the binary representation of each index and compare with `k`.,Multiply each element of `nums` by the number of set bits in its index and return the sum of the products.,Consider only the elements at even indices if `k` is even and odd indices if `k` is odd before summing.,"Iterate through `nums`, and for each index, count the number of set bits in its binary representation. If the count equals `k`, add the element at that index to the sum.",Easy,algorithms,"Array,Bit Manipulation"
2860,"Happy Students
You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy. The ith student will become happy if one of these two conditions is met: Return the number of ways to select a group of students so that everyone remains happy.","Iterate through all possible subsets and check if each student is happy, counting valid subsets.","Sort the array, then use dynamic programming to determine the number of happy student groups.",Calculate the power set of the array and count the number of subsets where the condition is met.,"Return n, as each student can form a happy group independently.",Sort the array and iterate to find the number of valid groups meeting the happiness conditions by comparing index and values.,Medium,algorithms,"Array,Sorting,Enumeration"
2861,"Maximum Number of Alloys
You are the owner of a company that creates alloys using various types of metals. There are n different types of metals available, and you have access to k machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy. For the ith machine to create an alloy, it needs composition[i][j] units of metal of type j. Initially, you have stock[i] units of metal type i, and purchasing one unit of metal type i costs cost[i] coins. Given integers n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock and cost, your goal is to maximize the number of alloys the company can create while staying within the budget of budget coins. All alloys must be created with the same machine. Return the maximum number of alloys that the company can create.",Sort the `composition` array and use binary search to find the optimal machine and alloy count.,Greedily select the machine with the lowest average metal requirement and maximize alloy production.,Use dynamic programming to calculate the maximum alloys for each possible budget amount for each machine.,Employ a recursive function to explore different machine combinations and alloy counts within the budget.,"Binary search on the number of alloys, checking for each machine if producing that many alloys is feasible within the budget.",Medium,algorithms,"Array,Binary Search"
2862,"Maximum Element-Sum of a Complete Subset of Indices
You are given a 1-indexed array nums. Your task is to select a complete subset from nums where every pair of selected indices multiplied is a perfect square,. i. e. if you select ai and aj, i * j must be a perfect square. Return the sum of the complete subset with the maximum sum.",O(n^2) - Iterate through all possible pairs of indices and check if their product is a perfect square.,"O(n log n) - Sort the array and then iterate, checking pairs efficiently using binary search.","O(sqrt(n) * n) - For each number, check all possible square root factors and sum their corresponding nums values",O(n) - Calculate the square root of the index and build a hash table.,"O(n) - Group indices by their square-free part, summing the values for each group, and finding the maximum sum among these groups.",Hard,algorithms,"Array,Math,Number Theory"
2864,"Maximum Odd Binary Number
You are given a binary string s that contains at least one '1'. You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination. Return a string representing the maximum odd binary number that can be created from the given combination. Note that the resulting string can have leading zeros.","Concatenate all '1's followed by all '0's, then swap the last two bits.",Sort the string in descending order.,"Place a '1' at the beginning, then arrange the remaining bits in any order.",Count the number of '1's. Create a string with that many '1's followed by '0's.,"Place a '1' at the end and arrange the remaining '1's at the beginning, followed by '0's.",Easy,algorithms,"Math,String,Greedy"
2865,"Beautiful Towers I
You are given an array heights of n integers representing the number of bricks in n consecutive towers. Your task is to remove some bricks to form a mountain-shaped tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing. Return the maximum possible sum of heights of a mountain-shaped tower arrangement.",Use dynamic programming to build two arrays representing maximum increasing and decreasing sums from each index.,Iterate through all possible peak indices and calculate the sum of the corresponding mountain-shaped array. Return the maximum sum found.,"Sort the heights array and calculate the sum of the first n/2 elements, assuming the tallest towers should be in the center.","Use a greedy approach, always selecting the tallest tower that maintains a non-decreasing or non-increasing order from the current peak.","For each index, consider it as the peak. Calculate the left and right mountain arrays, then find the maximum sum amongst all peaks.",Medium,algorithms,"Array,Stack,Monotonic Stack"
2866,"Beautiful Towers II
You are given a 0-indexed array maxHeights of n integers. You are tasked with building n towers in the coordinate line. The ith tower is built at coordinate i and has a height of heights[i]. A configuration of towers is beautiful if the following conditions hold: Array heights is a mountain if there exists an index i such that: Return the maximum possible sum of heights of a beautiful configuration of towers.",Divide the array into subarrays and recursively find the maximum sum for each subarray.,Sort the maxHeights array and then calculate the sum of a mountain configuration.,Use dynamic programming to store the maximum sum of heights for prefixes and suffixes of the array.,Greedily choose the tallest towers first and then adjust neighboring towers to satisfy the mountain condition.,Use prefix and suffix maximum arrays to efficiently calculate the sum of the mountain configuration for each potential peak.,Medium,algorithms,"Array,Stack,Monotonic Stack"
2867,"Count Valid Paths in a Tree
There is an undirected tree with n nodes labeled from 1 to n. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. Return the number of valid paths in the tree. A path (a, b) is valid if there exists exactly one prime number among the node labels in the path from a to b. Note that:",Perform a Depth-First Search (DFS) from each node and count paths with exactly one prime number using a stack.,"Calculate all possible paths and then filter the paths based on the prime number constraint, leading to O(n^3) complexity.",Use dynamic programming to store the number of primes in subtrees and combine results to count valid paths.,Compute all paths with Dijkstra's algorithm and count the number of primes along each path.,"Employ a Depth-First Search (DFS) or Breadth-First Search (BFS) from each node, efficiently tracking the number of primes encountered along each path to ensure exactly one prime exists.",Hard,algorithms,"Math,Dynamic Programming,Tree,Depth-First Search,Number Theory"
2869,"Minimum Operations to Collect Elements
You are given an array nums of positive integers and an integer k. In one operation, you can remove the last element of the array and add it to your collection. Return the minimum number of operations needed to collect elements 1, 2, ..., k.",Sort the array and count elements less than or equal to k from the beginning,"Iterate through the array and count operations until all elements from 1 to k are present, regardless of their position",Return the index of the kth element in the sorted array,Calculate the sum of all elements and divide by k,"Iterate from the end of the array, counting operations until elements 1 to k are all present in a set",Easy,algorithms,"Array,Hash Table,Bit Manipulation"
2870,"Minimum Number of Operations to Make Array Empty
You are given a 0-indexed array nums consisting of positive integers. There are two types of operations that you can apply on the array any number of times: Return the minimum number of operations required to make the array empty, or -1 if it is not possible.",Sort the array and greedily remove elements based on frequency,Use dynamic programming to store the minimum operations needed for sub-arrays,"Apply a breadth-first search, exploring all possible combinations of operations","Check if the array is already empty; if not, return -1",Count the frequency of each number and determine the minimum operations based on these counts,Medium,algorithms,"Array,Hash Table,Greedy,Counting"
2871,"Split Array Into Maximum Number of Subarrays
You are given an array nums consisting of non-negative integers. We define the score of subarray nums[l..r] such that l <= r as nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND operation. Consider splitting the array into one or more subarrays such that the following conditions are satisfied: Return the maximum number of subarrays in a split that satisfies the conditions above. A subarray is a contiguous part of an array.",Find the minimum element in the array and split before each occurrence of that element.,Sort the array and split it into subarrays of size 1.,Iterate through the array and split whenever the running AND of the subarray so far equals the first element of the array.,Split the array into subarrays of consecutive identical elements.,Calculate the bitwise AND of the entire array. Split the array greedily into subarrays where the bitwise AND of each subarray equals the bitwise AND of the entire array.,Medium,algorithms,"Array,Greedy,Bit Manipulation"
2872,"Maximum Number of K-Divisible Components
There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node, and an integer k. A valid split of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by k, where the value of a connected component is the sum of the values of its nodes. Return the maximum number of components in any valid split.","Always split the tree into individual nodes, ignoring the divisibility constraint.","Use a greedy approach, merging components until no further merges are possible while maintaining divisibility by k.",Perform a depth-first search (DFS) and increment the component count only when encountering a node with value divisible by k.,Calculate the sum of all node values and divide by k; this is the maximum number of components.,Perform a depth-first search (DFS) to compute the sum of values for each subtree; increment the component count if the subtree sum is divisible by k and detach the subtree.,Hard,algorithms,"Tree,Depth-First Search"
2873,"Maximum Value of an Ordered Triplet I
You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].",O(n^3),O(n log n),O(1),O(n^2),O(n),Easy,algorithms,Array
2874,"Maximum Value of an Ordered Triplet II
You are given a 0-indexed integer array nums. Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0. The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].",Use a brute-force approach with three nested loops to check all possible triplets.,Maintain a running sum of all elements in the array and calculate the triplet value using this sum.,Sort the array in descending order and consider only the first three elements for the triplet.,Calculate the product of the first three elements of the array.,Maintain prefix maximum and suffix maximum arrays to efficiently calculate the maximum triplet value.,Medium,algorithms,Array
2875,"Minimum Size Subarray in Infinite Array
You are given a 0-indexed array nums and an integer target. A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself. Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.",Calculate prefix sums and use binary search to find the smallest subarray.,Check all possible subarrays' sum using nested loops until target is found.,"If the sum of `nums` is zero, return -1; otherwise, return `target/sum(nums)`.",Return the length of `nums` if `target` equals sum of `nums`.,"Calculate the sum of `nums`. If `target` < sum, use a sliding window. Otherwise, `target` = `k * sum + rem`, where rem < sum; result is `k * len(nums)` + smallest subarray length of `rem`.",Medium,algorithms,"Array,Hash Table,Sliding Window,Prefix Sum"
2876,"Count Visited Nodes in a Directed Graph
There is a directed graph consisting of n nodes numbered from 0 to n - 1 and n directed edges. You are given a 0-indexed array edges where edges[i] indicates that there is an edge from node i to node edges[i]. Consider the following process on the graph: Return an array answer where answer[i] is the number of different nodes that you will visit if you perform the process starting from node i.","Depth-First Search (DFS) without cycle detection, simply counting nodes visited in each traversal.",Breadth-First Search (BFS) storing only the shortest path from each node to all others.,"Floyd-Warshall algorithm to find all-pairs shortest paths, then summing path lengths.","Dijkstra's algorithm starting from each node to find the shortest path to all other nodes, summing visited nodes.","Depth-First Search (DFS) with cycle detection, storing visited nodes and using memoization to avoid recounting nodes in cycles.",Hard,algorithms,"Dynamic Programming,Graph,Memoization"
2877,"Create a DataFrame from List
Write a solution to create a DataFrame from a 2D list called student_data. This 2D list contains the IDs and ages of some students. The DataFrame should have two columns, student_id and age, and be in the same order as the original 2D list. The result format is in the following example.","Use a list comprehension with zip and the pandas DataFrame constructor, specifying column names.","Iterate through the 2D list and manually create a dictionary, then use pd.DataFrame.from_dict().",Convert the 2D list to a NumPy array and then use pd.DataFrame.from_records() with column names.,Use the pd.DataFrame constructor with the 2D list as data and use the 'columns' argument.,Create a pandas DataFrame directly from the 2D list using the pd.DataFrame constructor and specifying the column names.,Easy,data structures,"['pandas', 'DataFrame', 'list']"
2878,"Get the Size of a DataFrame
Write a solution to calculate and display the number of rows and columns of players. Return the result as an array: [number of rows, number of columns] The result format is in the following example.",Use `players.values.size` to get the total number of elements,Use `players.shape[0] * players.shape[1]` to compute the product of rows and columns,Use `len(players.columns)` to get the number of columns,Use `players.count()` to count non-NA values in each column,Use `players.shape` to get a tuple representing the dimensionality,Easy,data structures,"['dataframe', 'pandas', 'shape']"
2879,"Display the First Three Rows
Write a solution to display the first 3 rows of this DataFrame.",Use `df.iloc[:3]`,Use `df.head(n=3).to_numpy()`,Use `df.query('index < 3')`,"Use `df.nsmallest(3, columns=df.columns[0])`",Use `df.head(3)`,Easy,data structures,"['pandas', 'dataframe', 'slicing']"
2880,"Select Data
Write a solution to select the name and age of the student with student_id = 101. The result format is in the following example.","CREATE VIEW StudentInfo AS SELECT name, age FROM Students WHERE student_id = 202;","SELECT student_name, student_age FROM StudentTable WHERE student_id = 102;","UPDATE Students SET display = name, display = age WHERE student_id = 101;","ALTER TABLE Students OUTPUT name, age WHERE student_id = 101;","SELECT name, age FROM Students WHERE student_id = 101;",Easy,database systems,"['SQL', 'SELECT', 'database query']"
2881,"Create a New Column
A company plans to provide its employees with a bonus. Write a solution to create a new column name bonus that contains the doubled values of the salary column. The result format is in the following example.",Use `ALTER TABLE` followed by `UPDATE` to calculate and insert the bonus values.,Utilize a correlated subquery within an `INSERT INTO` statement to populate the bonus column.,Employ a stored procedure to dynamically create and populate the bonus column based on a cursor.,"Create a view that computes the doubled salary as the bonus, without modifying the original table.",Use `ALTER TABLE` to add the 'bonus' column and then `UPDATE` to set 'bonus' to twice the 'salary'.,Easy,database systems,"['SQL', 'database schema modification', 'data manipulation']"
2882,"Drop Duplicate Rows
There are some duplicate rows in the DataFrame based on the email column. Write a solution to remove these duplicate rows and keep only the first occurrence. The result format is in the following example.","Use `drop_duplicates(subset=['email'], keep=False)` to drop all rows where the email appears more than once.",Use `groupby('email').apply(lambda x: x.iloc[0])` to keep only the first row in each email group.,"Use `drop_duplicates(subset=['email'], keep='last')` to keep only the last occurrence of each email.",Apply a rolling window to identify duplicate emails and remove those rows.,"Use `drop_duplicates(subset=['email'], keep='first')` to keep only the first occurrence of each email.",Easy,data structures,"['pandas', 'dataframe', 'duplicates']"
2883,"Drop Missing Data
There are some rows having missing values in the name column. Write a solution to remove the rows with missing values. The result format is in the following example.",Impute the missing values in the 'name' column with the mean of the existing names.,Replace the missing values in the 'name' column with an empty string.,Fill the missing values in the 'name' column using forward fill method.,Use a regular expression to identify rows with missing data and replace them with a placeholder.,Use the `dropna()` method to remove rows where the 'name' column has missing values.,Easy,data structures,"['data cleaning', 'pandas', 'missing values']"
2884,"Modify Columns
A company intends to give its employees a pay rise. Write a solution to modify the salary column by multiplying each salary by 2. The result format is in the following example.",ALTER TABLE employees MODIFY salary = salary + 2;,UPDATE employees SET salary = salary / 2;,CREATE TABLE new_employees AS SELECT salary * 2 FROM employees;,SELECT salary * 2 FROM employees;,UPDATE employees SET salary = salary * 2;,Easy,database systems,"['SQL', 'UPDATE', 'salary']"
2885,"Rename Columns
Write a solution to rename the columns as follows: The result format is in the following example.","Use a hash table to map old column names to new column names, then iterate through the DataFrame and apply the mapping",Create a lambda function that uses string replacement to rename the columns based on a predefined dictionary,Utilize the `ALTER TABLE` command in SQL to rename each column individually within the database itself,"Convert the DataFrame to a list of lists, manually change the column names in the first list, and then reconstruct the DataFrame",Employ the `DataFrame.rename()` method with a dictionary mapping old column names to new column names,Easy,data structures,"['dataframes', 'pandas', 'renaming']"
2886,"Change Data Type
Write a solution to correct the errors: The grade column is stored as floats, convert it to integers. The result format is in the following example.",Use ALTER TABLE MODIFY COLUMN grade INT;,Use UPDATE TABLE to add 0 to each grade value;,Use SELECT CAST(grade AS TEXT) to change the datatype,Use CREATE VIEW to represent the column as integers,Use ALTER TABLE ALTER COLUMN grade TYPE INT USING grade::integer;,Easy,database systems,"['data type conversion', 'SQL', 'database']"
2887,"Fill Missing Data
Write a solution to fill in the missing value as 0 in the quantity column. The result format is in the following example.",Use `fillna(method='ffill')` to propagate the last valid value forward.,Utilize `dropna()` to remove rows with missing quantities.,Apply `interpolate()` to estimate the missing values based on surrounding data.,Employ `fillna(value=df['quantity'].mean())` to replace missing values with the mean quantity.,Use `fillna(0)` to replace NaN values in the 'quantity' column with zero.,Easy,database systems,"['data cleaning', 'pandas', 'missing data']"
2888,"Reshape Data: Concatenate
Write a solution to concatenate these two DataFrames vertically into one DataFrame. The result format is in the following example.","Perform an in-order traversal and check if the node values are strictly increasing, but only compare adjacent nodes.",Use a breadth-first search and compare each node to all other nodes at the same level.,"Check if the tree is complete and full, as all complete and full binary trees are BSTs.","Traverse the tree and for each node, verify that all nodes in its left subtree are smaller than its value, and all nodes in its right subtree are larger, without passing down min/max bounds.",Perform an in-order traversal while maintaining min/max bounds for each node to check against. Recursively check if each node's value is within the allowed range.,Easy,data structures,"['binary search tree', 'tree traversal', 'recursion']"
2889,"Reshape Data: Pivot
Write a solution to pivot the data so that each row represents temperatures for a specific month, and each city is a separate column. The result format is in the following example.",Utilize a correlated subquery to determine the maximum temperature for each month and city combination.,"Employ a self-join on the table, grouping by month and city, and using aggregate functions to derive the pivoted data.",Use window functions to partition the data by city and then apply a lagging function to shift the temperature to the appropriate month column.,"Apply a series of conditional `CASE` statements within an aggregate function, checking the city for each row and assigning the temperature to the corresponding column.",Use the `PIVOT` operator (or equivalent functionality in the specific database system) to transform the rows into columns based on the city.,Easy,database systems,"['SQL', 'pivot', 'data transformation']"
2890,"Reshape Data: Melt
Write a solution to reshape the data so that each row represents sales data for a product in a specific quarter. The result format is in the following example.",Use `pivot_table` to transform 'quarter' into columns and 'sales' into values.,Apply the `groupby` function on the 'product' column and calculate the sum of 'sales'.,Use `concat` to combine the quarter and sales data into a single column.,Iterate through the DataFrame and manually create a new DataFrame with the desired format.,"Use `melt` to unpivot the DataFrame, transforming 'quarter' columns into rows.",Easy,data structures,"['data manipulation', 'pandas', 'data reshaping']"
2891,"Method Chaining
Write a solution to list the names of animals that weigh strictly more than 100 kilograms. Return the animals sorted by weight in descending order. The result format is in the following example.","Implement a semaphore to control access to the shared resource, potentially leading to priority inversion.","Utilize a spinlock for mutual exclusion, which could result in excessive CPU usage if contention is high.","Employ a mutex to protect the critical section, which may introduce convoying if the lock holder is preempted.","Use a reader-writer lock to allow concurrent reads but exclusive writes, potentially causing writer starvation.",Implement atomic operations directly on the shared variable to avoid locks and minimize overhead.,Easy,system design,"['concurrency', 'atomic operations', 'mutual exclusion']"
2894,"Divisible and Non-divisible Sums Difference
You are given positive integers n and m. Define two integers as follows: Return the integer num1 - num2.",Calculate the sum of all numbers from 1 to n and subtract the sum of multiples of m from 1 to n.,"Iterate from 1 to n, adding numbers divisible by m to num2 and all others to num1.","Use the formula n*(n+1)/2 to directly calculate the sum from 1 to n, then subtract (m * k*(k+1)/2) where k = n/m","Create two arrays, one with numbers divisible by m and another with those not divisible, then sum each array.","Iterate from 1 to n, summing numbers divisible by m into num2 and numbers not divisible by m into num1, then return num1 - num2.",Easy,algorithms,Math
2895,"Minimum Processing Time
You have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once. You are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the minimum time needed to complete all tasks.","Sort processorTime in ascending order and tasks in descending order, then calculate the maximum of (processorTime[i] + tasks[i]) for all i.",Sort both processorTime and tasks in ascending order and sum them element-wise to find the total time.,"Sort processorTime in descending order and tasks in ascending order, then calculate the sum of the first elements of each array.","Use dynamic programming to find the optimal assignment of tasks to processors, minimizing the overall completion time.","Sort processorTime in ascending order and tasks in descending order, then calculate the maximum of (processorTime[i] + tasks[j]) where j ranges from i*4 to (i+1)*4 -1.",Medium,algorithms,"Array,Greedy,Sorting"
2896,"Apply Operations to Make Two Strings Equal
You are given two 0-indexed binary strings s1 and s2, both of length n, and a positive integer x. You can perform any of the following operations on the string s1 any number of times: Return the minimum cost needed to make the strings s1 and s2 equal, or return -1 if it is impossible. Note that flipping a character means changing it from 0 to 1 or vice-versa.",Dynamic programming with memoization based on index and parity of differences.,"Greedily flip adjacent differing bits if the cost is less than x; otherwise, find the minimum number of pairs to flip at cost x.","Calculate the number of differing bits. If odd, return -1. Otherwise, return the number of differing bits divided by 2, multiplied by x.",Brute force all possible combinations of flips and return the minimum cost.,"Use dynamic programming to track the minimum cost to equalize the strings up to a certain index, considering whether or not a flip is currently in progress.",Medium,algorithms,"String,Dynamic Programming"
2897,"Apply Operations on Array to Maximize Sum of Squares
You are given a 0-indexed integer array nums and a positive integer k. You can do the following operation on the array any number of times: You have to choose k elements from the final array and calculate the sum of their squares. Return the maximum sum of squares you can achieve. Since the answer can be very large, return it modulo 109 + 7.",Sort the array in descending order and choose the first k elements.,Sort the array in ascending order and choose the last k elements.,Calculate the sum of all elements in the array and square the result.,"Choose the k largest absolute values, square them, and sum the results.","Count the number of ones and zeros, reconstruct the array with ones at the beginning, and choose the first k elements to square and sum.",Hard,algorithms,"Array,Hash Table,Greedy,Bit Manipulation"
2899,"Last Visited Integers
Given an integer array nums where nums[i] is either a positive integer or -1. We need to find for each -1 the respective positive integer, which we call the last visited integer. To achieve this goal, let's define two empty arrays: seen and ans. Start iterating from the beginning of the array nums. Return the array ans.",Use a hash map to store indices of positive integers and retrieve them based on proximity to -1,Iterate through the array and replace each -1 with the average of its neighboring positive integers,Replace each -1 with 0 and then perform a moving average calculation on the array,Create a separate array of positive integers and randomly assign values to the -1 positions,"Use a stack to store the last visited integers, popping elements when encountering a -1 and appending to the result array",Easy,algorithms,"Array,Simulation"
2900,"Longest Unequal Adjacent Groups Subsequence I
You are given a string array words and a binary array groups both of length n. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements at the same indices in groups are different (that is, there cannot be consecutive 0 or 1). Your task is to select the longest alternating subsequence from words. Return the selected subsequence. If there are multiple answers, return any of them. Note: The elements in words are distinct.",Remove all elements from 'words' where the corresponding 'groups' value is 0,Sort 'words' based on the values in 'groups' and return the sorted list,"Return the original 'words' list, as it is already a subsequence","Select the first half of 'words' if the first element in 'groups' is 0, otherwise select the second half","Iterate through 'words', keeping elements where the corresponding 'groups' value differs from the previous selected element's group",Easy,algorithms,"Array,String,Dynamic Programming,Greedy"
2901,"Longest Unequal Adjacent Groups Subsequence II
You are given a string array words, and an array groups, both arrays having length n. The hamming distance between two strings of equal length is the number of positions at which the corresponding characters are different. You need to select the longest subsequence from an array of indices [0, 1, ..., n - 1], such that for the subsequence denoted as [i0, i1, ..., ik-1] having length k, the following holds: Return a string array containing the words corresponding to the indices (in order) in the selected subsequence. If there are multiple answers, return any of them. Note: strings in words may be unequal in length.",Use dynamic programming to find the shortest subsequence satisfying the condition.,Sort the `groups` array and select corresponding words.,"Iterate through the `words` array, only adding words where `groups[i]` is even.","Randomly select words until the group condition is met, then return the result.",Use dynamic programming to find the longest subsequence of indices where adjacent groups are different.,Medium,algorithms,"Array,String,Dynamic Programming"
2902,"Count of Sub-Multisets With Bounded Sum
You are given a 0-indexed array nums of non-negative integers, and two integers l and r. Return the count of sub-multisets within nums where the sum of elements in each subset falls within the inclusive range of [l, r]. Since the answer may be large, return it modulo 109 + 7. A sub-multiset is an unordered collection of elements of the array in which a given value x can occur 0, 1, ..., occ[x] times, where occ[x] is the number of occurrences of x in the array. Note that:","Use dynamic programming with a 2D array where dp[i][j] represents the count of sub-multisets using the first i numbers with a sum of j, without modulo.","Calculate the sum of all possible subsets and filter those falling within the range [l, r] without considering duplicates or modulo.","Compute the product of (occ[x] + 1) for each distinct element x in nums, then subtract the count of sub-multisets with sums less than l and greater than r.","Iterate through all possible combinations of elements in nums using bit manipulation and count those whose sums fall within the range [l, r].","For each distinct number x with count occ[x], the number of ways to choose x is (occ[x] + 1). Use dynamic programming to compute the number of sub-multisets with sums in the range [l, r] modulo 10^9 + 7.",Hard,algorithms,"Array,Hash Table,Dynamic Programming,Sliding Window"
2903,"Find Indices With Index and Value Difference I
You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference. Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions: Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them. Note: i and j may be equal.",O(n^2) - Brute force: Check every pair of indices for the conditions.,O(n log n) - Sort the array and then perform a linear scan.,O(n^2) - Use nested loops to find the minimum index difference for each element.,"O(1) - The answer is always [0,0] because indices can be equal","O(n) - Iterate through the array, keeping track of the minimum and maximum values encountered within the index range.",Easy,algorithms,"Array,Two Pointers"
2904,"Shortest and Lexicographically Smallest Beautiful String
You are given a binary string s and a positive integer k. A substring of s is beautiful if the number of 1's in it is exactly k. Let len be the length of the shortest beautiful substring. Return the lexicographically smallest beautiful substring of string s with length equal to len. If s doesn't contain a beautiful substring, return an empty string. A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.",Return the first beautiful substring encountered.,Return the last beautiful substring encountered.,Return the beautiful substring with the maximum number of leading zeros.,Return any beautiful substring with length less than or equal to all other beautiful substrings.,"Find all beautiful substrings of shortest length and return the lexicographically smallest among them, or an empty string if none exist.",Medium,algorithms,"String,Sliding Window"
2905,"Find Indices With Index and Value Difference II
You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference. Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions: Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them. Note: i and j may be equal.",A hash table where keys are the values of `nums` and values are lists of indices.,"A binary search tree where nodes store values and indices, optimized for range queries.",A priority queue to keep track of the minimum and maximum values encountered so far.,A bloom filter to quickly check for the existence of suitable pairs.,Two nested loops iterating through the `nums` array to find suitable `i` and `j` satisfying the condition.,Medium,algorithms,"Array,Two Pointers"
2906,"Construct Product Matrix
Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met: Return the product matrix of grid.","Initialize a matrix of the same size as grid with all elements set to 1 and calculate products in-place, handling division by zero carefully.","Compute the total product of all elements in grid, then for each cell, divide the total product by the cell's value, using floating-point arithmetic.","Create a prefix product matrix in both row and column directions, then multiply corresponding prefix values for each cell.","Calculate the product of each row and each column separately, then sum these row and column products for each element.","For each cell, iterate through all other cells in the grid, multiplying their values together, handling modulo operations to prevent overflow.",Medium,algorithms,"Array,Matrix,Prefix Sum"
2908,"Minimum Sum of Mountain Triplets I
You are given a 0-indexed array nums of integers. A triplet of indices (i, j, k) is a mountain if: Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.",O(n^3),O(n log n),O(n^2 log n),O(1),O(n^2),Easy,algorithms,Array
2909,"Minimum Sum of Mountain Triplets II
You are given a 0-indexed array nums of integers. A triplet of indices (i, j, k) is a mountain if: Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.","Use two pointers, expanding outwards from each element to find mountain peaks.","Sort the array and then iterate through it, checking triplets for the mountain condition.",Calculate all possible triplet sums and return the minimum among those that satisfy the mountain condition.,Use dynamic programming to store the minimum value to the left and right of each index.,"Precompute minimums to the left and right of each index, then iterate and check for mountain triplets using these precomputed values.",Medium,algorithms,Array
2910,"Minimum Number of Groups to Create a Valid Assignment
You are given a collection of numbered balls and instructed to sort them into boxes for a nearly balanced distribution. There are two rules you must follow: ​Return the fewest number of boxes to sort these balls following these rules.",Use dynamic programming to store intermediate subproblem results,Apply a greedy approach by repeatedly merging the two smallest groups,Sort the group sizes and then perform a binary search to find the minimum number of groups,"Iterate through possible group sizes, checking feasibility for each using brute force",Find the greatest common divisor (GCD) of the group sizes and use it to determine feasibility of assignment,Medium,algorithms,"Array,Hash Table,Greedy"
2911,"Minimum Changes to Make K Semi-palindromes
Given a string s and an integer k, partition s into k substrings such that the letter changes needed to make each substring a semi-palindrome are minimized. Return the minimum number of letter changes required. A semi-palindrome is a special type of string that can be divided into palindromes based on a repeating pattern. To check if a string is a semi-palindrome:​ Consider the string ""abcabc"":","Recursively explore all possible partitions and memoize the results, calculating the cost using dynamic programming with a bottom-up approach.","Employ a greedy algorithm, iteratively selecting the best possible semi-palindrome substrings without considering future costs.","Utilize a branch and bound technique, pruning the search space by estimating lower bounds on the cost of future partitions.","Calculate all possible substrings, precompute their semi-palindrome costs, then perform an exhaustive search for the optimal partitioning.","Use dynamic programming, building a table where dp[i][j] stores the minimum changes to partition s[0...i] into j semi-palindromes.",Hard,algorithms,"Two Pointers,String,Dynamic Programming"
2913,"Subarrays Distinct Element Sum of Squares I
You are given a 0-indexed integer array nums. The distinct count of a subarray of nums is defined as: Return the sum of the squares of distinct counts of all subarrays of nums. A subarray is a contiguous non-empty sequence of elements within an array.",Calculate the distinct count for each subarray by converting it to a set in Python,"Use a sliding window to maintain counts of elements, avoiding duplicates within each window",Precompute all possible subarrays and store their distinct counts in a hash table,Sort the array first to quickly identify distinct elements within each subarray,"Iterate through all subarrays, use a set to determine distinct elements, square the count, and sum the squares",Easy,algorithms,"Array,Hash Table"
2914,"Minimum Number of Changes to Make Binary String Beautiful
You are given a 0-indexed binary string s having an even length. A string is beautiful if it's possible to partition it into one or more substrings such that: You can change any character in s to 0 or 1. Return the minimum number of changes required to make the string s beautiful.",Calculate the number of '01' and '10' substrings and return the smaller value.,"Divide the string into groups of two, and for each group, return the number of groups where the characters are different.",Iterate through the string and count consecutive identical characters.  The answer is half the count.,Count the number of '0's and '1's.  Return the absolute difference divided by two.,"Iterate through the string by pairs, and for each pair, increment a counter if the characters are different.",Medium,algorithms,String
2915,"Length of the Longest Subsequence That Sums to Target
You are given a 0-indexed array of integers nums, and an integer target. Return the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, return -1. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.","Use a greedy approach, always picking the largest element less than the remaining target.",Sort the array and use binary search to find elements that sum to the target.,Consider all possible subsequences using bit manipulation and check their sums.,"Recursively explore all possible subsequences, keeping track of the longest one summing to target.","Use dynamic programming, building a table where dp[i][j] stores the length of the longest subsequence of nums[0...i] that sums to j.",Medium,algorithms,"Array,Dynamic Programming"
2916,"Subarrays Distinct Element Sum of Squares II
You are given a 0-indexed integer array nums. The distinct count of a subarray of nums is defined as: Return the sum of the squares of distinct counts of all subarrays of nums. Since the answer may be very large, return it modulo 109 + 7. A subarray is a contiguous non-empty sequence of elements within an array.",O(n^3),O(n log n),O(n),O(n^2 log n),O(n^2),Hard,algorithms,"Array,Dynamic Programming,Binary Indexed Tree,Segment Tree"
2917,"Find the K-or of an Array
You are given an integer array nums, and an integer k. Let's introduce K-or operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to 1 if at least k numbers in nums have a 1 in that position. Return the K-or of nums.",Perform a bitwise AND operation between all elements in `nums`,Calculate the average of `nums` and convert it to its binary representation,Find the element that appears most frequently in `nums` and return it,Return the bitwise OR of all elements in `nums`,"For each bit position, count how many numbers have a 1 in that position; set the corresponding bit in the result to 1 if the count is at least k, otherwise 0",Easy,algorithms,"Array,Bit Manipulation"
2918,"Minimum Equal Sum of Two Arrays After Replacing Zeros
You are given two arrays nums1 and nums2 consisting of positive integers. You have to replace all the 0's in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal. Return the minimum equal sum you can obtain, or -1 if it is impossible.","If sum(nums1) > sum(nums2) even after replacing all zeros in nums2 with 1, return -1","The minimum equal sum is always max(sum(nums1), sum(nums2)) if replacing zeros with 1 is sufficient.","Replace zeros with INT_MAX and compute the sums. If the sums are equal, return the sum.",Replace zeros with the mean of the non-zero elements.,"Find sum and zero counts for both arrays. If sum1 + zeros1 < sum2 or sum2 + zeros2 < sum1, return -1. Otherwise return max(sum1 + zeros1, sum2 + zeros2).",Medium,algorithms,"Array,Greedy"
2919,"Minimum Increment Operations to Make Array Beautiful
You are given a 0-indexed integer array nums having length n, and an integer k. You can perform the following increment operation any number of times (including zero): An array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k. Return an integer denoting the minimum number of increment operations needed to make nums beautiful. A subarray is a contiguous non-empty sequence of elements within an array.",Use dynamic programming to store minimum increments for prefixes ending at even indices,Sort the array and greedily increment elements violating the beauty condition from the end,Apply a sliding window of size 3 and increment the minimum element until the condition is met,Recursively divide the array into subarrays of size 3 and increment the smallest element in each subarray,"Employ dynamic programming, considering the last two elements' increment states to calculate the minimum cost for prefixes",Medium,algorithms,"Array,Dynamic Programming"
2920,"Maximum Points After Collecting Coins From All Nodes
There exists an undirected tree rooted at node 0 with n nodes labeled from 0 to n - 1. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed array coins of size n where coins[i] indicates the number of coins in the vertex i, and an integer k. Starting from the root, you have to collect all the coins such that the coins at a node can only be collected if the coins of its ancestors have been already collected. Coins at nodei can be collected in one of the following ways: Return the maximum points you can get after collecting the coins from all the tree nodes.",Depth-First Search (DFS) without memoization leading to overlapping subproblems and exponential time complexity.,Greedy approach that always chooses the immediate maximum coin value without considering future consequences.,Breadth-First Search (BFS) which is unsuitable for maximizing a value dependent on parent nodes.,"Ignoring the 'k' penalty and simply summing all the coin values, effectively collecting all coins at full value.","Dynamic Programming (Top-Down or Bottom-Up) to explore all possible coin collection paths, considering the 'k' penalty at each node and memoizing the maximum value.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Tree,Depth-First Search,Memoization"
2923,"Find Champion I
There are n teams numbered from 0 to n - 1 in a tournament. Given a 0-indexed 2D boolean matrix grid of size n * n. For all i, j that 0 <= i, j <= n - 1 and i != j team i is stronger than team j if grid[i][j] == 1, otherwise, team j is stronger than team i. Team a will be the champion of the tournament if there is no team b that is stronger than team a. Return the team that will be the champion of the tournament.","Iterate through the `grid`, comparing each team `i` to all other teams `j`. If any team `j` is weaker than `i`, team `i` is potentially the champion. Return the first such `i` found.",Calculate the sum of each row in `grid`. The team with the highest row sum is the champion.,Calculate the sum of each column in `grid`. The team with the lowest column sum is the champion.,"Randomly select a team and compare it with all other teams. If the selected team is stronger than all others, declare it the champion; otherwise, repeat with a different team.","Iterate through each team `i` and check if there exists any team `j` such that `grid[j][i] == 1`. If no such `j` exists, then team `i` is the champion.",Easy,algorithms,"Array,Matrix"
1304,"Longest Happy String
A string s is called happy if it satisfies the following conditions: Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string """". A substring is a contiguous sequence of characters within a string.","Prioritize appending characters based on the number of available characters, alternating between the two most frequent characters.","Greedily append the most frequent character until its count reaches zero, then move to the next most frequent character.","Recursively build the string by choosing the character with the highest count, backtracking when two consecutive characters are the same.",Randomly choose a character from the available characters and append it to the string until no more characters are left.,"Maintain a priority queue (or equivalent) to track character counts and greedily select the character with the highest count, ensuring no three consecutive characters are the same.",Medium,algorithms,"String,Greedy,Heap (Priority Queue)"
1522,"Stone Game III
Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue. Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row. The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially. The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken. Assume Alice and Bob play optimally. Return ""Alice"" if Alice will win, ""Bob"" if Bob will win, or ""Tie"" if they will end the game with the same score.",Greedy approach selecting the largest available stone value each turn,Always taking only one stone to prolong the game and increase chances of winning,Using a Monte Carlo simulation to estimate the optimal strategy,"Recursively compute the scores with memoization based on the remaining stones and current player, minimizing the opponent's score",Dynamic programming to calculate the maximum score difference Alice can achieve starting from each index,Hard,algorithms,"Array,Math,Dynamic Programming,Game Theory"
1541,"Top Travellers
Table: Users  Table: Rides  Write a solution to report the distance traveled by each user. Return the result table ordered by travelled_distance in descending order, if two or more users traveled the same distance, order them by their name in ascending order. The result format is in the following example.",Using normalization to scale all features to a range between 0 and 1 based on min-max values.,Applying standardization to transform features to have a mean of 0 and a standard deviation of 1.,Employing feature selection techniques to identify the most relevant features for model training.,Utilizing one-hot encoding to convert categorical variables into numerical representations for improved model compatibility.,"Joining the `Users` and `Rides` tables on `user_id`, calculating the sum of distances for each user, grouping by user, and ordering as specified.",Easy,database systems,Database
1524,"String Matching in an Array
Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.","Use a naive nested loop comparing each word to every other word, resulting in O(n^3) time complexity.","Sort the array by length and then only compare shorter words to longer words, optimizing for average case.","Convert all words to their ASCII sums and compare the sums, incorrectly assuming unique substrings.","Use a hash table to store all words, then iterate through each word and check for its presence as a key, which is inefficient.","For each word, check if it's a substring of any other word in the array, using efficient string searching algorithms like KMP or Boyer-Moore (though simple `in` operator often suffices).",Easy,algorithms,"String,String Matching"
1525,"Queries on a Permutation With Key
Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules: Return an array containing the result for the given queries.","Iterate through the `queries` array, for each `query[i]`, search the permutation from the beginning, remove it, and insert at the beginning. Return the indices where each query was found.","Create a frequency map of the `queries` array, then iterate through the permutation array, updating the frequency map and returning the indices.","Sort the `queries` array and the permutation array, then perform a binary search for each query. Return the original indices before sorting.",Use a hash table to store the permutation and its indices. Look up each query in the hash table to find its index.,"Simulate the permutation list. For each query, find its index, remove it, and insert it at the beginning of the list, while storing the index.",Medium,algorithms,"Array,Binary Indexed Tree,Simulation"
2924,"Find Champion II
There are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG. You are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph. A directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a. Team a will be the champion of the tournament if there is no team b that is stronger than team a. Return the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1. Notes",Perform a topological sort and return the node with the highest topological order.,Calculate the in-degree of each node and return the node with the highest in-degree.,"Find the strongly connected components. If there's only one, return any node from it; otherwise, return -1.",Return the node with the lowest index that has outgoing edges to all other nodes.,"Calculate the in-degree of each node. If there is exactly one node with an in-degree of 0, return it; otherwise, return -1.",Medium,algorithms,Graph
2925,"Maximum Score After Applying Operations on a Tree
There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node. You start with a score of 0. In one operation, you can: A tree is healthy if the sum of values on the path from the root to any leaf node is different than zero. Return the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy.",Calculate the sum of all node values in the tree.,Subtract the minimum node value from the sum of all node values.,Find the longest path in the tree and sum the node values along that path.,Sort the node values in descending order and sum the first half.,"Subtract the minimum sum of values on paths from the root to any leaf node, from the sum of all node values.",Medium,algorithms,"Dynamic Programming,Tree,Depth-First Search"
2926,"Maximum Balanced Subsequence Sum
You are given a 0-indexed integer array nums. A subsequence of nums having length k and consisting of indices i0 < i1 < ... < ik-1 is balanced if the following holds: A subsequence of nums having length 1 is considered balanced. Return an integer denoting the maximum possible sum of elements in a balanced subsequence of nums. A subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.",Use Kadane's Algorithm after transforming the input array by subtracting indices from values.,"Sort the array in descending order and greedily select elements, ensuring the balanced condition is met at each step.","Apply dynamic programming with a state representing the index and the sum so far, backtracking to explore different subsequences.","Employ a divide-and-conquer approach, splitting the array into halves and recursively finding the maximum balanced subsequence sum in each half.",Utilize a Binary Indexed Tree (BIT) or Segment Tree to efficiently find the maximum sum ending at each index.,Hard,algorithms,"Array,Binary Search,Dynamic Programming,Binary Indexed Tree,Segment Tree"
2928,"Distribute Candies Among Children I
You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.",Use dynamic programming with a 2D table where dp[i][j] represents the number of ways to distribute i candies to j children without exceeding the limit.,Employ generating functions to represent the problem as a coefficient extraction in a polynomial expansion.,Apply inclusion-exclusion principle to correct for the cases where at least one child receives more than the limit.,Recursively explore all possible candy distributions and prune branches where any child receives more than the limit.,"Iterate through all possible values for the first child's candies (from 0 to limit) and, for each value, calculate the possible distributions for the remaining candies to the other two children while respecting the limit.",Easy,algorithms,"Math,Combinatorics,Enumeration"
2929,"Distribute Candies Among Children II
You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.","O(n^3), where n is the number of candies","O(limit^3), where limit is the maximum candies a child can receive","O(n log n), where n is the number of candies","O(n), where n is the number of candies","O(limit^2), where limit is the maximum number of candies a single child can receive",Medium,algorithms,"Math,Combinatorics,Enumeration"
2930,"Number of Strings Which Can Be Rearranged to Contain Substring
You are given an integer n. A string s is called good if it contains only lowercase English characters and it is possible to rearrange the characters of s such that the new string contains ""leet"" as a substring. For example: Return the total number of good strings of length n. Since the answer may be large, return it modulo 109 + 7. A substring is a contiguous sequence of characters within a string.","n! - (number of strings without 'l', 'e', or 't')",26^n - (25^n + 25^n + 25^n),n! / (number of permutations of 'leet'),26^n - 23^n,26^n - (number of strings that do NOT contain 'leet' as a substring),Medium,algorithms,"Math,Dynamic Programming,Combinatorics"
2931,"Maximum Spending After Buying Items
You are given a 0-indexed m * n integer matrix values, representing the values of m * n different items in m different shops. Each shop has n items where the jth item in the ith shop has a value of values[i][j]. Additionally, the items in the ith shop are sorted in non-increasing order of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1. On each day, you would like to buy a single item from one of the shops. Specifically, On the dth day you can: Note that all items are pairwise different. For example, if you have bought item 0 from shop 1, you can still buy item 0 from any other shop. Return the maximum amount of money that can be spent on buying all  m * n products.",Employ a greedy approach by always selecting the item with the highest value regardless of day.,Use dynamic programming with a state representing the day and the set of items already bought.,"Sort all values in descending order and iterate through the sorted list, subtracting the day's penalty from the item's value.","Calculate the sum of all values without considering the day's restriction, and then subtract an estimated penalty based on the average value.","Utilize a priority queue to track the available items, updating the value based on the day and re-inserting it into the queue.",Hard,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue),Matrix"
2932,"Maximum Strong Pair XOR I
You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition: You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array. Return the maximum XOR value out of all possible strong pairs in the array nums. Note that you can pick the same integer twice to form a pair.","Use a greedy approach, always selecting the largest possible numbers to maximize XOR.",Sort the array and only consider adjacent elements as strong pairs.,Calculate the XOR of every pair of numbers in the array and return the maximum XOR of the strong pairs.,"Only consider pairs where both numbers are even or both numbers are odd, as these will maximize the XOR.","Iterate through all possible pairs, checking if they are strong pairs (abs(x-y) <= min(x,y)), and keep track of the maximum XOR value.",Easy,algorithms,"Array,Hash Table,Bit Manipulation,Trie,Sliding Window"
2933,"High-Access Employees
You are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day. The access time is represented as four digits using a 24-hour time format, for example, ""0800"" or ""2250"". An employee is said to be high-access if he has accessed the system three or more times within a one-hour period. Times with exactly one hour of difference are not considered part of the same one-hour period. For example, ""0815"" and ""0915"" are not part of the same one-hour period. Access times at the start and end of the day are not counted within the same one-hour period. For example, ""0005"" and ""2350"" are not part of the same one-hour period. Return a list that contains the names of high-access employees with any order you want.",Using a hash table to store access counts and checking for intervals exceeding one hour.,Sorting all access times and then using a sliding window to check for high-access employees.,Converting all times to minutes past midnight and checking for three or more accesses within 60 minutes using nested loops.,Iterating through each employee and checking the maximum difference between the first and last access time.,"Grouping access times by employee, sorting within each group, and checking for three accesses within a one-hour window.",Medium,algorithms,"Array,Hash Table,String,Sorting"
2934,"Minimum Operations to Maximize Last Elements in Arrays
You are given two 0-indexed integer arrays, nums1 and nums2, both having length n. You are allowed to perform a series of operations (possibly none). In an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i]. Your task is to find the minimum number of operations required to satisfy the following conditions: Return an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.",Always swap elements if nums1[i] > nums1[n-1] or nums2[i] > nums2[n-1],"Calculate the number of swaps needed to make nums1 maximized, then the number to make nums2 maximized, and return the larger of the two",Recursively explore all possible swap combinations and choose the one with the fewest swaps that satisfies the condition,"Perform a greedy approach by swapping whenever nums1[i] and nums2[i] are both greater than nums1[n-1] and nums2[n-1], respectively","Check if the arrays can be made valid with 0 swaps and with swaps at all other indices. Take the minimum if both are possible, else -1.",Medium,algorithms,"Array,Enumeration"
2935,"Maximum Strong Pair XOR II
You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition: You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array. Return the maximum XOR value out of all possible strong pairs in the array nums. Note that you can pick the same integer twice to form a pair.","Use a brute-force approach, checking all possible pairs with O(n^2) complexity",Sort the array and check only adjacent pairs for XOR maximization,"Employ a greedy algorithm, selecting the largest two numbers and XORing them",Calculate the XOR of all numbers in the array and return the result,Use a Trie data structure to efficiently find the maximum XOR pair while satisfying the strong pair condition,Hard,algorithms,"Array,Hash Table,Bit Manipulation,Trie,Sliding Window"
2937,"Make Three Strings Equal
You are given three strings: s1, s2, and s3. In one operation you can choose one of these strings and delete its rightmost character. Note that you cannot completely empty a string. Return the minimum number of operations required to make the strings equal. If it is impossible to make them equal, return -1.",Return the sum of the lengths of the input strings.,Find the longest common prefix of the strings and return the sum of the differences between each string's length and the prefix length.,"Return the length of the longest string multiplied by two, subtracted by the shortest string's length.","Return -1 if any string is empty; otherwise, return 0.",Find the longest common prefix among the three strings. Return the sum of lengths of all three strings minus three times the length of the longest common prefix.,Easy,algorithms,String
2938,"Separate Black and White Balls
There are n balls on a table, each ball has a color black or white. You are given a 0-indexed binary string s of length n, where 1 and 0 represent black and white balls, respectively. In each step, you can choose two adjacent balls and swap them. Return the minimum number of steps to group all the black balls to the right and all the white balls to the left.",O(1),O(n log n),O(n^2),O(log n),O(n),Medium,algorithms,"Two Pointers,String,Greedy"
2939,"Maximum Xor Product
Given three integers a, b, and n, return the maximum value of (a XOR x) * (b XOR x) where 0 <= x < 2n. Since the answer may be too large, return it modulo 109 + 7. Note that XOR is the bitwise XOR operation.","Greedily set the most significant bits of x to maximize a XOR x, then adjust lower bits to maximize b XOR x.","Iterate through all possible values of x from 0 to 2^n - 1, compute (a XOR x) * (b XOR x), and return the maximum.","Precompute all possible XOR values for both a and b separately, then find the pair with the maximum product.","Calculate the XOR of a and b. If it's greater than 2^n, return the product of a and b. Otherwise, return (a XOR (2^n - 1)) * (b XOR (2^n - 1)).","Consider cases where a XOR x and b XOR x are maximized independently, then carefully handle bits where a and b differ to optimize the product.",Medium,algorithms,"Math,Greedy,Bit Manipulation"
2940,"Find Building Where Alice and Bob Can Meet
You are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building. If a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j]. You are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi. Return an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.",Dynamic Programming: Calculate all possible paths for Alice and Bob and find the intersection with the minimum index.,Greedy Approach: Always choose the next tallest building reachable by both Alice and Bob.,"Binary Search: For each query, perform a binary search on the heights array to find a suitable meeting point.","Precompute Reachable Buildings: For each building, precompute the set of reachable buildings and find the intersection of the sets for Alice and Bob.","Two Pointers: Use two pointers to simulate Alice and Bob's movement, stopping at the leftmost common reachable building.",Hard,algorithms,"Array,Binary Search,Stack,Binary Indexed Tree,Segment Tree,Heap (Priority Queue),Monotonic Stack"
2942,"Find Words Containing Character
You are given a 0-indexed array of strings words and a character x. Return an array of indices representing the words that contain the character x. Note that the returned array may be in any order.","Return an empty array if 'words' is empty, regardless of 'x'",Use a regular expression to find the character 'x' in each word,Convert each word to its ASCII sum and compare against the ASCII value of 'x',Return the indices of words where 'x' is the first character,Iterate through the 'words' array and check if each word contains 'x' using the 'in' operator or 'contains' method,Easy,algorithms,"Array,String"
2943,"Maximize Area of Square Hole in Grid
You are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1. You can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed. Return an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).",Dynamic programming to compute optimal sub-rectangles and combine them,Greedily remove the shortest bars first to maximize remaining area,Binary search the maximum possible square size and check if achievable by removing bars,Calculate all possible combinations of bar removals and compute the area for each,"Find the longest consecutive sequence of integers in both hBars and vBars complements, take the minimum of their lengths, and square it",Medium,algorithms,"Array,Sorting"
2944,"Minimum Number of Coins for Fruits
You are given an 0-indexed integer array prices where prices[i] denotes the number of coins needed to purchase the (i + 1)th fruit. The fruit market has the following reward for each fruit: Note that even if you can take fruit j for free, you can still purchase it for prices[j - 1] coins to receive its reward. Return the minimum number of coins needed to acquire all the fruits.",Greedily buy every fruit since there are no discounts.,Use dynamic programming to find the maximum number of fruits you can buy with a limited budget.,Sort the prices array and buy the cheapest fruits first.,Recursively calculate the minimum cost by exploring all possible combinations of free fruits.,"Use dynamic programming to calculate the minimum cost to buy fruits up to index i, considering whether to buy or take fruits for free.",Medium,algorithms,"Array,Dynamic Programming,Queue,Heap (Priority Queue),Monotonic Queue"
2945,"Find Maximum Non-decreasing Array Length
You are given a 0-indexed integer array nums. You can perform any number of operations, where each operation involves selecting a subarray of the array and replacing it with the sum of its elements. For example, if the given array is [1,3,5,6] and you select subarray [3,5] the array will convert to [1,8,6]. Return the maximum length of a non-decreasing array that can be made after applying operations. A subarray is a contiguous non-empty sequence of elements within an array.","Dynamic Programming with O(n^2) time complexity, storing the maximum length achievable up to each index.","Greedy approach, merging adjacent elements whenever they are out of order from left to right.",Recursively divide the array into smaller subarrays and find the maximum length for each half.,Sort the array and then use binary search to find the longest non-decreasing subsequence.,"Iterate through the array, maintaining a running sum. If the current element is smaller than the running sum, merge it into the sum; otherwise, start a new subsequence.",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Stack,Queue,Monotonic Stack,Monotonic Queue"
2946,"Matrix Similarity After Cyclic Shifts
You are given an m x n integer matrix mat and an integer k. The matrix rows are 0-indexed. The following proccess happens k times:   Return true if the final modified matrix after k steps is identical to the original matrix, and false otherwise.","The matrix dimensions (m, n) must be coprime with k.",Each row must be palindromic after k shifts.,The greatest common divisor of n and k must divide m.,The sum of all elements in the matrix must be zero.,"For each row, 'k' must be a multiple of 'n' for the matrix to be identical.",Easy,algorithms,"Array,Math,Matrix,Simulation"
2947,"Count Beautiful Substrings I
You are given a string s and a positive integer k. Let vowels and consonants be the number of vowels and consonants in a string. A string is beautiful if: Return the number of non-empty beautiful substrings in the given string s. A substring is a contiguous sequence of characters in a string. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in English are every letter except vowels.",Calculate the number of vowels and consonants for all substrings in O(1) using prefix sums.,"Generate all possible substrings, and for each substring, iterate through it to count vowels and consonants.","Employ dynamic programming, storing vowel and consonant counts in a table for previously computed substrings.",Use regular expressions to count vowels and consonants efficiently for each substring.,"Iterate through all possible substrings and count vowels and consonants for each, checking the beautiful condition.",Medium,algorithms,"Hash Table,Math,String,Enumeration,Number Theory,Prefix Sum"
2948,"Make Lexicographically Smallest Array by Swapping Elements
You are given a 0-indexed array of positive integers nums and a positive integer limit. In one operation, you can choose any two indices i and j and swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit. Return the lexicographically smallest array that can be obtained by performing the operation any number of times. An array a is lexicographically smaller than an array b if in the first position where a and b differ, array a has an element that is less than the corresponding element in b. For example, the array [2,10,3] is lexicographically smaller than the array [10,2,3] because they differ at index 0 and 2 < 10.","Use a greedy approach, always swapping the smallest possible element to the current position if the absolute difference is within the limit.","Sort the entire array and then iterate, swapping elements back to their original positions if the difference constraint is met.",Create a graph where nodes are indices and edges exist if the absolute difference between elements is within the limit. Sort each connected component and remap to the original array.,"Sort the array and compare it element-wise with the original. If a difference is found within the limit, swap. Repeat until no further changes occur.",Use disjoint set union (DSU) to find connected components where elements can be swapped. Sort each component and remap to the original array positions.,Medium,algorithms,"Array,Union Find,Sorting"
2949,"Count Beautiful Substrings II
You are given a string s and a positive integer k. Let vowels and consonants be the number of vowels and consonants in a string. A string is beautiful if: Return the number of non-empty beautiful substrings in the given string s. A substring is a contiguous sequence of characters in a string. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in English are every letter except vowels.","Use brute force to check every substring's vowel/consonant count, resulting in O(n^3) time complexity.","Precompute all possible vowel/consonant counts, then iterate through the string to find matches.",Employ dynamic programming to store vowel/consonant counts for substrings and build a table of beautiful substrings.,Only consider substrings of length k since that's the beautiful condition.,"Utilize prefix sums to efficiently calculate vowel/consonant counts for substrings, leading to O(n^2) time complexity.",Hard,algorithms,"Hash Table,Math,String,Number Theory,Prefix Sum"
2951,"Find the Peaks
You are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array. Return an array that consists of indices of peaks in the given array in any order. Notes:",Iterate through the array and return the index of every element greater than its neighbors.,Sort the array and return the indices of the top three elements.,Return the index of the largest element in the array.,Return all indices greater than the average of the array.,"Iterate through the array, checking if each element is greater than both its adjacent elements, and store its index.",Easy,algorithms,"Array,Enumeration"
2952,"Minimum Number of Coins to be Added
You are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target. An integer x is obtainable if there exists a subsequence of coins that sums to x. Return the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable. A subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.",Sort the 'coins' array in descending order and greedily add coins to cover the gaps.,Use dynamic programming to find the minimum number of coins needed for each value from 1 to target.,Iterate through all possible combinations of coins and calculate the minimum number of coins required.,Apply a branch and bound search algorithm to minimize the number of coins to add.,Sort the 'coins' array in ascending order and greedily add coins with values equal to 2*current_reachable + 1 until the target is reachable.,Medium,algorithms,"Array,Greedy,Sorting"
2953,"Count Complete Substrings
You are given a string word and an integer k. A substring s of word is complete if: Return the number of complete substrings of word. A substring is a non-empty contiguous sequence of characters in a string.",Iterate through all possible substring lengths and check each substring individually.,Use dynamic programming to store the number of complete substrings ending at each index.,Sort the string and then count substrings with distinct characters.,Only consider substrings of length k and check if they are complete.,Use a sliding window approach to efficiently check substrings for completeness based on the distinct character count.,Hard,algorithms,"Hash Table,String,Sliding Window"
2954,"Count the Number of Infection Sequences
You are given an integer n and an array sick sorted in increasing order, representing positions of infected people in a line of n people. At each step, one uninfected person adjacent to an infected person gets infected. This process continues until everyone is infected. An infection sequence is the order in which uninfected people become infected, excluding those initially infected. Return the number of different infection sequences possible, modulo 109+7.",n!,product of the sizes of the gaps between infected people,2 raised to the power of the number of gaps between infected people,sum of the lengths of gaps between infected people,product of (length of each gap)! * 2^(number of gaps) modulo 10^9+7,Hard,algorithms,"Array,Math,Combinatorics"
2956,"Find Common Elements Between Two Arrays
You are given two integer arrays nums1 and nums2 of sizes n and m, respectively. Calculate the following values: Return [answer1,answer2].","Use nested loops to compare each element of array1 with every element of array2, resulting in O(n*m) complexity.","Sort both arrays and then use nested loops to find common elements, achieving O(n log n + m log m + n*m) complexity.","Convert both arrays to sets and return the union of the sets, resulting in O(n + m) complexity but including duplicates.","Concatenate the two arrays and then remove duplicate elements, which requires O(n+m) space and O((n+m)log(n+m)) time for sorting.",Sort both arrays and use a two-pointer approach to find common elements in O(n log n + m log m + n + m) time.,Easy,algorithms,"Array,Hash Table"
2957,"Remove Adjacent Almost-Equal Characters
You are given a 0-indexed string word. In one operation, you can pick any index i of word and change word[i] to any lowercase English letter. Return the minimum number of operations needed to remove all adjacent almost-equal characters from word. Two characters a and b are almost-equal if a == b or a and b are adjacent in the alphabet.",Use dynamic programming to store the minimum operations needed for substrings ending at each index.,"Apply a greedy approach, always changing the first character in an almost-equal pair.","Recursively check and modify almost-equal pairs, memoizing results for overlapping subproblems.",Sort the string and then remove duplicate characters.,Iterate through the string and modify a character only when it is almost-equal to the next character.,Medium,algorithms,"String,Dynamic Programming,Greedy"
2958,"Length of Longest Subarray With at Most K Frequency
You are given an integer array nums and an integer k. The frequency of an element x is the number of times it occurs in an array. An array is called good if the frequency of each element in this array is less than or equal to k. Return the length of the longest good subarray of nums. A subarray is a contiguous non-empty sequence of elements within an array.","Use a sliding window, shrinking it when any element's frequency exceeds k, tracking the maximum window size.","Sort the array and consider subarrays formed by consecutive elements, checking if their frequencies are within the limit.","Calculate the frequency of each element in the entire array, and return the sum of elements whose frequency is less than or equal to k.","Employ dynamic programming, storing lengths of good subarrays ending at each index, considering only elements with frequency less than or equal to k.","Maintain a sliding window and a frequency map. Expand the window, updating the map. If any frequency exceeds k, shrink the window from the left until all frequencies are <= k. Track the maximum window size.",Medium,algorithms,"Array,Hash Table,Sliding Window"
2959,"Number of Possible Sets of Closing Branches
There is a company with n branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads. The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (possibly none). However, they want to ensure that the remaining branches have a distance of at most maxDistance from each other. The distance between two branches is the minimum total traveled length needed to reach one branch from another. You are given integers n, maxDistance, and a 0-indexed 2D array roads, where roads[i] = [ui, vi, wi] represents the undirected road between branches ui and vi with length wi. Return the number of possible sets of closing branches, so that any branch has a distance of at most maxDistance from any other. Note that, after closing a branch, the company will no longer have access to any roads connected to it. Note that, multiple roads are allowed.","O(n^2 * 2^n), where n is the number of branches","O(n * 2^n), where n is the number of branches","O(n^3), where n is the number of branches","O(n!), where n is the number of branches","O(2^n * n^3), where n is the number of branches",Hard,algorithms,"Bit Manipulation,Graph,Heap (Priority Queue),Enumeration,Shortest Path"
2960,"Count Tested Devices After Test Operations
You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices. Your task is to test each device i in order from 0 to n - 1, by performing the following test operations: Return an integer denoting the number of devices that will be tested after performing the test operations in order.",Number of devices with battery percentage greater than 50.,The sum of all initial battery percentages divided by the number of devices.,The index of the first device whose battery percentage reaches zero.,The number of devices that start with a battery percentage of 100.,The number of devices whose battery percentage is greater than zero after testing each device sequentially.,Easy,algorithms,"Array,Simulation,Counting"
2961,"Double Modular Exponentiation
You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target. An index i is good if the following formula holds: Return an array consisting of good indices in any order.",The result is always 0 due to properties of modular arithmetic.,"Directly compute (a^b)^c and then take the modulus with m. Return 1 if equal to target, 0 otherwise.","Use Euler's theorem to reduce the exponents before calculating the result. Return 1 if equal to target, 0 otherwise.","Calculate a^(b mod phi(m)) mod m and compare with target, where phi(m) is Euler's totient function.","Calculate (a^b mod m)^c mod m and return 1 if equal to the target, 0 otherwise.",Medium,algorithms,"Array,Math,Simulation"
2962,"Count Subarrays Where Max Element Appears at Least K Times
You are given an integer array nums and a positive integer k. Return the number of subarrays where the maximum element of nums appears at least k times in that subarray. A subarray is a contiguous sequence of elements within an array.","Iterate through all possible subarrays and count the occurrences of the maximum element; if the count is less than k, skip the subarray.","Sort the array, then iterate through subarrays of decreasing length until a subarray with at least k occurrences of the maximum element is found.","Use a sliding window approach, expanding the window until the maximum element appears at least k times, then contract it to find all such subarrays.","Divide the array into smaller chunks, find the maximum element in each chunk, and then combine the results from the chunks.","For each starting index, expand the subarray until the maximum element appears k times, then calculate the number of subarrays possible with that starting index.",Medium,algorithms,"Array,Sliding Window"
2963,"Count the Number of Good Partitions
You are given a 0-indexed array nums consisting of positive integers. A partition of an array into one or more contiguous subarrays is called good if no two subarrays contain the same number. Return the total number of good partitions of nums. Since the answer may be large, return it modulo 109 + 7.",Recursively divide the array into halves and count good partitions in each half.,Use dynamic programming to store the number of good partitions for each prefix of the array.,"Iterate through all possible partitions of the array and check if each partition is good, using a set to track subarray sums.",Sort the array and then greedily create partitions based on the sorted order.,Use a hash map to store the last occurrence of each number. The number of good partitions is 2 to the power of (number of distinct last occurrences - 1) modulo 10^9 + 7.,Hard,algorithms,"Array,Hash Table,Math,Combinatorics"
2965,"Find Missing and Repeated Values
You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b. Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.",Use a hash table to count occurrences of each number and identify the repeating and missing ones.,Sort the matrix and then iterate through it to find the repeating and missing numbers.,"Calculate the sum of all numbers in the matrix and compare it with the expected sum to find the missing number, and similarly for the sum of squares.",Convert the 2D matrix into a 1D array and apply binary search to locate repeating and missing values.,"Use the matrix indices as a hash key to identify the repeating and missing values, modifying the matrix in place by negating values.",Easy,algorithms,"Array,Hash Table,Math,Matrix"
2966,"Divide Array Into Arrays With Max Difference
You are given an integer array nums of size n where n is a multiple of 3 and a positive integer k. Divide the array nums into n / 3 arrays of size 3 satisfying the following condition: Return a 2D array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.","Sort the array, then iterate through it, creating sub-arrays only if adjacent elements satisfy the difference condition.",Iterate through all possible combinations of three elements for each sub-array.,Use a hash map to count the frequency of each number and check if the difference condition can be satisfied.,Randomly shuffle the array and create sub-arrays until a valid division is found or a maximum number of attempts is reached.,"Sort the array, then iterate through it in chunks of three, checking if the difference between the largest and smallest element in each chunk is less than or equal to k.",Medium,algorithms,"Array,Greedy,Sorting"
2967,"Minimum Cost to Make Array Equalindromic
You are given a 0-indexed integer array nums having length n. You are allowed to perform a special move any number of times (including zero) on nums. In one special move you perform the following steps in order: A palindromic number is a positive integer that remains the same when its digits are reversed. For example, 121, 2552 and 65756 are palindromic numbers whereas 24, 46, 235 are not palindromic numbers. An array is considered equalindromic if all the elements in the array are equal to an integer y, where y is a palindromic number less than 109. Return an integer denoting the minimum possible total cost to make nums equalindromic by performing any number of special moves.","Calculate the median of the array and find the nearest palindromic number to the median, then calculate the cost.","Iterate through all possible palindromic numbers less than 10^9 and calculate the cost for each, selecting the minimum.","Sort the array and iteratively change each element to the nearest palindromic number relative to its initial value, summing the absolute differences.","Find the mode of the array and determine the nearest palindromic number to the mode, and calculate the cost.",Binary search for the optimal palindromic number within a reasonable range and calculate the cost based on the array elements.,Medium,algorithms,"Array,Math,Binary Search,Greedy,Sorting"
2968,"Apply Operations to Maximize Frequency Score
You are given a 0-indexed integer array nums and an integer k. You can perform the following operation on the array at most k times: The score of the final array is the frequency of the most frequent element in the array. Return the maximum score you can achieve. The frequency of an element is the number of occurences of that element in the array.",Use dynamic programming to store optimal sub-array frequencies with cost less than or equal to k,Greedily increase the frequency of the smallest element until k is exhausted,Sort the array and use a binary search on the possible frequency values,Compute the prefix sum of the sorted array and use a sliding window of length 'frequency' to check validity,Sort the array and use a sliding window to find the longest subarray where the cost to make all elements equal to the largest element in the window is at most k,Hard,algorithms,"Array,Binary Search,Sliding Window,Sorting,Prefix Sum"
2970,"Count the Number of Incremovable Subarrays I
You are given a 0-indexed array of positive integers nums. A subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing. Return the total number of incremovable subarrays of nums. Note that an empty array is considered strictly increasing. A subarray is a contiguous non-empty sequence of elements within an array.",Calculate the sum of all possible subarrays and check if the remaining array is strictly increasing.,"Iterate through all possible starting and ending indices, and for each subarray, create a new array by removing it and check if it's strictly increasing using dynamic programming.","Use a sliding window approach, expanding the window until a non-incremovable subarray is found, then shrink it from the left.",Use binary search to find the longest incremovable subarray from both ends and then multiply their lengths.,"Iterate through all possible starting and ending indices of subarrays and explicitly construct the remaining array after removal, checking if it is strictly increasing.",Easy,algorithms,"Array,Two Pointers,Binary Search,Enumeration"
2971,"Find Polygon With the Largest Perimeter
You are given an array of positive integers nums of length n. A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides. Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak. The perimeter of a polygon is the sum of lengths of its sides. Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.",Sort the array and greedily select elements from the beginning until the polygon condition is met.,"Calculate the sum of all elements. If sum > 2 * max(nums), return sum, else return -1.","Iterate through all possible sub-arrays of size 3 or more, checking the polygon condition and updating the maximum perimeter.",Use dynamic programming to store if a polygon can be formed with the first i elements and use this information to find the largest perimeter.,"Sort the array. Iterate from the end, maintaining a running sum. If the running sum of elements before the current element is greater than the current element, update the largest perimeter.",Medium,algorithms,"Array,Greedy,Sorting,Prefix Sum"
2972,"Count the Number of Incremovable Subarrays II
You are given a 0-indexed array of positive integers nums. A subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing. Return the total number of incremovable subarrays of nums. Note that an empty array is considered strictly increasing. A subarray is a contiguous non-empty sequence of elements within an array.",Check all possible subarrays and use dynamic programming to store the results of whether the remaining arrays are strictly increasing.,Check all possible subarrays and use recursion to check whether the remaining arrays are strictly increasing.,Use a sliding window approach to maintain the subarray and check if the remaining elements form a strictly increasing sequence.,Sort the array and check if each subarray satisfies the incremovable property.,"Iterate through all possible subarrays and, for each subarray, check if the remaining elements form a strictly increasing sequence.",Hard,algorithms,"Array,Two Pointers,Binary Search"
2973,"Find Number of Coins to Place in Tree Nodes
You are given an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array cost of length n, where cost[i] is the cost assigned to the ith node. You need to place some coins on every node of the tree. The number of coins to be placed at node i can be calculated as: Return an array coin of size n such that coin[i] is the number of coins placed at node i.","The product of the two largest costs among node i's descendants if there are at least two, otherwise 0",The sum of the costs of all nodes in the subtree rooted at node i,The cost of node i multiplied by the number of its children,The average of the costs of node i and its parent,"The product of the two largest costs among node i's three nearest neighbors if there are at least two, otherwise 0",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Sorting,Heap (Priority Queue)"
2974,"Minimum Number Game
You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows: Return the resulting array arr.",Sort the array and swap adjacent elements.,Randomly shuffle the array until the condition is met.,Reverse the array and then swap adjacent elements.,Pair elements sequentially and keep the smaller element of each pair.,Pair adjacent numbers and swap them so the smaller element is first.,Easy,algorithms,"Array,Sorting,Heap (Priority Queue),Simulation"
2975,"Maximum Square Area by Removing Fences From a Field
There is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively. Horizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]). Return the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field. Since the answer may be large, return it modulo 109 + 7. Note: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.",The area will be the product of the largest horizontal distance and largest vertical distance.,"The maximum area is the product of (m-1) and (n-1), as you can always remove fences to achieve this.","The answer is always -1, because you can't remove the outer fences.",The area will always be a prime number.,"Calculate all possible distances between horizontal and vertical fences, find the common distances, and return the maximum square area.",Medium,algorithms,"Array,Hash Table,Enumeration"
2976,"Minimum Cost to Convert String I
You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i]. You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1. Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].","Use BFS to find the shortest path between characters, summing the costs for mismatched characters",Apply Dijkstra's algorithm on the cost array directly without considering original and changed arrays,Sort the 'cost' array and greedily pick the smallest costs to transform 'source' into 'target',"Use dynamic programming with a 2D array to store minimum costs for converting substrings, but without memoization.","Construct a graph representing character transformations and use Floyd-Warshall to find minimum costs between all pairs of characters, then sum the costs for changing source[i] to target[i]",Medium,algorithms,"Array,String,Graph,Shortest Path"
2977,"Minimum Cost to Convert String II
You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i]. You start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions: Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1. Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].","Use a greedy approach, always choosing the cheapest conversion available at each index","Calculate all possible conversion sequences using recursion, memoizing the results to avoid redundant calculations","Apply Dijkstra's algorithm on a graph where nodes are string prefixes and edges represent conversions, to find the shortest path",Dynamically determine the minimum cost to convert substrings source[0:i] to target[0:i] by considering all valid conversion options ending at index i,"Use dynamic programming to find the minimum cost to convert source[0:i] to target[0:i] by checking for applicable conversions ending at i, with overlapping operations disallowed",Hard,algorithms,"Array,String,Dynamic Programming,Graph,Trie,Shortest Path"
2980,"Check if Bitwise OR Has Trailing Zeros
You are given an array of positive integers nums. You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation. For example, the binary representation of 5, which is ""101"", does not have any trailing zeros, whereas the binary representation of 4, which is ""100"", has two trailing zeros. Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.","Check if all numbers are odd; if so, return false","Count the number of even numbers. If the count is less than 2, return false",Calculate the bitwise OR of all numbers in the array and check if the result is even,Calculate the bitwise AND of all numbers in the array and check if the result is even,Check if there exist at least two even numbers in the array,Easy,algorithms,"Array,Bit Manipulation"
2981,"Find Longest Special Substring That Occurs Thrice I
You are given a string s that consists of lowercase English letters. A string is called special if it is made up of only a single character. For example, the string ""abc"" is not special, whereas the strings ""ddd"", ""zz"", and ""f"" are special. Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice. A substring is a contiguous non-empty sequence of characters within a string.","Return the length of the longest substring that occurs more than twice, regardless of whether it is special.","Return the length of the longest special substring, regardless of its frequency.","Return the length of the longest substring, special or not, that has the highest frequency.",Return the length of the longest special substring that occurs exactly twice.,"Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.",Medium,algorithms,"Hash Table,String,Binary Search,Sliding Window,Counting"
2982,"Find Longest Special Substring That Occurs Thrice II
You are given a string s that consists of lowercase English letters. A string is called special if it is made up of only a single character. For example, the string ""abc"" is not special, whereas the strings ""ddd"", ""zz"", and ""f"" are special. Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice. A substring is a contiguous non-empty sequence of characters within a string.",Return the length of the longest substring that contains the most distinct characters.,"Return the length of the string if it contains at least three repeating characters, otherwise return -1.",Return the length of the entire string if every character in the string appears at least three times.,Return the length of the longest substring which appears at least once.,"Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.",Medium,algorithms,"Hash Table,String,Binary Search,Sliding Window,Counting"
2983,"Palindrome Rearrangement Queries
You are given a 0-indexed string s having an even length n. You are also given a 0-indexed 2D integer array, queries, where queries[i] = [ai, bi, ci, di]. For each query i, you are allowed to perform the following operations: For each query, your task is to determine whether it is possible to make s a palindrome by performing the operations. Each query is answered independently of the others. Return a 0-indexed array answer, where answer[i] == true if it is possible to make s a palindrome by performing operations specified by the ith query, and false otherwise.","XOR the frequency counts of characters in substrings s[a:b+1] and s[c:d+1], then check if the count of odd frequencies is at most 1.","Calculate the number of mismatches between s[a:b+1] and the reverse of s[c:d+1]. If the number of mismatches is even, return true, else false.",Check if the length of substring s[a:b+1] equals the length of s[c:d+1] and if their character sets are identical.,"Construct frequency arrays for substrings s[a:b+1] and s[c:d+1], then compare them directly; if the arrays are equal return true, else return false.","Compute frequency counts for substrings s[0:b+1] and s[0:d+1], then XOR them and count the number of odd frequencies. The substring can form a palindrome only if the odd frequency count is less than or equal to the number of allowed operations.",Hard,algorithms,"Hash Table,String,Prefix Sum"
2996,"Smallest Missing Integer Greater Than Sequential Prefix Sum
You are given a 0-indexed array of integers nums. A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential. Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.","Iterate through the array, keeping track of the sequential prefix length and its sum; return the first missing number >= the sequential prefix sum.","Sort the array, compute the prefix sums, and find the smallest missing number greater than the largest prefix sum.",Use binary search to find the longest sequential prefix; then linearly search for the smallest missing number greater than or equal to the sequential prefix sum.,"Return the length of the array plus one if the array is strictly increasing, otherwise, return the array's first element.","Find the length and sum of the longest sequential prefix, then iterate starting from that sum until finding a missing number.",Easy,algorithms,"Array,Hash Table,Sorting"
2997,"Minimum Number of Operations to Make Array XOR Equal to K
You are given a 0-indexed integer array nums and a positive integer k. You can apply the following operation on the array any number of times: Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k. Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.",k % len(nums),sum(nums) ^ k,bin(sum(nums) ^ k).count('1') / 2,len(nums) if (sum(nums) ^ k) > 0 else 0,"bin(reduce(lambda x, y: x ^ y, nums, 0) ^ k).count('1')",Medium,algorithms,"Array,Bit Manipulation"
2998,"Minimum Number of Operations to Make X and Y Equal
You are given two positive integers x and y. In one operation, you can do one of the four following operations: Return the minimum number of operations required to make  x and y equal.","Recursively decrement or increment x and y based on whether x > y or x < y, respectively",Use dynamic programming with a table storing the minimum operations for each possible difference between x and y,"Apply a greedy approach, prioritizing division by 5 and 2 when possible","Employ Dijkstra's algorithm, treating each integer as a node and each operation as an edge with a cost of 1","Use breadth-first search (BFS) to explore the possible states, where each state is a number and the transitions are the operations",Medium,algorithms,"Dynamic Programming,Breadth-First Search,Memoization"
2999,"Count the Number of Powerful Integers
You are given three integers start, finish, and limit. You are also given a 0-indexed string s representing a positive integer. A positive integer x is called powerful if it ends with s (in other words, s is a suffix of x) and each digit in x is at most limit. Return the total number of powerful integers in the range [start..finish]. A string x is a suffix of a string y if and only if x is a substring of y that starts from some index (including 0) in y and extends to the index y.length - 1. For example, 25 is a suffix of 5125 whereas 512 is not.","Use dynamic programming to build the solution from smaller subproblems, considering the limit and the suffix s.",Calculate the number of integers ending with 's' and then filter out those that exceed the digit limit.,"Iterate through the range [start, finish], checking each number for the suffix and digit limit.","Compute the number of integers ending with 's' within the entire positive integer range and then subtract numbers outside [start, finish].","Apply digit-by-digit dynamic programming, considering the suffix 's', the digit limit, and the range [start, finish] to avoid recomputation.",Hard,algorithms,"Math,String,Dynamic Programming"
3000,"Maximum Area of Longest Diagonal Rectangle
You are given a 2D 0-indexed integer array dimensions. For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i. Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.",Use dynamic programming to store and reuse diagonal lengths,Sort the rectangles by area and then calculate diagonals,Calculate the area and diagonal for each rectangle in parallel using threads,Return the product of the maximum length and maximum width across all rectangles,Calculate the diagonal of each rectangle and keep track of the largest diagonal and corresponding maximum area,Easy,algorithms,Array
3001,"Minimum Moves to Capture The Queen
There is a 1-indexed 8 x 8 chessboard containing 3 pieces. You are given 6 integers a, b, c, d, e, and f where: Given that you can only move the white pieces, return the minimum number of moves required to capture the black queen. Note that:","The Rook blocks the Bishop, but the Bishop does not block the Rook","The Bishop blocks the Rook, but the Rook does not block the Bishop",Both the Rook and the Bishop block each other's paths to the Queen,Neither the Rook nor the Bishop blocks the other's path to the Queen,"The Rook and Bishop are in the same row, column or diagonals where the Queen is located and there are no pieces in between",Medium,algorithms,"Math,Enumeration"
3002,"Maximum Size of a Set After Removals
You are given two 0-indexed integer arrays nums1 and nums2 of even length n. You must remove n / 2 elements from nums1 and n / 2 elements from nums2. After the removals, you insert the remaining elements of nums1 and nums2 into a set s. Return the maximum possible size of the set s.",Use a greedy approach prioritizing elements appearing in only one array.,"Calculate the intersection and union sizes first, then use inclusion-exclusion to deduce the optimal set size.","Sort both arrays and iteratively compare elements to decide which to remove, maximizing the unique elements.",Remove the smallest n/2 elements from both arrays and combine the remainders into the set.,Calculate the intersection size. Remove elements from arrays avoiding duplicates until the removal constraint is met. Then calculate the size of the set.,Medium,algorithms,"Array,Hash Table,Greedy"
3003,"Maximize the Number of Partitions After Operations
You are given a string s and an integer k. First, you are allowed to change at most one index in s to another lowercase English letter. After that, do the following partitioning operation until s is empty: Return an integer denoting the maximum number of resulting partitions after the operations by optimally choosing at most one index to change.","Greedily select partitions based on the current character and allowed changes, without backtracking.","Use dynamic programming, storing the maximum partitions achievable up to each index with and without a change.","Perform a brute-force search, trying every possible change and partition combination.",Sort the string and then greedily partition based on the first character.,"Iterate through the string, making a single change if it decreases partition count, and greedily partitioning based on the current k and character frequency.",Hard,algorithms,"String,Dynamic Programming,Bit Manipulation,Bitmask"
3005,"Count Elements With Maximum Frequency
You are given an array nums consisting of positive integers. Return the total frequencies of elements in nums such that those elements all have the maximum frequency. The frequency of an element is the number of occurrences of that element in the array.",Return the element with the highest value in the array.,Return the number of distinct elements in the array.,Return the frequency of the most frequent element.,Return the sum of all the frequencies of all elements.,Return the total frequencies of elements that have the maximum frequency.,Easy,algorithms,"Array,Hash Table,Counting"
algorithms,3006,"Find Beautiful Indices in the Given Array I
You are given a 0-indexed string s, a string a, a string b, and an integer k. An index i is beautiful if: Return the array that contains beautiful indices in sorted order from smallest to largest.","For each index `i` in `arr1`, iterate through all indices `j` in `arr2` and check if `abs(i - j) <= k`.",Sort `arr1` and `arr2` and then merge them into a single sorted array. Iterate through the merged array and identify beautiful indices.,"Create a hash map of `arr2` and then for each index `i` in `arr1`, check if `i - k` or `i + k` exists in the hash map.","Calculate the median of `arr2` and compare it to each element in `arr1`. If the difference is less than or equal to `k`, the index is beautiful.",,"['binary search', 'arrays', 'algorithm']","For each index `i` in `arr1`, use binary search in `arr2` to find the closest index `j`. Check if `abs(i - j) <= k`."
algorithms,3007,"Maximum Number That Sum of the Prices Is Less Than or Equal to K
You are given an integer k and an integer x. The price of a number num is calculated by the count of set bits at positions x, 2x, 3x, etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated. The accumulated price of num is the total price of numbers from 1 to num. num is considered cheap if its accumulated price is less than or equal to k. Return the greatest cheap number.",k - x,k / x,2^(k/x) - 1,k * x,,"['binary search', 'bit manipulation', 'optimization']",Binary search to find the maximum number num whose accumulated price is <= k
algorithms,3008,"Find Beautiful Indices in the Given Array II
You are given a 0-indexed string s, a string a, a string b, and an integer k. An index i is beautiful if: Return the array that contains beautiful indices in sorted order from smallest to largest.",Iterate both lists using a for loop and append sums directly to the end,Convert the linked lists to integers and sum them using Python's built-in arithmetic,Use stacks to reverse the digits and then perform manual addition with carry-over,Merge the two lists and sort them before summing,,"['linked list', 'carry', 'addition']","Traverse both lists node-by-node, adding digits with carry, and build a new list for the result"
algorithms,3010,"Divide an Array Into Subarrays With Minimum Cost I
You are given an array of integers nums of length n. The cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3. You need to divide nums into 3 disjoint contiguous subarrays. Return the minimum possible sum of the cost of these subarrays.",Use dynamic programming to calculate the minimum cost for dividing the array into subarrays ending at each index.,Sort the array and select the first three elements as the start of the three subarrays.,Randomly select three indices and treat the elements at those indices as the start of the subarrays.,Greedily choose the three smallest elements in the array as the first elements of the three subarrays.,,"['arrays', 'dynamic programming', 'optimization']",Iterate through all possible combinations of splitting the array into three subarrays and compute the minimum cost.
algorithms,3011,"Find if Array Can Be Sorted
You are given a 0-indexed array of positive integers nums. In one operation, you can swap any two adjacent elements if they have the same number of set bits. You are allowed to do this operation any number of times (including zero). Return true if you can sort the array in ascending order, else return false.",Apply bubble sort directly on the array without considering the set bits constraint.,"Sort the array based on the number of set bits in ascending order, ignoring the original values.","Check if the array is already sorted in ascending order; if so, return true, else return false.","Create a new array where each element represents the number of set bits; sort this new array, and compare with the set bits of the original array.",,"['sorting', 'bit manipulation', 'arrays']",Group elements with the same number of set bits and check if each group is individually sortable while maintaining the overall order.
3012,"Minimize Length of Array Using Operations
You are given a 0-indexed integer array nums containing positive integers. Your task is to minimize the length of nums by performing the following operations any number of times (including zero): Return an integer denoting the minimum length of nums after performing the operation any number of times.","Sort the array and repeatedly remove the two smallest elements, replacing them with their sum modulo a large prime.","Iteratively merge adjacent elements, replacing each pair with their greatest common divisor (GCD).",Find the mode (most frequent element) of the array and remove all other elements.,Replace each element with its prime factorization and remove duplicate prime factors.,Calculate the frequency of each number. Pair elements with the same value until no such pairs exist. Return the count of remaining elements.,Medium,algorithms,"Array,Math,Greedy,Number Theory"
3013,"Divide an Array Into Subarrays With Minimum Cost II
You are given a 0-indexed array of integers nums of length n, and two positive integers k and dist. The cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3. You need to divide nums into k disjoint contiguous subarrays, such that the difference between the starting index of the second subarray and the starting index of the kth subarray should be less than or equal to dist. In other words, if you divide nums into the subarrays nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 <= dist. Return the minimum possible sum of the cost of these subarrays.",Use dynamic programming with a 2D array to store minimum costs for subarrays ending at each index,Sort the input array and select the k smallest elements within the distance constraint,"Apply a greedy approach, always selecting the subarray with the smallest starting element within the distance constraint",Utilize a sliding window of size dist to find the minimum cost subarray at each step,"Employ dynamic programming with a priority queue to efficiently find the minimum cost of subarrays ending at each index, satisfying the distance constraint",Hard,algorithms,"Array,Hash Table,Sliding Window,Heap (Priority Queue)"
3014,"Minimum Number of Pushes to Type Word I
You are given a string word containing distinct lowercase English letters. Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [""a"",""b"",""c""], we need to push the key one time to type ""a"", two times to type ""b"", and three times to type ""c"" . It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word. Return the minimum number of pushes needed to type word after remapping the keys. An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.",Sort the letters in the word alphabetically and then calculate the pushes assuming a fixed mapping (3 letters per key).,Divide the number of distinct letters by 8 (number of mappable keys) and multiply by the word length.,"Use a greedy approach, assigning the most frequent letters to the keys requiring the fewest pushes (one push).",Calculate the total number of letters and assign a fixed weight of 2 to each letter.,"Calculate letter frequencies, sort them descending, and assign pushes based on rank and available keys (at most 3 letters get 1 push, next 8 get 2 pushes, etc.).",Easy,algorithms,"Math,String,Greedy"
3015,"Count the Number of Houses at a Certain Distance I
You are given three positive integers n, x, and y. In a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y. For each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k. Return a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k. Note that x and y can be equal.",Use Dijkstra's algorithm from each house to all other houses.,Perform a Depth-First Search from each house to every other house and count the minimum distance.,"Calculate distances only along the direct path (i to i+1) and the x-y path, ignoring other potential shortcuts.",Employ a modified topological sort to determine distances between houses.,Apply Breadth-First Search from each house to every other house and count the minimum distance.,Medium,algorithms,"Breadth-First Search,Graph,Prefix Sum"
3016,"Minimum Number of Pushes to Type Word II
You are given a string word containing lowercase English letters. Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [""a"",""b"",""c""], we need to push the key one time to type ""a"", two times to type ""b"", and three times to type ""c"" . It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word. Return the minimum number of pushes needed to type word after remapping the keys. An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.","Sort the word alphabetically and assign the most frequent letters to the lowest numbered keys (2, 3, etc.) and calculate total pushes.","Use dynamic programming to calculate the minimum pushes, considering all possible key remappings.","Calculate the frequency of each letter, assign letters based on their alphabetical order to keys, and calculate pushes.",Assign each unique character in 'word' to a separate key and count the length of the word.,"Calculate the frequency of each letter, sort the frequencies in descending order, assign the most frequent letters to keys 2-9 (one push), the next most frequent to keys 2-9 (two pushes), and so on, calculating the total pushes.",Medium,algorithms,"Hash Table,String,Greedy,Sorting,Counting"
3017,"Count the Number of Houses at a Certain Distance II
You are given three positive integers n, x, and y. In a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y. For each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k. Return a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k. Note that x and y can be equal.",O(n^3),O(n log n),O(n^2 log n),O(1),O(n^2),Hard,algorithms,"Graph,Prefix Sum"
3019,"Number of Changing Keys
You are given a 0-indexed string s typed by a user. Changing a key is defined as using a key different from the last used key. For example, s = ""ab"" has a change of a key while s = ""bBBb"" does not have any. Return the number of times the user had to change the key. Note: Modifiers like shift or caps lock won't be counted in changing the key that is if a user typed the letter 'a' and then the letter 'A' then it will not be considered as a changing of key.",The last key entered is always changing.,The number of characters in the string minus one.,The number of uppercase letters in the string.,The length of the string.,"The number of times a character differs from the previous character, ignoring case.",Easy,algorithms,String
3020,"Find the Maximum Number of Elements in Subset
You are given an array of positive integers nums. You need to select a subset of nums which satisfies the following condition: Return the maximum number of elements in a subset that satisfies these conditions.",Iterate through the array and count the frequency of each element. Return the highest frequency found.,Sort the array and remove duplicates. The length of the resulting array is the answer.,"Find the mode of the array, if any. Return the count of the mode in the array.",Return the length of the input array divided by 2 (rounded down).,"Count the frequency of each number. The answer is the highest frequency among numbers appearing only once, plus the total count of the numbers that appear more than once.",Medium,algorithms,"Array,Hash Table,Enumeration"
3021,"Alice and Bob Playing Flower Game
Alice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them. The game proceeds as follows: Given two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions: Return the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.",n * m,(n + 1) * (m + 1),(n * m) / 2,n + m,(n * m) // 2,Medium,algorithms,Math
3022,"Minimize OR of Remaining Elements Using Operations
You are given a 0-indexed integer array nums and an integer k. In one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator. Return the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.",Find the smallest element and apply AND operations around it.,Greedily perform AND operations on the largest elements first.,Calculate the bitwise OR of all possible sub-arrays resulting from k operations and choose the minimum.,Sort the array and then perform AND operations on adjacent elements based on k.,Use binary search on the possible range of the OR result to find the minimum value that can be achieved with at most k operations.,Hard,algorithms,"Array,Greedy,Bit Manipulation"
3024,"Type of Triangle
You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle. Return a string representing the type of triangle that can be formed or ""none"" if it cannot form a triangle.",Equilateral: all three sides are equal,Isosceles: exactly two sides are equal,Scalene: no sides are equal,none,"If any two sides sum to less than or equal to the third side, return 'none'. Otherwise, determine if it is 'equilateral', 'isosceles', or 'scalene'",Easy,algorithms,"Array,Math,Sorting"
3025,"Find the Number of Ways to Place People I
You are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi]. Count the number of pairs of points (A, B), where Return the count.",O(n^2) where n is the number of points.,O(n log n) where n is the number of points.,O(1) since the constraint is only the return,O(n^3) where n is the number of points.,O(n) where n is the number of points.,Medium,algorithms,"Array,Math,Geometry,Sorting,Enumeration"
3026,"Maximum Good Subarray Sum
You are given an array nums of length n and a positive integer k. A subarray of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k. Return the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.",Divide the array into subarrays of size k and check each one,Sort the array and then check for good subarrays within a sliding window,Use dynamic programming to store the maximum sum ending at each index,"Calculate the prefix sum array and iterate through all possible subarrays, checking the difference in prefix sums","Use a sliding window approach, expanding the window and tracking the first and last elements to determine if it's a 'good' subarray, updating the maximum sum as needed",Medium,algorithms,"Array,Hash Table,Prefix Sum"
3027,"Find the Number of Ways to Place People II
You are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We define the right direction as positive x-axis (increasing x-coordinate) and the left direction as negative x-axis (decreasing x-coordinate). Similarly, we define the up direction as positive y-axis (increasing y-coordinate) and the down direction as negative y-axis (decreasing y-coordinate) You have to place n people, including Alice and Bob, at these points such that there is exactly one person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the upper left corner and Bob's position as the lower right corner of the fence (Note that the fence might not enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either inside the fence or on the fence, Alice will be sad. Return the number of pairs of points where you can place Alice and Bob, such that Alice does not become sad on building the fence. Note that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and (3, 3), because:",Sort the points array and then iterate to find valid pairs using binary search for enclosed points.,"Brute-force: Iterate through all possible pairs of points and, for each pair, iterate through the remaining points to check if any are enclosed. This approach has O(n^3) time complexity.",Use a quadtree to efficiently find points within a given rectangle and count the valid Alice-Bob pairs.,"Precompute a 2D prefix sum array to calculate the number of points within a given rectangle in O(1) time, leading to an O(n^2) solution.","Iterate through all pairs of points (Alice and Bob) and for each pair, iterate through the other points to check if they fall within or on the fence. The time complexity is O(n^3).",Hard,algorithms,"Array,Math,Geometry,Sorting,Enumeration"
3028,"Ant on the Boundary
An ant is on a boundary. It sometimes goes left and sometimes right. You are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element: Return the number of times the ant returns to the boundary. Notes:","Recursively call the function with a smaller sub-array until the array is empty, incrementing the boundary count if the current sum is zero.","Use a `while` loop to iterate through the array, keeping track of the cumulative sum and resetting the sum to zero whenever it crosses the boundary.",Track only positive movements and negative movements separately. A return to the boundary only occurs when they are equal.,Employ dynamic programming to store intermediate sums and efficiently calculate the number of boundary returns.,"Iterate through the array, maintaining a running sum. Increment a counter each time the running sum returns to zero.",Easy,algorithms,"Array,Simulation,Prefix Sum"
3029,"Minimum Time to Revert Word to Initial State I
You are given a 0-indexed string word and an integer k. At every second, you must perform the following operations: Note that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second. Return the minimum time greater than zero required for word to revert to its initial state.",Divide the length of the string by k and round up to the nearest integer.,"Iterate through the string comparing substrings of length k, returning when a mismatch occurs.","Use a sliding window of size k, checking if the current window matches the initial substring.",Recursively remove prefixes of length k and count the steps until the string is empty.,"Compare the string with its prefixes of length k, 2k, 3k... until a prefix matches the original string; the number of prefixes checked is the time.",Medium,algorithms,"String,Rolling Hash,String Matching,Hash Function"
3030,"Find the Grid of Region Average
You are given m x n grid image which represents a grayscale image, where image[i][j] represents a pixel with intensity in the range [0..255]. You are also given a non-negative integer threshold. Two pixels are adjacent if they share an edge. A region is a 3 x 3 subgrid where the absolute difference in intensity between any two adjacent pixels is less than or equal to threshold. All pixels in a region belong to that region, note that a pixel can belong to multiple regions. You need to calculate a m x n grid result, where result[i][j] is the average intensity of the regions to which image[i][j] belongs, rounded down to the nearest integer. If image[i][j] belongs to multiple regions, result[i][j] is the average of the rounded-down average intensities of these regions, rounded down to the nearest integer. If image[i][j] does not belong to any region, result[i][j] is equal to image[i][j]. Return the grid result.",Apply a median filter to the entire image using a 3x3 kernel.,Convolve the image with a Gaussian blur filter to smooth the pixel intensities.,Calculate the average intensity of all pixels in the image and assign that value to each pixel.,"Iterate through the image and set each pixel to the average intensity of its immediate neighbors (up, down, left, right).","Iterate through each pixel, check for valid 3x3 regions, calculate the average intensity of those regions the pixel belongs to, and average these averages.",Medium,algorithms,"Array,Matrix"
3031,"Minimum Time to Revert Word to Initial State II
You are given a 0-indexed string word and an integer k. At every second, you must perform the following operations: Note that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second. Return the minimum time greater than zero required for word to revert to its initial state.","Divide the length of the word by k, rounding up to the nearest integer.","Find the longest prefix of the word that is also a suffix, divide the length of the word by k and subtract the length of the prefix.",Calculate the number of times k divides into the length of the word and increment by one.,Check all possible substrings of length k and determine if they are equal to the prefix of length k.,"Iterate through the word, checking if word[i:] is a prefix of word where i is a multiple of k. Return the number of iterations.",Hard,algorithms,"String,Rolling Hash,String Matching,Hash Function"
3033,"Modify the Matrix
Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column. Return the matrix answer.","Iterate through the matrix, and if matrix[i][j] is -1, replace it with the average of its row.","Create a copy of the matrix, and if matrix[i][j] is -1, replace it with the minimum of its row.","Iterate through the matrix, if a value is -1, set it to 0 and then compute column sums.",Replace all -1 values with the global maximum of the entire matrix.,"Iterate through each column, find the maximum value in that column, then iterate through the column again, replacing -1 values with the maximum.",Easy,algorithms,"Array,Matrix"
3034,"Number of Subarrays That Match a Pattern I
You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1. A subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]: Return the count of subarrays in nums that match the pattern.",O(n^3),O(m log n),O(n + m),O(n * m * log n),O(n * m),Medium,algorithms,"Array,Rolling Hash,String Matching,Hash Function"
3035,"Maximum Palindromes After Operations
You are given a 0-indexed string array words having length n and containing 0-indexed strings. You are allowed to perform the following operation any number of times (including zero): Return an integer denoting the maximum number of palindromes words can contain, after performing some operations. Note: i and j may be equal during an operation.",Sort each word individually and then sort the entire array,Concatenate all words into a single string and check for palindromic substrings,"Calculate the frequency of each character across all words, and maximize palindrome creation greedily",Use dynamic programming to find the longest palindromic subsequence in each word,Count the occurrences of each character.  Pair characters to form palindromes and maximize the number of such pairs.,Medium,algorithms,"Array,Hash Table,String,Greedy,Sorting,Counting"
3036,"Number of Subarrays That Match a Pattern II
You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1. A subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]: Return the count of subarrays in nums that match the pattern.","Use a sliding window of size m on `nums`, comparing it directly to the `pattern` array without any preprocessing.","For each possible subarray, compute a simplified difference array and directly compare it to `pattern`.","Precompute all possible subarrays and store them in a hash map. Then, iterate through the pattern and check the hash map.","Use dynamic programming to store intermediate results of matching subarrays, but only consider overlapping subarrays.",Compute the difference array of `nums` and `pattern` and then use the KMP algorithm to find matches.,Hard,algorithms,"Array,Rolling Hash,String Matching,Hash Function"
3038,"Maximum Number of Operations With the Same Score I
You are given an array of integers nums. Consider the following operation: You can perform this operation until nums contains fewer than two elements. Additionally, the same score must be achieved in all operations. Return the maximum number of operations you can perform.",Sort the array and greedily pair elements with the smallest sum,Iterate through all possible pairs and count the occurrences of each sum,Use dynamic programming to store the maximum number of operations for each subarray,Calculate the average of all numbers and find pairs that sum to twice the average,"Calculate the sum of the first pair and then iterate through the rest, checking if each pair's sum matches. If not, return 0.",Easy,algorithms,"Array,Simulation"
3039,"Apply Operations to Make String Empty
You are given a string s. Consider performing the following operation until s becomes empty: For example, let initially s = ""aabcbbca"". We do the following operations: Return the value of the string s right before applying the last operation. In the example above, answer is ""ba"".",Always remove the lexicographically smallest character.,Sort the string and remove characters based on their sorted order.,Remove characters from the string in the reverse order of their appearance.,"Remove characters based on the frequency of their occurrence, starting with the most frequent.","Use a doubly linked list and maintain the sorted order of character indices; then, iteratively remove the leftmost or rightmost index based on odd/even length.",Medium,algorithms,"Array,Hash Table,Sorting,Counting"
3040,"Maximum Number of Operations With the Same Score II
Given an array of integers called nums, you can perform any of the following operation while nums contains at least 2 elements: The score of the operation is the sum of the deleted elements. Your task is to find the maximum number of operations that can be performed, such that all operations have the same score. Return the maximum number of operations possible that satisfy the condition mentioned above.",Recursively compute the greatest common divisor (GCD) of all possible sums of pairs and divide the total sum by the GCD.,"Use dynamic programming to store the maximum number of operations for each possible subarray of 'nums', considering all possible sums.",Sort the array and greedily select pairs from the ends of the array that yield the largest sum.,Iterate through all possible sums that can be formed by any pair of numbers in 'nums' and count the maximum number of operations achievable for each sum.,Use memoization to store the maximum number of operations achievable for each subarray and target sum.,Medium,algorithms,"Array,Dynamic Programming,Memoization"
3041,"Maximize Consecutive Elements in an Array After Modification
You are given a 0-indexed array nums consisting of positive integers. Initially, you can increase the value of any element in the array by at most 1. After that, you need to select one or more elements from the final array such that those elements are consecutive when sorted in increasing order. For example, the elements [3, 4, 5] are consecutive while [3, 4, 6] and [1, 1, 2, 3] are not. Return the maximum number of elements that you can select.","Sort the array and apply dynamic programming to find the longest consecutive subsequence, modifying elements as needed during the DP process.","Use a greedy approach, always increasing the smallest element to potentially create a consecutive sequence and track the maximum length.","Iterate through all possible sub-arrays, check if they can be made consecutive with modifications, and keep track of the longest possible subsequence.",Apply binary search to find the optimal range of values that can form the longest consecutive sequence after modifications.,"Sort the array, use a sliding window to maintain consecutive elements, and update the window by potentially incrementing elements.",Hard,algorithms,"Array,Dynamic Programming,Sorting"
3042,"Count Prefix and Suffix Pairs I
You are given a 0-indexed string array words. Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2: For example, isPrefixAndSuffix(""aba"", ""ababa"") is true because ""aba"" is a prefix of ""ababa"" and also a suffix, but isPrefixAndSuffix(""abc"", ""abcd"") is false. Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.",Check if `words[i]` is a substring of `words[j]` using naive string matching.,"Iterate through all possible pairs (i, j) and compare the lengths of `words[i]` and `words[j]`, skipping if `words[i]` is longer.",Use regular expressions to check if `words[i]` is both a prefix and suffix of `words[j]`.,Compute the longest common subsequence between `words[i]` and `words[j]` and check if its length equals the length of `words[i]`.,"For each pair (i, j) where i < j, check if `words[i]` is a prefix and a suffix of `words[j]` by direct string comparison.",Easy,algorithms,"Array,String,Trie,Rolling Hash,String Matching,Hash Function"
3043,"Find the Length of the Longest Common Prefix
You are given two arrays with positive integers arr1 and arr2. A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not. A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have common prefixes 565 and 5655 while 1223 and 43456 do not have a common prefix. You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2. Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.","O(m*n), where m and n are the lengths of arr1 and arr2 respectively, due to pairwise comparisons","O(k), where k is the length of the longest number in either array, because of string conversion and prefix checking","O(1), since the length of the longest common prefix is independent of the input size","O(n log n), where n is the total number of digits in both arrays, due to sorting","O(m*n*k), where m and n are the lengths of arr1 and arr2 respectively, and k is the maximum length of the numbers",Medium,algorithms,"Array,Hash Table,String,Trie"
3044,"Most Frequent Prime
You are given a m x n 0-indexed 2D matrix mat. From every cell, you can create numbers in the following way: Return the most frequent prime number greater than 10 out of all the numbers created by traversing the matrix or -1 if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the largest among them. Note: It is invalid to change the direction during the move.","Scan each direction and store all numbers, then count primes using trial division",Convert the matrix to a 1D array and check each sliding window for primality,"Generate all possible paths from each cell, convert to numbers, and then find the most frequent prime using a hash map","Use a sieve of Eratosthenes on the maximum possible number, then iterate through the matrix and count prime occurrences","Iterate through each cell and direction, creating numbers; check each number for primality using an efficient algorithm like Miller-Rabin and track frequencies.",Medium,algorithms,"Array,Hash Table,Math,Matrix,Counting,Enumeration,Number Theory"
3045,"Count Prefix and Suffix Pairs II
You are given a 0-indexed string array words. Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2: For example, isPrefixAndSuffix(""aba"", ""ababa"") is true because ""aba"" is a prefix of ""ababa"" and also a suffix, but isPrefixAndSuffix(""abc"", ""abcd"") is false. Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.",Use a brute-force approach with nested loops to compare all pairs of words for prefix and suffix matches.,"Implement a Trie data structure to efficiently check for prefixes, and then iterate through the array to check for corresponding suffixes.",Sort the array lexicographically and then check adjacent elements for prefix and suffix relationships.,"Compute all possible prefixes and suffixes of each word, store them in a hash set, and then count pairs based on hash set intersections.","Build a combined prefix and suffix Trie for each word, then efficiently query for overlaps to count valid pairs.",Hard,algorithms,"Array,String,Trie,Rolling Hash,String Matching,Hash Function"
3046,"Split the Array
You are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that: Return true if it is possible to split the array, and false otherwise.",Use a greedy approach by always placing the largest element in nums1,Calculate the sum of all elements and check if half of it exists as a subset,Sort the array and check if the sum of the first half equals the sum of the second half,Recursively try all possible combinations of elements into nums1 and nums2,Check if the sum of all elements is even and if there exists a subset with a sum equal to half of the total sum,Easy,algorithms,"Array,Hash Table,Counting"
3047,"Find the Largest Area of Square Inside Two Rectangles
There exist n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays bottomLeft and topRight where bottomLeft[i] = [a_i, b_i] and topRight[i] = [c_i, d_i] represent the bottom-left and top-right coordinates of the ith rectangle, respectively. You need to find the maximum area of a square that can fit inside the intersecting region of at least two rectangles. Return 0 if such a square does not exist.",Calculate the area of each rectangle and return the largest one.,Find the intersection of all rectangles and return the area of the smallest rectangle inside it.,Calculate the perimeter of each rectangle and return the largest perimeter.,Return the area of the smallest rectangle provided as input.,"Find the intersection of every pair of rectangles; for each intersection, determine the largest square that fits within it, and return the maximum area among all such squares.",Medium,algorithms,"Array,Math,Geometry"
3048,"Earliest Second to Mark Indices I
You are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively. Initially, all indices in nums are unmarked. Your task is to mark all indices in nums. In each second, s, in order from 1 to m (inclusive), you can perform one of the following operations: Return an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.","Use a greedy approach, marking the smallest index in `nums` first at each `changeIndices` value.",Iterate through `changeIndices` and mark `nums` indices regardless of whether they need to be marked.,Sort `nums` and `changeIndices` and then iterate to find the earliest second.,Return the length of `changeIndices` if `nums` contains only unique elements.,"Use binary search to find the earliest second, and simulate the marking process for each candidate second.",Medium,algorithms,"Array,Binary Search"
3049,"Earliest Second to Mark Indices II
You are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively. Initially, all indices in nums are unmarked. Your task is to mark all indices in nums. In each second, s, in order from 1 to m (inclusive), you can perform one of the following operations: Return an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.","Use a greedy approach, always marking the smallest unmarked index first.",Use dynamic programming to find the longest subsequence of changeIndices that marks all indices.,Simulate the process for all possible starting times in changeIndices using binary search.,"Consider only the first n elements of changeIndices, as all indices must be marked.","Use binary search to find the earliest second, and for each potential second, simulate the marking process to check if all indices are marked.",Hard,algorithms,"Array,Binary Search,Greedy,Heap (Priority Queue)"
3065,"Minimum Operations to Exceed Threshold Value I
You are given a 0-indexed integer array nums, and an integer k. In one operation, you can remove one occurrence of the smallest element of nums. Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.",Sort the array in descending order and count elements greater than or equal to k.,Return the count of elements strictly less than k without modifying the array.,Iterate through the array and replace elements less than k with k before counting.,"Find the minimum element, increment it until it is greater than or equal to k, and repeat.",Sort the array in ascending order and count the elements strictly less than k.,Easy,algorithms,Array
3066,"Minimum Operations to Exceed Threshold Value II
You are given a 0-indexed integer array nums, and an integer k. You are allowed to perform some operations on nums, where in a single operation, you can: Note that you can only apply the described operation if nums contains at least two elements. Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.",Use a linear search to find the smallest element and repeatedly combine it until all elements meet the threshold.,Sort the array in descending order and iteratively combine the largest elements.,Recursively divide the array into sub-arrays and apply the combining operation.,"Always combine the first two elements of the array, regardless of their values.",Use a min-heap data structure to efficiently find and combine the two smallest elements until all elements are greater than or equal to k.,Medium,algorithms,"Array,Heap (Priority Queue),Simulation"
3067,"Count Pairs of Connectable Servers in a Weighted Tree Network
You are given an unrooted weighted tree with n vertices representing servers numbered from 0 to n - 1, an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional edge between vertices ai and bi of weight weighti. You are also given an integer signalSpeed. Two servers a and b are connectable through a server c if: Return an integer array count of length n where count[i] is the number of server pairs that are connectable through the server i.","Depth-First Search (DFS) from each node to count valid pairs, resulting in O(n^2) complexity","Floyd-Warshall algorithm to find all-pairs shortest paths, and then check connectability in O(n^3) time",Prim's algorithm to find the Minimum Spanning Tree (MST) and check for connectability within the MST,"Breadth-First Search (BFS) from each node, tracking distances, followed by an O(n^2) check for connectability","For each server, perform Depth-First Search (DFS) to identify subtrees connected to it. Calculate pairs connectable via the root server from the size of these subtrees whose cumulative weight is divisible by signalSpeed",Medium,algorithms,"Array,Tree,Depth-First Search"
3068,"Find the Maximum Sum of Node Values
There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i. Alice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree: Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.",Greedily select nodes with the largest values until the operation limit is reached.,"Use dynamic programming, keeping track of the maximum sum achievable with and without flipping the sign of each node's value.","Perform a depth-first search, flipping the sign of a node's value if it increases the overall sum.",Calculate the average node value and flip the sign of all nodes with values below the average.,"Employ a tree DP approach, considering for each node whether to flip its sign or not, based on the effect on its children's maximum sums.",Hard,algorithms,"Array,Dynamic Programming,Greedy,Bit Manipulation,Tree,Sorting"
3069,"Distribute Elements Into Two Arrays I
You are given a 1-indexed array of distinct integers nums of length n. You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation: The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6]. Return the array result.",Recursively divide the array into subarrays and distribute elements based on index parity,Sort the input array and alternately append elements to arr1 and arr2,Append elements to arr1 and arr2 based on whether they are prime or composite,Use a hash map to track element occurrences and distribute based on the hash value,"Iteratively append elements to arr1 and arr2 in an alternating fashion based on the operation number's parity, then concatenate arr1 and arr2",Easy,algorithms,"Array,Simulation"
3070,"Count Submatrices with Top-Left Element and Sum Less Than k
You are given a 0-indexed integer matrix grid and an integer k. Return the number of submatrices that contain the top-left element of the grid, and have a sum less than or equal to k.",Calculate prefix sums for each row and then iterate through all possible submatrices.,Sort the grid and count submatrices starting from the smallest element.,Use dynamic programming to store the sum of all possible submatrices and then filter.,Recursively divide the grid into smaller subgrids and count valid submatrices in each.,Iterate through all possible bottom-right corners of submatrices starting from the top-left element and calculate their sum.,Medium,algorithms,"Array,Matrix,Prefix Sum"
3071,"Minimum Operations to Write the Letter Y on a Grid
You are given a 0-indexed n x n grid where n is odd, and grid[r][c] is 0, 1, or 2. We say that a cell belongs to the Letter Y if it belongs to one of the following: The Letter Y is written on the grid if and only if: Return the minimum number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to 0, 1, or 2.","Consider all possible combinations of changing cells to minimize the total operations, resulting in high time complexity.","Calculate the number of 0s, 1s, and 2s currently in the 'Y' region and non-'Y' region, and choose the operation with the minimum swaps.","Iterate through the grid, flipping all cells in the 'Y' region to the value that appears most frequently in the entire grid.",Change all cells to the mode value across the grid; this will minimize changes by default.,"Count the occurrences of 0, 1, and 2 in the 'Y' region and non-'Y' region separately, then find the minimum number of operations by changing the values in each region to the optimal value (1 for 'Y', 0 or 2 for non-'Y').",Medium,algorithms,"Array,Hash Table,Matrix,Counting"
3072,"Distribute Elements Into Two Arrays II
You are given a 1-indexed array of integers nums of length n. We define a function greaterCount such that greaterCount(arr, val) returns the number of elements in arr that are strictly greater than val. You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation: The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6]. Return the integer array result.","Employ a greedy approach, always adding the smaller number to the array with fewer elements.",Recursively split the input array and merge the sorted halves into the two output arrays.,Sort the input array and distribute elements alternately to arr1 and arr2.,"Maintain two priority queues, one for arr1 and one for arr2, and add the current element to the queue with the smaller maximum.","Simulate the operations, keeping track of arr1 and arr2, and use greaterCount to decide where to append each element.",Hard,algorithms,"Array,Binary Indexed Tree,Segment Tree,Simulation"
3074,"Apple Redistribution into Boxes
You are given an array apple of size n and an array capacity of size m. There are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples. Return the minimum number of boxes you need to select to redistribute these n packs of apples into boxes. Note that, apples from the same pack can be distributed into different boxes.",Sort both arrays in ascending order and use the first-fit decreasing algorithm.,Use dynamic programming to find the minimum number of boxes needed.,Apply a greedy approach by always selecting the largest box available.,Divide the total number of apples by the average box capacity and round up.,Sort the capacity array in descending order and use a greedy approach to fill the boxes.,Easy,algorithms,"Array,Greedy,Sorting"
3075,"Maximize Happiness of Selected Children
You are given an array happiness of length n, and a positive integer k. There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns. In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive. Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.",Use a greedy approach by always selecting the child with the highest initial happiness.,Sort the happiness array and select the last k elements.,Use dynamic programming with a state representing the number of children selected and the current index in the array.,Simulate the process for all possible combinations of k children and choose the combination with the maximum sum.,"Sort the happiness array and use a modified greedy approach where the happiness values are updated during each selection round by subtracting 1, capped at zero, from the remaining elements.",Medium,algorithms,"Array,Greedy,Sorting"
3076,"Shortest Uncommon Substring in an Array
You are given an array arr of size n consisting of non-empty strings. Find a string array answer of size n such that: Return the array answer.","Implement a bloom filter to probabilistically identify and remove common characters, then take the shortest string.",Generate all possible substrings for each string and compare them using dynamic programming to find the shortest uncommon one.,"Sort the strings by length, then iterate through each and check if a shorter string is a substring. If not, return the string itself.",Use a suffix tree to efficiently find all substrings of each string and compare against other strings in the array.,"For each string, generate substrings of increasing length and check if they are substrings of other strings. Return the shortest uncommon substring.",Medium,algorithms,"Array,Hash Table,String,Trie"
3077,"Maximum Strength of K Disjoint Subarrays
You are given an array of integers nums with length n, and a positive odd integer k. Select exactly k disjoint subarrays sub1, sub2, ..., subk from nums such that the last element of subi appears before the first element of sub{i+1} for all 1 <= i <= k-1. The goal is to maximize their combined strength. The strength of the selected subarrays is defined as: strength = k * sum(sub1)- (k - 1) * sum(sub2) + (k - 2) * sum(sub3) - ... - 2 * sum(sub{k-1}) + sum(subk) where sum(subi) is the sum of the elements in the i-th subarray. Return the maximum possible strength that can be obtained from selecting exactly k disjoint subarrays from nums. Note that the chosen subarrays don't need to cover the entire array.","Use a greedy approach, always selecting the largest possible subarray sum at each step.","Apply dynamic programming with memoization to store the maximum strength for different subarray combinations, indexed by start and end positions.",Formulate the problem as a linear programming problem and solve it using the simplex algorithm.,"Calculate the prefix sums of the input array and use them to efficiently compute subarray sums; then, iterate through all possible k disjoint subarray combinations.",Use dynamic programming with a state representing the index in the array and the number of subarrays selected so far.,Hard,algorithms,"Array,Dynamic Programming,Prefix Sum"
3079,"Find the Sum of Encrypted Integers
You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333. Return the sum of encrypted elements.","Iterate through the array, converting each integer to a string, finding the max digit, repeating it, and summing the resulting integers.",Sort the array in descending order and multiply the first element by the length of the array.,Calculate the average of the array and multiply it by the array length.,Find the median of the array and multiply it by the number of elements greater than the median.,"Iterate through the array, for each number, find its largest digit, create a new number by repeating that digit for the same number of places, and sum these new numbers.",Easy,algorithms,"Array,Math"
3080,"Mark Elements on Array by Performing Queries
You are given a 0-indexed array nums of size n consisting of positive integers. You are also given a 2D array queries of size m where queries[i] = [indexi, ki]. Initially all elements of the array are unmarked. You need to apply m queries on the array in order, where on the ith query you do the following: Return an array answer of size m where answer[i] is the sum of unmarked elements in the array after the ith query.",Apply each query by iterating through the entire array and updating the sum of unmarked elements. This results in O(m*n) time complexity.,"Create a boolean array to track marked elements and update it for each query. Recalculate the sum of unmarked elements for each query, resulting in O(m*n) time complexity.",Sort the queries array to optimize the marking process. This reduces time complexity if queries are clustered.,Precompute the cumulative sum of the array and update it after each query to efficiently calculate the sum of unmarked elements.,"Use a boolean array to track marked elements. For each query, mark the element and subtract its value from the initial sum, resulting in O(m+n) time complexity.",Medium,algorithms,"Array,Hash Table,Sorting,Heap (Priority Queue),Simulation"
3081,"Replace Question Marks in String to Minimize Its Value
You are given a string s. s[i] is either a lowercase English letter or '?'. For a string t having length m containing only lowercase English letters, we define the function cost(i) for an index i as the number of characters equal to t[i] that appeared before it, i.e. in the range [0, i - 1]. The value of t is the sum of cost(i) for all indices i. For example, for the string t = ""aab"": Your task is to replace all occurrences of '?' in s with any lowercase English letter so that the value of s is minimized. Return a string denoting the modified string with replaced occurrences of '?'. If there are multiple strings resulting in the minimum value, return the lexicographically smallest one.","Replace all '?' with 'z' to minimize the lexicographical order, which indirectly minimizes value.",Replace all '?' with the most frequent character in the initial string.,"Replace '?' with 'a' if the preceding character is not 'a', otherwise use 'b'.",Replace each '?' with the character that results in the lowest individual cost(i) at that index considering already replaced characters.,"Iterate through the string, replacing each '?' with the smallest lexicographical character ('a') that doesn't increase the cost at that index, considering previously placed characters.",Medium,algorithms,"Hash Table,String,Greedy,Sorting,Heap (Priority Queue),Counting"
3082,"Find the Sum of the Power of All Subsequences
You are given an integer array nums of length n and a positive integer k. The power of an array of integers is defined as the number of subsequences with their sum equal to k. Return the sum of power of all subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.",Calculate the power set of the array and then sum the powers of all subsequences.,Use dynamic programming to count the number of subsequences with a sum equal to k for each subsequence.,Recursively generate all possible subsequences and check their sum.,Sort the array and then calculate subsequences only from positive numbers to reduce complexity.,"Iterate through the array, at each element either include it in the sum calculation or exclude it, using memoization to store intermediate results and prevent redundant calculations.",Hard,algorithms,"Array,Dynamic Programming"
3083,"Existence of a Substring in a String and Its Reverse
Given a string s, find any substring of length 2 which is also present in the reverse of s. Return true if such a substring exists, and false otherwise.",Hash all substrings of length 2 from the original string and check for their presence in the reversed string using a set.,Compare the first two characters of the original string with the last two characters of the reversed string.,Sort the original string and its reverse alphabetically and then compare them character by character.,Concatenate the original string and its reverse and then search for any substring of length 2.,Iterate through all substrings of length 2 in the original string and check if each substring exists in the reversed string using the 'in' operator or string search methods.,Easy,algorithms,"Hash Table,String"
3084,"Count Substrings Starting and Ending with Given Character
You are given a string s and a character c. Return the total number of substrings of s that start and end with c.",Use dynamic programming to store counts of substrings ending with 'c' at each index.,"Iterate through the string and for each occurrence of 'c', count all substrings that include it.",Count all occurrences of 'c' and return the square of the count.,"Use a sliding window to check substrings, resizing when 'c' is encountered.","Iterate through the string and for each 'c', count all subsequent 'c's including the first one.",Medium,algorithms,"Math,String,Counting"
3085,"Minimum Deletions to Make String K-Special
You are given a string word and an integer k. We consider word to be k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in the string. Here, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y. Return the minimum number of characters you need to delete to make word k-special.",Greedily delete characters with the highest frequency until the condition is met.,Sort the frequencies and use dynamic programming to find the optimal subset to keep.,"Calculate all possible sub-strings and check each for the k-special property, keeping the shortest one.",Use a sliding window approach to find the longest k-special substring.,Calculate character frequencies and use dynamic programming to minimize deletions to achieve the k-special property.,Medium,algorithms,"Hash Table,String,Greedy,Sorting,Counting"
3086,"Minimum Moves to Pick K Ones
You are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges. Alice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions: Return the minimum number of moves required by Alice to pick exactly k ones.",Greedily pick the k ones closest to each other without considering the cost of changes,"Use a sliding window of size k and calculate the moves for each window, picking the minimum",Recursively try all possible combinations of picking k ones and find the one with the minimum moves,"Sort the array and pick the first k elements, calculating the moves needed","Use dynamic programming to calculate the minimum moves to pick j ones up to index i, considering the cost of changing zeros to ones",Hard,algorithms,"Array,Greedy,Sliding Window,Prefix Sum"
3091,"Apply Operations to Make Sum of Array Greater Than or Equal to k
You are given a positive integer k. Initially, you have an array nums = [1]. You can perform any of the following operations on the array any number of times (possibly zero): Return the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.",Sort the array and repeatedly halve the largest element until the sum is at least k.,"Calculate the initial sum. If the sum is less than k, return 1; otherwise, return 0.","Repeatedly double each element of the array until the sum is at least k, counting the number of doubling operations.","Find the smallest element in the array and keep adding it to the sum until the sum is at least k, counting the additions.",Sort the array in descending order.  Repeatedly multiply the largest element by 2 until the sum is at least k. Count the number of multiplications.,Medium,algorithms,"Math,Greedy,Enumeration"
3092,"Most Frequent IDs
The problem involves tracking the frequency of IDs in a collection that changes over time. You have two integer arrays, nums and freq, of equal length n. Each element in nums represents an ID, and the corresponding element in freq indicates how many times that ID should be added to or removed from the collection at each step. Return an array ans of length n, where ans[i] represents the count of the most frequent ID in the collection after the ith step. If the collection is empty at any step, ans[i] should be 0 for that step.","Use a hash map to store ID frequencies and update it after each step, then sort the map by value to find the most frequent ID.",Keep a running sum of all frequencies and divide by the number of unique IDs to get the most frequent ID count.,"Maintain a sorted array of IDs and their frequencies. After each step, binary search for the ID and update its frequency. If not found, insert it in the correct position.","Use a fixed-size array to store frequencies, where the index represents the ID. If an ID exceeds the array size, return 0.",Use a hash map to store ID frequencies and update it after each step. Track the maximum frequency encountered so far and return it for each step.,Medium,algorithms,"Array,Hash Table,Heap (Priority Queue),Ordered Set"
3093,"Longest Common Suffix Queries
You are given two arrays of strings wordsContainer and wordsQuery. For each wordsQuery[i], you need to find a string from wordsContainer that has the longest common suffix with wordsQuery[i]. If there are two or more strings in wordsContainer that share the longest common suffix, find the string that is the smallest in length. If there are two or more such strings that have the same smallest length, find the one that occurred earlier in wordsContainer. Return an array of integers ans, where ans[i] is the index of the string in wordsContainer that has the longest common suffix with wordsQuery[i].",Using dynamic programming to build a table of common suffixes,Reversing both arrays and finding the longest common prefix,Comparing each query string with every container string using naive suffix comparison,Using a hash table to store suffixes of container strings for faster lookup,Using a suffix tree built from the container strings to efficiently find the longest common suffix for each query string,Hard,algorithms,"Array,String,Trie"
3095,"Shortest Subarray With OR at Least K I
You are given an array nums of non-negative integers and an integer k. An array is called special if the bitwise OR of all of its elements is at least k. Return the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.","Use a sliding window, shrinking it when the bitwise OR is less than k and expanding otherwise.",Sort the array first and then use a two-pointer approach to find the shortest subarray.,Calculate the bitwise OR of all possible subarrays and return the smallest length if the OR is greater than or equal to k.,Perform a binary search on the array to find the subarray closest to the value of k.,"Use a sliding window, expanding it until the bitwise OR is at least k, then shrinking it from the left until the OR is less than k, tracking the minimum length.",Easy,algorithms,"Array,Bit Manipulation,Sliding Window"
3096,"Minimum Levels to Gain More Points
You are given a binary array possible of length n. Alice and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it. At the start of the game, Alice will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels. Alice wants to know the minimum number of levels she should play to gain more points than Bob, if both players play optimally to maximize their points. Return the minimum number of levels Alice should play to gain more points. If this is not possible, return -1. Note that each player must play at least 1 level.","Alice plays all levels, regardless of possible[i]",Alice plays only the levels where possible[i] == 1,"Alice plays half the levels (n/2), rounding up if n is odd",Alice plays until her score equals Bob's potential maximum score,"Use a binary search to find the minimum number of levels for Alice such that her maximum score exceeds Bob's maximum score, considering possible[i]",Medium,algorithms,"Array,Prefix Sum"
3097,"Shortest Subarray With OR at Least K II
You are given an array nums of non-negative integers and an integer k. An array is called special if the bitwise OR of all of its elements is at least k. Return the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.",Use a binary search to find the minimum subarray length.,Iterate through all possible subarrays and check their bitwise OR.,Sort the array and then iterate to find the shortest special subarray.,Apply dynamic programming to store the bitwise OR of all subarrays.,Use a sliding window approach to efficiently find the shortest special subarray.,Medium,algorithms,"Array,Bit Manipulation,Sliding Window"
3098,"Find the Sum of Subsequence Powers
You are given an integer array nums of length n, and a positive integer k. The power of a subsequence is defined as the minimum absolute difference between any two elements in the subsequence. Return the sum of powers of all subsequences of nums which have length equal to k. Since the answer may be large, return it modulo 109 + 7.","O(n^2), where n is the length of nums.","O(n!), where n is the length of nums.","O(k!), where k is the required subsequence length.","O(n log n), where n is the length of nums.","O(nCk), where n is the length of nums and k is the required subsequence length.",Hard,algorithms,"Array,Dynamic Programming,Sorting"
3099,"Harshad Number
An integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.",Return -2,Return 0,Return the product of the digits of x,Return x divided by the sum of its digits,"Return the sum of the digits of x if x is divisible by the sum of its digits, otherwise, return -1",Easy,algorithms,Math
3100,"Water Bottles II
You are given two integers numBottles and numExchange. numBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations: Note that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles. Return the maximum number of water bottles you can drink.","Always exchange all available empty bottles, even if it results in leftover bottles that cannot be exchanged later.",Calculate the number of full bottles obtained solely from the initial bottles divided by numExchange.,Ignore any leftover bottles that don't form a complete set for exchange. Simply add the initial bottles to the quotient of initial bottles divided by numExchange.,"Simulate the exchange process using integer division and modulo operations, adding the resulting full bottles to the total count in each iteration until no more exchanges are possible.","Simulate the exchange process using integer division and modulo operations, updating full and empty bottle counts until the number of empty bottles is less than numExchange.",Medium,algorithms,"Math,Simulation"
3101,"Count Alternating Subarrays
You are given a binary array nums. We call a subarray alternating if no two adjacent elements in the subarray have the same value. Return the number of alternating subarrays in nums.","Use dynamic programming to store the lengths of alternating subarrays ending at each index, then sum these lengths.","Iterate through the array, and for each index, extend the subarray as long as it alternates, counting only the longest possible subarrays.","Recursively check each possible subarray to determine if it alternates, incrementing a counter for each valid one.","Employ a two-pointer approach, expanding and shrinking the window based on whether the alternating condition is met.","Iterate through the array, incrementing a counter for each index that starts an alternating subarray.",Medium,algorithms,"Array,Math"
3102,"Minimize Manhattan Distances
You are given an array points representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi]. The distance between two points is defined as their Manhattan distance. Return the minimum possible value for maximum distance between any two points by removing exactly one point.",Calculate the maximum Manhattan distance between all pairs of points and return the smallest maximum distance found when each point is excluded.,"Find the centroid of all points, remove the point farthest from the centroid, and calculate the maximum Manhattan distance between remaining points.","Sort the points by x-coordinate and then by y-coordinate, remove the median point, and calculate the maximum Manhattan distance between remaining points.","Remove the point closest to the origin (0,0) and calculate the maximum Manhattan distance between remaining points.","For each point, temporarily remove it from the set, calculate the maximum Manhattan distance between all remaining pairs, and return the minimum of these maximum distances.",Hard,algorithms,"Array,Math,Geometry,Sorting,Ordered Set"
3105,"Longest Strictly Increasing or Strictly Decreasing Subarray
You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.","O(n log n), where n is the length of the input array.","O(n^2), where n is the length of the input array.","O(1), indicating constant time complexity.","O(n!), where n is the length of the input array.","O(n), where n is the length of the input array.",Easy,algorithms,Array
3106,"Lexicographically Smallest String After Operations With Constraint
You are given a string s and an integer k. Define a function distance(s1, s2) between two strings s1 and s2 of the same length n as: For example, distance(""ab"", ""cd"") == 4, and distance(""a"", ""z"") == 1. You can change any letter of s to any other lowercase English letter, any number of times. Return a string denoting the lexicographically smallest string t you can get after some changes, such that distance(s, t) <= k.","Greedily iterate through the string and replace each character with 'a' until k is exhausted, then return the modified string.","Sort the input string 's' first, then iteratively try to make it lexicographically smaller by decrementing characters until the distance constraint is met.",Use dynamic programming to calculate the minimum distance required to reach each prefix of the string and construct the optimal string.,Recursively explore all possible string combinations and return the lexicographically smallest one that satisfies the distance constraint; prune when k < 0.,"Iterate through the string, greedily replacing each character with the smallest possible character ('a', 'b', etc.) while ensuring the total distance does not exceed k.",Medium,algorithms,"String,Greedy"
3107,"Minimum Operations to Make Median of Array Equal to K
You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1. Return the minimum number of operations needed to make the median of nums equal to k. The median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.",Sort the array and calculate the sum of absolute differences between elements greater than or equal to k and k.,"Calculate the sum of differences between each element and k, regardless of their position relative to the median.","Iterate through all possible subarrays, compute their medians, and find the minimum operations for each to equal k.",Use dynamic programming to find the optimal number of operations for each element to be equal to k.,"Sort the array, then calculate the sum of the absolute differences between k and each element that needs adjustment to make k the median.",Medium,algorithms,"Array,Greedy,Sorting"
3108,"Minimum Cost Walk in Weighted Graph
There is an undirected weighted graph with n vertices labeled from 0 to n - 1. You are given the integer n and an array edges, where edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui and vi with a weight of wi. A walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It's important to note that a walk may visit the same edge or vertex more than once. The cost of a walk starting at node u and ending at node v is defined as the bitwise AND of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is w0, w1, w2, ..., wk, then the cost is calculated as w0 & w1 & w2 & ... & wk, where & denotes the bitwise AND operator. You are also given a 2D array query, where query[i] = [si, ti]. For each query, you need to find the minimum cost of the walk starting at vertex si and ending at vertex ti. If there exists no such walk, the answer is -1. Return the array answer, where answer[i] denotes the minimum cost of a walk for query i.",Use Dijkstra's algorithm to find the shortest path and bitwise AND the edge weights along that path.,"Use a greedy approach, always selecting the edge with the smallest weight until the destination is reached.",Calculate the bitwise AND of all edge weights in the graph and return that value for every query.,Perform a depth-first search (DFS) for each query and keep track of the minimum cost encountered.,"Modify Breadth-First Search (BFS) to explore all possible walks, maintaining the bitwise AND of edge weights along each path and tracking the minimum cost for each query.",Hard,algorithms,"Array,Bit Manipulation,Union Find,Graph"
3110,"Score of a String
You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters. Return the score of s.",Calculate the sum of ASCII values of all characters in the string.,Multiply the ASCII value of each character by its index and sum the results.,Find the difference between the maximum and minimum ASCII values in the string.,Calculate the sum of the squares of ASCII values of all characters in the string.,"Iterate through the string, calculate the absolute difference between the ASCII values of adjacent characters, and sum these differences.",Easy,algorithms,String
3111,"Minimum Rectangles to Cover Points
You are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles. Each rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition x2 - x1 <= w must be satisfied for each rectangle. A point is considered covered by a rectangle if it lies within or on the boundary of the rectangle. Return an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle. Note: A point may be covered by more than one rectangle.",Sort the points based on their y-coordinates and greedily form rectangles.,Sort the points based on their x-coordinates and use dynamic programming.,"Use a recursive approach, considering each point and trying to form a rectangle.",Calculate the convex hull of the points and use the hull's vertices.,Sort the points based on their x-coordinates and greedily form rectangles with the lowest possible y2.,Medium,algorithms,"Array,Greedy,Sorting"
3112,"Minimum Time to Visit Disappearing Nodes
There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units. Additionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it. Note that the graph might be disconnected and might contain multiple edges. Return the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.",Dijkstra's algorithm without considering node disappearance times,Breadth-first search (BFS) without accounting for edge traversal times,Depth-first search (DFS) to explore all paths without pruning based on time,"Bellman-Ford algorithm to detect negative cycles, irrespective of node disappearance","Modified Dijkstra's algorithm considering node disappearance times, using a priority queue to explore nodes with shortest times first",Medium,algorithms,"Array,Graph,Heap (Priority Queue),Shortest Path"
3113,"Find the Number of Subarrays Where Boundary Elements Are Maximum
You are given an array of positive integers nums. Return the number of subarrays of nums, where the first and the last elements of the subarray are equal to the largest element in the subarray.",Return the count of elements that appear exactly once in the array.,Return the count of all possible subarrays.,Return the count of subarrays with a length of one.,Return the count of subarrays where all elements are identical.,Iterate through all subarrays and check if the boundary elements are the maximum.,Hard,algorithms,"Array,Binary Search,Stack,Monotonic Stack"
3114,"Latest Time You Can Obtain After Replacing Characters
You are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a ""?"". 12-hour times are formatted as ""HH:MM"", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59. You have to replace all the ""?"" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible. Return the resulting string.",09:59,23:59,12:60,19:99,11:59,Easy,algorithms,"String,Enumeration"
3115,"Maximum Prime Difference
You are given an integer array nums. Return an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.",Return 0 if the array contains no prime numbers,Return the length of the array if all numbers are prime,Return -1 if the array is empty,Return 1 if the array contains only one prime number,Return the difference between the largest and smallest index of prime numbers within the array,Medium,algorithms,"Array,Math,Number Theory"
3116,"Kth Smallest Amount With Single Denomination Combination
You are given an integer array coins representing coins of different denominations and an integer k. You have an infinite number of coins of each denomination. However, you are not allowed to combine coins of different denominations. Return the kth smallest amount that can be made using these coins.",Use a min-heap to track the amounts and extract the smallest until the kth one.,Generate all possible amounts and then sort them to find the kth smallest.,Employ dynamic programming to build a table of possible amounts up to a certain limit and retrieve the kth entry.,Sort the coins array and multiply the kth element by the smallest coin value.,"Sort the coins array and then generate amounts using k-ary representation, treating coins as digits.",Hard,algorithms,"Array,Math,Binary Search,Bit Manipulation,Combinatorics,Number Theory"
3117,"Minimum Sum of Values by Dividing Array
You are given two arrays nums and andValues of length n and m respectively. The value of an array is equal to the last element of that array. You have to divide nums into m disjoint contiguous subarrays such that for the ith subarray [li, ri], the bitwise AND of the subarray elements is equal to andValues[i], in other words, nums[li] & nums[li + 1] & ... & nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise AND operator. Return the minimum possible sum of the values of the m subarrays nums is divided into. If it is not possible to divide nums into m subarrays satisfying these conditions, return -1.","Use dynamic programming to find the optimal split, memoizing subproblem solutions based on the index and the last used value.",Iterate through all possible subarray divisions using recursion and backtracking to find a valid division with minimal sum.,"Greedily create subarrays starting from the beginning, matching the `andValues` elements, and sum the last elements of each.",Precompute all possible bitwise AND values for every subarray and then find a division that satisfies the conditions and minimizes the sum using a brute force approach.,"Apply dynamic programming, where dp[i][j] represents the minimum sum to divide nums[0...i] into j subarrays, satisfying the AND conditions.",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Bit Manipulation,Segment Tree,Queue"
3120,"Count the Number of Special Characters I
You are given a string word. A letter is called special if it appears both in lowercase and uppercase in word. Return the number of special letters in word.",Use regular expressions to find all characters that appear in both lowercase and uppercase.,Convert the string to lowercase and count the occurrences of each character.,Iterate through the string and use a hash map to track the frequency of each character; increment a counter if both cases exist.,Sort the string alphabetically and count consecutive matching characters.,"Create two sets, one for lowercase and one for uppercase characters, then find the intersection of the two sets and return the size.",Easy,algorithms,"Hash Table,String"
3121,"Count the Number of Special Characters II
You are given a string word. A letter c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c. Return the number of special letters in word.","Iterate through the string, using a hash map to store character counts, then iterate through the hash map checking if count[char] > 1","Convert the string to lowercase, then count the unique characters","Use regular expressions to find all lowercase and uppercase letters, then compare them","Convert the string to an array, then use nested loops to find matching lowercase and uppercase characters","Use sets to store lowercase and uppercase letters, then find the intersection and verify order of occurrences",Medium,algorithms,"Hash Table,String"
3122,"Minimum Number of Operations to Satisfy Conditions
You are given a 2D matrix grid of size m x n. In one operation, you can change the value of any cell to any non-negative number. You need to perform some operations such that each cell grid[i][j] is: Return the minimum number of operations needed.",Calculate the total number of cells and return that value.,Return the number of rows multiplied by the number of columns.,Count the number of negative numbers in the grid and return that count.,Return the count of cells that do not satisfy the condition.,Calculate the number of cells not satisfying the condition and return that number.,Medium,algorithms,"Array,Dynamic Programming,Matrix"
3123,"Find Edges in Shortest Paths
You are given an undirected weighted graph of n nodes numbered from 0 to n - 1. The graph consists of m edges represented by a 2D array edges, where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi. Consider all the shortest paths from node 0 to node n - 1 in the graph. You need to find a boolean array answer where answer[i] is true if the edge edges[i] is part of at least one shortest path. Otherwise, answer[i] is false. Return the array answer. Note that the graph may not be connected.","Use Dijkstra's algorithm to find the shortest path, and then check if each edge is present in that single path.","Calculate the shortest path using Bellman-Ford and mark edges with weights equal to the shortest path weight as true, the rest as false.","Perform a Depth-First Search (DFS) from node 0 to node n-1, marking all edges visited in any path as true.","Run a Breadth-First Search (BFS) from node 0, and consider any edge included in the BFS tree as part of a shortest path.","Compute shortest path distances from node 0 and node n-1 using Dijkstra's algorithm. An edge (u, v) with weight w is on a shortest path if dist[0][u] + w + dist[v][n-1] == dist[0][n-1] or dist[0][v] + w + dist[u][n-1] == dist[0][n-1].",Hard,algorithms,"Depth-First Search,Breadth-First Search,Graph,Heap (Priority Queue),Shortest Path"
3127,"Make a Square with the Same Color
You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color. Your task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color. Return true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.",Return true if the grid is already all 'B' or all 'W',Check only the top-left 2x2 subgrid for a uniform color,Return false if the number of 'B' is not equal to the number of 'W',"Modify the grid in-place, changing each cell sequentially and checking for a 2x2 uniform square after each change","Iterate through each cell, temporarily changing its color, checking for a 2x2 uniform square, and reverting the change",Easy,algorithms,"Array,Matrix,Enumeration"
3128,"Right Triangles
You are given a 2D boolean matrix grid. A collection of 3 elements of grid is a right triangle if one of its elements is in the same row with another element and in the same column with the third element. The 3 elements may not be next to each other. Return an integer that is the number of right triangles that can be made with 3 elements of grid such that all of them have a value of 1.","O(n^3), where n is the number of rows/columns, by checking all possible triplets.","O(r*c), where r and c are the number of rows and columns, by iterating through the matrix only once.","O(1), as the number of triangles is independent of the input size.","O(n log n), where n is the total number of elements, by sorting and searching for triplets.","O(r*c), where r and c are the number of rows and columns, by pre-calculating row and column sums of 1s and using those to count triangles.",Medium,algorithms,"Array,Hash Table,Math,Combinatorics,Counting"
3129,"Find All Possible Stable Binary Arrays I
You are given 3 positive integers zero, one, and limit. A binary array arr is called stable if: Return the total number of stable binary arrays. Since the answer may be very large, return it modulo 109 + 7.",Depth-first search with backtracking,Dynamic programming with a 2D table storing the number of arrays with a given number of zeros and ones,Greedy approach by always placing the smaller number of zeros or ones next,Recursion with memoization storing intermediate results,Dynamic programming using binomial coefficients (n choose k),Medium,algorithms,"Dynamic Programming,Prefix Sum"
3130,"Find All Possible Stable Binary Arrays II
You are given 3 positive integers zero, one, and limit. A binary array arr is called stable if: Return the total number of stable binary arrays. Since the answer may be very large, return it modulo 109 + 7.",Brute force: Generate all binary arrays and check for stability. O(2^(zero+one)),Dynamic programming: Store counts of stable arrays using a 2D array indexed by number of zeros and ones. O(zero*one),"Greedy approach: Fill the array with zeros until the limit is reached, then fill with ones.","Recursion: Recursively generate stable arrays by either adding a zero or a one, ensuring stability conditions are met.",Combinatorics: Use stars and bars to calculate the number of ways to arrange ones and zeros with the given constraints.,Hard,algorithms,"Dynamic Programming,Prefix Sum"
3131,"Find the Integer Added to Array I
You are given two arrays of equal length, nums1 and nums2. Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x. As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies. Return the integer x.",Calculate the difference between the sums of the elements in nums1 and nums2 and divide by the length of the array.,Sort both arrays and calculate the average difference between corresponding elements.,"Use a hash map to store the frequency of each number in nums1 and nums2, and calculate the differences between common numbers only.",Return the absolute difference between the first element of nums1 and nums2.,"Iterate through the arrays, calculating the difference between each pair of corresponding elements, then return the mode of the calculated differences.",Easy,algorithms,Array
3132,"Find the Integer Added to Array II
You are given two integer arrays nums1 and nums2. From nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x. As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies. Return the minimum possible integer x that achieves this equivalence.","Use a brute-force approach, trying all possible values of x within a reasonable range.",Sort both arrays and find the median difference between corresponding elements.,Calculate the sum of elements in both arrays and derive x from the difference in sums divided by the array length difference.,Find the intersection of the two arrays; the difference between any remaining element in nums2 and its closest match in nums1 will give x.,"Calculate the frequency of each number in both arrays, then iterate through potential x values and check if the adjusted frequencies in nums1 match those in nums2 after removing two elements.",Medium,algorithms,"Array,Two Pointers,Sorting,Enumeration"
3133,"Minimum Array End
You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x. Return the minimum possible value of nums[n - 1].",x + n - 1,x * n,x + 2 * (n - 1),n * (x + 1),x + n - 1,Medium,algorithms,Bit Manipulation
3134,"Find the Median of the Uniqueness Array
You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 <= i <= j < nums.length. Here, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j. Return the median of the uniqueness array of nums. Note that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.",Calculate the number of distinct elements in each subarray using a sliding window approach.,Sort the original array and then count distinct elements in all subarrays.,Use a hash table to store the frequency of each element in the original array and then compute the number of distinct elements in each subarray.,Precompute the count of distinct elements for all possible subarrays of a certain size and use these counts to determine the counts for larger subarrays.,"Generate all subarrays, compute the number of distinct elements in each, store these counts in a list, sort the list, and return the median.",Hard,algorithms,"Array,Hash Table,Binary Search,Sliding Window"
3136,"Valid Word
A word is considered valid if: You are given a string word. Return true if word is valid, otherwise, return false. Notes:",The word contains only characters that appear exactly twice and in adjacent pairs,"The word is a palindrome, reading the same forwards and backwards","The word's length is a power of 2, and all characters are unique",The word contains only vowels and each vowel appears at least once,"The word consists of repeating identical substrings of length greater than one, concatenated together",Easy,algorithms,String
3137,"Minimum Number of Operations to Make Word K-Periodic
You are given a string word of size n, and an integer k such that k divides n. In one operation, you can pick any two indices i and j, that are divisible by k, then replace the substring of length k starting at i with the substring of length k starting at j. That is, replace the substring word[i..i + k - 1] with the substring word[j..j + k - 1]. Return the minimum number of operations required to make word k-periodic. We say that word is k-periodic if there is some string s of length k such that word can be obtained by concatenating s an arbitrary number of times. For example, if word == “ababab”, then word is 2-periodic for s = ""ab"".",Calculate the frequency of each k-length substring and return n minus the frequency of the most frequent substring.,Use dynamic programming to store the minimum operations needed to make the first i characters k-periodic.,Iterate through all possible k-length substrings and count the operations to make the string periodic with that substring; return the minimum.,Divide the string into k-length substrings and sort them lexicographically; the number of swaps is the answer.,"Divide the string into k-length substrings and, for each index i from 0 to k-1, find the most frequent character at that index across all substrings. Sum the differences between the substring count and the maximum frequencies.",Medium,algorithms,"Hash Table,String,Counting"
3138,"Minimum Length of Anagram Concatenation
You are given a string s, which is known to be a concatenation of anagrams of some string t. Return the minimum possible length of the string t. An anagram is formed by rearranging the letters of a string. For example, ""aab"", ""aba"", and, ""baa"" are anagrams of ""aab"".",Find the longest repeating substring within 's',Calculate the length of 's' divided by the number of anagrams,"Return the length of 's' if 's' is not empty, otherwise return 0",Find the smallest substring of 's' that contains all unique characters of 's',Find the frequency of each character in 's' and return the sum of unique characters' greatest common divisor (GCD),Medium,algorithms,"Hash Table,String,Counting"
3139,"Minimum Cost to Equalize Array
You are given an integer array nums and two integers cost1 and cost2. You are allowed to perform either of the following operations any number of times: Return the minimum cost required to make all elements in the array equal. Since the answer may be very large, return it modulo 109 + 7.",Sort the array and calculate the cost to make all elements equal to the median.,Find the minimum and maximum elements and calculate the cost to make all elements equal to their average.,Use dynamic programming to store the minimum cost to equalize the first i elements.,"Calculate the cost to equalize the array to the minimum value, the maximum value, and return the minimum of the two.","Use binary search to find the optimal target value that minimizes the total cost, considering cost1 and cost2.",Hard,algorithms,"Array,Greedy,Enumeration"
3142,"Check if Grid Satisfies Conditions
You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is: Return true if all the cells satisfy these conditions, otherwise, return false.",The element in the same row and the column is strictly greater than all the other values in the row,The element is the smallest value in its row and largest in its column,The element is greater than or equal to all the elements in its column and smaller than or equal to all the elements in its row,The element is strictly less than the element in the top-left corner of the matrix,The element is greater than or equal to all the elements in its row and greater than or equal to all the elements in its column,Easy,algorithms,"Array,Matrix"
3143,"Maximum Points Inside the Square
You are given a 2D array points and a string s where, points[i] represents the coordinates of point i, and s[i] represents the tag of point i. A valid square is a square centered at the origin (0, 0), has edges parallel to the axes, and does not contain two points with the same tag. Return the maximum number of points contained in a valid square. Note:","Maintain a hash map to track tags, and expand the square's side length until a duplicate tag is found, then return the previous size's count.","Sort points by their distance from the origin. Greedily add points, skipping those with duplicate tags, until no more points can be added within a fixed maximum square size.",Divide the coordinate plane into quadrants and independently find the maximum points within each quadrant before summing the results.,"Precompute all possible square sizes and, for each size, iterate through all points to count points within the square, breaking when a duplicate tag is found.","Binary search on the square's side length. For each size, check for duplicate tags within the square and maintain the maximum count of points with unique tags.",Medium,algorithms,"Array,Hash Table,String,Binary Search,Sorting"
3144,"Minimum Substring Partition of Equal Character Frequency
Given a string s, you need to partition it into one or more balanced substrings. For example, if s == ""ababcc"" then (""abab"", ""c"", ""c""), (""ab"", ""abc"", ""c""), and (""ababcc"") are all valid partitions, but (""a"", ""bab"", ""cc""), (""aba"", ""bc"", ""c""), and (""ab"", ""abcc"") are not. The unbalanced substrings are bolded. Return the minimum number of substrings that you can partition s into. Note: A balanced string is a string where each character in the string occurs the same number of times.",O(n^3) - by checking all possible substring combinations using brute force,O(n log n) - by sorting the string and then partitioning based on character counts,O(n^2) - by iteratively improving the partition by merging adjacent substrings,O(2^n) - by exploring every possible partition of the string via recursion,O(n) - by greedily finding the smallest balanced substring at each step,Medium,algorithms,"Hash Table,String,Dynamic Programming,Counting"
3145,"Find Products of Elements of Big Array
The powerful array of a non-negative integer x is defined as the shortest sorted array of powers of two that sum up to x. The table below illustrates examples of how the powerful array is determined. It can be proven that the powerful array of x is unique. The array big_nums is created by concatenating the powerful arrays for every positive integer i in ascending order: 1, 2, 3, and so on. Thus, big_nums begins as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, ...]. You are given a 2D integer matrix queries, where for queries[i] = [fromi, toi, modi] you should calculate (big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]) % modi. Return an integer array answer such that answer[i] is the answer to the ith query.","Decompose each number into its binary representation, then perform modular arithmetic on the resulting bit strings.",Precompute all possible powerful arrays up to the maximum 'to' value in queries and store them in a lookup table for faster access.,"Calculate the product iteratively, applying the modulo operator only at the end of the entire product calculation.",Utilize dynamic programming to store intermediate products and avoid redundant calculations for overlapping query ranges.,"Use binary exponentiation and properties of modular arithmetic to efficiently compute the product modulo 'modi' for each query range, deriving the powerful array on demand.",Hard,algorithms,"Array,Binary Search,Bit Manipulation"
3146,"Permutation Difference between Two Strings
You are given two strings s and t such that every character occurs at most once in s and t is a permutation of s. The permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t. Return the permutation difference between s and t.",0,1,3,4,2,Easy,algorithms,"Hash Table,String"
3147,"Taking Maximum Energy From the Mystic Dungeon
In a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you. You have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist. In other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey. You are given an array energy and an integer k. Return the maximum possible energy you can gain. Note that when you are reach a magician, you must take energy from them, whether it is negative or positive energy.",Use Kadane's Algorithm directly on the energy array.,"Calculate the sum of all elements in the energy array, then return that value.",Sort the energy array in descending order and sum the first k elements.,Return the absolute value of the smallest element in the array.,"Iterate through all possible starting positions and calculate the sum for each sequence of k jumps, then return the maximum sum found.",Medium,algorithms,"Array,Prefix Sum"
3148,"Maximum Difference Score in a Grid
You are given an m x n matrix grid consisting of positive integers. You can move from a cell in the matrix to any other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value c1 to a cell with the value c2 is c2 - c1. You can start at any cell, and you have to make at least one move. Return the maximum total score you can achieve.",Use a greedy approach by always choosing the move with the highest immediate score.,Calculate the difference between the maximum and minimum values in the grid.,Apply dynamic programming to find the longest increasing subsequence in the grid.,Employ a randomized search algorithm to explore possible paths and track the maximum score.,"Use dynamic programming to calculate the maximum score achievable from each cell, considering right and bottom moves.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
3149,"Find the Minimum Cost Array Permutation
You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1]. The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined as: score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]| Return the permutation perm which has the minimum possible score. If multiple permutations exist with this score, return the one that is lexicographically smallest among them.",Use dynamic programming with bitmasking to track visited elements and minimize the cost.,"Apply a greedy approach, always selecting the element that minimizes the immediate cost without considering future impacts.","Sort the 'nums' array and construct 'perm' such that perm[i] = i, assuming sorted 'nums' minimizes the total cost.","Employ a hill-climbing algorithm, starting with a random permutation and iteratively improving it until a local minimum is reached.","Utilize a branch and bound algorithm to systematically explore the permutation space, pruning branches that cannot lead to a lower cost.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
3151,"Special Array I
An array is considered special if the parity of every pair of adjacent elements is different. In other words, one element in each pair must be even, and the other must be odd. You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.",Always returns true regardless of the input array,Checks only the first two elements for alternating parity,Returns true only if all elements are even,Returns false if the array is empty,Iterates through the array and checks if the parity of each adjacent pair is different,Easy,algorithms,Array
3152,"Special Array II
An array is considered special if every pair of its adjacent elements contains two numbers with different parity. You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not. Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.",Check if all elements in the subarray are even or odd.,Check if the subarray is sorted in ascending or descending order.,Check if the sum of the elements in the subarray is a prime number.,Check if the absolute difference between adjacent elements in the subarray is always 1.,Iterate through the subarray and verify that adjacent elements have different parity.,Medium,algorithms,"Array,Binary Search,Prefix Sum"
3153,"Sum of Digit Differences of All Pairs
You are given an array nums consisting of positive integers where all integers have the same number of digits. The digit difference between two integers is the count of different digits that are in the same position in the two integers. Return the sum of the digit differences between all pairs of integers in nums.","Iterate through all pairs of numbers, comparing digits at each position and summing the differences.",Sort the array and then calculate the digit differences only for adjacent pairs to reduce computations.,Precompute the frequency of each digit at each position across all numbers and use this to calculate the sum of differences.,"Convert each number to a string, pad with leading zeros if necessary, and then compare strings character by character.","For each position, count the occurrences of each digit and use this to efficiently compute the sum of differences for that position.",Medium,algorithms,"Array,Hash Table,Math,Counting"
3154,"Find Number of Ways to Reach the K-th Stair
You are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0. Alice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can: Return the total number of ways Alice can reach stair k. Note that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.",O(k^2),O(k log k),O(2^k),O(1),O(k),Hard,algorithms,"Math,Dynamic Programming,Bit Manipulation,Memoization,Combinatorics"
3158,"Find the XOR of Numbers Which Appear Twice
You are given an array nums, where each number in the array appears either once or twice. Return the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.",Return the XOR of all numbers in the array,"Return 0 if the array is empty, otherwise return the first element",Return the XOR of all even numbers in the array,Return the sum of all numbers appearing twice,Return the XOR of all numbers that appear exactly twice in the array,Easy,algorithms,"Array,Hash Table,Bit Manipulation"
3159,"Find Occurrences of an Element in an Array
You are given an integer array nums, an integer array queries, and an integer x. For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query. Return an integer array answer containing the answers to all queries.",Return the index of the first occurrence of 'x' after slicing 'nums' to the appropriate size based on 'queries[i]',"Iterate through 'nums' for each query, counting occurrences until 'queries[i]' is reached, then return the current index.","Use a hash map to store the indices of all occurrences of 'x', and then use 'queries[i]' as an index into the map.","Return the 'queries[i]'th element of 'nums' if 'x' is found at that index, otherwise return -1.","Maintain a list of indices where 'x' occurs in 'nums'. For each query, return the index at queries[i]-1 in the list or -1 if the list is too short.",Medium,algorithms,"Array,Hash Table"
3160,"Find the Number of Distinct Colors Among the Balls
You are given an integer limit and a 2D array queries of size n x 2. There are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of colors among the balls. Return an array result of length n, where result[i] denotes the number of colors after ith query. Note that when answering a query, lack of a color will not be considered as a color.",Use a hash table to store ball-color mappings and count distinct colors after each query by iterating through all balls.,"Sort the queries array and then, for each query, iterate through the balls array to find distinct colors.","Maintain a bit vector representing the colors and update it for each query; then, count the set bits.",Use a disjoint-set data structure to track connected components of colored balls and report the number of components.,Use a hash set to store the unique colors applied so far and update it after each query; the size of the set gives the answer.,Medium,algorithms,"Array,Hash Table,Simulation"
3161,"Block Placement Queries
There exists an infinite number line, with its origin at 0 and extending towards the positive x-axis. You are given a 2D array queries, which contains two types of queries: Return a boolean array results, where results[i] is true if you can place the block specified in the ith query of type 2, and false otherwise.",First-Fit: Place the block in the first available space large enough.,Worst-Fit: Place the block in the largest available space.,Best-Fit: Place the block in the smallest available space that can accommodate it.,Random-Fit: Place the block in a randomly selected available space.,Maintain a balanced binary search tree representing available spaces. Query if a space of sufficient size exists.,Hard,system design,"Array,Binary Search,Binary Indexed Tree,Segment Tree"
3162,"Find the Number of Good Pairs I
You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k. A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1). Return the total number of good pairs.",Iterate through all possible pairs and count those where nums1[i] % (nums2[j] * k) == 0,"Calculate the product of all elements in nums1 and nums2, then check divisibility by k.","Sort both nums1 and nums2, and use binary search to optimize the counting process.",Compute the greatest common divisor (GCD) of all elements in nums2 and divide k by GCD before checking pairs.,"Iterate through all possible pairs (i, j) and increment a counter if nums1[i] is divisible by nums2[j] * k",Easy,algorithms,"Array,Hash Table"
3163,"String Compression III
Given a string word, compress it using the following algorithm: Return the string comp.",Replace consecutive repeating characters with a single instance of the character,Represent the string using Huffman coding for optimal space utilization,Encode the string by assigning a unique integer to each distinct character,Store the string as a bit array representing character presence,Replace consecutive repeating characters with the character followed by the count if the count is greater than 1,Medium,algorithms,String
3164,"Find the Number of Good Pairs II
You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k. A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1). Return the total number of good pairs.",Use nested loops and check the divisibility condition directly,Precompute the divisors of each element in nums1 and compare with nums2,Sort both arrays and use binary search to optimize the divisibility check,Use dynamic programming to store intermediate results of divisibility,Use a hash map to store the frequencies of nums2[j] * k and iterate through nums1 to count divisible pairs efficiently,Medium,algorithms,"Array,Hash Table"
3165,"Maximum Sum of Subsequence With Non-adjacent Elements
You are given an array nums consisting of integers. You are also given a 2D array queries, where queries[i] = [posi, xi]. For query i, we first set nums[posi] equal to xi, then we calculate the answer to query i which is the maximum sum of a subsequence of nums where no two adjacent elements are selected. Return the sum of the answers to all queries. Since the final answer may be very large, return it modulo 109 + 7. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.","Brute-force: Generate all possible subsequences, check for non-adjacency, and find the maximum sum.","Dynamic Programming: Store maximum sums ending at each index, updating after each query.",Greedy Approach: Always choose the larger element among non-adjacent pairs after each query.,Recursion: Define a recursive function that explores all possible subsequence combinations after each query.,"Dynamic Programming: Use two variables to store the maximum sum including and excluding the current element, updating them after each query.",Hard,algorithms,"Array,Divide and Conquer,Dynamic Programming,Segment Tree"
3168,"Minimum Number of Chairs in a Waiting Room
You are given a string s. Simulate events at each second i: Return the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.","The events are independent, so only the maximum number of people arriving at any given second matters","Calculate the prefix sum of the arrival rate, then find the maximum prefix sum value","Sort the arrival times and departure times, then iterate through them while maintaining a count of occupied chairs",Use a min-heap to track available chairs and allocate them to arriving people based on availability,"Keep a running count of occupied chairs, incrementing for arrivals and decrementing for departures at each second",Easy,algorithms,"String,Simulation"
3169,"Count Days Without Meetings
You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive). Return the count of days when the employee is available for work but no meetings are scheduled. Note: The meetings may overlap.","Sort the meetings array and then iterate through the days, checking for overlaps using binary search.","Create a boolean array representing each day, mark days with meetings as unavailable, and then count the remaining available days.",Iterate through each meeting and increment a counter for each unavailable day within the meeting's range. Subtract this counter from the total days.,Calculate the total number of days covered by meetings by summing the durations of each meeting and subtracting from the total days.,"Use a boolean array to mark unavailable days based on meeting schedules, then count the unmarked days.",Medium,algorithms,"Array,Sorting"
3170,"Lexicographically Minimum String After Removing Stars
You are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters. While there is a '*', do the following operation: Return the lexicographically smallest resulting string after removing all '*' characters.",Greedily remove '*' characters until the string contains none.,"Sort the string, then remove all '*' characters to minimize the lexicographical order.",Remove each '*' and the character immediately before it from the string.,Replace each '*' with the smallest character in the string before removing all '*' characters.,"Iterate through the string, maintaining a stack. Add characters to the stack unless a '*' is encountered, in which case the top element is removed if the stack is not empty.",Medium,algorithms,"Hash Table,String,Stack,Greedy,Heap (Priority Queue)"
3171,"Find Subarray With Bitwise OR Closest to K
You are given an array nums and an integer k. You need to find a subarray of nums such that the absolute difference between k and the bitwise OR of the subarray elements is as small as possible. In other words, select a subarray nums[l..r] such that |k - (nums[l] OR nums[l + 1] ... OR nums[r])| is minimum. Return the minimum possible value of the absolute difference. A subarray is a contiguous non-empty sequence of elements within an array.",Return the absolute difference between k and the bitwise AND of the entire array.,Consider only subarrays of size 1.,Calculate the bitwise OR of all possible subarrays and return the maximum difference from k.,"Return 0 if k is present in the array; otherwise, return k.",Calculate the bitwise OR of all possible subarrays and return the minimum absolute difference between the result and k.,Hard,algorithms,"Array,Binary Search,Bit Manipulation,Segment Tree"
3174,"Clear Digits
You are given a string s. Your task is to remove all digits by doing this operation repeatedly: Return the resulting string after removing all digits. Note that the operation cannot be performed on a digit that does not have any non-digit character to its left.",A linked list where elements are added and removed from the tail.,A binary search tree where elements are inserted based on priority.,A queue implemented using a circular buffer.,A hash table where keys represent insertion order.,"A stack, where elements are pushed and popped from the top.",Easy,data structures,"String,Stack,Simulation"
3175,"Find The First Player to win K Games in a Row
A competition consists of n players numbered from 0 to n - 1. You are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique. All players are standing in a queue in order from player 0 to player n - 1. The competition process is as follows: The winner of the competition is the first player who wins k games in a row. Return the initial index of the winning player.",The index of the player with the highest skill level,The index of the player with the lowest skill level,The index of the last player in the queue,The index of the player who wins the first game,The index of the first player to win k games consecutively,Medium,algorithms,"Array,Simulation"
3176,"Find the Maximum Length of a Good Subsequence I
You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum possible length of a good subsequence of nums.",Greedily select elements that are equal to the most frequent element in nums until k violations are allowed,"Apply dynamic programming with states representing the current index and the number of allowed violations, but only consider subsequences ending at the current index",Sort the array and pick the longest subsequence with elements that are close to each other,Recursively explore all possible subsequences and prune branches when the number of violations exceeds k,"Use dynamic programming with states representing the current index and the number of allowed violations, considering both including and excluding the current element",Medium,algorithms,"Array,Hash Table,Dynamic Programming"
3177,"Find the Maximum Length of a Good Subsequence II
You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum possible length of a good subsequence of nums.",O(n^2) where n is the length of nums,O(n log n) where n is the length of nums,"O(n*k) where n is the length of nums, and k is the allowed difference count",O(2^n) where n is the length of nums,O(n) where n is the length of nums,Hard,algorithms,"Array,Hash Table,Dynamic Programming"
3178,"Find the Child Who Has the Ball After K Seconds
You are given two positive integers n and k. There are n children numbered from 0 to n - 1 standing in a queue in order from left to right. Initially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches either end of the line, i.e. child 0 or child n - 1, the direction of passing is reversed. Return the number of the child who receives the ball after k seconds.",Use modulo arithmetic: (k % n),"Return max(0, k - n)","Return min(k, n)","Always return k, regardless of n","Simulate the ball's movement, accounting for direction reversals at the ends of the line.",Easy,algorithms,"Math,Simulation"
3179,"Find the N-th Value After K Seconds
You are given two integers n and k. Initially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on. Return the value of a[n - 1] after k seconds. Since the answer may be very large, return it modulo 109 + 7.","O(n * k), where n is the size of the array and k is the number of seconds","O(n + k), where n is the size of the array and k is the number of seconds","O(k log n), where n is the size of the array and k is the number of seconds","O(log n + k), where n is the size of the array and k is the number of seconds","O(log k), utilizing binomial coefficients to compute the final value efficiently",Medium,algorithms,"Array,Math,Simulation,Combinatorics,Prefix Sum"
3180,"Maximum Total Reward Using Operations I
You are given an integer array rewardValues of length n, representing the values of rewards. Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times: Return an integer denoting the maximum total reward you can collect by performing the operations optimally.",Perform a greedy approach by always choosing the largest available reward value.,Sort the reward values in descending order and sum the first half of the array.,Recursively select the first element and add it to the result of the same operation on the rest of the array.,Always select the smallest reward value in each step.,"Use dynamic programming to determine the optimal sequence of operations, maximizing total reward at each step.",Medium,algorithms,"Array,Dynamic Programming"
3181,"Maximum Total Reward Using Operations II
You are given an integer array rewardValues of length n, representing the values of rewards. Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times: Return an integer denoting the maximum total reward you can collect by performing the operations optimally.",Greedily select the highest value rewards until no rewards remain.,Use dynamic programming to calculate the maximum reward obtainable by either marking or not marking each index.,Sort the reward values and take the top half as the maximum reward.,Recursively divide the array and choose the sub-array with a higher sum.,Apply dynamic programming with memoization to store the maximum reward achievable from each index with a boolean flag indicating whether the current index is marked or unmarked.,Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation"
3184,"Count Pairs That Form a Complete Day I
Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day. A complete day is defined as a time duration that is an exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.",Use a hash map to store the frequency of each hour and iterate through the hash map to count pairs that sum to a multiple of 24.,Sort the hours array and use two pointers to find pairs that sum to a multiple of 24.,"For each element hours[i], iterate through the rest of the array to find a matching hours[j] such that hours[i] + hours[j] is a multiple of 24. After calculation, break the inner loop.",Find the minimum and maximum value in array hours. Calculate the possible pairs between the two values and return their count.,"For each element hours[i], iterate through the rest of the array to find a matching hours[j] such that hours[i] + hours[j] is a multiple of 24.",Easy,algorithms,"Array,Hash Table,Counting"
3185,"Count Pairs That Form a Complete Day II
Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day. A complete day is defined as a time duration that is an exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.","Use a hash map to store frequencies and check pairs summing to 24, but only for values less than or equal to 24",Sort the array and use two pointers to find pairs that sum to multiples of 24,Iterate through all possible pairs and check if their sum is divisible by 24 without considering memoization or frequency counts,Use recursion to find the pairs. Make sure you account for stack overflow,"Use a hash map to store remainders when each element is divided by 24, then count pairs that sum to a multiple of 24",Medium,algorithms,"Array,Hash Table,Counting"
3186,"Maximum Total Damage With Spell Casting
A magician has various spells. You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value. It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2. Each spell can be cast only once. Return the maximum possible total damage that a magician can cast.","Sort the `power` array and greedily select spells from the highest damage, skipping those that violate the rule.","Apply dynamic programming by considering each spell and calculating the maximum damage with and without casting that spell, memoizing the results.","Use a backtracking approach, exploring all possible combinations of spell castings and pruning branches that violate the rules.","Calculate the sum of all elements in the `power` array. Then, subtract the smallest element and the element that violates the rule, and return the result.","Use dynamic programming to iterate through the sorted `power` array, choosing to cast a spell or skip it based on whether it maximizes the total damage without violating the constraints.",Medium,algorithms,"Array,Hash Table,Two Pointers,Binary Search,Dynamic Programming,Sorting,Counting"
3187,"Peaks in Array
A peak in an array arr is an element that is greater than its previous and next element in arr. You are given an integer array nums and a 2D integer array queries. You have to process queries of two types: Return an array answer containing the results of the queries of the first type in order. Notes:",Use dynamic programming to store intermediate results and optimize query processing,Precompute all possible peak combinations and store them in a lookup table,Sort the array and use binary search to find peaks efficiently,Iterate through the entire array for each query to identify peaks within the given range,Use segment trees or range trees to efficiently query for peaks within specified ranges,Hard,algorithms,"Array,Binary Indexed Tree,Segment Tree"
3190,"Find Minimum Operations to Make All Elements Divisible by Three
You are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums. Return the minimum number of operations to make all elements of nums divisible by 3.","Calculate the sum of remainders when divided by 3. If the sum is divisible by 3, return 0; otherwise, return 1.","For each number, find the minimum of (number % 3) and (3 - (number % 3)). Sum these minimums.",Multiply each number by 2 and then take the modulo by 3. Sum the results.,Sort the numbers in descending order and perform the operations on the largest numbers first.,"For each number, find the minimum of (number % 3) and (3 - (number % 3)), then sum these values. This is the minimum number of operations.",Easy,algorithms,"Array,Math"
3191,"Minimum Operations to Make Binary Array Elements Equal to One I
You are given a binary array nums. You can do the following operation on the array any number of times (possibly zero): Flipping an element means changing its value from 0 to 1, and from 1 to 0. Return the minimum number of operations required to make all elements in nums equal to 1. If it is impossible, return -1.",Calculate the bitwise AND of all elements and flip the result if it's 0,"Count the number of 0s, and if it's greater than half the array size, return the array size minus the count of 0s, otherwise return -1","Return the index of the first occurrence of 0 if it exists, otherwise return 0","If the array contains at least one 1, return the number of 0s, otherwise return -1",Return the number of 0s in the array,Medium,algorithms,"Array,Bit Manipulation,Queue,Sliding Window,Prefix Sum"
3192,"Minimum Operations to Make Binary Array Elements Equal to One II
You are given a binary array nums. You can do the following operation on the array any number of times (possibly zero): Flipping an element means changing its value from 0 to 1, and from 1 to 0. Return the minimum number of operations required to make all elements in nums equal to 1.",Count the total number of 0s in the array.,Find the longest sequence of consecutive 0s and return its length.,Iterate through the array and flip all elements to 1 if the previous element was 0.,Count the number of transitions from 1 to 0 in the array.,Count the number of maximal contiguous subarrays of 0s and return the number of such subarrays.,Medium,algorithms,"Array,Dynamic Programming,Greedy"
3193,"Count the Number of Inversions
You are given an integer n and a 2D array requirements, where requirements[i] = [endi, cnti] represents the end index and the inversion count of each requirement. A pair of indices (i, j) from an integer array nums is called an inversion if: Return the number of permutations perm of [0, 1, 2, ..., n - 1] such that for all requirements[i], perm[0..endi] has exactly cnti inversions. Since the answer may be very large, return it modulo 109 + 7.","Use a greedy approach, filling the permutation from left to right to satisfy requirements in order","Employ dynamic programming, storing counts of permutations satisfying requirements up to a certain index","Utilize backtracking to explore all possible permutations, pruning branches that violate inversion counts","Apply a divide-and-conquer strategy, splitting the permutation and merging the inversion counts",Use a combination of dynamic programming and inclusion-exclusion to count valid permutations,Hard,algorithms,"Array,Dynamic Programming"
3194,"Minimum Average of Smallest and Largest Elements
You have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even. You repeat the following procedure n / 2 times: Return the minimum element in averages.",Sort the entire array and calculate the average of the first and last elements.,Iterate through all possible pairs in the array and calculate the average of each pair.,Randomly select two numbers from the array and calculate their average.,"Find the minimum and maximum elements of the array, ignoring all other elements.","Repeatedly find and remove the minimum and maximum elements from the array, calculating their average each time.",Easy,algorithms,"Array,Two Pointers,Sorting"
3195,"Find the Minimum Area to Cover All Ones I
You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle. Return the minimum possible area of the rectangle.","Use binary search to find the topmost, bottommost, leftmost, and rightmost '1's","Iterate through the grid linearly, updating the minimum and maximum row and column indices of '1's encountered",Apply dynamic programming to precompute the cumulative sum of '1's in the grid,Use a quadtree data structure to recursively divide the grid and find the bounding rectangle,"Scan the grid to find the minimum and maximum row and column indices containing '1's, and compute the area using these bounds",Medium,algorithms,"Array,Matrix"
3196,"Maximize Total Cost of Alternating Subarrays
You are given an integer array nums with length n. The cost of a subarray nums[l..r], where 0 <= l <= r < n, is defined as: cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l Your task is to split nums into subarrays such that the total cost of the subarrays is maximized, ensuring each element belongs to exactly one subarray. Formally, if nums is split into k subarrays, where k > 1, at indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then the total cost will be: cost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1) Return an integer denoting the maximum total cost of the subarrays after splitting the array optimally. Note: If nums is not split into subarrays, i.e. k = 1, the total cost is simply cost(0, n - 1).",Recursively calculate the cost for all possible subarray splits and choose the maximum,Use dynamic programming with a 2D table to store costs of all subarrays,Greedily split the array at each index where nums[i] > nums[i+1],Calculate the cost of the entire array and the cost of splitting it into individual elements and take the maximum of the two,Use dynamic programming with a 1D array to store the maximum cost up to each index,Medium,algorithms,"Array,Dynamic Programming"
3197,"Find the Minimum Area to Cover All Ones II
You are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-zero areas with horizontal and vertical sides such that all the 1's in grid lie inside these rectangles. Return the minimum possible sum of the area of these rectangles. Note that the rectangles are allowed to touch.","Use dynamic programming with a 2D array to store intermediate results, considering all possible rectangle placements.",Employ a greedy algorithm that iteratively selects the largest contiguous region of 1s and attempts to enclose it in a rectangle.,"Apply a divide-and-conquer strategy, recursively splitting the grid into smaller subgrids and solving the problem for each.","Transform the grid into a graph and use graph coloring to identify connected components of 1s, then enclose them in rectangles.","Utilize dynamic programming with four dimensions: row, column, number of rectangles used, and a bitmask representing whether the cell is covered by a rectangle, to minimize the total area.",Hard,algorithms,"Array,Matrix,Enumeration"
3200,"Maximum Height of a Triangle
You are given two integers red and blue representing the count of red and blue colored balls. You have to arrange these balls to form a triangle such that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd row will have 3 balls, and so on. All the balls in a particular row should be the same color, and adjacent rows should have different colors. Return the maximum height of the triangle that can be achieved.",Return the floor of the square root of (2 * (red + blue)),"Return the sum of red and blue divided by 2, rounded down to the nearest integer",Return the maximum of red and blue,"Use binary search to find the largest height such that the sum of 1 to height is less than or equal to (red + blue), regardless of alternating colors","Use binary search to find the largest height such that the sum of 1 to height is less than or equal to (red + blue), checking for alternating color feasibility at each step",Easy,algorithms,"Array,Enumeration"
3201,"Find the Maximum Length of Valid Subsequence I
A subsequence sub of nums with length x is called valid if it satisfies: Return the length of the longest valid subsequence of nums. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.","Greedily select elements, always choosing the smallest available number","Recursively check all possible subsequences for validity, returning the maximum length found",Sort the array and count the number of elements greater than zero,Use dynamic programming to store the maximum length of valid subsequences ending at each index,"Iterate through the array, tracking the count of positive elements encountered so far",Medium,algorithms,"Array,Dynamic Programming"
3202,"Find the Maximum Length of Valid Subsequence II
A subsequence sub of nums with length x is called valid if it satisfies:","Recursively explore all possible subsequences and check validity, which is inefficient for large inputs.",Use dynamic programming to store the maximum length of valid subsequences ending at each index.,Sort the input array and greedily select elements that satisfy the subsequence condition.,Use a sliding window approach to find the longest valid subsequence.,Apply bit manipulation to generate all possible subsequences and check for validity.,Medium,algorithms,"Array,Dynamic Programming"
3203,"Find Minimum Diameter After Merging Two Trees
There exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree. You must connect one node from the first tree with another node from the second tree with an edge. Return the minimum possible diameter of the resulting tree. The diameter of a tree is the length of the longest path between any two nodes in the tree.",Use Prim's algorithm to find the minimum spanning tree and then calculate its diameter.,Connect all possible pairs of nodes between the two trees and choose the connection resulting in the smallest diameter using Dijkstra's algorithm to compute shortest paths.,"Calculate the diameters of both trees independently, then simply add them together for the result.",Contract each tree to a single node and then connect these two nodes to minimize the diameter.,Find the endpoints of the diameters of both trees. Connect the two most distant endpoints and compute the diameter of the combined tree. Repeat for all endpoint pairs and find the minimum.,Hard,algorithms,"Tree,Depth-First Search,Breadth-First Search,Graph"
3206,"Alternating Groups I
There is a circle of red and blue tiles. You are given an array of integers colors. The color of tile i is represented by colors[i]: Every 3 contiguous tiles in the circle with alternating colors (the middle tile has a different color from its left and right tiles) is called an alternating group. Return the number of alternating groups. Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.",The maximum depth of a binary tree is always less than or equal to the height of a complete binary tree with the same number of nodes.,"In a left-leaning red-black tree, every node is either red or black, and red nodes lean towards the left.  Deleting a node always preserves perfect black balance.","A B-tree of order m always has a height of log_m(n), where n is the number of keys. Inserting a key always splits nodes from the root down.","Skip lists offer deterministic logarithmic time complexity for search, insertion, and deletion operations.","AVL trees maintain balance through rotations that ensure the height difference between left and right subtrees of any node is at most one, guaranteeing O(log n) search time.",Easy,data structures,"Array,Sliding Window"
3207,"Maximum Points After Enemy Battles
You are given an integer array enemyEnergies denoting the energy values of various enemies. You are also given an integer currentEnergy denoting the amount of energy you have initially. You start with 0 points, and all the enemies are unmarked initially. You can perform either of the following operations zero or multiple times to gain points: Return an integer denoting the maximum points you can get in the end by optimally performing operations.","Use a greedy approach, always battling the weakest enemy first, regardless of energy cost.",Sort the enemy energies in descending order and battle as many as possible until energy runs out.,"Employ a brute-force approach, trying all possible combinations of enemy battles and choosing the one with maximum points.","Battle all enemies if possible; otherwise, battle none to conserve energy.",Use dynamic programming to determine the maximum points achievable with each possible energy level after battling each enemy.,Medium,algorithms,"Array,Greedy"
3208,"Alternating Groups II
There is a circle of red and blue tiles. You are given an array of integers colors and an integer k. The color of tile i is represented by colors[i]: An alternating group is every k contiguous tiles in the circle with alternating colors (each tile in the group except the first and last one has a different color from its left and right tiles). Return the number of alternating groups. Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.","Divide the input array into k-sized chunks and check if each chunk alternates, handling edge cases for circularity.",Concatenate the array with itself to simulate the circle and then iterate through all possible k-sized subarrays.,Use a sliding window of size k and maintain two boolean variables to track the expected color in the alternating sequence.,"Sort the array and then check for alternating patterns in contiguous k-sized segments, accounting for wrap-around.","Iterate through the array using a sliding window of size k and, for each window, verify that adjacent elements have different values, wrapping around at the array's end to simulate circularity.",Medium,algorithms,"Array,Sliding Window"
3209,"Number of Subarrays With AND Value of K
Given an array of integers nums and an integer k, return the number of subarrays of nums where the bitwise AND of the elements of the subarray equals k.",Iterate through all possible subarrays and calculate the bitwise AND using a standard loop structure.,Precompute the bitwise AND of all prefixes of the array and use this information to efficiently calculate the AND of subarrays.,Sort the array and then count subarrays that contain k and have a bitwise AND equal to k.,"Use a sliding window approach, shrinking the window when the AND is less than k and expanding it when it is greater.","Use a sliding window approach, expanding the window to include more elements and shrinking the window when the bitwise AND is less than k, counting valid subarrays.",Hard,algorithms,"Array,Binary Search,Bit Manipulation,Segment Tree"
3210,"Find the Encrypted String
You are given a string s and an integer k. Encrypt the string using the following algorithm: Return the encrypted string.",Reverse the string and apply a Caesar cipher with key k.,Replace each character with its ASCII value modulo k.,Apply a Vigenère cipher using a key generated from the digits of k.,XOR each character with k.,Shift each character's ASCII value by k positions cyclically within the alphabet.,Easy,algorithms,String
3211,"Generate Binary Strings Without Adjacent Zeros
You are given a positive integer n. A binary string x is valid if all substrings of x of length 2 contain at least one ""1"". Return all valid strings with length n, in any order.","Use dynamic programming to count valid strings ending in '0' and '1', then reconstruct the strings.",Generate all possible binary strings of length n and then filter out the invalid ones.,"Employ a greedy approach, always adding '1' unless two '1's have already been added consecutively.","Use backtracking to explore possible binary strings, pruning branches that violate the adjacent zero constraint.","Use recursion, building strings by appending '0' only if the last character was '1', and always appending '1'.",Medium,algorithms,"String,Backtracking,Bit Manipulation"
3212,"Count Submatrices With Equal Frequency of X and Y
Given a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain:","Calculate the cumulative sum of 'X' and 'Y' occurrences in prefix sums and iterate over all submatrices, checking frequency equality in O(n^4) time.",Use dynamic programming to store the counts of 'X' and 'Y' in submatrices ending at each cell and iterate through DP table.,Perform a brute-force search by generating all possible submatrices and counting 'X' and 'Y' occurrences for each.,Employ a sliding window technique across rows and columns to efficiently count the occurrences of 'X' and 'Y' within dynamically sized submatrices.,"Compute prefix sums for 'X' and 'Y' counts, then iterate through all possible submatrices, using the prefix sums for O(1) count retrieval per submatrix.",Medium,algorithms,"Array,Matrix,Prefix Sum"
3213,"Construct String with Minimum Cost
You are given a string target, an array of strings words, and an integer array costs, both arrays of the same length. Imagine an empty string s. You can perform the following operation any number of times (including zero): Return the minimum cost to make s equal to target. If it's not possible, return -1.",Use dynamic programming to compute the minimum cost to construct prefixes of the target string using words as building blocks.,"Employ a greedy approach, always selecting the word with the lowest cost that is a substring of the remaining target string.",Recursively try all possible combinations of words and memoize the minimum cost for each subproblem.,"Sort the words by length and then iterate through them in descending order, selecting the cheapest option.","Build a directed acyclic graph (DAG) where nodes represent prefixes of the target, and edges represent words that can be appended. Use topological sort and dynamic programming to find the shortest path.",Hard,algorithms,"Array,String,Dynamic Programming,Suffix Array"
3216,"Lexicographically Smallest String After a Swap
Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once. Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.",Sort the input string and return the result.,Perform all possible adjacent swaps and select the lexicographically smallest string.,"Iterate through the string and swap each digit with the smallest digit of the same parity to its right, if it results in a smaller string.",Reverse the string before performing any swaps to get the smallest lexicographical order.,"For each position, find the smallest digit of the same parity to the right and swap it to the current position if it results in a smaller string.",Easy,algorithms,"String,Greedy"
3217,"Delete Nodes From Linked List Present in Array
You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.",Use a hash table to store the elements of `nums` and remove nodes in the linked list if their value is not in the hash table.,"Sort the linked list and the array `nums` then iterate through the linked list, removing nodes found in `nums`.","Recursively traverse the linked list, comparing each node's value to `nums` and skipping nodes that match.","Convert the linked list into an array, filter out the elements present in `nums`, and then rebuild the linked list.","Iterate through the linked list, maintaining a `previous` pointer. If a node's value is in `nums`, update `previous.next` to skip the node.",Medium,data structures,"Array,Hash Table,Linked List"
3218,"Minimum Cost for Cutting Cake I
There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given integers m, n, and two arrays: In one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts: After the cut, the piece of cake is divided into two distinct pieces. The cost of a cut depends only on the initial cost of the line and does not change. Return the minimum total cost to cut the entire cake into 1 x 1 pieces.",Greedily cut along the longest remaining dimension at each step.,Sort both horizontal and vertical cuts independently and sum their costs.,"Dynamically program by calculating the cost of cutting sub-rectangles, starting from 1x1.",Always cut along the dimension with the higher cost per unit length.,Apply dynamic programming considering all possible cut sequences and memoizing subproblem solutions.,Medium,algorithms,"Array,Dynamic Programming,Greedy,Sorting"
3219,"Minimum Cost for Cutting Cake II
There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given integers m, n, and two arrays: In one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts: After the cut, the piece of cake is divided into two distinct pieces. The cost of a cut depends only on the initial cost of the line and does not change. Return the minimum total cost to cut the entire cake into 1 x 1 pieces.",Apply a greedy approach by always cutting along the longest dimension first,Use dynamic programming with a state representing the size of the cake and the cuts already made,Sort the horizontal and vertical cuts and sum their individual costs,Cut the cake into equal-sized squares and recursively cut these squares until 1x1 size,"Sort both horizontal and vertical cuts in descending order, and apply cuts greedily based on their costs, considering both dimensions",Hard,algorithms,"Array,Greedy,Sorting"
3220,"Odd and Even Transactions
Table: transactions Write a solution to find the sum of amounts for odd and even transactions for each day. If there are no odd or even transactions for a specific date, display as 0. Return the result table ordered by transaction_date in ascending order. The result format is in the following example.  Example: Input: transactions table: Output: Explanation: Note: The output table is ordered by transaction_date in ascending order.",Use a single aggregate function with a CASE statement to differentiate between odd and even transactions.,Employ window functions to partition the data by transaction type (odd/even) and calculate running sums.,"Create temporary tables for odd and even transactions, then join them on transaction_date and sum the amounts.",Use a recursive common table expression (CTE) to iterate through each transaction and accumulate odd and even amounts.,Use two separate aggregate functions with WHERE clauses to sum odd and even transaction amounts for each date.,Medium,database systems,Database
3222,"Find the Winning Player in Coin Game
You are given two positive integers x and y, denoting the number of coins with values 75 and 10 respectively. Alice and Bob are playing a game. Each turn, starting with Alice, the player must pick up coins with a total value 115. If the player is unable to do so, they lose the game. Return the name of the player who wins the game if both players play optimally.","Alice wins if x >= 1 and y >= 4, otherwise Bob wins.","Bob wins if x and y are both even, otherwise Alice wins.",Alice always wins because she goes first.,The winner depends on the greatest common divisor of x and y.,"Alice wins if floor((75x + 10y) / 115) is odd, otherwise Bob wins.",Easy,algorithms,"Math,Simulation,Game Theory"
3223,"Minimum Length of String After Operations
You are given a string s. You can perform the following process on s any number of times: Return the minimum length of the final string s that you can achieve.","Count occurrences of 'A' and 'B', returning the larger count.","Remove all 'A's then all 'B's, returning the length of the remaining string.",Return the length of the original string without modifications.,"Replace all occurrences of 'AB' and 'BA' with an empty string until no more replacements can be made, then return the length of the final string.","Count occurrences of 'A' and 'B', returning the absolute difference between the counts.",Medium,algorithms,"Hash Table,String,Counting"
3224,"Minimum Array Changes to Make Differences Equal
You are given an integer array nums of size n where n is even, and an integer k. You can perform some changes on the array, where in one change you can replace any element in the array with any integer in the range from 0 to k. You need to perform some changes (possibly none) such that the final array satisfies the following condition: Return the minimum number of changes required to satisfy the above condition.",Apply dynamic programming to track the minimum changes for each prefix of the array.,"Sort the array and then iterate through each element, making changes only if necessary.","Use a greedy approach, always changing the element furthest from the required difference.",Calculate the average of the array and change all elements to that average.,"For each index i, find the mode of nums[i], nums[i+k], nums[i+2k],..., and change other elements to the mode",Medium,algorithms,"Array,Hash Table,Prefix Sum"
3225,"Maximum Score From Grid Operations
You are given a 2D matrix grid of size n x n. Initially, all cells of the grid are colored white. In one operation, you can select any cell of indices (i, j), and color black all the cells of the jth column starting from the top row down to the ith row. The grid score is the sum of all grid[i][j] such that cell (i, j) is white and it has a horizontally adjacent black cell. Return the maximum score that can be achieved after some number of operations.",Use dynamic programming to calculate the maximum score for each possible state of the grid after each operation.,"Apply a greedy algorithm, always choosing the operation that yields the highest immediate score increase.","Solve the problem using a brute-force approach, trying all possible combinations of operations.",Calculate the total sum of the grid and subtract the minimum possible score after any number of operations.,"Iterate through the columns and for each column, determine the optimal row to color black based on the prefix sum of the rows in that column and the adjacent cells.",Hard,algorithms,"Array,Dynamic Programming,Matrix,Prefix Sum"
3226,"Number of Bit Changes to Make Two Integers Equal
You are given two positive integers n and k. You can choose any bit in the binary representation of n that is equal to 1 and change it to 0. Return the number of changes needed to make n equal to k. If it is impossible, return -1.",Count the set bits in n and unset bits in k. Return the larger of the two counts.,Calculate the difference between n and k. Return the number of set bits in the absolute value of the difference.,"Right shift both n and k until they are 0, counting the shifts. The difference in shift counts is the result.",Return the number of set bits in (n AND k).,Calculate the bitwise XOR of n and k. Return the number of set bits in the result.,Easy,algorithms,Bit Manipulation
3227,"Vowels Game in a String
Alice and Bob are playing a game on a string. You are given a string s, Alice and Bob will take turns playing the following game where Alice starts first: The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally. Return true if Alice wins the game, and false otherwise. The English vowels are: a, e, i, o, and u.","If the number of vowels is even, Bob wins.","If the string contains no vowels, Bob wins.","If the string length is even, Alice wins.","If the first and last characters are vowels, Alice wins.","If the number of vowels is odd, Alice wins.",Medium,algorithms,"Math,String,Brainteaser,Game Theory"
3228,"Maximum Number of Operations to Move Ones to the End
You are given a binary string s. You can perform the following operation on the string any number of times: Return the maximum number of operations that you can perform.",Sort the string and count the moves needed to shift all '1's to the end.,"Count '0's and '1's, and the answer will be the min of those values.",Swap adjacent characters in the string until all '1's are at the end.,Reverse the string and count trailing '1's. This is the answer.,Count pairs of '01' that can be swapped until all '1's are at the end of the string.,Medium,algorithms,"String,Greedy,Counting"
3229,"Minimum Operations to Make Array Equal to Target
You are given two positive integer arrays nums and target, of the same length. In a single operation, you can select any subarray of nums and increment each element within that subarray by 1 or decrement each element within that subarray by 1. Return the minimum number of operations required to make nums equal to the array target.",Calculate the prefix sums of both arrays and find the absolute difference between corresponding elements.,Sort both arrays and calculate the sum of absolute differences between elements at the same index.,Use dynamic programming to find the longest common subsequence and subtract its length from the total length of the arrays.,Compute the difference array for both arrays and sum the absolute values of the differences.,Calculate the sum of absolute differences between adjacent elements in the difference array (nums - target).,Hard,algorithms,"Array,Dynamic Programming,Stack,Greedy,Monotonic Stack"
3232,"Find if Digit Game Can Be Won
You are given an array of positive integers nums. Alice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers. Return true if Alice can win this game, otherwise, return false.",Always choose single-digit numbers for Alice and double-digit numbers for Bob.,Alice wins only if the sum of all numbers is even.,"If the length of nums is even, Bob always wins.",Sort the numbers in descending order and give the largest half to Alice.,"Compare the sums of all possible combinations of single-digit and double-digit numbers assigned to Alice, checking if any combination leads to Alice winning.",Easy,algorithms,"Array,Math"
3233,"Find the Count of Numbers Which Are Not Special
You are given 2 positive integers l and r. For any number x, all positive divisors of x except x are called the proper divisors of x. A number is called special if it has exactly 2 proper divisors. For example: Return the count of numbers in the range [l, r] that are not special.",A number is special if and only if it's the square of a prime number.,A number is special if and only if it is a prime number.,A number is special if and only if it is a power of 2.,A number is special if and only if it is a perfect cube.,A number is special if and only if it's the product of two distinct primes.,Medium,algorithms,"Array,Math,Number Theory"
3234,"Count the Number of Substrings With Dominant Ones
You are given a binary string s. Return the number of substrings with dominant ones. A string has dominant ones if the number of ones in the string is greater than or equal to the square of the number of zeros in the string.",Enumerate all substrings and check the 'dominant ones' condition with O(1) calculation per substring.,Precompute the counts of ones and zeros for all prefixes to optimize substring checks.,Use dynamic programming to store the counts of valid substrings ending at each index.,"Employ a two-pointer technique, expanding and contracting a window to identify valid substrings.","Iterate through all substrings, counting ones and zeros, and verifying if the number of ones is greater than or equal to the square of the number of zeros.",Medium,algorithms,"String,Sliding Window,Enumeration"
3235,"Check if the Rectangle Corner Is Reachable
You are given two positive integers xCorner and yCorner, and a 2D array circles, where circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and radius ri. There is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at the coordinate (xCorner, yCorner). You need to check whether there is a path from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, does not touch or lie inside any circle, and touches the rectangle only at the two corners. Return true if such a path exists, and false otherwise.","Use a greedy algorithm to find the shortest path, and if it intersects a circle, return false","Check if any circle's center lies within the rectangle; if so, return false",Divide the rectangle into smaller cells and use Dijkstra's algorithm to find a path avoiding the circles,Check if the origin and the corner are within the same connected component in a graph where nodes are points and edges connect points that are not blocked by circles,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the rectangle, treating circles as obstacles, and determine if a path exists from the origin to the corner",Hard,algorithms,"Array,Math,Depth-First Search,Breadth-First Search,Union Find,Geometry"
3238,"Find the Number of Winning Players
You are given an integer n representing the number of players in a game and a 2D array pick where pick[i] = [xi, yi] represents that the player xi picked a ball of color yi. Player i wins the game if they pick strictly more than i balls of the same color. In other words, Return the number of players who win the game. Note that multiple players can win the game.",Sort the 'pick' array by player ID and count occurrences of each color for each player.,Calculate the average number of balls picked per player and compare individual counts against the average.,"Use a hash map to track the color picked by each player, and increment a counter when the same player picks the same color. Increment the player counter when the number of balls exceeds player ID.",Iterate through the pick array and mark players who picked the same color. Return the number of marked players.,"Use a hash map to count color occurrences per player. Iterate through players; if any color count is greater than the player ID, increment the winner count.",Easy,algorithms,"Array,Hash Table,Counting"
3239,"Minimum Number of Flips to Make Binary Grid Palindromic I
You are given an m x n binary matrix grid. A row or column is considered palindromic if its values read the same forward and backward. You can flip any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum number of cells that need to be flipped to make either all rows palindromic or all columns palindromic.","Calculate the Hamming distance between each row and its reverse, and each column and its reverse. Return the minimum of the sums of these distances for rows and columns.",Calculate the number of 0s and 1s in each row and column. Flip rows or columns with a higher number of 0s to minimize the total number of flips.,Use dynamic programming to find the optimal number of flips for making the first i rows/columns palindromic.,Iterate through all possible combinations of row and column flips and calculate the number of flips required for each. Return the minimum.,Use bit manipulation to represent each row and column as an integer. Compare each with its reverse using XOR and count the set bits for each to calculate the minimum flips needed. Return the minimum of row-wise and column-wise sums.,Medium,algorithms,"Array,Two Pointers,Matrix"
3240,"Minimum Number of Flips to Make Binary Grid Palindromic II
You are given an m x n binary matrix grid. A row or column is considered palindromic if its values read the same forward and backward. You can flip any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum number of cells that need to be flipped to make all rows and columns palindromic, and the total number of 1's in grid divisible by 4.","Use dynamic programming, considering all possible subsets of flipped cells with overlapping subproblems","Employ a greedy algorithm, flipping cells based on the most frequent value in each row and column","Apply a brute-force approach, trying every possible combination of cell flips and checking for palindromes and the ones count",Transform the problem into a maximum flow network and use the Ford-Fulkerson algorithm,Formulate the problem as a minimum cost maximum matching problem on a bipartite graph,Medium,algorithms,"Array,Two Pointers,Matrix"
3241,"Time Taken to Mark All Nodes
There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. Initially, all nodes are unmarked. For each node i: Return an array times where times[i] is the time when all nodes get marked in the tree, if you mark node i at time t = 0. Note that the answer for each times[i] is independent, i.e. when you mark node i all other nodes are unmarked.","BFS, without considering already visited nodes, potentially leading to infinite loops.","DFS using recursion, limited by stack size for large trees, possibly causing stack overflow errors.","Calculating the sum of shortest paths from node 'i' to every other node, which doesn't represent the time when all nodes are marked.","Prioritizing exploration of the farthest nodes first, instead of propagating the mark from the starting node.","BFS or DFS starting from node 'i', keeping track of the maximum distance from 'i' to any node visited so far.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search,Graph"
3242,"Design Neighbor Sum Service
You are given a n x n 2D array grid containing distinct elements in the range [0, n2 - 1]. Implement the NeighborSum class:",Precompute all possible neighbor sums and store them in a lookup table,Use a multi-threaded approach to calculate sums for different grid sections concurrently,Employ a recursive algorithm to find neighbor sums,Iterate through the grid and update each cell with its neighbor sum directly in place,Cache previously calculated neighbor sums to improve performance for repeated queries,Easy,system design,"Array,Hash Table,Design,Matrix,Simulation"
3243,"Shortest Distance After Road Addition Queries I
You are given an integer n and a 2D integer array queries. There are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1. Return an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.","Use Dijkstra's algorithm from node 0 to node n-1 after each query, without considering previously computed distances.",Use the Floyd-Warshall algorithm to compute all-pairs shortest paths after each query.,Compute shortest paths using BFS only after all queries are processed to reduce computational overhead.,Maintain a single shortest path tree and update it incrementally after each query using a naive update approach without considering possible shorter paths created due to new edges.,"Use Dijkstra's algorithm, but optimize by incrementally updating distances considering only the nodes potentially affected by the new edge.",Medium,algorithms,"Array,Breadth-First Search,Graph"
3244,"Shortest Distance After Road Addition Queries II
You are given an integer n and a 2D integer array queries. There are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1. There are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Return an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.","Use Dijkstra's algorithm, recomputing from scratch after each query.",Precompute all-pairs shortest paths using Floyd-Warshall initially and update only paths affected by the new edge after each query.,Run Bellman-Ford algorithm from node 0 after each query.,Maintain a topological ordering and update distances based on the topological order after each addition.,"Use Dijkstra's algorithm with a priority queue, updating distances incrementally after each edge addition, taking advantage of the monotonic nature of the queries.",Hard,algorithms,"Array,Greedy,Graph,Ordered Set"
3245,"Alternating Groups III
There are some red and blue tiles arranged circularly. You are given an array of integers colors and a 2D integers array queries. The color of tile i is represented by colors[i]: An alternating group is a contiguous subset of tiles in the circle with alternating colors (each tile in the group except the first and last one has a different color from its adjacent tiles in the group). You have to process queries of two types: Return an array answer containing the results of the queries of the first type in order. Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.",Use dynamic programming to store lengths of alternating subsequences starting at each index.,"Employ a greedy algorithm, always extending the current alternating group if possible.",Sort the colors array and then search for alternating groups in the sorted array.,Recursively divide the circle in half and find the longest alternating groups in each half.,"Iterate through the colors array, checking for alternating patterns and handling the circular wrap-around efficiently for each query.",Hard,algorithms,"Array,Binary Indexed Tree"
3248,"Snake in Matrix
There is a snake in an n x n matrix grid and can move in four possible directions. Each cell in the grid is identified by the position: grid[i][j] = (i * n) + j. The snake starts at cell 0 and follows a sequence of commands. You are given an integer n representing the size of the grid and an array of strings commands where each command[i] is either ""UP"", ""RIGHT"", ""DOWN"", and ""LEFT"". It's guaranteed that the snake will remain within the grid boundaries throughout its movement. Return the position of the final cell where the snake ends up after executing commands.",Use a Breadth-First Search algorithm to explore all possible paths.,"Recursively move the snake based on the commands, tracking the path.",Translate the commands into corresponding coordinate changes and apply them iteratively.,Simulate the snake's movement using a stack data structure to track its path.,"Iterate through the commands, updating the row and column indices based on each command's direction.",Easy,algorithms,"Array,String,Simulation"
3249,"Count the Number of Good Nodes
There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. A node is good if all the subtrees rooted at its children have the same size. Return the number of good nodes in the given tree. A subtree of treeName is a tree consisting of a node in treeName and all of its descendants.",Nodes with even labels are considered good.,Nodes that are leaves in the tree are considered good.,Nodes where the sum of its children's labels is a prime number are considered good.,All nodes in the tree are considered good.,Nodes where all subtrees rooted at its children have the same size are considered good.,Medium,algorithms,"Tree,Depth-First Search"
3250,"Find the Count of Monotonic Pairs I
You are given an array of positive integers nums of length n. We call a pair of non-negative integer arrays (arr1, arr2) monotonic if: Return the count of monotonic pairs. Since the answer may be very large, return it modulo 109 + 7.",Sort the input array using bubble sort and count pairs where nums[i] <= nums[i+1],Use dynamic programming to store the count of monotonic subsequences ending at each index,"Iterate through all possible pairs and check if they are monotonic, using recursion to handle the modulo operation",Calculate the prefix sum of the array and then count pairs based on prefix sum differences,"Iterate through the array, comparing adjacent elements and incrementing a counter if the condition nums[i] <= nums[i+1] is met; apply the modulo operator at each increment",Hard,algorithms,"Array,Math,Dynamic Programming,Combinatorics,Prefix Sum"
3251,"Find the Count of Monotonic Pairs II
You are given an array of positive integers nums of length n. We call a pair of non-negative integer arrays (arr1, arr2) monotonic if: Return the count of monotonic pairs. Since the answer may be very large, return it modulo 109 + 7.","Divide the array into sub-arrays and recursively count monotonic pairs within each sub-array, then combine the results.","Sort the array and then iterate through it, counting pairs that maintain the sorted order.",Use dynamic programming to store the counts of monotonic sub-sequences ending at each index.,"Iterate through the array and for each element, iterate through the rest of the array to find monotonic pairs.",Use a modified merge sort algorithm that counts monotonic pairs during the merge step.,Hard,algorithms,"Array,Math,Dynamic Programming,Combinatorics,Prefix Sum"
3254,"Find the Power of K-Size Subarrays I
You are given an array of integers nums of length n and a positive integer k. The power of an array is defined as: You need to find the power of all subarrays of nums of size k. Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].","Calculate the sum of each subarray using a sliding window of size k, then apply the power function.",Precompute prefix sums and use them to calculate the sum of each subarray of size k before applying the power function.,"Iterate through all possible subarrays of size k, calculate their sums by direct iteration, and then apply the power function.",Use dynamic programming to store the sums of all possible subarrays and retrieve the sums of size k subarrays to calculate the power.,Use a sliding window of size k to efficiently calculate the sum of each subarray and maintain a running power value.,Medium,algorithms,"Array,Sliding Window"
3255,"Find the Power of K-Size Subarrays II
You are given an array of integers nums of length n and a positive integer k. The power of an array is defined as: You need to find the power of all subarrays of nums of size k. Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].",Calculate the sum of all elements and divide by k,Find the median of each subarray and raise it to the power of k,Multiply each element within the subarray by its index and sum the result,Calculate the variance of each subarray,Compute the sum of squares of each element in the subarray,Medium,algorithms,"Array,Sliding Window"
3256,"Maximum Value Sum by Placing Three Rooks I
You are given a m x n 2D array board representing a chessboard, where board[i][j] represents the value of the cell (i, j). Rooks in the same row or column attack each other. You need to place three rooks on the chessboard such that the rooks do not attack each other. Return the maximum sum of the cell values on which the rooks are placed.","Use a greedy approach by selecting the top three largest values in the entire board, regardless of row/column conflicts.","Iterate through all possible combinations of three cells and select the combination with the highest sum, without checking for row/column conflicts.","For each row, select the largest value and place a rook there, then remove that row/column and repeat, doing this three times.","Sort the entire board in descending order and pick the first three elements, ignoring row/column constraints.","Use backtracking to explore all possible rook placements, pruning branches when rooks attack each other, and track the maximum sum.",Hard,algorithms,"Array,Dynamic Programming,Matrix,Enumeration"
3257,"Maximum Value Sum by Placing Three Rooks II
You are given a m x n 2D array board representing a chessboard, where board[i][j] represents the value of the cell (i, j). Rooks in the same row or column attack each other. You need to place three rooks on the chessboard such that the rooks do not attack each other. Return the maximum sum of the cell values on which the rooks are placed.","Use dynamic programming to store maximum sums for sub-boards with fewer rooks, considering all possible rook placements","Greedily place rooks on the cells with the highest values, skipping rows and columns already occupied","Iterate through all possible combinations of three cells and check if they are non-attacking, then calculate the sum and track the maximum","Sort the board in descending order and choose the top three values, ensuring they are in different rows and columns","Use backtracking to explore all valid rook placements, pruning branches that lead to attacking rooks and maximizing the sum",Hard,algorithms,"Array,Dynamic Programming,Matrix,Enumeration"
3258,"Count Substrings That Satisfy K-Constraint I
You are given a binary string s and an integer k. A binary string satisfies the k-constraint if either of the following conditions holds: Return an integer denoting the number of substrings of s that satisfy the k-constraint.",Check if the substring contains at most k '1's or at most k '0's,Check if the substring contains exactly k '1's and exactly k '0's,Check if the substring's length is at most k,Check if the substring contains at least k '1's and at least k '0's,"Check if the substring contains at most k '1's or at most k '0's, then count valid substrings",Easy,algorithms,"String,Sliding Window"
3259,"Maximum Energy Boost From Two Drinks
You are given two integer arrays energyDrinkA and energyDrinkB of the same length n by a futuristic sports scientist. These arrays represent the energy boosts per hour provided by two different energy drinks, A and B, respectively. You want to maximize your total energy boost by drinking one energy drink per hour. However, if you want to switch from consuming one energy drink to the other, you need to wait for one hour to cleanse your system (meaning you won't get any energy boost in that hour). Return the maximum total energy boost you can gain in the next n hours. Note that you can start consuming either of the two energy drinks.","Use a greedy approach, always choosing the drink with the higher energy boost at each hour, without considering the switching penalty.","Calculate the total energy boost for drinking only drink A and only drink B, and return the maximum of the two. Ignore the switching penalty.",Use dynamic programming with a state representing the current hour and the last drink consumed to find the optimal energy boost.,Sort both energyDrinkA and energyDrinkB in descending order and sum the first n elements of the merged sorted array.,"Employ dynamic programming with states representing the current hour and the last drink consumed, including a state for the cleansing hour after switching.",Medium,algorithms,"Array,Dynamic Programming"
3260,"Find the Largest Palindrome Divisible by K
You are given two positive integers n and k. An integer x is called k-palindromic if: Return the largest integer having n digits (as a string) that is k-palindromic. Note that the integer must not have leading zeros.","Iterate through all n-digit numbers, check for divisibility by k, and if it is divisible, then also check if it is a palindrome. Keep track of the largest found so far.","Generate all palindromes of n digits, then check each one for divisibility by k and choose the largest.",Start with the largest n-digit number; decrement it checking if it is divisible by K and a palindrome. Terminate and return the first match.,"Create a list of all factors of k, select the largest n-digit number in the list, and build its palindrome.",Construct the largest possible n-digit palindrome and iteratively decrement until the number is divisible by k.,Hard,algorithms,"Math,String,Dynamic Programming,Greedy,Number Theory"
3261,"Count Substrings That Satisfy K-Constraint II
You are given a binary string s and an integer k. You are also given a 2D integer array queries, where queries[i] = [li, ri]. A binary string satisfies the k-constraint if either of the following conditions holds: Return an integer array answer, where answer[i] is the number of substrings of s[li..ri] that satisfy the k-constraint.",Calculate the number of substrings with at most k '1's and subtract the number of substrings with at most k-1 '1's.,"Use dynamic programming to store the counts of substrings ending at each index, based on the number of '1's encountered.","Maintain a sliding window, shrinking it when the number of '1's exceeds k, and counting the valid substrings within the window.",Precompute all possible substrings and then filter those that satisfy the k-constraint.,"For each query, iterate through all substrings of s[li..ri] and check if the substring satisfies the k-constraint, incrementing a counter for each valid substring.",Hard,algorithms,"Array,String,Binary Search,Sliding Window,Prefix Sum"
3264,"Final Array State After K Multiplication Operations I
You are given an integer array nums, an integer k, and an integer multiplier. You need to perform k operations on nums. In each operation: Return an integer array denoting the final state of nums after performing all k operations.",Sort the array and multiply the k largest elements,Divide the array into k sub-arrays and multiply elements within each sub-array independently,Multiply each element of the array by the multiplier k,Replace each element in the array with the product of its index and the multiplier,"The problem does not specify the operations to be performed. Without knowing the multiplication operations to apply based on the multiplier k, return the original array nums",Easy,algorithms,"Array,Math,Heap (Priority Queue),Simulation"
3265,"Count Almost Equal Pairs I
You are given an array nums consisting of positive integers. We call two integers x and y in this problem almost equal if both integers can become equal after performing the following operation at most once: Return the number of indices i and j in nums where i < j such that nums[i] and nums[j] are almost equal. Note that it is allowed for an integer to have leading zeros after performing an operation.",O(1),O(log n),O(n log n),O(n^2),O(n),Medium,algorithms,"Array,Hash Table,Sorting,Counting,Enumeration"
3266,"Final Array State After K Multiplication Operations II
You are given an integer array nums, an integer k, and an integer multiplier. You need to perform k operations on nums. In each operation: After the k operations, apply modulo 109 + 7 to every value in nums. Return an integer array denoting the final state of nums after performing all k operations and then applying the modulo.",Apply the multiplier cumulatively by repeatedly multiplying each element k times,Multiply the array elements only if the index is a prime number less than k,"Multiply elements at even indices by the multiplier in each operation, leaving odd indices untouched",Multiply the entire array by the multiplier only once at the beginning and apply modulo at the end,"For each element, multiply by the multiplier k times, taking the modulo after each multiplication",Hard,algorithms,"Array,Heap (Priority Queue),Simulation"
3267,"Count Almost Equal Pairs II
Attention: In this version, the number of operations that can be performed, has been increased to twice. You are given an array nums consisting of positive integers. We call two integers x and y almost equal if both integers can become equal after performing the following operation at most twice: Return the number of indices i and j in nums where i < j such that nums[i] and nums[j] are almost equal. Note that it is allowed for an integer to have leading zeros after performing an operation.",Use brute-force comparison of all pairs with two allowed modifications,Sort the array and count pairs within a fixed range assuming max two operations can make the numbers equal,Calculate the absolute difference between each pair of numbers and count when the difference is less than or equal to 2,Apply a hash map counting occurrences of each number and calculate the valid pairs using frequencies,"Iterate through each number, check all numbers within the modification range twice using nested loops, and increment the count when the modification condition is met.",Hard,algorithms,"Array,Hash Table,Sorting,Counting,Enumeration"
3270,"Find the Key of the Numbers
You are given three positive integers num1, num2, and num3. The key of num1, num2, and num3 is defined as a four-digit number such that: Return the key of the three numbers without leading zeros (if any).",Find the minimum of the three numbers and return it multiplied by 1111.,Concatenate the string representations of the numbers and take the first four digits.,Sort the three numbers in ascending order and use the last digit of each as the key digits.,Calculate the average of the three numbers and convert it to a four-digit integer.,Extract specific digits from each number based on their magnitude and combine them to form the key.,Easy,algorithms,Math
3271,"Hash Divided String
You are given a string s of length n and an integer k, where n is a multiple of k. Your task is to hash the string s into a new string called result, which has a length of n / k. First, divide s into n / k substrings, each with a length of k. Then, initialize result as an empty string. For each substring in order from the beginning: Return result.",Concatenate the ASCII values of the characters in each substring,Calculate the sum of the character indices and append the sum as a character to the result,Append the first character of each substring to the result,Take the XOR of all characters in each substring and append the result as a character,Calculate the sum of ASCII values of each substring modulo 256 and append the corresponding character to the result,Medium,algorithms,"String,Simulation"
3272,"Find the Count of Good Integers
You are given two positive integers n and k. An integer x is called k-palindromic if: An integer is called good if its digits can be rearranged to form a k-palindromic integer. For example, for k = 2, 2020 can be rearranged to form the k-palindromic integer 2002, whereas 1010 cannot be rearranged to form a k-palindromic integer. Return the count of good integers containing n digits. Note that any integer must not have leading zeros, neither before nor after rearrangement. For example, 1010 cannot be rearranged to form 101.","Calculate combinations using factorials, adjusting for permutations of repeated digits",Generate all n-digit integers and test each for the k-palindromic property using dynamic programming,Use recursion to build integers and backtracking to avoid leading zeros and invalid rearrangements,Employ the inclusion-exclusion principle to account for leading zeros in all possible rearrangements,"Determine the possible digit frequencies, considering leading zero constraints, and calculate combinations based on these frequencies",Hard,algorithms,"Hash Table,Math,Combinatorics,Enumeration"
3273,"Minimum Amount of Damage Dealt to Bob
You are given an integer power and two integer arrays damage and health, both having length n. Bob has n enemies, where enemy i will deal Bob damage[i] points of damage per second while they are alive (i.e. health[i] > 0). Every second, after the enemies deal damage to Bob, he chooses one of the enemies that is still alive and deals power points of damage to them. Determine the minimum total amount of damage points that will be dealt to Bob before all n enemies are dead.",Prioritize attacking enemies with the highest damage-to-health ratio each second.,Sort the damage array in descending order and always attack the enemy dealing the most damage.,"Divide the health of each enemy by the power to find the number of turns needed to kill it, and sum the damage dealt during those turns.",Attack enemies in the order they appear in the input arrays to simplify the calculation.,"Calculate the turns needed to kill each enemy (ceiling of health/power), then calculate the total damage dealt by all enemies during their respective lifetimes.",Hard,algorithms,"Array,Greedy,Sorting"
3274,"Check if Two Chessboard Squares Have the Same Color
You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard. Below is the chessboard for reference.  Return true if these two squares have the same color and false otherwise. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).",Return true if the sum of ASCII values of the first characters equals the sum of the second characters,"Return true if the absolute difference of ASCII values of the first characters is even, and the absolute difference of the second characters is odd","Return true if the product of the row and column numbers, modulo 2, is the same for both coordinates",Return true if both coordinates have the same row number or the same column letter,"Return true if the sum of the column letter's position (a=1, b=2, ...) and row number is even for both coordinates or odd for both coordinates",Easy,algorithms,"Math,String"
3275,"K-th Nearest Obstacle Queries
There is an infinite 2D plane. You are given a positive integer k. You are also given a 2D array queries, which contains the following queries: After each query, you need to find the distance of the kth nearest obstacle from the origin. Return an integer array results where results[i] denotes the kth nearest obstacle after query i, or results[i] == -1 if there are less than k obstacles. Note that initially there are no obstacles anywhere. The distance of an obstacle at coordinate (x, y) from the origin is given by |x| + |y|.","Use a binary search tree to store obstacles, and for each query, perform k nearest neighbor search.","Use a priority queue to store all obstacles and update the queue after each query with the new obstacle, then find the kth element.","Use a hash map to store the locations of obstacles and iterate through all possible locations, calculating distances and tracking the kth smallest.",Maintain a sorted array of obstacles by distance and update it after each query using insertion sort.,"Use a balanced binary search tree (e.g., AVL or Red-Black tree) to store obstacle distances. After each insertion, find the k-th smallest distance using order statistics on the tree.",Medium,algorithms,"Array,Heap (Priority Queue)"
3276,"Select Cells in Grid With Maximum Score
You are given a 2D matrix grid consisting of positive integers. You have to select one or more cells from the matrix such that the following conditions are satisfied: Your score will be the sum of the values of the selected cells. Return the maximum score you can achieve.",Sort the grid in ascending order and select the cells with the highest values until no more cells can be selected without violating the constraints.,"Apply a greedy approach, selecting the cell with the highest value at each step without considering dependencies between cells.",Calculate the sum of all cells in the grid and return that value as the maximum score.,"Use dynamic programming to compute the maximum score attainable for each subgrid, considering only adjacent cells.","Use dynamic programming to compute the maximum score attainable for each subgrid, considering dependencies and constraints between selected cells.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Matrix,Bitmask"
3277,"Maximum XOR Score Subarray Queries
You are given an array nums of n integers, and a 2D integer array queries of size q, where queries[i] = [li, ri]. For each query, you must find the maximum XOR score of any subarray of nums[li..ri]. The XOR score of an array a is found by repeatedly applying the following operations on a so that only one element remains, that is the score: Return an array answer of size q where answer[i] is the answer to query i.",Precompute all possible subarray XORs and store them in a hash table for O(1) lookup.,Sort the array 'nums' and use binary search to find the maximum XOR within the given range.,"For each query, calculate the XOR sum of all possible subarrays within the range and return the maximum.",Use a segment tree to store the XOR values of the array and efficiently query the maximum XOR in the given range.,"Use a sliding window approach, maintaining a Trie data structure of XOR prefixes within the current window to find the maximum XOR for each query.",Hard,algorithms,"Array,Dynamic Programming"
3280,"Convert Date to Binary
You are given a string date representing a Gregorian calendar date in the yyyy-mm-dd format. date can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in year-month-day format. Return the binary representation of date.","Concatenate the year, month, and day strings directly without conversion.",Convert the entire date string to an integer and then to binary.,"Convert each part to binary, pad with leading zeros to a fixed length, and concatenate.",Convert each component to binary using a lookup table.,"Convert year, month, and day to binary strings separately and concatenate them.",Easy,algorithms,"Math,String"
3281,"Maximize Score of Numbers in Ranges
You are given an array of integers start and an integer d, representing n intervals [start[i], start[i] + d]. You are asked to choose n integers where the ith integer must belong to the ith interval. The score of the chosen integers is defined as the minimum absolute difference between any two integers that have been chosen. Return the maximum possible score of the chosen integers.",Sort the intervals by their start times and always pick the start time for each interval.,Sort the intervals by their end times and always pick the end time for each interval.,Use dynamic programming to find the optimal choice for each interval based on previously chosen numbers.,Always pick the midpoint of each interval (start[i] + d/2) and round to the nearest integer.,Sort the intervals and use binary search to find the maximum possible minimum difference.,Medium,algorithms,"Array,Binary Search,Greedy,Sorting"
3282,"Reach End of Array With Max Score
You are given an integer array nums of length n. Your goal is to start at index 0 and reach index n - 1. You can only jump to indices greater than your current index. The score for a jump from index i to index j is calculated as (j - i) * nums[i]. Return the maximum possible total score by the time you reach the last index.","Use a greedy approach, always jumping to the index that maximizes the immediate score.",Employ a depth-first search (DFS) to explore all possible paths and select the one with the highest total score.,Sort the array in descending order and then apply dynamic programming.,Calculate the prefix sum array and use binary search to find the optimal jump at each step.,"Apply dynamic programming, where dp[i] represents the maximum score to reach index i.",Medium,algorithms,"Array,Greedy"
3283,"Maximum Number of Moves to Kill All Pawns
There is a 50 x 50 chessboard with one knight and some pawns on it. You are given two integers kx and ky where (kx, ky) denotes the position of the knight, and a 2D array positions where positions[i] = [xi, yi] denotes the position of the pawns on the chessboard. Alice and Bob play a turn-based game, where Alice goes first. In each player's turn: Alice is trying to maximize the sum of the number of moves made by both players until there are no more pawns on the board, whereas Bob tries to minimize them. Return the maximum total number of moves made during the game that Alice can achieve, assuming both players play optimally. Note that in one move, a chess knight has eight possible positions it can move to, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.",Prioritize moving to pawns closest to the knight in Manhattan distance first.,Calculate the minimum moves to each pawn individually and sum them.,"Always move the knight to the closest available square, regardless of pawn positions.","Use a greedy approach, always targeting the pawn that requires the fewest moves.",Model the problem as a bipartite matching problem and use a max-flow algorithm to find the optimal assignment of knight moves to pawns.,Hard,algorithms,"Array,Math,Bit Manipulation,Breadth-First Search,Game Theory,Bitmask"
3285,"Find Indices of Stable Mountains
There are n mountains in a row, and each mountain has a height. You are given an integer array height where height[i] represents the height of mountain i, and an integer threshold. A mountain is called stable if the mountain just before it (if it exists) has a height strictly greater than threshold. Note that mountain 0 is not stable. Return an array containing the indices of all stable mountains in any order.",Return all indices greater than zero.,Check if height[i] > threshold for all i and return all indices where this holds true.,Iterate through the height array and only consider the peaks of the mountains when checking the threshold condition.,Return an empty array because mountain 0 is never stable.,"Iterate through the height array starting at index 1, and for each index i, check if height[i-1] > threshold. If so, add i to the result array.",Easy,algorithms,Array
3286,"Find a Safe Walk Through a Grid
You are given an m x n binary matrix grid and an integer health. You start on the upper-left corner (0, 0) and would like to get to the lower-right corner (m - 1, n - 1). You can move up, down, left, or right from one cell to another adjacent cell as long as your health remains positive. Cells (i, j) with grid[i][j] = 1 are considered unsafe and reduce your health by 1. Return true if you can reach the final cell with a health value of 1 or more, and false otherwise.",Use Dijkstra's algorithm to find the shortest path with the least health reduction.,"Employ a greedy approach, always choosing the path with the fewest unsafe cells in the immediate vicinity.",Calculate the number of unsafe cells and subtract it from the initial health; return true if the result is greater than or equal to 1.,Only move right or down; any path going up or left is invalid.,"Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore possible paths, decrementing health for unsafe cells, and pruning paths when health becomes non-positive.",Medium,algorithms,"Array,Breadth-First Search,Graph,Heap (Priority Queue),Matrix,Shortest Path"
3287,"Find the Maximum Sequence Value of Array
You are given an integer array nums and a positive integer k. The value of a sequence seq of size 2 * x is defined as: Return the maximum value of any subsequence of nums having size 2 * k.","Use dynamic programming to build a table storing maximum subsequence sums for increasing sizes up to 2*k, considering all possible subsequences",Sort the array and pick the 2*k largest elements. Sum these elements and return the value.,Iterate through all possible subsequences of size 2*k and find the subsequence with the maximum sum. Return this value.,Return the sum of the first 2*k elements of the array.,"Use a min-heap of size 2*k to keep track of the largest elements. Once the heap is full, replace the smallest element with the current element if the current element is larger. Return the sum of elements in the heap.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation"
3288,"Length of the Longest Increasing Path
You are given a 2D array of integers coordinates of length n and an integer k, where 0 <= k < n. coordinates[i] = [xi, yi] indicates the point (xi, yi) in a 2D plane. An increasing path of length m is defined as a list of points (x1, y1), (x2, y2), (x3, y3), ..., (xm, ym) such that: Return the maximum length of an increasing path that contains coordinates[k].",Memoize the length of the longest increasing path starting from each cell to avoid recomputation.,Use Dijkstra's algorithm to find the longest path from the starting cell coordinates[k].,Sort the matrix based on cell values and then apply dynamic programming.,Perform a breadth-first search (BFS) from the given coordinate and track the maximum path length.,"Perform a depth-first search (DFS) from coordinates[k], memoizing the longest increasing path starting from each cell.",Hard,algorithms,"Array,Binary Search,Sorting"
3289,"The Two Sneaky Numbers of Digitville
In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual. As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.","Calculate the sum of numbers from 0 to n-1 and the sum of squares of numbers from 0 to n-1, then compare with the actual sums to find the missing numbers","Sort the array and iterate through it, identifying duplicates and missing numbers by comparing adjacent elements","Create a boolean array of size n, iterate through the input array, marking numbers as present. The unmarked index is the missing number, and any number marked twice is the duplicate","Use a hash table to count the frequency of each number. The numbers with frequency 2 are the duplicates, and the missing number can be found by checking which numbers from 0 to n-1 are not in the hash table",Use the input array as a hash table. Negate the element at index 'num' for each number 'num' in the array. The index of the first positive element is the missing number. The duplicate is the number whose corresponding index was visited twice (resulting in a negative value that was already negative),Easy,algorithms,"Array,Hash Table,Math"
3290,"Maximum Multiplication Score
You are given an integer array a of size 4 and another integer array b of size at least 4. You need to choose 4 indices i0, i1, i2, and i3 from the array b such that i0 < i1 < i2 < i3. Your score will be equal to the value a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3]. Return the maximum score you can achieve.","Use a greedy approach, always selecting the largest remaining elements from 'b' for each index.",Sort array 'b' in descending order and select the first four elements.,"Calculate all possible combinations of 4 indices in 'b' and choose the one with the maximum score, using recursion.",Sort array 'a' in descending order and array 'b' in ascending order and multiply corresponding elements.,Use dynamic programming to store and reuse optimal sub-solutions for smaller sub-arrays of 'b'.,Medium,algorithms,"Array,Dynamic Programming"
3291,"Minimum Number of Valid Strings to Form Target I
You are given an array of strings words and a string target. A string x is called valid if x is a prefix of any string in words. Return the minimum number of valid strings that can be concatenated to form target. If it is not possible to form target, return -1.","Use dynamic programming, where dp[i] represents the minimum number of valid strings needed to form target[0...i] starting from the end of target.","Use a greedy approach, always picking the longest valid string that is a prefix of the remaining target string.","Use recursion with memoization, checking all possible prefix combinations in words and memoizing the results to avoid redundant calculations.","Use a brute-force approach, trying all possible combinations of valid strings and returning the minimum number used.","Use dynamic programming, where dp[i] represents the minimum number of valid strings needed to form target[0...i]. Iterate through the target, and for each index, check if any word is a prefix ending at that index.",Medium,algorithms,"Array,String,Binary Search,Dynamic Programming,Trie,Segment Tree,Rolling Hash,String Matching,Hash Function"
3292,"Minimum Number of Valid Strings to Form Target II
You are given an array of strings words and a string target. A string x is called valid if x is a prefix of any string in words. Return the minimum number of valid strings that can be concatenated to form target. If it is not possible to form target, return -1.","Depth-first search with memoization to explore all prefix combinations, minimizing count",Breadth-first search to find the shortest path of prefix combinations to reach the target,Greedy algorithm selecting the longest matching prefix at each step to minimize the count,Dynamic programming tracking the minimum valid string count for all substrings of the target,"Dynamic programming with memoization, where dp[i] stores the minimum valid strings to form target[i:]",Hard,algorithms,"Array,String,Binary Search,Dynamic Programming,Segment Tree,Rolling Hash,String Matching,Hash Function"
3295,"Report Spam Message
You are given an array of strings message and an array of strings bannedWords. An array of words is considered spam if there are at least two words in it that exactly match any word in bannedWords. Return true if the array message is spam, and false otherwise.",Use regular expressions to identify banned words without considering word boundaries.,"Iterate through the message and increment a counter for each banned word found, returning `true` if the counter is greater than zero.",Convert both arrays to sets and check if their intersection has a size greater than or equal to 2.,"Implement a hash table to store word counts in the message, only checking banned words if any word appears more than once.","Iterate through each word in the message array and check for matches in the bannedWords array, returning `true` if at least two distinct banned words are found.",Medium,algorithms,"Array,Hash Table,String"
3296,"Minimum Number of Seconds to Make Mountain Height Zero
You are given an integer mountainHeight denoting the height of a mountain. You are also given an integer array workerTimes representing the work time of workers in seconds. The workers work simultaneously to reduce the height of the mountain. For worker i: Return an integer representing the minimum number of seconds required for the workers to make the height of the mountain 0.",Use a greedy approach by always assigning the worker with the shortest time to the remaining mountain height.,Employ a dynamic programming approach to calculate the minimum time to reduce all possible sub-heights of the mountain.,Simulate the workers' actions second by second until the mountain height reaches zero.,Divide the mountain height by the sum of all worker times to get the minimum time.,Use binary search to find the minimum time such that the cumulative work done by all workers equals or exceeds the mountain height.,Medium,algorithms,"Array,Math,Binary Search,Greedy,Heap (Priority Queue)"
3297,"Count Substrings That Can Be Rearranged to Contain a String I
You are given two strings word1 and word2. A string x is called valid if x can be rearranged to have word2 as a prefix. Return the total number of valid substrings of word1.","Compare the frequency of each character in every substring of `word1` with the frequency of characters in `word2` directly. If all characters in `word2` are present in the substring of `word1`, increment a counter.",Generate all permutations of every substring of `word1` and check if `word2` is a prefix of any of these permutations. Return the total count.,"Check if all the characters in `word2` appear in the original `word1`. If so, return the length of `word1` minus the length of `word2` plus one.",Precompute all possible prefixes of `word2` and check if any of the prefixes are substrings of `word1`. Count the total number of such prefixes found in `word1`.,"Iterate through all substrings of `word1`. For each substring, check if the frequency of each character is greater than or equal to the frequency of the same character in `word2`. Increment the count if the condition is met.",Medium,algorithms,"Hash Table,String,Sliding Window"
3298,"Count Substrings That Can Be Rearranged to Contain a String II
You are given two strings word1 and word2. A string x is called valid if x can be rearranged to have word2 as a prefix. Return the total number of valid substrings of word1. Note that the memory limits in this problem are smaller than usual, so you must implement a solution with a linear runtime complexity.",Brute force: Generate all substrings of `word1` and check each if it can be rearranged to start with `word2`.,Sort `word1` and `word2` and then find if `word2` is a prefix of `word1`.,Use dynamic programming to store intermediate results of substring matching.,Construct a suffix tree for `word1` and search for permutations of `word2` within its branches.,Use a sliding window with character frequency counting to efficiently check if a substring of `word1` can be rearranged to have `word2` as a prefix.,Hard,algorithms,"Hash Table,String,Sliding Window"
3300,"Minimum Element After Replacement With Digit Sum
You are given an integer array nums. You replace each element in nums with the sum of its digits. Return the minimum element in nums after all replacements.",Apply a bitwise XOR operation on all elements of the array.,"Calculate the product of all elements, then find the smallest factor.",Return the original minimum element of the array without replacement.,Sort the array and return the first element.,Calculate the digit sum for each element and return the minimum of the resulting sums.,Easy,algorithms,"Array,Math"
3301,"Maximize the Total Height of Unique Towers
You are given an array maximumHeight, where maximumHeight[i] denotes the maximum height the ith tower can be assigned. Your task is to assign a height to each tower so that: Return the maximum possible total sum of the tower heights. If it's not possible to assign heights, return -1.","Use a greedy approach, always selecting the tallest tower available.","Sort the array in descending order and assign heights equal to their index, limited by maximumHeight[i].",Sort the array in ascending order and build towers from shortest to tallest ensuring uniqueness.,Calculate all possible height assignments and select the combination with the maximum sum.,Sort the array and use dynamic programming to compute the maximum possible sum of unique tower heights.,Medium,algorithms,"Array,Greedy,Sorting"
3302,"Find the Lexicographically Smallest Valid Sequence
You are given two strings word1 and word2. A string x is called almost equal to y if you can change at most one character in x to make it identical to y. A sequence of indices seq is called valid if: Return an array of size word2.length representing the lexicographically smallest valid sequence of indices. If no such sequence of indices exists, return an empty array. Note that the answer must represent the lexicographically smallest array, not the corresponding string formed by those indices.",Use dynamic programming to build a table of minimum changes required for prefixes of both strings,"Employ a greedy approach, always choosing the index that minimizes the difference between substrings","Sort the indices and check if the resulting sequence is valid, returning it if it is","Apply backtracking to explore all possible index sequences, pruning branches that are not valid","Iterate through all possible permutations of indices and select the lexicographically smallest valid sequence, if one exists",Medium,algorithms,"Two Pointers,String,Dynamic Programming,Greedy"
3303,"Find the Occurrence of First Almost Equal Substring
You are given two strings s and pattern. A string x is called almost equal to y if you can change at most one character in x to make it identical to y. Return the smallest starting index of a substring in s that is almost equal to pattern. If no such index exists, return -1.",Greedily match the longest possible prefix of the pattern in the string.,Use dynamic programming to build a table of all possible substring matches.,Employ a trie data structure to efficiently store and search for the pattern's variations.,Calculate the Levenshtein distance between the pattern and all substrings of 's'.,Use a sliding window of the same size as the pattern and count the differences in characters.,Hard,algorithms,"String,String Matching"
3304,"Find the K-th Character in String Game I
Alice and Bob are playing a game. Initially, Alice has a string word = ""a"". You are given a positive integer k. Now Bob will ask Alice to perform the following operation forever: For example, performing the operation on ""c"" generates ""cd"" and performing the operation on ""zb"" generates ""zbac"". Return the value of the kth character in word, after enough operations have been done for word to have at least k characters. Note that the character 'z' can be changed to 'a' in the operation.",k % 26 + ord('a'),chr(ord('a') + (k - 1) % 25),chr(97 + (k % 27)),chr(ord('a') + (k % 26) -1),chr(ord('a') + (k - 1) % 26),Easy,algorithms,"Math,Bit Manipulation,Recursion,Simulation"
3305,"Count of Substrings Containing Every Vowel and K Consonants I
You are given a string word and a non-negative integer k. Return the total number of substrings of word that contain every vowel ('a', 'e', 'i', 'o', and 'u') at least once and exactly k consonants.","Calculate the number of vowels and consonants using a sliding window, incrementing the count only when all vowels are present and the consonant count equals k.","Generate all possible substrings, then filter the substrings that meet the vowel and consonant criteria and return their count.","Use dynamic programming to store the count of vowels and consonants encountered so far, then check if the substring satisfies the required conditions using the stored values.",Precompute all possible combinations of vowels and check if a substring with exactly k consonants can be added to the existing vowel combinations to form valid substrings.,"Use a nested loop to iterate through all possible substrings, and for each substring, count the vowels and consonants to check if it satisfies the conditions.",Medium,algorithms,"Hash Table,String,Sliding Window"
3306,"Count of Substrings Containing Every Vowel and K Consonants II
You are given a string word and a non-negative integer k. Return the total number of substrings of word that contain every vowel ('a', 'e', 'i', 'o', and 'u') at least once and exactly k consonants.",Iterate through all possible substrings and use regular expressions to check for vowels and consonants,Use dynamic programming to store the counts of vowels and consonants for each prefix of the string,"Employ a sliding window technique, expanding and shrinking the window based on vowel and consonant counts",Precompute the frequencies of vowels and consonants in the entire string and use this information to efficiently count valid substrings,"Employ a sliding window approach, maintaining counts of vowels and consonants within the window, and efficiently updating these counts as the window slides",Medium,algorithms,"Hash Table,String,Sliding Window"
3307,"Find the K-th Character in String Game II
Alice and Bob are playing a game. Initially, Alice has a string word = ""a"". You are given a positive integer k. You are also given an integer array operations, where operations[i] represents the type of the ith operation. Now Bob will ask Alice to perform all operations in sequence: Return the value of the kth character in word after performing all the operations. Note that the character 'z' can be changed to 'a' in the second type of operation.",Simulate all operations and directly access the k-th character in the final string.,Precompute the length of the string after all operations and use modulo arithmetic.,Construct a lookup table mapping operation sequences to final string states.,Employ dynamic programming to track string modifications at each operation index.,"Analyze the operation sequence to determine the net effect on the k-th character directly, without full simulation.",Hard,algorithms,"Math,Bit Manipulation,Recursion"
3309,"Maximum Possible Number by Binary Concatenation
You are given an array of integers nums of size 3. Return the maximum possible number whose binary representation can be formed by concatenating the binary representation of all elements in nums in some order. Note that the binary representation of any number does not contain leading zeros.",Sort the integers in ascending order and concatenate their binary representations.,Concatenate the binary representations of the integers in their original order.,Calculate the sum of the integers and convert the sum to its binary representation.,Convert each integer to its binary representation and find the lexicographically largest string among all permutations.,"Generate all permutations of the integers, convert each to its binary representation, concatenate, and find the maximum integer value among the resulting binary strings.",Medium,algorithms,"Array,Bit Manipulation,Enumeration"
3310,"Remove Methods From Project
You are maintaining a project that has n methods numbered from 0 to n - 1. You are given two integers n and k, and a 2D integer array invocations, where invocations[i] = [ai, bi] indicates that method ai invokes method bi. There is a known bug in method k. Method k, along with any method invoked by it, either directly or indirectly, are considered suspicious and we aim to remove them. A group of methods can only be removed if no method outside the group invokes any methods within it. Return an array containing all the remaining methods after removing all the suspicious methods. You may return the answer in any order. If it is not possible to remove all the suspicious methods, none should be removed.",Methods outside the suspicious group can invoke methods within the suspicious group after removal.,The suspicious group contains method k and all methods that directly invoke it.,Only methods in the invocations array should be removed.,"If any method in the suspicious group cannot be removed, remove only the method 'k'.","If any method outside the suspicious group invokes a method within it, no methods can be removed; otherwise, remove the suspicious methods.",Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph"
3311,"Construct 2D Grid Matching Graph Layout
You are given a 2D integer array edges representing an undirected graph having n nodes, where edges[i] = [ui, vi] denotes an edge between nodes ui and vi. Construct a 2D grid that satisfies these conditions: It is guaranteed that edges can form a 2D grid that satisfies the conditions. Return a 2D integer array satisfying the conditions above. If there are multiple solutions, return any of them.","Use a greedy approach, iteratively placing nodes based on minimizing Manhattan distance to existing nodes.",Apply a force-directed layout algorithm to iteratively refine node positions until edge lengths are minimized.,Use a spring-embedding algorithm to simulate attractive and repulsive forces between nodes to find optimal positions.,Sort the nodes by degree and assign coordinates based on the sorted order.,"Perform a depth-first search, assigning coordinates based on neighbors, backtracking if conflicts arise.",Hard,algorithms,"Array,Hash Table,Graph,Matrix"
algorithms,3312,"Sorted GCD Pair Queries
You are given an integer array nums of length n and an integer array queries. Let gcdPairs denote an array obtained by calculating the GCD of all possible pairs (nums[i], nums[j]), where 0 <= i < j < n, and then sorting these values in ascending order. For each query queries[i], you need to find the element at index queries[i] in gcdPairs. Return an integer array answer, where answer[i] is the value at gcdPairs[queries[i]] for each query. The term gcd(a, b) denotes the greatest common divisor of a and b.","[2, 4]","[2, 6]","[4, 6]","[8, 8]",,"['gcd', 'array', 'sorting']","[2, 2]"
algorithms,3314,"Construct the Minimum Bitwise Array I
You are given an array nums consisting of n prime integers. You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of ans[i] in the resulting array. If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.",ans[i] = nums[i] - 1,ans[i] = nums[i] | (nums[i] + 1),ans[i] = nums[i] + 1,ans[i] = nums[i] & (nums[i] + 1),,"['bitwise operations', 'primes', 'arrays']",ans[i] = nums[i] - (nums[i] & -nums[i])
algorithms,3315,"Construct the Minimum Bitwise Array II
You are given an array nums consisting of n prime integers. You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of ans[i] in the resulting array. If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.",ans[i] = nums[i] - 1. This will always satisfy the bitwise OR condition.,ans[i] = nums[i] & (nums[i] + 1). This utilizes the bitwise AND operation.,ans[i] = nums[i] ^ 1. This uses the bitwise XOR operation.,"ans[i] = nums[i] / 2 if nums[i] is even, -1 otherwise.",,"['bitwise operations', 'array manipulation', 'prime numbers']","ans[i] = nums[i] - 1 if nums[i] is a power of 2, -1 otherwise."
algorithms,3316,"Find Maximum Removals From Source String
You are given a string source of size n, a string pattern that is a subsequence of source, and a sorted integer array targetIndices that contains distinct numbers in the range [0, n - 1]. We define an operation as removing a character at an index idx from source such that: Performing an operation does not change the indices of the other characters in source. For example, if you remove 'c' from ""acb"", the character at index 2 would still be 'b'. Return the maximum number of operations that can be performed.",Return the largest index in targetIndices such that removing characters at targetIndices[0...index] still allows pattern to be a subsequence of source.,Return the smallest index in targetIndices such that removing characters at targetIndices[0...index] still allows pattern to be a subsequence of source.,Return the number of occurrences of the pattern string in the source string.,Return the number of characters in pattern that are also in source.,,"['string', 'subsequence', 'binary search']",Return the largest index in targetIndices such that removing characters at targetIndices[0...index] results in pattern no longer being a subsequence of source.
algorithms,3317,"Find the Number of Possible Ways for an Event
You are given three integers n, x, and y. An event is being held for n performers. When a performer arrives, they are assigned to one of the x stages. All performers assigned to the same stage will perform together as a band, though some stages might remain empty. After all performances are completed, the jury will award each band a score in the range [1, y]. Return the total number of possible ways the event can take place. Since the answer may be very large, return it modulo 109 + 7. Note that two events are considered to have been held differently if either of the following conditions is satisfied:",x^(n*y) mod (10^9 + 7),(x*y)^n mod (10^9 + 7),(y^x)*n mod (10^9 + 7),n^(x*y) mod (10^9 + 7),,"['combinatorics', 'modular arithmetic', 'exponentiation']",(y * (x^n)) mod (10^9 + 7)
3318,"Find X-Sum of All K-Long Subarrays I
You are given an array nums of n integers and two integers k and x. The x-sum of an array is calculated by the following procedure: Note that if an array has less than x distinct elements, its x-sum is the sum of the array. Return an integer array answer of length n - k + 1 where answer[i] is the x-sum of the subarray nums[i..i + k - 1].","Use a sliding window, recomputing the sum and distinct element count for each subarray.",Precompute all possible subarrays and store their sums in a hash map.,Sort the original array and then calculate the x-sum for each k-length subarray based on the sorted array.,Calculate the sum of the entire array and subtract elements outside the current window to obtain the x-sum.,"Employ a sliding window, maintaining a count of distinct elements and updating the x-sum incrementally.",Easy,algorithms,"Array,Hash Table,Sliding Window,Heap (Priority Queue)"
3319,"K-th Largest Perfect Subtree Size in Binary Tree
You are given the root of a binary tree and an integer k. Return an integer denoting the size of the kth largest perfect binary subtree, or -1 if it doesn't exist. A perfect binary tree is a tree where all leaves are on the same level, and every parent has two children.","A left outer join returns all rows from the right table and matching rows from the left table. If there are no matching rows from the left table, it returns NULL values for the left table's columns.",A left outer join returns only the rows where there is a match between the left and right tables.,A left outer join excludes rows where the joining column has a NULL value in the left table.,A left outer join is identical to an inner join.,"A left outer join returns all rows from the left table and the matching rows from the right table. If there are no matching rows from the right table, it returns NULL values for the right table's columns.",Medium,database systems,"Tree,Depth-First Search,Sorting,Binary Tree"
3320,"Count The Number of Winning Sequences
Alice and Bob are playing a fantasy battle game consisting of n rounds where they summon one of three magical creatures each round: a Fire Dragon, a Water Serpent, or an Earth Golem. In each round, players simultaneously summon their creature and are awarded points as follows: You are given a string s consisting of n characters 'F', 'W', and 'E', representing the sequence of creatures Alice will summon in each round: Bob’s sequence of moves is unknown, but it is guaranteed that Bob will never summon the same creature in two consecutive rounds. Bob beats Alice if the total number of points awarded to Bob after n rounds is strictly greater than the points awarded to Alice. Return the number of distinct sequences Bob can use to beat Alice. Since the answer may be very large, return it modulo 109 + 7.","Define a recursive function that calculates the points for Bob given Alice's sequence and checks if Bob wins, then iterate through all possible sequences for Bob.","Enumerate all possible sequences for Bob using a backtracking algorithm, pruning branches where Bob's score is already less than or equal to Alice's score multiplied by a safety factor.",Precompute the score difference between each possible pair of creatures and use dynamic programming to determine the number of sequences where Bob's score exceeds Alice's.,"Calculate Alice's total score, then use stars and bars to determine the number of ways Bob can arrange creatures to achieve a higher score.","Calculate Alice's score, and then use dynamic programming to count the number of Bob's sequences with a strictly greater score, ensuring Bob doesn't pick the same creature consecutively.",Hard,algorithms,"String,Dynamic Programming"
3321,"Find X-Sum of All K-Long Subarrays II
You are given an array nums of n integers and two integers k and x. The x-sum of an array is calculated by the following procedure: Note that if an array has less than x distinct elements, its x-sum is the sum of the array. Return an integer array answer of length n - k + 1 where answer[i] is the x-sum of the subarray nums[i..i + k - 1].","Sliding window with a hash map to track frequencies, recalculating the x-sum for each window.",Precompute all possible subarrays and then compute their x-sums independently.,Use a priority queue to maintain the k largest elements in the current window.,Sort each subarray before computing the x-sum.,"Maintain a sliding window and a frequency map. Incrementally update the x-sum by adding the new element and subtracting the old element from the frequency map, only recalculating the sum if the number of distinct elements changes.",Hard,algorithms,"Array,Hash Table,Sliding Window,Heap (Priority Queue)"
3324,"Find the Sequence of Strings Appeared on the Screen
You are given a string target. Alice is going to type target on her computer using a special keyboard that has only two keys: Note that initially there is an empty string """" on the screen, so she can only press key 1. Return a list of all strings that appear on the screen as Alice types target, in the order they appear, using the minimum key presses.",Return only the target string.,Return all prefixes of the target string in reverse order.,Return all suffixes of the target string in the order they appear.,Return only the first and last characters of the target string.,Return all prefixes of the target string in the order they appear.,Medium,algorithms,"String,Simulation"
3325,"Count Substrings With K-Frequency Characters I
Given a string s and an integer k, return the total number of substrings of s where at least one character appears at least k times.","Iterate through all possible substrings and use a hash map to count character frequencies, returning only substrings where the maximum frequency is equal to k.","Use a sliding window approach, expanding the window until at least one character's frequency reaches k, then contract the window from the left until no character meets the k frequency requirement. Count all valid windows.","Sort the string first, then iterate and count substrings where the first k characters are unique.","Use dynamic programming to store the counts of each character in all prefixes of the string. Then, calculate the result using these stored counts.",Iterate through all possible substrings and check if at least one character appears at least k times using a frequency array or hash map for each substring.,Medium,algorithms,"Hash Table,String,Sliding Window"
3326,"Minimum Division Operations to Make Array Non Decreasing
You are given an integer array nums. Any positive divisor of a natural number x that is strictly less than x is called a proper divisor of x. For example, 2 is a proper divisor of 4, while 6 is not a proper divisor of 6. You are allowed to perform an operation any number of times on nums, where in each operation you select any one element from nums and divide it by its greatest proper divisor. Return the minimum number of operations required to make the array non-decreasing. If it is not possible to make the array non-decreasing using any number of operations, return -1.","Use a greedy approach, always dividing by the largest possible divisor until non-decreasing or 1 is reached, but without memoization.",Sort the array and then count the operations needed to make each element equal to its predecessor.,"Recursively divide each element by its smallest prime factor until the array is non-decreasing, backtracking if necessary.",Calculate the product of all elements and find the minimum number of divisions to reduce each element to the average of all elements.,"Use dynamic programming to store the minimum operations needed to make the array non-decreasing up to each index, considering all possible divisions.",Medium,algorithms,"Array,Math,Greedy,Number Theory"
3327,"Check if DFS Strings Are Palindromes
You are given a tree rooted at node 0, consisting of n nodes numbered from 0 to n - 1. The tree is represented by an array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to node i. Consider an empty string dfsStr, and define a recursive function dfs(int x) that takes a node x as a parameter and performs the following steps in order: Note that dfsStr is shared across all recursive calls of dfs. You need to find a boolean array answer of size n, where for each index i from 0 to n - 1, you do the following: Return the array answer.",Create an adjacency matrix and then perform a Floyd-Warshall algorithm to check palindromes.,Perform a breadth-first search and check if the level order traversal strings are palindromes.,Use dynamic programming to precompute all possible palindrome substrings of the DFS string.,Calculate the XOR sum of the characters along each DFS path and check if the result is zero.,"Perform a Depth-First Search, building a string for each path from the root. Check if each string is a palindrome.",Hard,algorithms,"Array,Hash Table,String,Tree,Depth-First Search,Hash Function"
3330,"Find the Original Typed String I
Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and may press a key for too long, resulting in a character being typed multiple times. Although Alice tried to focus on her typing, she is aware that she may still have done this at most once. You are given a string word, which represents the final output displayed on Alice's screen. Return the total number of possible original strings that Alice might have intended to type.",Return the length of the string.,Iterate through the string and count the occurrences of each character.,"Return 1 if all characters are distinct, otherwise return the number of unique characters.",Use dynamic programming to find the longest repeating subsequence.,Count consecutive repeating characters; the original string possibilities are the product of (repetition_count + 1) for each repetition sequence.,Easy,algorithms,String
3331,"Find Subtree Sizes After Changes
You are given a tree rooted at node 0 that consists of n nodes numbered from 0 to n - 1. The tree is represented by an array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to node i. We make the following changes on the tree one time simultaneously for all nodes x from 1 to n - 1: Return an array answer of size n where answer[i] is the size of the subtree rooted at node i in the final tree.","The subtree size of each node remains unchanged, so the answer is an array of 1s.",The subtree size of each node becomes the size of the entire tree (n).,"Each node inherits the subtree of its parent, resulting in all subtrees being duplicates of the original tree.","Each node now has only one child (if any), resulting in all subtree sizes being either 1 or 2.",The final subtree size for each node i is the number of nodes in the original subtree of i that have the same character in string 's' as node i.,Medium,algorithms,"Array,Hash Table,String,Tree,Depth-First Search"
3332,"Maximum Points Tourist Can Earn
You are given two integers, n and k, along with two 2D integer arrays, stayScore and travelScore. A tourist is visiting a country with n cities, where each city is directly connected to every other city. The tourist's journey consists of exactly k 0-indexed days, and they can choose any city as their starting point. Each day, the tourist has two choices: Return the maximum possible points the tourist can earn.","Use dynamic programming to compute the maximum score for each city and day, considering all possible travel paths.","Implement a greedy algorithm that always chooses the path with the highest immediate score, prioritizing stayScore over travelScore.",Employ a recursive approach with memoization to explore all possible paths and store the maximum score for each city and day.,Apply Dijkstra's algorithm to find the shortest path between cities and maximize the score based on the path length.,"Utilize dynamic programming with state (city, day) to track the maximum possible score, considering stay and travel options for each day.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
3333,"Find the Original Typed String II
Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and may press a key for too long, resulting in a character being typed multiple times. You are given a string word, which represents the final output displayed on Alice's screen. You are also given a positive integer k. Return the total number of possible original strings that Alice might have intended to type, if she was trying to type a string of size at least k. Since the answer may be very large, return it modulo 109 + 7.","Dynamic programming with memoization based on string prefixes and repetition counts, calculating combinations of repetitions.","Recursively explore possible original strings, pruning branches where the remaining length is less than k, and counting valid paths.","Greedily remove repeated characters from the input string until the length is at least k, then calculate the number of ways to add back the removed characters.",Use a sliding window approach to identify valid substrings of length at least k that can be formed by removing repeated characters.,"Backtracking with memoization to explore all possible original strings, considering the minimum length constraint and counting valid options modulo 10^9 + 7.",Hard,algorithms,"String,Dynamic Programming,Prefix Sum"
3334,"Find the Maximum Factor Score of Array
You are given an integer array nums. The factor score of an array is defined as the product of the LCM and GCD of all elements of that array. Return the maximum factor score of nums after removing at most one element from it. Note that both the LCM and GCD of a single number are the number itself, and the factor score of an empty array is 0.",Recursively calculate GCD and LCM by skipping one element in each recursive call.,Sort the array and only remove either the smallest or largest element to maximize factor score.,Calculate the factor score of the original array and return that value.,Calculate all possible subarrays after removing elements and return the maximum of the minimum factor score.,"Iterate through the array, calculating the factor score of the array with each element removed, and return the maximum factor score found.",Medium,algorithms,"Array,Math,Number Theory"
3335,"Total Characters in String After Transformations I
You are given a string s and an integer t, representing the number of transformations to perform. In one transformation, every character in s is replaced according to the following rules: Return the length of the resulting string after exactly t transformations. Since the answer may be very large, return it modulo 109 + 7.",The length remains constant as characters are merely substituted.,The length doubles with each transformation.,The length decreases linearly with 't'.,The length oscillates between two values based on 't' parity.,The length changes based on character mapping and can be calculated using matrix exponentiation.,Medium,algorithms,"Hash Table,Math,String,Dynamic Programming,Counting"
3336,"Find the Number of Subsequences With Equal GCD
You are given an integer array nums. Your task is to find the number of pairs of non-empty subsequences (seq1, seq2) of nums that satisfy the following conditions: Return the total number of such pairs. Since the answer may be very large, return it modulo 109 + 7.","O(n^2), where n is the length of nums","O(n log n), where n is the length of nums","O(n!), where n is the length of nums","O(2^n), where n is the length of nums","O(n * m), where n is the length of nums and m is the maximum value in nums",Hard,algorithms,"Array,Math,Dynamic Programming,Number Theory"
algorithms,3337,"Total Characters in String After Transformations II
You are given a string s consisting of lowercase English letters, an integer t representing the number of transformations to perform, and an array nums of size 26. In one transformation, every character in s is replaced according to the following rules: Return the length of the resulting string after exactly t transformations. Since the answer may be very large, return it modulo 109 + 7.",Calculate the length of the transformed string after one transformation and multiply it by 't' modulo 10^9 + 7.,"Apply all transformations sequentially, recalculating string length after each, then take the modulo 10^9 + 7 of the final length.","Treat 'nums' as weights for each character and compute a weighted sum of characters in 's' raised to the power of 't', then take the modulo 10^9 + 7.","Find the repeating pattern in transformations, then compute the length after 't % pattern_length' transformations modulo 10^9 + 7.",,"['string manipulation', 'dynamic programming', 'modulo arithmetic']","Simulate the transformations using dynamic programming to store the length of the string after each transformation, and return the length after 't' transformations modulo 10^9 + 7."
algorithms,3340,"Check Balanced String
You are given a string num consisting of only digits. A string of digits is called balanced if the sum of the digits at even indices is equal to the sum of digits at odd indices. Return true if num is balanced, otherwise return false.",Use a hash map to store digit counts and check for symmetry,Convert the string to an integer and check if it's a palindrome,Calculate the absolute difference between even and odd index sums and check if it's zero,Sort the string lexicographically and check if the first half equals the second half,,"['string manipulation', 'arithmetic', 'iteration']","Iterate through the string, calculate the sum of digits at even and odd indices separately, and compare the sums for equality"
algorithms,3341,"Find Minimum Time to Reach Last Room I
There is a dungeon with n x m rooms arranged as a grid. You are given a 2D array moveTime of size n x m, where moveTime[i][j] represents the minimum time in seconds after which the room opens and can be moved to. You start from the room (0, 0) at time t = 0 and can move to an adjacent room. Moving between adjacent rooms takes exactly one second. Return the minimum time to reach the room (n - 1, m - 1). Two rooms are adjacent if they share a common wall, either horizontally or vertically.","Use Dijkstra's algorithm, prioritizing paths with the fewest rooms visited.","Apply a greedy approach, always moving to the adjacent room with the smallest moveTime value.",Calculate the Manhattan distance and add the maximum moveTime value along the path.,"Perform a depth-first search, backtracking when encountering a moveTime constraint.",,"['Dijkstra', 'graph', 'dynamic programming']","Use Dijkstra's algorithm, where the cost of moving to a room is max(current_time + 1, moveTime[i][j] + 1)."
algorithms,3342,"Find Minimum Time to Reach Last Room II
There is a dungeon with n x m rooms arranged as a grid. You are given a 2D array moveTime of size n x m, where moveTime[i][j] represents the minimum time in seconds when you can start moving to that room. You start from the room (0, 0) at time t = 0 and can move to an adjacent room. Moving between adjacent rooms takes one second for one move and two seconds for the next, alternating between the two. Return the minimum time to reach the room (n - 1, m - 1). Two rooms are adjacent if they share a common wall, either horizontally or vertically.","Apply Dijkstra's algorithm with a priority queue to explore rooms based on earliest arrival time, updating times based on moveTime and alternating move costs.","Use a greedy approach, always moving to the adjacent room with the lowest moveTime value.",Employ a depth-first search (DFS) to explore all possible paths and return the minimum time to reach the destination.,Calculate the Manhattan distance and add the sum of the smallest moveTime values along any possible path.,,"['dynamic programming', 'graph traversal', 'optimization']","Use dynamic programming to calculate the minimum time to reach each cell, considering moveTime and alternating move costs between adjacent cells."
algorithms,3343,"Count Number of Balanced Permutations
You are given a string num. A string of digits is called balanced if the sum of the digits at even indices is equal to the sum of the digits at odd indices. Return the number of distinct permutations of num that are balanced. Since the answer may be very large, return it modulo 109 + 7. A permutation is a rearrangement of all the characters of a string.",Use dynamic programming to store counts of digit sums for prefixes of the number,"Generate all permutations and filter for balanced ones, using a hash set to avoid duplicates","Calculate the frequency of each digit, then use stars and bars to count balanced arrangements","Sort the digits and count permutations using factorials, adjusting for repeated digits",,"['dynamic programming', 'permutations', 'memoization']","Use dynamic programming with memoization to count balanced permutations, accounting for digit frequencies and modulo arithmetic"
3345,"Smallest Divisible Digit Product I
You are given two integers n and t. Return the smallest number greater than or equal to n such that the product of its digits is divisible by t.",Check divisibility using only prime factorization of 't',Return 'n' immediately if 't' is 1,Increment 'n' until the product of digits equals 't',Return 'n' if 'n' is divisible by 't',Increment 'n' and check if the product of its digits is divisible by 't' until a valid number is found,Easy,algorithms,"Math,Enumeration"
3346,"Maximum Frequency of an Element After Performing Operations I
You are given an integer array nums and two integers k and numOperations. You must perform an operation numOperations times on nums, where in each operation you: Return the maximum possible frequency of any element in nums after performing the operations.",Sort the array and greedily increase elements from the end to the maximum value within the operation limit.,Calculate the frequency of each element and return the frequency of the most frequent element. Ignore 'k'.,"Use dynamic programming to store the maximum frequency achievable for each prefix of the array, ignoring 'k'.",Iterate through all possible subarrays and check if each element within the subarray can be made equal using the operations.,Sort the array and use a sliding window to find the longest subarray that can be made equal to the largest element using at most 'k' operations.,Medium,algorithms,"Array,Binary Search,Sliding Window,Sorting,Prefix Sum"
3347,"Maximum Frequency of an Element After Performing Operations II
You are given an integer array nums and two integers k and numOperations. You must perform an operation numOperations times on nums, where in each operation you: Return the maximum possible frequency of any element in nums after performing the operations.",Sort the array and greedily increase elements from the right until operations are exhausted.,"Apply binary search on the possible frequency, and for each frequency check if it's achievable with the given operations by iterating through every subarray.",Use dynamic programming where dp[i][j] represents the maximum frequency achievable using the first i elements and j operations.,Track prefix sums of the array to efficiently check if the current frequency is achievable,Sort the array and use a sliding window to find the maximum frequency achievable by increasing elements within the window.,Hard,algorithms,"Array,Binary Search,Sliding Window,Sorting,Prefix Sum"
3348,"Smallest Divisible Digit Product II
You are given a string num which represents a positive integer, and an integer t. A number is called zero-free if none of its digits are 0. Return a string representing the smallest zero-free number greater than or equal to num such that the product of its digits is divisible by t. If no such number exists, return ""-1"".",Recursively check each substring of `num` for divisibility by `t`.,Generate all numbers greater than or equal to `num` and check their digit product.,Use dynamic programming to store the divisibility of substrings by factors of `t`.,"Employ a greedy approach, incrementing digits from right to left until the product is divisible by `t`.","Increment `num` and check the digit product's divisibility by `t`, backtracking and adjusting digits as needed while avoiding zeroes.",Hard,algorithms,"Math,String,Backtracking,Greedy,Number Theory"
3349,"Adjacent Increasing Subarrays Detection I
Given an array nums of n integers and an integer k, determine whether there exist two adjacent subarrays of length k such that both subarrays are strictly increasing. Specifically, check if there are two subarrays starting at indices a and b (a < b), where: Return true if it is possible to find two such subarrays, and false otherwise.","Use dynamic programming to find the longest increasing subsequence, then check if any two adjacent subsequences have length k.",Sort the array and check if the first 2k elements form two increasing subarrays.,"Iterate through the array and maintain a count of increasing elements. If the count reaches 2k, return true.","Check all possible pairs of subarrays of length k using nested loops, comparing corresponding elements for strict increase.","Iterate through the array, checking for increasing subarrays of length k starting at each index. If two adjacent increasing subarrays are found, return true.",Easy,algorithms,Array
3350,"Adjacent Increasing Subarrays Detection II
Given an array nums of n integers, your task is to find the maximum value of k for which there exist two adjacent subarrays of length k each, such that both subarrays are strictly increasing. Specifically, check if there are two subarrays of length k starting at indices a and b (a < b), where: Return the maximum possible value of k. A subarray is a contiguous non-empty sequence of elements within an array.","A divide-and-conquer approach recursively splitting the array and merging sorted subarrays, resulting in O(n log n) time complexity.","Dynamically programming solutions store the lengths of increasing subarrays at each index, which can be computationally expensive for large arrays.","Greedy algorithms select the largest possible k at each step, potentially overlooking optimal solutions later in the array.","Binary search on the possible k values, combined with a linear check for adjacent increasing subarrays of length k.",Iterate through the array and maintain the length of the current increasing subarray. Compare adjacent subarray lengths to find the maximum k.,Medium,algorithms,"Array,Binary Search"
3351,"Sum of Good Subsequences
You are given an integer array nums. A good subsequence is defined as a subsequence of nums where the absolute difference between any two consecutive elements in the subsequence is exactly 1. Return the sum of all possible good subsequences of nums. Since the answer may be very large, return it modulo 109 + 7. Note that a subsequence of size 1 is considered good by definition.",Calculate the sum of all subsequences and then filter the good ones.,"Recursively explore all possible subsequences, checking for the 'good' property at each step.","Use dynamic programming, storing the sum of good subsequences ending at each index.","Sort the array and then iterate through it, building good subsequences.",Use dynamic programming to maintain the sum of good subsequences ending with each number.,Hard,algorithms,"Array,Hash Table,Dynamic Programming"
3352,"Count K-Reducible Numbers Less Than N
You are given a binary string s representing a number n in its binary form. You are also given an integer k. An integer x is called k-reducible if performing the following operation at most k times reduces it to 1: For example, the binary representation of 6 is ""110"". Applying the operation once reduces it to 2 (since ""110"" has two set bits). Applying the operation again to 2 (binary ""10"") reduces it to 1 (since ""10"" has one set bit). Return an integer denoting the number of positive integers less than n that are k-reducible. Since the answer may be too large, return it modulo 109 + 7.",Return the number of integers less than N with at most K set bits.,Return the number of integers less than N whose Hamming weight is less than or equal to K.,Return the number of integers less than N that can be represented with at most K bits.,Return the number of integers less than N that have exactly K divisors.,"Return an integer denoting the number of positive integers less than n that are k-reducible. Since the answer may be too large, return it modulo 109 + 7.",Hard,algorithms,"Math,String,Dynamic Programming,Combinatorics"
3354,"Make Array Elements Equal to Zero
You are given an integer array nums. Start by selecting a starting position curr such that nums[curr] == 0, and choose a movement direction of either left or right. After that, you repeat the following process: A selection of the initial position curr and movement direction is considered valid if every element in nums becomes 0 by the end of the process. Return the number of possible valid selections.","Check if all elements are initially zero and return 1 if so, otherwise 0.","Find the minimum element. If it's negative, return 0; otherwise, return 1.","Count the number of zero elements. If it's greater than 1, return the count; otherwise, return 0.","Return the product of the array elements. If the product is zero, return 1, else return 0.","Count the number of zero elements, and for each zero element, simulate movements left and right. Increment the count if all elements can be made zero.",Easy,algorithms,"Array,Simulation,Prefix Sum"
3355,"Zero Array Transformation I
You are given an integer array nums of length n and a 2D array queries, where queries[i] = [li, ri]. For each queries[i]: A Zero Array is an array where all elements are equal to 0. Return true if it is possible to transform nums into a Zero Array after processing all the queries sequentially, otherwise return false.",Sort the array and check if the sum of elements at even indices equals the sum of elements at odd indices.,"Calculate the prefix sum array and for each query, subtract nums[li] from nums[ri]. Return true if the final prefix sum array is all zeros.","Calculate the sum of all elements in the array. For each query, check if the sum of the subarray from li to ri is zero. If all queries return true, return true; otherwise, return false.","For each query, set all elements from nums[li] to nums[ri] to zero. Return true if all elements in nums are zero after processing all queries.","Calculate the total sum of nums. For each query, subtract twice the sum of the subarray from li to ri from the total sum. Return true if the final total sum is zero.",Medium,algorithms,"Array,Prefix Sum"
3356,"Zero Array Transformation II
You are given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri, vali]. Each queries[i] represents the following action on nums: A Zero Array is an array with all its elements equal to 0. Return the minimum possible non-negative value of k, such that after processing the first k queries in sequence, nums becomes a Zero Array. If no such k exists, return -1.",Process queries in reverse order to identify the earliest point of zeroing,Use binary search to efficiently find the minimum 'k' queries,Maintain a cumulative sum array to track changes and detect the zero state,Employ dynamic programming to store intermediate array states,"Iterate through queries, applying them and checking for a zero array; return the index upon success or -1 if never achieved",Medium,algorithms,"Array,Binary Search,Prefix Sum"
3357,"Minimize the Maximum Adjacent Element Difference
You are given an array of integers nums. Some values in nums are missing and are denoted by -1. You must choose a pair of positive integers (x, y) exactly once and replace each missing element with either x or y. You need to minimize the maximum absolute difference between adjacent elements of nums after replacements. Return the minimum possible difference.","Use dynamic programming to track the minimum difference achievable up to each index, considering only x or y for replacements.","Sort the array first, then replace the -1 values with the median of the non -1 values.",Replace all -1 values with the average of the known adjacent elements to each -1.,"Use binary search to find the optimal difference, then greedily replace -1 values to achieve this difference.","Perform a binary search on the possible range of differences. For a given difference, check if it's possible to replace the -1 values with x and y to satisfy the difference constraint. ",Hard,algorithms,"Array,Binary Search,Greedy"
3360,"Stone Removal Game
Alice and Bob are playing a game where they take turns removing stones from a pile, with Alice going first. The player who cannot make a move loses the game. Given a positive integer n, return true if Alice wins the game and false otherwise.","If n is even, Alice loses","If n is a power of 2, Alice wins","If n is divisible by 3, Alice wins","If n is a prime number, Alice loses","If n is divisible by 4, Alice loses",Easy,algorithms,"Math,Simulation"
3361,"Shift Distance Between Two Strings
You are given two strings s and t of the same length, and two integer arrays nextCost and previousCost. In one operation, you can pick any index i of s, and perform either one of the following actions: The shift distance is the minimum total cost of operations required to transform s into t. Return the shift distance from s to t.",Use dynamic programming to find the optimal cost by considering all possible shift combinations.,Calculate the Levenshtein distance between the strings.,Compare the strings character by character and sum the absolute differences in ASCII values.,"Apply a greedy approach, always selecting the shift operation with the lowest immediate cost.",Use dynamic programming to find the minimum cost to transform each character in 's' to the corresponding character in 't' considering nextCost and previousCost.,Medium,algorithms,"Array,String,Prefix Sum"
3362,"Zero Array Transformation III
You are given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri]. Each queries[i] represents the following action on nums: A Zero Array is an array with all its elements equal to 0. Return the maximum number of elements that can be removed from queries, such that nums can still be converted to a zero array using the remaining queries. If it is not possible to convert nums to a zero array, return -1.","Greedily select queries based on length, prioritizing shorter intervals first.",Use a dynamic programming approach to find the optimal subset of queries to maximize covered elements.,"Randomly select queries until the array is zero, then count the selected queries.",Sort the queries based on their start indices and process them sequentially.,"Model the problem as a maximum independent set on an interval graph, and use a greedy or approximation algorithm to solve it.",Medium,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue),Prefix Sum"
3363,"Find the Maximum Number of Fruits Collected
There is a game dungeon comprised of n x n rooms arranged in a grid. You are given a 2D array fruits of size n x n, where fruits[i][j] represents the number of fruits in the room (i, j). Three children will play in the game dungeon, with initial positions at the corner rooms (0, 0), (0, n - 1), and (n - 1, 0). The children will make exactly n - 1 moves according to the following rules to reach the room (n - 1, n - 1): When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave. Return the maximum number of fruits the children can collect from the dungeon.",Calculate the total fruits in the entire grid and subtract the minimum possible fruits left uncollected by the children.,Simulate all possible path combinations for the three children using recursion and select the path configuration with the maximum fruit count.,"Divide the grid into three regions, assign a child to each region, and maximize fruit collection within each region independently.","Greedily move each child along the path with the most fruits at each step, without considering the overlapping paths.","Use dynamic programming to track the maximum fruits collected by the children at each cell, considering path overlaps and constraints.",Hard,algorithms,"Array,Dynamic Programming,Matrix"
3364,"Minimum Positive Sum Subarray
You are given an integer array nums and two integers l and r. Your task is to find the minimum sum of a subarray whose size is between l and r (inclusive) and whose sum is greater than 0. Return the minimum sum of such a subarray. If no such subarray exists, return -1. A subarray is a contiguous non-empty sequence of elements within an array.",Kadane's algorithm modified to track minimum positive sum within the given length constraints.,Brute-force: Calculate the sum of every possible subarray of lengths l to r and find the minimum positive sum.,Binary search on the possible sums to find the minimum positive sum.,Use a min-heap to store all subarray sums of lengths l to r and extract the minimum positive sum.,Sliding window technique with prefix sums to efficiently find the minimum positive sum subarray within the given length constraints.,Easy,algorithms,"Array,Sliding Window,Prefix Sum"
3365,"Rearrange K Substrings to Form Target String
You are given two strings s and t, both of which are anagrams of each other, and an integer k. Your task is to determine whether it is possible to split the string s into k equal-sized substrings, rearrange the substrings, and concatenate them in any order to create a new string that matches the given string t. Return true if this is possible, otherwise, return false. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. A substring is a contiguous non-empty sequence of characters within a string.","Calculate the frequency of each character in 's' and 't', and return true if at least 'k' characters have the same frequency.","Check if 's' and 't' are anagrams. If they are, return true if 'k' is less than or equal to the length of 's'.","Return true if 's' and 't' are identical, regardless of the value of 'k'. Otherwise, return false.",Calculate the number of distinct characters in 's'. Return true if 'k' is less than or equal to that count.,Count the frequency of each character in 's'. Return true if the count of each character is divisible by 'k'.,Medium,algorithms,"Hash Table,String,Sorting"
3366,"Minimum Array Sum
You are given an integer array nums and three integers k, op1, and op2. You can perform the following operations on nums: Note: Both operations can be applied to the same index, but at most once each. Return the minimum possible sum of all elements in nums after performing any number of operations.","Recursively divide the array until single elements are reached, then apply operations bottom-up",Sort the array and greedily apply op1 and op2 to the largest elements first,Use dynamic programming to determine the optimal combination of operations for each subarray,Calculate the average of the array and apply operations to elements furthest from the average,"For each element, determine whether applying op1, op2, or neither results in the smallest value, then sum the resulting values",Medium,algorithms,"Array,Dynamic Programming"
3367,"Maximize Sum of Weights after Edge Removals
There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi in the tree. Your task is to remove zero or more edges such that: Return the maximum possible sum of weights for the remaining edges after making the necessary removals.",Always remove edges with weights less than the average weight of all edges.,"Use a greedy approach, always keeping the edge with the highest weight first.",Apply Depth-First Search (DFS) to identify the longest path and keep edges on that path.,Calculate the minimum spanning tree and only keep edges that are part of it.,"Use dynamic programming, considering each node and its subtrees to decide which edges to keep for maximum weight.",Hard,algorithms,"Dynamic Programming,Tree,Depth-First Search"
3370,"Smallest Number With All Set Bits
You are given a positive number n. Return the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits","Subtract 1 from n and repeatedly apply bitwise AND with n until n becomes 0, then return the original n","Left-shift n by 1 until its most significant bit is set, then return n","Find the most significant bit of n, then return that bit minus 1","Right-shift n by 1 until n becomes 0, then return the initial value of n",Repeatedly set the rightmost unset bit of n until all bits are set,Easy,algorithms,"Math,Bit Manipulation"
3371,"Identify the Largest Outlier in an Array
You are given an integer array nums. This array contains n elements, where exactly n - 2 elements are special numbers. One of the remaining two elements is the sum of these special numbers, and the other is an outlier. An outlier is defined as a number that is neither one of the original special numbers nor the element representing the sum of those numbers. Note that special numbers, the sum element, and the outlier must have distinct indices, but may share the same value. Return the largest potential outlier in nums.","Find the mean and standard deviation, then identify elements outside a certain range (e.g., 3 standard deviations)",Sort the array and return the element furthest from the median,Calculate the sum of all elements and return the element with the largest absolute difference from this sum,Calculate the median of the entire array and return the element with the largest difference from the median,Calculate the sum of all possible subsets of n-2 elements and check which remaining element isn't equal to any subset's sum,Medium,algorithms,"Array,Hash Table,Counting,Enumeration"
3372,"Maximize the Number of Target Nodes After Connecting Trees I
There exist two undirected trees with n and m nodes, with distinct labels in ranges [0, n - 1] and [0, m - 1], respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree. You are also given an integer k. Node u is target to node v if the number of edges on the path from u to v is less than or equal to k. Note that a node is always target to itself. Return an array of n integers answer, where answer[i] is the maximum possible number of nodes target to node i of the first tree if you have to connect one node from the first tree to another node in the second tree. Note that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.","Use a depth-first search (DFS) from each node in the first tree, exploring the second tree only once and memorizing results",Calculate all-pairs shortest paths in both trees using the Floyd-Warshall algorithm and then connect the trees,Precompute the distances between all pairs of nodes in both trees using Dijkstra's algorithm and connect the closest pair,Connect a random node from the first tree to a random node from the second tree and perform a BFS from each node in the first tree,"For each node in the first tree, iterate through all possible connection points in the second tree, performing a BFS/DFS to compute target node counts and maximizing the result",Medium,algorithms,"Tree,Depth-First Search,Breadth-First Search"
3373,"Maximize the Number of Target Nodes After Connecting Trees II
There exist two undirected trees with n and m nodes, labeled from [0, n - 1] and [0, m - 1], respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree. Node u is target to node v if the number of edges on the path from u to v is even. Note that a node is always target to itself. Return an array of n integers answer, where answer[i] is the maximum possible number of nodes that are target to node i of the first tree if you had to connect one node from the first tree to another node in the second tree. Note that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.",Use Depth First Search (DFS) on the first tree and for each node connect it to every node in the second tree to check target nodes and return the maximum,"Apply a greedy approach where for each node in the first tree, connect it to the node in the second tree that results in the most target nodes being connected",Utilize a dynamic programming approach to store the number of even/odd paths from each node and merge these results after adding an edge between the two trees,"Ignore the tree structure and treat the problem as finding the best connection to maximize even-length paths, iterating through all possible connections","Perform Breadth-First Search (BFS) on each tree, tracking path lengths, then for each node in the first tree, try connecting it to each node in the second and recalculate target nodes using the precomputed BFS data.",Hard,algorithms,"Tree,Depth-First Search,Breadth-First Search"
3374,"First Letter Capitalization II
Table: user_content Write a solution to transform the text in the content_text column by applying the following rules: Return the result table that includes both the original content_text and the modified text following the above rules. The result format is in the following example.  Example: Input: user_content table: Output: Explanation:",Apply `INITCAP` function directly on the column,"Use `UPPER(SUBSTR(content_text, 1, 1)) || LOWER(SUBSTR(content_text, 2))`",Utilize a recursive function to capitalize each word,Implement a complex regular expression replacement,"Write a custom function to split the string into words, capitalize the first letter of each word, and then join them back together",Hard,database systems,Database
3375,"Minimum Operations to Make Array Values Equal to K
You are given an integer array nums and an integer k. An integer h is called valid if all values in the array that are strictly greater than h are identical. For example, if nums = [10, 8, 10, 8], a valid integer is h = 9 because all nums[i] > 9 are equal to 10, but 5 is not a valid integer. You are allowed to perform the following operation on nums: Return the minimum number of operations required to make every element in nums equal to k. If it is impossible to make all elements equal to k, return -1.",Use dynamic programming to compute the minimum operations by considering subproblems of different array sizes.,Sort the array and iteratively replace elements furthest from 'k' until all elements are equal to 'k'.,"Calculate the average of the array. If 'k' is equal to the average, return 0; otherwise, return -1.","Check if 'k' exists in the array. If not, return -1; otherwise, return the number of elements not equal to 'k'.","Count elements greater than 'k' and elements less than 'k'. The answer is the maximum of these counts, or -1 if it's impossible.",Easy,algorithms,"Array,Hash Table"
3376,"Minimum Time to Break Locks I
Bob is stuck in a dungeon and must break n locks, each requiring some amount of energy to break. The required energy for each lock is stored in an array called strength where strength[i] indicates the energy needed to break the ith lock. To break a lock, Bob uses a sword with the following characteristics: Your task is to determine the minimum time in minutes required for Bob to break all n locks and escape the dungeon. Return the minimum time required for Bob to break all n locks.",Sort the 'strength' array in descending order and sum the first half of the elements.,Calculate the average energy required and multiply it by the number of locks.,Find the lock with the minimum strength and multiply its strength by the total number of locks.,Square each element of the 'strength' array and then take the square root of the sum of these squares.,Sum all the elements in the 'strength' array.,Medium,algorithms,"Array,Dynamic Programming,Backtracking,Bit Manipulation,Depth-First Search,Bitmask"
3377,"Digit Operations to Make Two Integers Equal
You are given two integers n and m that consist of the same number of digits. You can perform the following operations any number of times: The integer n must not be a prime number at any point, including its original value and after each operation. The cost of a transformation is the sum of all values that n takes throughout the operations performed. Return the minimum cost to transform n into m. If it is impossible, return -1.","Dynamic Programming: Build a table of minimum costs to transform each digit of 'n' into the corresponding digit of 'm', considering all possible intermediate states.","Greedy Approach: Repeatedly change the digits of 'n' to match 'm' from left to right, always choosing the smallest change that doesn't make 'n' prime.","Depth-First Search: Explore all possible sequences of digit changes from 'n' until 'm' is reached or all paths are exhausted, memoizing intermediate states to avoid revisiting.","Breadth-First Search: Explore possible digit changes starting from 'n', level by level, avoiding prime numbers, until 'm' is found or all reachable states are exhausted.","Graph Theory: Treat each number as a node, and an edge exists between two numbers if one can be transformed into the other via a digit change without becoming prime. Use Dijkstra's algorithm to find the shortest path from 'n' to 'm'.",Medium,algorithms,"Math,Graph,Heap (Priority Queue),Number Theory,Shortest Path"
3378,"Count Connected Components in LCM Graph
You are given an array of integers nums of size n and a positive integer threshold. There is a graph consisting of n nodes with the ith node having a value of nums[i]. Two nodes i and j in the graph are connected via an undirected edge if lcm(nums[i], nums[j]) <= threshold. Return the number of connected components in this graph. A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph. The term lcm(a, b) denotes the least common multiple of a and b.",Depth-First Search (DFS) with a stack to track visited nodes and an adjacency list to represent the graph.,"Kruskal's Algorithm for finding the Minimum Spanning Tree, then count the number of trees.","Dynamic Programming approach, storing the connected component size for each node and updating based on neighbors.",Use a disjoint set data structure (Union-Find) without path compression for merging components based on LCM values.,Use a disjoint set data structure (Union-Find) with path compression and union by rank to efficiently track connected components.,Hard,algorithms,"Array,Hash Table,Math,Union Find,Number Theory"
3379,"Transformed Array
You are given an integer array nums that represents a circular array. Your task is to create a new array result of the same size, following these rules: Return the new array result. Note: Since nums is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.","Iterate through the array, setting each element in result to the value of the next element in nums",Create a copy of nums and reverse it to form result,"Initialize result with zeros, then iterate nums assigning each element to the corresponding index plus one in result, wrapping around if needed","Concatenate nums with itself to create a temporary array, then copy segments of the temporary array into result","Iterate through nums, calculating the sum of the previous, current, and next elements (handling wraparound) and storing it in result",Easy,algorithms,"Array,Simulation"
3380,"Maximum Area Rectangle With Point Constraints I
You are given an array points where points[i] = [xi, yi] represents the coordinates of a point on an infinite plane. Your task is to find the maximum area of a rectangle that: Return the maximum area that you can obtain or -1 if no such rectangle is possible.","Enumerate all possible combinations of points and calculate the area, keeping track of the maximum.","Sort the points by x-coordinate and then by y-coordinate, and consider only adjacent points for rectangle formation.",Calculate the convex hull of the points and consider only the points on the hull for forming the rectangle.,"Divide the plane into quadrants and find the maximum area rectangle in each quadrant independently, then take the maximum of those.","Iterate through all pairs of points, check if a valid rectangle can be formed, and track the maximum area.",Medium,algorithms,"Array,Math,Binary Indexed Tree,Segment Tree,Geometry,Sorting,Enumeration"
3381,"Maximum Subarray Sum With Length Divisible by K
You are given an array of integers nums and an integer k. Return the maximum sum of a subarray of nums, such that the size of the subarray is divisible by k.",Compute prefix sums modulo k and find the largest difference between two such sums.,Sort the array and then iterate through all possible subarrays of lengths divisible by k.,Use a sliding window of size k and calculate the sum for each position.,"Apply dynamic programming to store sums of subarrays, updating only those with lengths divisible by k.",Maintain an array of size k storing the maximum sum ending at each remainder modulo k and update accordingly.,Medium,algorithms,"Array,Hash Table,Prefix Sum"
3382,"Maximum Area Rectangle With Point Constraints II
There are n points on an infinite plane. You are given two integer arrays xCoord and yCoord where (xCoord[i], yCoord[i]) represents the coordinates of the ith point. Your task is to find the maximum area of a rectangle that: Return the maximum area that you can obtain or -1 if no such rectangle is possible.",Check every possible rectangle formed by the points; O(n^4) time complexity,Sort points and use a sliding window approach to find suitable pairs; O(n log n) time complexity,Use a quadtree to efficiently partition the space and search for rectangles; O(n log n) average case complexity,Employ dynamic programming to store intermediate rectangle areas; O(n^2) space complexity,Iterate through all pairs of points and then check if the other two points to form a rectangle exist using a hash set; O(n^3) average case complexity,Hard,algorithms,"Array,Math,Binary Indexed Tree,Segment Tree,Geometry,Sorting"
3386,"Button with Longest Push Time
You are given a 2D array events which represents a sequence of events where a child pushes a series of buttons on a keyboard. Each events[i] = [indexi, timei] indicates that the button at index indexi was pressed at time timei. Return the index of the button that took the longest time to push. If multiple buttons have the same longest time, return the button with the smallest index.",Sort the events array by time and return the index of the last element.,Calculate the time difference between consecutive presses for each button and return the maximum difference.,Maintain a running sum of press times for each button and return the button with the largest sum.,Use a hash map to store each button's press time and return the button with the highest average press time.,"Iterate through the events array, tracking the longest push time for each button, and return the smallest index among those with the longest time.",Easy,algorithms,Array
3387,"Maximize Amount After Two Days of Conversions
You are given a string initialCurrency, and you start with 1.0 of initialCurrency. You are also given four arrays with currency pairs (strings) and rates (real numbers): You can perform any number of conversions, including zero, using rates1 on day 1, followed by any number of additional conversions, including zero, using rates2 on day 2. Return the maximum amount of initialCurrency you can have after performing any number of conversions on both days in order. Note: Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.",Use Dijkstra's algorithm to find the longest path in a graph where currencies are nodes and rates are edge weights.,Apply the Bellman-Ford algorithm to detect positive weight cycles in the currency conversion graph and maximize the amount.,Use dynamic programming with memoization to store the maximum amount achievable for each currency at each day.,Calculate the product of all exchange rates for each currency pair on both days and select the highest product.,Construct a graph where currencies are nodes and conversion rates are edge weights. Use Floyd-Warshall to find the highest conversion rate between the initial currency and itself after two days.,Medium,algorithms,"Array,String,Depth-First Search,Breadth-First Search,Graph"
3388,"Count Beautiful Splits in an Array
You are given an array nums. A split of an array nums is beautiful if: Return the number of ways you can make this split.",Check if both halves have the same number of unique elements.,Calculate the product of unique elements in both halves and compare.,Compare the sum of unique elements in the first half to the total number of elements.,Count splits where the first half's maximum element is less than the second half's minimum element.,Count splits where the number of unique elements is the same in both the left and right subarrays.,Medium,algorithms,"Array,Dynamic Programming"
3389,"Minimum Operations to Make Character Frequencies Equal
You are given a string s. A string t is called good if all characters of t occur the same number of times. You can perform the following operations any number of times: Note that you cannot change 'z' to 'a' using the third operation. Return the minimum number of operations required to make s good.",Recursively remove characters until all frequencies are the same,Calculate the average frequency and remove characters to match it,Sort the string and remove characters from the end until all frequencies are equal,Iterate through all possible frequency values and count the operations to reach each,"Calculate character frequencies, then iterate through possible target frequencies and calculate the minimum operations to achieve each",Hard,algorithms,"Hash Table,String,Dynamic Programming,Counting,Enumeration"
3392,"Count Subarrays of Length Three With a Condition
Given an integer array nums, return the number of subarrays of length 3 such that the sum of the first and third numbers equals exactly half of the second number.",The average case running time is O(n log n) and space complexity is O(1).,The average case running time is O(n) and space complexity is O(n).,The worst case running time is O(n^2) and space complexity is O(1).,The average case running time is O(1) and space complexity is O(n).,The running time is O(n) and space complexity is O(1).,Easy,algorithms,Array
3393,"Count Paths With the Given XOR Value
You are given a 2D integer array grid with size m x n. You are also given an integer k. Your task is to calculate the number of paths you can take from the top-left cell (0, 0) to the bottom-right cell (m - 1, n - 1) satisfying the following constraints: Return the total number of such paths. Since the answer can be very large, return the result modulo 109 + 7.","Use dynamic programming, storing the XOR value encountered at each cell to avoid recomputation and reduce time complexity.","Recursively explore all possible paths, using backtracking to avoid cycles and pruning to reduce the search space.","Employ a greedy algorithm, always choosing the path with the smallest XOR value at each step.",Calculate the XOR value of every possible path using nested loops and compare it with k. Paths with XOR equal to k are counted. This approach is not efficient for large grids.,"Apply dynamic programming, using memoization to store the number of paths from each cell with a specific XOR value, and check the XOR value matches 'k' when reaching the end",Medium,algorithms,"Array,Dynamic Programming,Bit Manipulation,Matrix"
3394,"Check if Grid can be Cut into Sections
You are given an integer n representing the dimensions of an n x n grid, with the origin at the bottom-left corner of the grid. You are also given a 2D array of coordinates rectangles, where rectangles[i] is in the form [startx, starty, endx, endy], representing a rectangle on the grid. Each rectangle is defined as follows: Note that the rectangles do not overlap. Your task is to determine if it is possible to make either two horizontal or two vertical cuts on the grid such that: Return true if such cuts can be made; otherwise, return false.","Check if the entire grid is covered by the rectangles, which would prevent any valid cuts.",Sort the rectangles by their area and iteratively try cuts based on area distribution.,Perform a brute-force search by trying all possible combinations of horizontal and vertical cut locations.,Only consider cuts that align with the edges of the rectangles in the input.,"Compute the union of rectangles and then iterate through possible cut locations, checking if each section is fully covered or fully empty of the union.",Medium,algorithms,"Array,Sorting"
3395,"Subsequences with a Unique Middle Mode I
Given an integer array nums, find the number of subsequences of size 5 of nums with a unique middle mode. Since the answer may be very large, return it modulo 109 + 7. A mode of a sequence of numbers is defined as the element that appears the maximum number of times in the sequence. A sequence of numbers contains a unique mode if it has only one mode. A sequence of numbers seq of size 5 contains a unique middle mode if the middle element (seq[2]) is a unique mode.","Iterate through the array, counting subsequence frequencies and then checking each subsequence for the unique middle mode condition.","Sort the input array and then iterate through all possible subsequences, checking for the unique middle mode condition to improve performance.",Use a sliding window of size 5 and check if the middle element is the unique mode within that window.,"Calculate the mode of the entire array, and only consider subsequences containing that mode as the middle element.","Use combinations to select indices for the subsequence, then check if the middle element is a unique mode, and increment a counter modulo 10^9 + 7.",Hard,algorithms,"Array,Hash Table,Math,Combinatorics"
3396,"Minimum Number of Operations to Make Elements in Array Distinct
You are given an integer array nums. You need to ensure that the elements in the array are distinct. To achieve this, you can perform the following operation any number of times: Note that an empty array is considered to have distinct elements. Return the minimum number of operations needed to make the elements in the array distinct.","Sort the array and increment duplicates until unique, counting operations.","Use a hash map to count occurrences, then increment duplicates until a unique value is found, counting operations.","Recursively find duplicates and increment them to the minimum available unique value, tracking operation count.","Calculate the mode, and increment any value equal to the mode by 1 until all elements differ.","Sort the array, then iterate. If a value is not greater than the previous, increment it until unique and count the increments.",Easy,algorithms,"Array,Hash Table"
3397,"Maximum Number of Distinct Elements After Operations
You are given an integer array nums and an integer k. You are allowed to perform the following operation on each element of the array at most once: Return the maximum possible number of distinct elements in nums after performing the operations.","Sort the array and greedily increment duplicates until k is exhausted, then count distinct elements.","Use a hash map to count frequencies, then decrement the most frequent elements until k is zero, and return the hash map size.","Iterate through the array, and if an element has a duplicate, remove both elements. Then return the length of the modified array if k is large enough.","Decrement all elements by 1 until k reaches 0, then return the number of non-zero elements.","Count frequencies, prioritize incrementing least frequent duplicates to distinct values within the k limit, then count distinct elements.",Medium,algorithms,"Array,Greedy,Sorting"
3398,"Smallest Substring With Identical Characters I
You are given a binary string s of length n and an integer numOps. You are allowed to perform the following operation on s at most numOps times: You need to minimize the length of the longest substring of s such that all the characters in the substring are identical. Return the minimum length after the operations.",Sliding window approach with character replacements until numOps is exhausted,Greedily replace characters starting from the beginning and end of the string,Binary search on the substring length and check if it's achievable with numOps,Sort the string and count the longest substring of identical characters,Use a sliding window and expand/contract based on the number of operations needed to make all characters within the window identical,Hard,algorithms,"Array,Binary Search,Enumeration"
3399,"Smallest Substring With Identical Characters II
You are given a binary string s of length n and an integer numOps. You are allowed to perform the following operation on s at most numOps times: You need to minimize the length of the longest substring of s such that all the characters in the substring are identical. Return the minimum length after the operations.","Binary search for the length of the substring, using a greedy approach to check if it's achievable within numOps, prioritizing flips that maximize substring length","Use a sliding window approach, expanding and shrinking the window based on the number of operations needed to make all characters in the window identical, prioritizing shorter substrings","Apply dynamic programming to calculate the minimum number of operations for each possible substring, considering all possible flip combinations, starting from substrings of length 1","Sort the string 's', calculate the most frequent character, and attempt to transform all other characters into the most frequent one using the available operations, minimizing the number of remaining mismatched characters","Binary search for the length of the substring, use a sliding window to validate the substring, and count the number of 0s and 1s and ensure that min(count0, count1) <= numOps",Hard,algorithms,"String,Binary Search"
3402,"Minimum Operations to Make Columns Strictly Increasing
You are given a m x n matrix grid consisting of non-negative integers. In one operation, you can increment the value of any grid[i][j] by 1. Return the minimum number of operations needed to make all columns of grid strictly increasing.","Apply dynamic programming on rows, tracking the minimum operations to make each row strictly increasing considering previous rows.",Sort each column independently and then calculate the operations needed to make it strictly increasing.,"Use a greedy approach, iterating through columns and incrementing elements to match the maximum value seen so far.",Calculate the difference between the maximum and minimum values in the entire grid and multiply by the number of columns.,"Apply dynamic programming on columns, tracking the cost of making the i-th column strictly increasing based on the values in the (i-1)-th column.",Easy,algorithms,"Array,Greedy,Matrix"
3403,"Find the Lexicographically Largest String From the Box I
You are given a string word, and an integer numFriends. Alice is organizing a game for her numFriends friends. There are multiple rounds in the game, where in each round: Find the lexicographically largest string from the box after all the rounds are finished.",Sort the string and take the substring of length numFriends from the end,Remove the smallest character numFriends times,Reverse the string and remove the first numFriends characters,Keep the largest character and remove all others,"Iteratively remove the smallest character from the string until only the most lexicographically maximal string constructable remains, doing this at most numFriends times",Medium,algorithms,"Two Pointers,String,Enumeration"
3404,"Count Special Subsequences
You are given an array nums consisting of positive integers. A special subsequence is defined as a subsequence of length 4, represented by indices (p, q, r, s), where p < q < r < s. This subsequence must satisfy the following conditions: Return the number of different special subsequences in nums.",O(n^4),O(n log n),O(n^2),O(1),O(n),Medium,algorithms,"Array,Hash Table,Math,Enumeration"
3405,"Count the Number of Arrays with K Matching Adjacent Elements
You are given three integers n, m, k. A good array arr of size n is defined as follows: Return the number of good arrays that can be formed. Since the answer may be very large, return it modulo 109 + 7.","Employ a brute-force approach, generating all possible arrays and counting those with exactly k matching adjacent elements.","Use dynamic programming with states (index, previous_value, count_matching) to store intermediate results.","Apply a greedy algorithm, prioritizing array configurations that minimize matching adjacent elements.",Derive a closed-form mathematical formula based on combinatorial analysis.,"Utilize dynamic programming with memoization to avoid redundant calculations, considering states (index, previous_element, matching_count).",Hard,algorithms,"Math,Combinatorics"
3407,"Substring Matching Pattern
You are given a string s and a pattern string p, where p contains exactly one '*' character. The '*' in p can be replaced with any sequence of zero or more characters. Return true if p can be made a substring of s, and false otherwise.",Use dynamic programming to build a table of all possible substring matches.,"Greedily match the prefix and suffix of 'p' in 's', skipping characters in 's' as needed.",Split 's' into all possible substrings and check if any of them match 'p' after replacing '*' with an empty string.,Replace the '*' in 'p' with every possible substring of 's' and check for a direct match.,"Split 'p' at '*', match the prefix in 's', then match the suffix starting from the end of 's', allowing for any characters in between.",Easy,algorithms,"String,String Matching"
3408,"Design Task Manager
There is a task management system that allows users to manage their tasks, each associated with a priority. The system should efficiently handle adding, modifying, executing, and removing tasks. Implement the TaskManager class: TaskManager(vector<vector<int>>& tasks) initializes the task manager with a list of user-task-priority triples. Each element in the input list is of the form [userId, taskId, priority], which adds a task to the specified user with the given priority. void add(int userId, int taskId, int priority) adds a task with the specified taskId and priority to the user with userId. It is guaranteed that taskId does not exist in the system. void edit(int taskId, int newPriority) updates the priority of the existing taskId to newPriority. It is guaranteed that taskId exists in the system. void rmv(int taskId) removes the task identified by taskId from the system. It is guaranteed that taskId exists in the system. int execTop() executes the task with the highest priority across all users. If there are multiple tasks with the same highest priority, execute the one with the highest taskId. After executing, the taskId is removed from the system. Return the userId associated with the executed task. If no tasks are available, return -1. Note that a user may be assigned multiple tasks.","Using a single priority queue for all tasks, sorted by priority then taskId.","Storing tasks in a hash map, keyed by taskId, and iterating through the map for execTop.",Maintaining a list of tasks for each user and sorting the lists before each operation.,"Employing a binary search tree to store tasks, ordered by taskId.","Employing a priority queue for each user, ordered by priority then taskId, and a hash map to look up tasks by taskId.",Medium,data structures,"Hash Table,Design,Heap (Priority Queue),Ordered Set"
3409,"Longest Subsequence With Decreasing Adjacent Difference
You are given an array of integers nums. Your task is to find the length of the longest subsequence seq of nums, such that the absolute differences between consecutive elements form a non-increasing sequence of integers. In other words, for a subsequence seq0, seq1, seq2, ..., seqm of nums, |seq1 - seq0| >= |seq2 - seq1| >= ... >= |seqm - seqm - 1|. Return the length of such a subsequence.",Return the length of the original array.,Return the length of the longest decreasing subsequence.,Return the length of the longest increasing subsequence.,Return the number of unique elements in the array.,Use dynamic programming to track the length of the longest subsequence ending at each index with a specific absolute difference.,Medium,algorithms,"Array,Dynamic Programming"
3410,"Maximize Subarray Sum After Removing All Occurrences of One Element
You are given an integer array nums. You can do the following operation on the array at most once: Return the maximum subarray sum across all possible resulting arrays.",Calculate the sum of all possible subarrays and then subtract the maximum occurrence of any single element's contribution,"Sort the array, remove the element with the highest frequency, and then calculate the sum of the remaining array","Use Kadane's Algorithm to find the maximum subarray sum without removing any elements, and return that value directly","Iterate through each unique element, remove all occurrences of it from the array, and calculate the maximum subarray sum using brute force","Iterate through each unique element, remove all occurrences of it, and then use Kadane's Algorithm to find the maximum subarray sum.",Hard,algorithms,"Array,Dynamic Programming,Segment Tree"
3411,"Maximum Subarray With Equal Products
You are given an array of positive integers nums. An array arr is called product equivalent if prod(arr) == lcm(arr) * gcd(arr), where: Return the length of the longest product equivalent subarray of nums.","O(n log n), due to sorting the subarray in each iteration to calculate gcd and lcm","O(n^3), as the gcd and lcm calculations within each subarray take O(n) time on average","O(n^2 log n), due to potential logarithmic time for gcd or lcm calculations within each of the n^2 subarrays","O(n), since the gcd and lcm calculations can be done in constant time","O(n^2), iterating through all possible subarrays to check the product equivalent property",Easy,algorithms,"Array,Math,Sliding Window,Enumeration,Number Theory"
3412,"Find Mirror Score of a String
You are given a string s. We define the mirror of a letter in the English alphabet as its corresponding letter when the alphabet is reversed. For example, the mirror of 'a' is 'z', and the mirror of 'y' is 'b'. Initially, all characters in the string s are unmarked. You start with a score of 0, and you perform the following process on the string s: Return the total score at the end of the process.",O(n log n),O(n),O(log n),O(n^2),O(1),Medium,data structures,"Hash Table,String,Stack,Simulation"
3413,"Maximum Coins From K Consecutive Bags
There are an infinite amount of bags on a number line, one bag for each coordinate. Some of these bags contain coins. You are given a 2D array coins, where coins[i] = [li, ri, ci] denotes that every bag from li to ri contains ci coins. The segments that coins contain are non-overlapping. You are also given an integer k. Return the maximum amount of coins you can obtain by collecting k consecutive bags.",Divide the number line into blocks of size k and select the block with the largest sum.,"Use a greedy approach, always picking the bag with the most coins.",Calculate the prefix sum of coins for each bag and find the maximum difference between two prefix sums k positions apart.,Perform a binary search to find the optimal starting position for the k consecutive bags.,Use a sliding window of size k to calculate the sum of coins for each consecutive k bags and keep track of the maximum sum.,Medium,algorithms,"Array,Binary Search,Greedy,Sliding Window,Sorting,Prefix Sum"
3414,"Maximum Score of Non-overlapping Intervals
You are given a 2D integer array intervals, where intervals[i] = [li, ri, weighti]. Interval i starts at position li and ends at ri, and has a weight of weighti. You can choose up to 4 non-overlapping intervals. The score of the chosen intervals is defined as the total sum of their weights. Return the lexicographically smallest array of at most 4 indices from intervals with maximum score, representing your choice of non-overlapping intervals. Two intervals are said to be non-overlapping if they do not share any points. In particular, intervals sharing a left or right boundary are considered overlapping.","Use a greedy approach, always selecting the highest weight interval that doesn't overlap with previously selected ones.",Sort the intervals by start time and use dynamic programming to find the maximum weight of non-overlapping intervals.,Sort the intervals by weight in descending order and pick the first four non-overlapping intervals.,Exhaustively check every combination of up to 4 intervals and return the indices of the highest scoring non-overlapping set.,"Sort intervals by end time, use dynamic programming to find the maximum score of non-overlapping intervals ending at each interval, and backtrack to find the lexicographically smallest indices.",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Sorting"
3417,"Zigzag Grid Traversal With Skip
You are given an m x n 2D array grid of positive integers. Your task is to traverse grid in a zigzag pattern while skipping every alternate cell. Zigzag pattern traversal is defined as following the below actions: Note that you must skip every alternate cell during the traversal. Return an array of integers result containing, in order, the value of the cells visited during the zigzag traversal with skips.","Traverse row-wise, skipping elements at even indices, then traverse column-wise, skipping elements at odd indices.","Iterate through the grid in a spiral pattern, skipping every other element based on a counter.","Use a recursive function to traverse the grid diagonally, switching direction after each skip.","Visit cells based on their parity (even/odd) of row+column sum, skipping alternate cells encountered this way.","Traverse the grid row-wise or column-wise based on the current direction, skipping every other element encountered.",Easy,algorithms,"Array,Matrix,Simulation"
3418,"Maximum Amount of Money Robot Can Earn
You are given an m x n grid. A robot starts at the top-left corner of the grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The robot can move either right or down at any point in time. The grid contains a value coins[i][j] in each cell: The robot has a special ability to neutralize robbers in at most 2 cells on its path, preventing them from stealing coins in those cells. Note: The robot's total coins can be negative. Return the maximum profit the robot can gain on the route.","Use a greedy approach, always choosing the path with the highest immediate coin value, ignoring potential future gains or losses.",Calculate the sum of all coin values in the grid and subtract the two smallest coin values to account for neutralization.,Employ dynamic programming to find the shortest path and then subtract the values of the two smallest coins on that path.,"Use a backtracking algorithm to explore all possible paths and keep track of the maximum profit found so far, without memoization.","Apply dynamic programming to calculate the maximum profit for each cell, considering the possibility of neutralizing up to two cells along the path.",Medium,algorithms,"Array,Dynamic Programming,Matrix"
3419,"Minimize the Maximum Edge Weight of Graph
You are given two integers, n and threshold, as well as a directed weighted graph of n nodes numbered from 0 to n - 1. The graph is represented by a 2D integer array edges, where edges[i] = [Ai, Bi, Wi] indicates that there is an edge going from node Ai to node Bi with weight Wi. You have to remove some edges from this graph (possibly none), so that it satisfies the following conditions: Return the minimum possible value of the maximum edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.","Use Kruskal's algorithm to find the minimum spanning tree, and the largest edge in the MST is the answer.",Perform a binary search on the possible range of maximum edge weights and check if a valid graph can be formed by only keeping edges with weights less than or equal to the current weight during the binary search.,Sort all the edge weights and pick the middle one as the minimum possible value.,Calculate the average edge weight and return that value as the answer.,"Apply binary search on the range of possible maximum edge weights. For each weight, use Depth-First Search (DFS) or Breadth-First Search (BFS) to check if all nodes are reachable under the threshold.",Medium,algorithms,"Binary Search,Depth-First Search,Breadth-First Search,Graph,Shortest Path"
3420,"Count Non-Decreasing Subarrays After K Operations
You are given an array nums of n integers and an integer k. For each subarray of nums, you can apply up to k operations on it. In each operation, you increment any element of the subarray by 1. Note that each subarray is considered independently, meaning changes made to one subarray do not persist to another. Return the number of subarrays that you can make non-decreasing ​​​​​after performing at most k operations. An array is said to be non-decreasing if each element is greater than or equal to its previous element, if it exists.",Use dynamic programming to track the minimum number of operations needed for each prefix and suffix.,"Employ a greedy approach, always incrementing the smallest element in each subarray until it is non-decreasing.",Sort each subarray individually and count the number of non-decreasing subarrays.,Apply a binary search to find the optimal number of operations for each subarray.,Utilize a sliding window to efficiently determine if a subarray can be made non-decreasing within k operations.,Hard,algorithms,"Array,Stack,Segment Tree,Queue,Sliding Window,Monotonic Stack,Monotonic Queue"
3421,"Find Students Who Improved
Table: Scores Write a solution to find the students who have shown improvement. A student is considered to have shown improvement if they meet both of these conditions: Return the result table ordered by student_id, subject in ascending order. The result format is in the following example.  Example: Input: Scores table: Output: Explanation: Result table is ordered by student_id, subject.",Use a correlated subquery to compare each student's current score with their previous score,Employ a window function with a LAG clause to access the previous score and filter based on the difference,Create a temporary table to store each student's minimum score and then join it back to the original table,"Use a self-join on the table, grouping by student ID and comparing the minimum and maximum scores",Use a window function with the LEAD clause to compare the scores and filter where the current score is greater than the previous score,Medium,database systems,Database
829,"Subdomain Visit Count
A website domain ""discuss.leetcode.com"" consists of various subdomains. At the top level, we have ""com"", at the next level, we have ""leetcode.com"" and at the lowest level, ""discuss.leetcode.com"". When we visit a domain like ""discuss.leetcode.com"", we will also visit the parent domains ""leetcode.com"" and ""com"" implicitly. A count-paired domain is a domain that has one of the two formats ""rep d1.d2.d3"" or ""rep d1.d2"" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself. Given an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order.","Use a hash map to store counts, iterating through the input array from right to left, accumulating counts for each subdomain.","Sort the input array alphabetically and then iterate through it, summing counts for identical domains.","Use regular expressions to extract subdomains and counts, storing them in a SQL database and querying the sums.","Iterate through the array once, storing the subdomain strings into a trie data structure and counting frequencies during insertion.","Iterate through the input, splitting each domain string into subdomains, and use a hash map to accumulate visit counts for each subdomain.",Medium,algorithms,"Array,Hash Table,String,Counting"
830,"Largest Triangle Area
Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.",Calculate the area of each triangle using Heron's formula and return the maximum,"Find the convex hull of the points, then check only triangles formed by hull vertices",Sort the points by x-coordinate and only consider triangles formed by adjacent points,"Use a brute force approach, but optimize by skipping points within a small radius of each other",Iterate through all combinations of three points and calculate the area of each triangle using the determinant method; return the maximum area,Easy,algorithms,"Array,Math,Geometry"
831,"Largest Sum of Averages
You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray. Note that the partition must use every integer in nums, and that the score is not necessarily an integer. Return the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted.",Greedily choose the largest element and start a new subarray.,Calculate the average of the entire array and multiply by k.,Use a sliding window of size k to find the maximum average subarray.,Sort the array and divide it into k equal parts.,Use dynamic programming to store the maximum score for each prefix of the array with a given number of subarrays.,Medium,algorithms,"Array,Dynamic Programming"
832,"Binary Tree Pruning
Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node.",Perform a post-order traversal and set nodes to null if both children are null,Use a breadth-first search to identify subtrees containing only zeros and then remove them,"Convert the tree to an array, remove the subtrees containing no 1's from the array, then rebuild the tree","Perform an in-order traversal, and if the current node and all visited nodes contain 0, prune the current node","Recursively prune the left and right subtrees, and if a node's value is 0 and both subtrees are null, return null",Medium,algorithms,"Tree,Depth-First Search,Binary Tree"
833,"Bus Routes
You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only. Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.","Use Depth-First Search (DFS) to explore possible routes, prioritizing routes with fewer stops","Employ a greedy algorithm, always choosing the route that gets you closest to the target stop","Randomly select bus routes until the target is reached, recording the number of routes taken",Precompute all possible paths between every pair of bus stops and retrieve the shortest one,Utilize Breadth-First Search (BFS) to find the shortest path in terms of the number of buses taken,Hard,algorithms,"Array,Hash Table,Breadth-First Search"
2186,"Count Vowel Substrings of a String
A substring is a contiguous (non-empty) sequence of characters within a string. A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given a string word, return the number of vowel substrings in word.","Use a sliding window, expanding until a vowel is missing, then resetting.",Generate all possible substrings and then filter for those containing only vowels.,Recursively check each substring for vowel completeness.,Use dynamic programming to store the count of vowels seen so far.,"Use a sliding window, expanding until all 5 vowels are present, then contracting from the start while maintaining all 5 vowels.",Easy,algorithms,"Hash Table,String"
2187,"Vowels of All Substrings
Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word. A substring is a contiguous (non-empty) sequence of characters within a string. Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.","Divide the string into substrings of length 1, 2, ..., n, count vowels in each, and sum the counts.",Use regular expressions to identify and count vowels in the string.,Precompute the vowel count for prefixes of the string and use this to calculate vowel counts for substrings.,"Iterate through the string and for each character, only consider substrings starting from that character.","Iterate through the string and, for each vowel, calculate the number of substrings it appears in based on its position.",Medium,algorithms,"Math,String,Dynamic Programming,Combinatorics"
2188,"Minimized Maximum of Products Distributed to Any Store
You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type. You need to distribute all products to the retail stores following these rules: Return the minimum possible x.","Binary search on the range [1, max(quantities)] and check if all quantities can be distributed such that no store receives more than the current mid value, using integer division.","Sort the quantities array in descending order and use a greedy approach, assigning the largest quantities to different stores until all quantities are distributed.","Dynamically programming, create a table to store the minimum stores needed for distributing the first i product types up to a certain maximum quantity per store.","Use a min-heap to keep track of the remaining stores, repeatedly assign the largest quantity to the store with the least number of products currently assigned.","Binary search on the range [1, max(quantities)] and check if the total number of stores required is less than or equal to n. The check involves summing the ceiling of quantities[i] / mid for all i.",Medium,algorithms,"Array,Binary Search"
2189,"Maximum Path Quality of a Graph
There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime. A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum). Return the maximum quality of a valid path. Note: There are at most four edges connected to each node.","Use a greedy approach, always choosing the edge with the highest value node until maxTime is reached.","Perform a Breadth-First Search (BFS), pruning paths that exceed maxTime, and selecting the path with the largest accumulated node value.",Calculate all possible paths from node 0 back to node 0 using Depth-First Search (DFS) and choose the path with the maximum quality that respects maxTime.,Apply Dijkstra's algorithm to find the shortest path from node 0 to node 0 and then sum the values of the nodes in that path if the time is less than maxTime.,"Employ Depth-First Search (DFS) to explore all valid paths, keeping track of visited nodes and time spent to maximize path quality within the maxTime constraint.",Hard,algorithms,"Array,Backtracking,Graph"
2189,"Maximum Path Quality of a Graph
There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime. A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum). Return the maximum quality of a valid path. Note: There are at most four edges connected to each node.","Use a greedy approach, always choosing the edge with the highest value node until maxTime is reached.","Perform a Breadth-First Search (BFS), pruning paths that exceed maxTime, and selecting the path with the largest accumulated node value.",Calculate all possible paths from node 0 back to node 0 using Depth-First Search (DFS) and choose the path with the maximum quality that respects maxTime.,Apply Dijkstra's algorithm to find the shortest path from node 0 to node 0 and then sum the values of the nodes in that path if the time is less than maxTime.,"Employ Depth-First Search (DFS) to explore all valid paths, keeping track of visited nodes and time spent to maximize path quality within the maxTime constraint.",Hard,algorithms,"Array,Backtracking,Graph"
2177,"Check Whether Two Strings are Almost Equivalent
Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3. Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise. The frequency of a letter x is the number of times it occurs in the string.","Compare the lengths of the strings. If the difference is greater than 3, return false.","Iterate through each string, counting the total number of characters. If the difference is greater than 3, return false.","Create sets of unique characters in each string. Compare the sizes of the sets. If the difference is greater than 3, return false.","Calculate the absolute difference in string lengths. If the result equals 3, return true.",Create frequency maps for each string and check if the absolute difference in counts for each character ('a' to 'z') is at most 3.,Easy,algorithms,"Hash Table,String,Counting"
3312,"Sorted GCD Pair Queries
You are given an integer array nums of length n and an integer array queries. Let gcdPairs denote an array obtained by calculating the GCD of all possible pairs (nums[i], nums[j]), where 0 <= i < j < n, and then sorting these values in ascending order. For each query queries[i], you need to find the element at index queries[i] in gcdPairs. Return an integer array answer, where answer[i] is the value at gcdPairs[queries[i]] for each query. The term gcd(a, b) denotes the greatest common divisor of a and b.","Calculate all GCD pairs, sort them using bubble sort, and return the element at the specified index.","Calculate the GCD of only adjacent elements, sort them, and return the element at the specified index. Ignore non-adjacent pairs.","Use a hash table to store GCD pairs and their frequencies, then iterate through the sorted hash table to find the element at the given index.","Calculate all GCD pairs, sort them using insertion sort optimized for nearly sorted data, and return the element at the specified index.","Calculate all GCD pairs, sort them using merge sort, and return the element at the specified index.",Hard,algorithms,"Array,Hash Table,Math,Binary Search,Combinatorics,Counting,Number Theory,Prefix Sum"
3314,"Construct the Minimum Bitwise Array I
You are given an array nums consisting of n prime integers. You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of ans[i] in the resulting array. If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.",ans[i] = nums[i] - 1,ans[i] = nums[i] | (nums[i] + 1),ans[i] = nums[i] >> 1,ans[i] = nums[i] & (nums[i] - 1),ans[i] = nums[i] ^ 1,Easy,algorithms,"Array,Bit Manipulation"
3315,"Construct the Minimum Bitwise Array II
You are given an array nums consisting of n prime integers. You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of ans[i] in the resulting array. If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.",ans[i] = nums[i] - 1 if (nums[i] & 1) == 0 else -1,ans[i] = nums[i] & (nums[i] + 1),ans[i] = nums[i] + 1 if (nums[i] % 2) == 1 else -1,ans[i] = nums[i] ^ (nums[i] + 1),ans[i] = nums[i] - 1 if (nums[i] % 2) == 1 else -1,Medium,algorithms,"Array,Bit Manipulation"
3316,"Find Maximum Removals From Source String
You are given a string source of size n, a string pattern that is a subsequence of source, and a sorted integer array targetIndices that contains distinct numbers in the range [0, n - 1]. We define an operation as removing a character at an index idx from source such that: Performing an operation does not change the indices of the other characters in source. For example, if you remove 'c' from ""acb"", the character at index 2 would still be 'b'. Return the maximum number of operations that can be performed.","Binary search to find the maximum number of removals, checking if the pattern is still a subsequence after removing `k` characters greedily from `targetIndices`.",Iterate through `targetIndices` removing characters from `source` one by one and check at each step if `pattern` is still a subsequence using dynamic programming.,Sort `targetIndices` in reverse order and greedily remove the last element until pattern is no longer a subsequence,Remove elements from source at `targetIndices` until source no longer contains the pattern and return the number of elements removed.,Use binary search on the number of removals from `targetIndices` and verify if the remaining `source` still contains `pattern` as a subsequence,Medium,algorithms,"Array,Hash Table,Two Pointers,String,Dynamic Programming"
3317,"Find the Number of Possible Ways for an Event
You are given three integers n, x, and y. An event is being held for n performers. When a performer arrives, they are assigned to one of the x stages. All performers assigned to the same stage will perform together as a band, though some stages might remain empty. After all performances are completed, the jury will award each band a score in the range [1, y]. Return the total number of possible ways the event can take place. Since the answer may be very large, return it modulo 109 + 7. Note that two events are considered to have been held differently if either of the following conditions is satisfied:",x^n * y^(x+n),n^x * y^x,x! * y^n (mod 10^9 + 7),x^n + y^n,x^n * y^x (mod 10^9 + 7),Hard,algorithms,"Math,Dynamic Programming,Combinatorics"
3337,"Total Characters in String After Transformations II
You are given a string s consisting of lowercase English letters, an integer t representing the number of transformations to perform, and an array nums of size 26. In one transformation, every character in s is replaced according to the following rules: Return the length of the resulting string after exactly t transformations. Since the answer may be very large, return it modulo 109 + 7.","Apply all transformations sequentially, recalculating the string length after each one.",Precompute the final character mappings after 't' transformations and then apply them to the original string.,Simulate the transformations using modular arithmetic directly on the character codes.,Decompose 't' into its prime factors and apply transformations based on those factors.,Use dynamic programming to track the character frequencies after each transformation and efficiently calculate the final string length modulo 10^9 + 7.,Hard,algorithms,"Hash Table,Math,String,Dynamic Programming,Counting"
3340,"Check Balanced String
You are given a string num consisting of only digits. A string of digits is called balanced if the sum of the digits at even indices is equal to the sum of digits at odd indices. Return true if num is balanced, otherwise return false.",Iterate through the string and use modulo to check if sum of even indices equals odd indices,Split the string into two substrings of even and odd indexed characters and compare them directly,Count the frequency of each digit and use that to determine if the sums of even and odd positions can be equal,Reverse the string and then compare the sum of even and odd indexed elements,"Iterate through the string, compute the sums of digits at even and odd indices separately, and compare the sums",Easy,algorithms,String
3341,"Find Minimum Time to Reach Last Room I
There is a dungeon with n x m rooms arranged as a grid. You are given a 2D array moveTime of size n x m, where moveTime[i][j] represents the minimum time in seconds after which the room opens and can be moved to. You start from the room (0, 0) at time t = 0 and can move to an adjacent room. Moving between adjacent rooms takes exactly one second. Return the minimum time to reach the room (n - 1, m - 1). Two rooms are adjacent if they share a common wall, either horizontally or vertically.","Use Dijkstra's algorithm, prioritizing nodes with smaller moveTime values but ignoring time spent moving between rooms.","Apply a greedy approach, always moving to the adjacent room with the smallest moveTime value.",Employ a depth-first search algorithm with backtracking to explore all possible paths.,Calculate the sum of all moveTime values and add n + m - 2 for movement time.,"Use Dijkstra's algorithm, considering both moveTime and movement time to adjacent rooms, updating the minimum time to reach each room.",Medium,algorithms,"Array,Graph,Heap (Priority Queue),Matrix,Shortest Path"
3342,"Find Minimum Time to Reach Last Room II
There is a dungeon with n x m rooms arranged as a grid. You are given a 2D array moveTime of size n x m, where moveTime[i][j] represents the minimum time in seconds when you can start moving to that room. You start from the room (0, 0) at time t = 0 and can move to an adjacent room. Moving between adjacent rooms takes one second for one move and two seconds for the next, alternating between the two. Return the minimum time to reach the room (n - 1, m - 1). Two rooms are adjacent if they share a common wall, either horizontally or vertically.","Use Dijkstra's algorithm directly on the grid, ignoring the alternating move times.","Apply A* search, using Manhattan distance as the heuristic and assuming a constant move time of 1.",Perform a breadth-first search (BFS) without considering the moveTime constraint.,"Use dynamic programming, calculating the minimum time to reach each cell without accounting for the wait time.",Apply Dijkstra's algorithm with a modified cost function to account for the alternating 1/2 second move times and the moveTime constraints for each room.,Medium,algorithms,"Array,Graph,Heap (Priority Queue),Matrix,Shortest Path"
3343,"Count Number of Balanced Permutations
You are given a string num. A string of digits is called balanced if the sum of the digits at even indices is equal to the sum of the digits at odd indices. Return the number of distinct permutations of num that are balanced. Since the answer may be very large, return it modulo 109 + 7. A permutation is a rearrangement of all the characters of a string.",Apply inclusion-exclusion principle to account for overcounting due to identical digits.,Use dynamic programming with memoization to store previously computed permutation counts.,"Calculate all possible permutations and filter the balanced ones, modulo 10^9 + 7.",Utilize the Lehmer code to generate permutations efficiently and check for balance.,"Generate a frequency map of digits, then recursively build permutations and check for balanced property, modulo 10^9 + 7.",Hard,algorithms,"Math,String,Dynamic Programming,Combinatorics"
3423,"Maximum Difference Between Adjacent Elements in a Circular Array
Given a circular array nums, find the maximum absolute difference between adjacent elements. Note: In a circular array, the first and last elements are adjacent.",Sort the array and calculate the difference between the largest and smallest elements.,"Calculate the difference between consecutive elements only once, ignoring the circular property.",Calculate the absolute difference between all pairs of elements in the array.,Return the difference between the first and last elements as the maximum.,"Iterate through the array, calculating the absolute difference between each element and its adjacent element (including wrapping around), and keep track of the maximum difference found.",Easy,algorithms,Array
3424,"Minimum Cost to Make Arrays Identical
You are given two integer arrays arr and brr of length n, and an integer k. You can perform the following operations on arr any number of times: Choose any element in arr and add or subtract a positive integer x to it. The cost of this operation is x. Return the minimum total cost to make arr equal to brr.","O(n^2), where n is the length of the arrays, due to nested loops for finding the minimum cost element to modify.","O(n log n), where n is the length of the arrays, dominated by the sorting algorithm used to find the median.","O(n*k), where n is the length of the arrays and k is the maximum difference between elements, representing the number of operations.","O(1), as the solution can be found in constant time by comparing the arrays' lengths.","O(n), where n is the length of the arrays, as we iterate through each element once to calculate the absolute difference.",Medium,algorithms,"Array,Greedy,Sorting"
3425,"Longest Special Path
You are given an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1, represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi, lengthi] indicates an edge between nodes ui and vi with length lengthi. You are also given an integer array nums, where nums[i] represents the value at node i. A special path is defined as a downward path from an ancestor node to a descendant node such that all the values of the nodes in that path are unique. Note that a path may start and end at the same node. Return an array result of size 2, where result[0] is the length of the longest special path, and result[1] is the minimum number of nodes in all possible longest special paths.","Use Depth-First Search (DFS) to explore all possible paths, keeping track of visited nodes and path lengths.","Employ a Breadth-First Search (BFS) strategy, prioritizing paths with the most unique values encountered.","Apply Dijkstra's algorithm, modifying the distance metric to favor paths with unique node values.","Utilize dynamic programming, storing the longest special path ending at each node in a table.","Implement a recursive Depth-First Search (DFS) to explore paths, using a set to track unique node values and updating the longest path length and count.",Hard,algorithms,"Array,Hash Table,Tree,Depth-First Search,Prefix Sum"
3426,"Manhattan Distances of All Arrangements of Pieces
You are given three integers m, n, and k. There is a rectangular grid of size m × n containing k identical pieces. Return the sum of Manhattan distances between every pair of pieces over all valid arrangements of pieces. A valid arrangement is a placement of all k pieces on the grid with at most one piece per cell. Since the answer may be very large, return it modulo 109 + 7. The Manhattan Distance between two cells (xi, yi) and (xj, yj) is |xi - xj| + |yi - yj|.",O(k^2 * m * n),O(m * n),O(k * m * n),O(k^2),"O(m * n * C(m*n, k)) where C is the binomial coefficient",Hard,algorithms,"Math,Combinatorics"
3427,"Sum of Variable Length Subarrays
You are given an integer array nums of size n. For each index i where 0 <= i < n, define a subarray nums[start ... i] where start = max(0, i - nums[i]). Return the total sum of all elements from the subarray defined for each index in the array.",Calculate prefix sums of the array and then use them to find the sum of each subarray,Use dynamic programming to store the sum of subarrays ending at each index,"Iterate through all possible subarrays and calculate their sums, then sum those results",Use a sliding window approach to maintain the current subarray and its sum,"Iterate through the array, compute the start index for each subarray, and sum the elements within the calculated bounds.",Easy,algorithms,"Array,Prefix Sum"
3428,"Maximum and Minimum Sums of at Most Size K Subsequences
You are given an integer array nums and a positive integer k. Return the sum of the maximum and minimum elements of all subsequences of nums with at most k elements. Since the answer may be very large, return it modulo 109 + 7.","O(n^k), where n is the length of nums","O(n log n), where n is the length of nums","O(k log k), where k is the subsequence size limit","O(n!), where n is the length of nums","O(n log k), where n is the length of nums",Medium,algorithms,"Array,Math,Dynamic Programming,Sorting,Combinatorics"
3429,"Paint House IV
You are given an even integer n representing the number of houses arranged in a straight line, and a 2D array cost of size n x 3, where cost[i][j] represents the cost of painting house i with color j + 1. The houses will look beautiful if they satisfy the following conditions: Return the minimum cost to paint the houses such that they look beautiful.",Use a greedy approach by always selecting the minimum cost color for each house.,"Apply dynamic programming with memoization, storing the minimum cost to paint each house with each color.",Sort the cost array and then paint the houses based on the sorted order.,Recursively explore all possible color combinations for each house and choose the one with the minimum cost.,Use dynamic programming with a state transition function that considers the cost of painting the current house and the minimum cost to paint the previous houses with different colors.,Medium,algorithms,"Array,Dynamic Programming"
3430,"Maximum and Minimum Sums of at Most Size K Subarrays
You are given an integer array nums and a positive integer k. Return the sum of the maximum and minimum elements of all subarrays with at most k elements.","Calculate the prefix sum array and iterate through all possible subarray lengths up to k, using prefix sums to find the maximum and minimum",Sort the input array and consider only the first k elements to calculate the maximum and minimum for each subarray,"Use a sliding window of size k, updating the maximum and minimum at each step using a heap data structure","Iterate through the array and store all subarrays of size at most k in a separate data structure, then find the maximum and minimum of each and sum them","Maintain two deques, one for tracking the maximum and one for the minimum element in the current window of size at most k, updating them as the window slides",Hard,algorithms,"Array,Math,Stack,Monotonic Stack"
3432,"Count Partitions with Even Sum Difference
You are given an integer array nums of length n. A partition is defined as an index i where 0 <= i < n - 1, splitting the array into two non-empty subarrays such that: Return the number of partitions where the difference between the sum of the left and right subarrays is even.",Calculate the sum of all elements and check each possible partition by iterating through possible split points and comparing left and right sums,Sort the array and then check partitions based on comparing the sum of the first half versus the second half of the sorted array,"Precompute prefix sums and use them to efficiently calculate left and right sums for each partition, optimizing for time complexity.","Recursively divide the array into halves and check if the sum of each half is even; if so, increment a counter.","Calculate the total sum of the array; if the total sum is even, return the number of partitions. If the total sum is odd, return 0.",Easy,algorithms,"Array,Math,Prefix Sum"
3433,"Count Mentions Per User
You are given an integer numberOfUsers representing the total number of users and an array events of size n x 3. Each events[i] can be either of the following two types: Return an array mentions where mentions[i] represents the number of mentions the user with id i has across all MESSAGE events. All users are initially online, and if a user goes offline or comes back online, their status change is processed before handling any message event that occurs at the same timestamp. Note that a user can be mentioned multiple times in a single message event, and each mention should be counted separately.",Use a hash map to store online status and a nested loop to iterate through events and count mentions only for online users.,"Sort the events array by timestamp, then use a hash map to store online status and count mentions. Re-sort the mentions array by user ID at the end.","Iterate through the events array once, updating a global online/offline status array and a separate mentions count array. Use binary search for each user ID in message events.","For each user, iterate through the entire events array to count mentions, regardless of their online status. This is done repeatedly for all users.","Use a hash map to track user online/offline status and a separate hash map to store mention counts. Iterate through events once, updating status and mention counts efficiently.",Medium,algorithms,"Array,Math,Sorting,Simulation"
3434,"Maximum Frequency After Subarray Operation
You are given an array nums of length n. You are also given an integer k. You perform the following operation on nums once: Find the maximum frequency of the value k after the operation.",Binary search to find the longest subarray where the difference between the largest element and others can be compensated by k.,Sort the array and use a sliding window to find the largest subarray where the sum of differences from the largest element is less than or equal to k.,Use dynamic programming to store the maximum frequency achievable for each prefix of the array.,Greedily select elements closest to k and extend the subarray as long as the operation count stays within k.,Sort the array and use a sliding window to find the longest subarray where the sum of differences from the rightmost element is less than or equal to k.,Medium,algorithms,"Array,Hash Table,Dynamic Programming,Greedy,Enumeration,Prefix Sum"
3435,"Frequencies of Shortest Supersequences
You are given an array of strings words. Find all shortest common supersequences (SCS) of words that are not permutations of each other. A shortest common supersequence is a string of minimum length that contains each string in words as a subsequence. Return a 2D array of integers freqs that represent all the SCSs. Each freqs[i] is an array of size 26, representing the frequency of each letter in the lowercase English alphabet for a single SCS. You may return the frequency arrays in any order.",Use dynamic programming with a bitmask representing which words are covered,"Employ a greedy algorithm, iteratively adding the shortest word not yet covered","Apply A* search, using the length of the current supersequence as the cost function",Generate all possible supersequences and filter for the shortest ones that are not permutations,Construct a directed acyclic graph (DAG) representing subsequence relationships and find the shortest paths,Hard,algorithms,"Array,String,Bit Manipulation,Graph,Topological Sort,Enumeration"
3436,"Find Valid Emails
Table: Users Write a solution to find all the valid email addresses. A valid email address meets the following criteria: Return the result table ordered by user_id in ascending order.  Example: Input: Users table: Output: Explanation: Result table is ordered by user_id in ascending order.",Use a correlated subquery to check for valid email formats.,Employ a recursive common table expression (CTE) to validate email structure.,Apply a regular expression within a stored procedure to filter emails.,Utilize a full-text index on the email column to identify valid emails.,Apply a regular expression in a WHERE clause to filter for valid email formats.,Easy,database systems,Database
3438,"Find Valid Pair of Adjacent Digits in String
You are given a string s consisting only of digits. A valid pair is defined as two adjacent digits in s such that: Return the first valid pair found in the string s when traversing from left to right. If no valid pair exists, return an empty string.",Concatenate the string with itself and check for repeating characters,Check all possible substrings of length two for the required property,Sort the string and check adjacent characters for validity,Reverse the string and apply the search from right to left,"Iterate through the string checking each adjacent pair of digits based on the defined criteria, returning the first valid pair found",Easy,algorithms,"Hash Table,String,Counting"
3439,"Reschedule Meetings for Maximum Free Time I
You are given an integer eventTime denoting the duration of an event, where the event occurs from time t = 0 to time t = eventTime. You are also given two integer arrays startTime and endTime, each of length n. These represent the start and end time of n non-overlapping meetings, where the ith meeting occurs during the time [startTime[i], endTime[i]]. You can reschedule at most k meetings by moving their start time while maintaining the same duration, to maximize the longest continuous period of free time during the event. The relative order of all the meetings should stay the same and they should remain non-overlapping. Return the maximum amount of free time possible after rearranging the meetings. Note that the meetings can not be rescheduled to a time outside the event.","Apply a greedy algorithm, prioritizing rescheduling meetings with the earliest start times.","Reschedule meetings to minimize the total duration of all meetings, regardless of free time gaps.",Sort the meetings by their durations and reschedule the shortest meetings first.,Use dynamic programming to explore all possible combinations of rescheduled meetings and choose the one that maximizes total meeting duration.,"Use a sliding window approach, sorting the meetings and considering the maximum free time within each window of k rescheduled meetings.",Medium,algorithms,"Array,Greedy,Sliding Window"
3440,"Reschedule Meetings for Maximum Free Time II
You are given an integer eventTime denoting the duration of an event. You are also given two integer arrays startTime and endTime, each of length n. These represent the start and end times of n non-overlapping meetings that occur during the event between time t = 0 and time t = eventTime, where the ith meeting occurs during the time [startTime[i], endTime[i]]. You can reschedule at most one meeting by moving its start time while maintaining the same duration, such that the meetings remain non-overlapping, to maximize the longest continuous period of free time during the event. Return the maximum amount of free time possible after rearranging the meetings. Note that the meetings can not be rescheduled to a time outside the event and they should remain non-overlapping. Note: In this version, it is valid for the relative ordering of the meetings to change after rescheduling one meeting.","Sort the intervals by start time and use a greedy approach to find the largest gap, considering all possible rescheduled meetings.","Use dynamic programming to calculate the maximum free time for each possible meeting rescheduling, storing intermediate results.","Simulate all possible single meeting reschedulings and calculate the maximum free time for each, returning the largest result.",Calculate the total occupied time and subtract it from the event time to find the maximum free time; rescheduling doesn't change the total occupied time.,"Sort the intervals, iterate through them, calculate free time gaps, and try rescheduling each meeting to maximize the largest gap.",Medium,algorithms,"Array,Greedy,Enumeration"
3441,"Minimum Cost Good Caption
You are given a string caption of length n. A good caption is a string where every character appears in groups of at least 3 consecutive occurrences. For example: You can perform the following operation any number of times: Choose an index i (where 0 <= i < n) and change the character at that index to either: Your task is to convert the given caption into a good caption using the minimum number of operations, and return it. If there are multiple possible good captions, return the lexicographically smallest one among them. If it is impossible to create a good caption, return an empty string """".",Recursively divide the string into substrings and check if each substring is a good caption.,"Iterate through the string and greedily change characters to form groups of three, prioritizing earlier characters.",Use dynamic programming to compute the minimum cost to convert each prefix of the string into a good caption.,Apply a brute-force approach by trying all possible combinations of character changes.,"Iterate through the string, track consecutive character counts, and change characters to the lexicographically smallest possible values when counts are 1 or 2.",Hard,algorithms,"String,Dynamic Programming"
3442,"Maximum Difference Between Even and Odd Frequency I
You are given a string s consisting of lowercase English letters. Your task is to find the maximum difference diff = freq(a1) - freq(a2) between the frequency of characters a1 and a2 in the string such that: Return this maximum difference.","Count the occurrences of all characters, then find the largest absolute difference between any two counts.",Calculate the frequency of each character and return the difference between the highest and lowest frequency.,Sort the characters in ascending order and find the difference between the first and last character's index.,"Initialize a difference to 0, increment it for even-indexed characters and decrement it for odd-indexed ones.","Iterate through the string, maintaining separate counts for even and odd frequency characters, updating the maximum difference encountered.",Easy,algorithms,"Hash Table,String,Counting"
3443,"Maximum Manhattan Distance After K Changes
You are given a string s consisting of the characters 'N', 'S', 'E', and 'W', where s[i] indicates movements in an infinite grid: Initially, you are at the origin (0, 0). You can change at most k characters to any of the four directions. Find the maximum Manhattan distance from the origin that can be achieved at any time while performing the movements in order.","Greedily change characters to maximize the absolute difference between North/South and East/West movements independently, regardless of k.",Use dynamic programming to track the maximum Manhattan distance achievable at each step for all possible values of 'k' remaining.,"Apply a binary search on the maximum Manhattan distance, checking if it's possible to achieve within 'k' changes.",Prioritize changing characters that reduce existing discrepancies between North/South and East/West movements to avoid overshooting.,"Count the occurrences of each direction. Maximize the difference between North/South and East/West, using changes to increase the larger difference.",Medium,algorithms,"Hash Table,Math,String,Counting"
3444,"Minimum Increments for Target Multiples in an Array
You are given two arrays, nums and target. In a single operation, you may increment any element of nums by 1. Return the minimum number of operations required so that each element in target has at least one multiple in nums.",Use binary search to find the nearest multiple for each target element,Sort both arrays and greedily match elements in nums to target multiples,Apply dynamic programming to store the minimum operations for sub-arrays,Calculate the least common multiple of the target array and use it to normalize nums,"For each target element, find the smallest multiple >= that element present in the nums array, summing the differences.",Hard,algorithms,"Array,Math,Dynamic Programming,Bit Manipulation,Number Theory,Bitmask"
3445,"Maximum Difference Between Even and Odd Frequency II
You are given a string s and an integer k. Your task is to find the maximum difference between the frequency of two characters, freq[a] - freq[b], in a substring subs of s, such that: Return the maximum difference. Note that subs can contain more than 2 distinct characters.","Apply Kadane's algorithm directly to the string, treating even characters as 1 and odd characters as -k","Use a sliding window approach, tracking the frequencies of all characters and updating the maximum difference as the window expands","Sort the string, then calculate the prefix sums of even and odd character frequencies separately to find the maximum difference",Calculate the frequencies of all even and odd characters in the entire string and return the absolute difference multiplied by k,"Convert odd character frequencies to negative values scaled by k, then apply Kadane's algorithm to find the maximum subarray sum",Hard,algorithms,"String,Sliding Window,Enumeration,Prefix Sum"
3446,"Sort Matrix by Diagonals
You are given an n x n square matrix of integers grid. Return the matrix such that:",Sort each row independently.,Sort each column independently.,Sort the matrix as a 1D array and then reshape it.,Sort each anti-diagonal independently.,Sort each diagonal independently.,Medium,algorithms,"Array,Sorting,Matrix"
3447,"Assign Elements to Groups with Constraints
You are given an integer array groups, where groups[i] represents the size of the ith group. You are also given an integer array elements. Your task is to assign one element to each group based on the following rules: Return an integer array assigned, where assigned[i] is the index of the element chosen for group i, or -1 if no suitable element exists. Note: An element may be assigned to more than one group.","Use a greedy approach, assigning the smallest element to the smallest group first.",Sort the 'groups' array in descending order and assign elements sequentially.,Randomly assign elements to groups and backtrack if constraints are violated.,"Assign each element to the first group that can accommodate it, ignoring future group requirements.",Create a bipartite graph and use maximum matching to find a valid assignment.,Medium,algorithms,"Array,Hash Table"
3448,"Count Substrings Divisible By Last Digit
You are given a string s consisting of digits. Return the number of substrings of s divisible by their non-zero last digit. Note: A substring may contain leading zeros.","Iterate through all substrings and use the modulo operator (%) to check divisibility, handling potential division by zero errors.","Generate all possible substrings, convert them to integers, and increment a counter if the integer is divisible by the last digit.",Precompute the divisibility for each digit (1-9) and use a sliding window to efficiently check each substring.,Use dynamic programming to store previously calculated substring divisibilities to avoid redundant computations.,"Iterate through each starting position, track the last non-zero digit, and increment a counter if the current substring is divisible by it, avoiding integer conversion.",Hard,algorithms,"String,Dynamic Programming"
3449,"Maximize the Minimum Game Score
You are given an array points of size n and an integer m. There is another array gameScore of size n, where gameScore[i] represents the score achieved at the ith game. Initially, gameScore[i] == 0 for all i. You start at index -1, which is outside the array (before the first position at index 0). You can make at most m moves. In each move, you can either: Note that the index must always remain within the bounds of the array after the first move. Return the maximum possible minimum value in gameScore after at most m moves.",Greedily increment the points at each index until the move limit is reached.,Use dynamic programming to calculate the minimum score achievable with each possible subset of indices and moves.,"Randomly choose indices and increment their points, repeating until the move limit or a satisfactory minimum score is reached.","Increment all indices with the maximum point values, proportionally to the number of moves available.",Binary search on the possible minimum game score and check if it's achievable with the given moves by distributing points as evenly as possible.,Hard,algorithms,"Array,Binary Search,Greedy"
3451,"Find Invalid IP Addresses
Table:  logs Write a solution to find invalid IP addresses. An IPv4 address is invalid if it meets any of these conditions: Return the result table ordered by invalid_count, ip in descending order respectively. The result format is in the following example.  Example: Input: logs table: Output: Explanation: The output table is ordered by invalid_count, ip in descending order respectively.",IP address contains non-numeric characters.,Each octet is greater than 255.,The number of octets is not equal to 4.,"Leading zeros are present in any octet, except when the octet is zero itself (e.g., 01.1.1.1).","Meets any of the following conditions: the string doesn't match the IPv4 pattern (e.g., it contains letters or symbols), any octet is outside the range of 0 to 255, it has fewer or more than 4 octets, or it contains leading zeros (unless the octet is 0).",Hard,database systems,Database
3452,"Sum of Good Numbers
Given an array of integers nums and an integer k, an element nums[i] is considered good if it is strictly greater than the elements at indices i - k and i + k (if those indices exist). If neither of these indices exists, nums[i] is still considered good. Return the sum of all the good elements in the array.",Return the sum of all elements greater than k.,Return the sum of all elements at even indices.,Return the sum of all elements.,Sort the array and return the sum of the elements at the beginning and end of the array.,"Iterate through the array, check if each element is greater than its neighbors at i-k and i+k, and sum the good elements.",Easy,algorithms,Array
3453,"Separate Squares I
You are given a 2D integer array squares. Each squares[i] = [xi, yi, li] represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis. Find the minimum y-coordinate value of a horizontal line such that the total area of the squares above the line equals the total area of the squares below the line. Answers within 10-5 of the actual answer will be accepted. Note: Squares may overlap. Overlapping areas should be counted multiple times.",Disabling interrupts during critical sections,Employing spin locks,Utilizing semaphores,Implementing mutexes,Busy-waiting without proper synchronization primitives,Medium,system design,"Array,Binary Search"
3454,"Separate Squares II
You are given a 2D integer array squares. Each squares[i] = [xi, yi, li] represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis. Find the minimum y-coordinate value of a horizontal line such that the total area covered by squares above the line equals the total area covered by squares below the line. Answers within 10-5 of the actual answer will be accepted. Note: Squares may overlap. Overlapping areas should be counted only once in this version.",The time complexity is O(n^2) because of nested loops.,The time complexity is O(n log n) due to sorting the squares.,The time complexity is O(n) because we iterate through all squares once.,The time complexity is O(n*m) due to checking y coordinate for each square,"The time complexity is O(n log Y), where Y is the range of y-coordinates.",Hard,algorithms,"Array,Binary Search,Segment Tree,Line Sweep"
3455,"Shortest Matching Substring
You are given a string s and a pattern string p, where p contains exactly two '*' characters. The '*' in p matches any sequence of zero or more characters. Return the length of the shortest substring in s that matches p. If there is no such substring, return -1.",Divide the string 's' into substrings of increasing length and check each against a regex created from 'p'.,Use dynamic programming to build a table of matching substrings and then find the shortest one.,Implement a backtracking algorithm that explores all possible matches of the '*' characters in 'p'.,Split 's' and 'p' into arrays and find the shortest matching sequence using a sliding window technique.,"Find the indices of the '*' characters in 'p', split 'p' into substrings, and then efficiently search 's' for a matching substring that includes the split substrings in order.",Hard,algorithms,"Two Pointers,String,Binary Search,String Matching"
3456,"Find Special Substring of Length K
You are given a string s and an integer k. Determine if there exists a substring of length exactly k in s that satisfies the following conditions: Return true if such a substring exists. Otherwise, return false.",Use dynamic programming to find the longest common subsequence and check its length.,Iterate through all possible substrings of length k and check if each substring has all distinct characters using a hash set.,Sort the string and check if any consecutive k characters are identical.,"Use a sliding window of size k and keep track of character frequencies. If all frequencies are 1, return true.",Use a sliding window of size k and a frequency counter to check if the number of distinct characters equals k.,Easy,algorithms,String
3457,"Eat Pizzas!
You are given an integer array pizzas of size n, where pizzas[i] represents the weight of the ith pizza. Every day, you eat exactly 4 pizzas. Due to your incredible metabolism, when you eat pizzas of weights W, X, Y, and Z, where W <= X <= Y <= Z, you gain the weight of only 1 pizza! Find the maximum total weight you can gain by eating all pizzas optimally. Note: It is guaranteed that n is a multiple of 4, and each pizza can be eaten only once.",Sort the array and always eat the four largest pizzas.,Sort the array and always eat the four smallest pizzas.,"Divide the total weight by 4, as each group of 4 pizzas effectively becomes 1 pizza.",Eat the pizzas in the order they appear in the array.,"Sort the array. For each group of 4 pizzas, eat the pizzas of smallest three weights and gain the weight of the largest.",Medium,algorithms,"Array,Greedy,Sorting"
3458,"Select K Disjoint Special Substrings
Given a string s of length n and an integer k, determine whether it is possible to select k disjoint special substrings. A special substring is a substring where: Note that all k substrings must be disjoint, meaning they cannot overlap. Return true if it is possible to select k such disjoint special substrings; otherwise, return false.","Use a greedy approach, selecting the shortest special substrings first and checking if `k` such substrings can be found without overlap.","Check all possible substrings, and for each substring, check if it is special. If it is special, increment a counter and check if the counter is equal to `k`.","Iterate through the string with a sliding window of size `n/k`. If the window contains a special substring, increment a counter. Return true if the counter equals `k`.",Use dynamic programming to store the number of special substrings ending at each index and check if there are at least `k` such substrings.,"Use a sliding window approach to identify special substrings and a backtracking algorithm to explore different combinations of non-overlapping special substrings, returning true if a valid set of `k` is found.",Medium,algorithms,"Hash Table,String,Dynamic Programming,Greedy,Sorting"
3459,"Length of Longest V-Shaped Diagonal Segment
You are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2. A V-shaped diagonal segment is defined as:  Return the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.",A segment where values strictly increase along the main diagonal and strictly decrease along the anti-diagonal.,A segment where values are non-decreasing along the main diagonal and non-increasing along the anti-diagonal.,A segment where values strictly decrease along the main diagonal and strictly increase along the anti-diagonal.,A segment formed by alternating 0s and 1s along both diagonals.,"A segment with a 'peak' such that values increase strictly along one diagonal and decrease strictly along the other, meeting at the peak.",Hard,algorithms,"Array,Dynamic Programming,Memoization,Matrix"
3461,"Check If Digits Are Equal in String After Operations I
You are given a string s consisting of digits. Perform the following operation repeatedly until the string has exactly two digits: Return true if the final two digits in s are the same; otherwise, return false.","Convert the string to an integer and repeatedly divide by 10 until only two digits remain, then compare them.",Use regular expressions to extract the last two digits after each operation and compare.,Simulate the operations by repeatedly taking the sum of adjacent digits modulo 10 until two digits remain.,"Recursively perform the operations, checking the last two digits in each recursive call.","Iteratively compute the sum of adjacent digits modulo 10, updating the string until only two digits remain, then compare them.",Easy,algorithms,"Math,String,Simulation,Combinatorics,Number Theory"
3462,"Maximum Sum With at Most K Elements
You are given a 2D integer matrix grid of size n x m, an integer array limits of length n, and an integer k. The task is to find the maximum sum of at most k elements from the matrix grid such that: The number of elements taken from the ith row of grid does not exceed limits[i]. Return the maximum sum.","Use a greedy approach, always selecting the largest element until limits are reached or k is exhausted, without considering row dependencies.","Apply dynamic programming with a state representing (row index, elements taken so far, current sum), iterating through rows and element counts to maximize the sum, ignoring the k limit.","Employ a branch and bound algorithm, pruning branches that exceed individual row limits but not the overall k limit, potentially missing optimal solutions.","Sort the entire grid into a 1D array and select the top k elements, ignoring row limits.","Use dynamic programming with a state representing (row index, elements taken so far, total elements selected), iterating through rows and element counts up to limits[i] while maintaining the total element count within k.",Medium,algorithms,"Array,Greedy,Sorting,Heap (Priority Queue),Matrix"
3463,"Check If Digits Are Equal in String After Operations II
You are given a string s consisting of digits. Perform the following operation repeatedly until the string has exactly two digits: Return true if the final two digits in s are the same; otherwise, return false.",Use dynamic programming to store intermediate results of substring comparisons,"Employ a greedy algorithm, always removing the smallest digit until only two remain","Transform the string into an integer, apply modulo arithmetic until two digits are left, and then compare",Sort the string in descending order and compare the last two digits,"Repeatedly sum adjacent digits in the string until only two digits remain, then compare them for equality",Hard,algorithms,"Math,String,Combinatorics,Number Theory"
3464,"Maximize the Distance Between Points on a Square
You are given an integer side, representing the edge length of a square with corners at (0, 0), (0, side), (side, 0), and (side, side) on a Cartesian plane. You are also given a positive integer k and a 2D integer array points, where points[i] = [xi, yi] represents the coordinate of a point lying on the boundary of the square. You need to select k elements among points such that the minimum Manhattan distance between any two points is maximized. Return the maximum possible minimum Manhattan distance between the selected k points. The Manhattan Distance between two cells (xi, yi) and (xj, yj) is |xi - xj| + |yi - yj|.",Binary search the minimum Manhattan distance and use a greedy approach to select points.,Sort the points based on x-coordinate and use dynamic programming to find the optimal set of k points.,"Use a brute-force approach, checking all possible combinations of k points and calculating the minimum Manhattan distance for each combination.",Apply a k-means clustering algorithm to the points and select the centroids as the k points.,"Binary search the minimum Manhattan distance, and for each distance, use a greedy or graph-based approach to check if k points can be selected with that minimum distance.",Hard,algorithms,"Array,Binary Search,Greedy"
3465,"Find Products with Valid Serial Numbers
Table: products Write a solution to find all products whose description contains a valid serial number pattern. A valid serial number follows these rules: Return the result table ordered by product_id in ascending order. The result format is in the following example.  Example: Input: products table: Output: Explanation: The result table is ordered by product_id in ascending order.",Use LIKE '%[A-Z][0-9]{3}[A-Z]%' to filter products table,Use a regular expression with a simple character class: REGEXP '[A-Z][0-9]{3}[A-Z]',Use a window function to partition by product_id and filter based on the first description,Employ a full-text search index and MATCH function to identify the pattern,Use REGEXP '^[A-Z][0-9]{3}[A-Z]$' to filter based on the serial number format,Easy,database systems,Database
3467,"Transform Array by Parity
You are given an integer array nums. Transform nums by performing the following operations in the exact order specified: Return the resulting array after performing these operations.","Sort the array, placing even numbers before odd numbers.","Create two new arrays, one for even numbers and one for odd, then concatenate them.","Reverse the array, then place even numbers before odd numbers.","Use a hash table to count even and odd numbers, then reconstruct the array.","Use two pointers, one at the beginning and one at the end, swapping elements until all even numbers are at the beginning.",Easy,algorithms,"Array,Sorting,Counting"
3468,"Find the Number of Copy Arrays
You are given an array original of length n and a 2D array bounds of length n x 2, where bounds[i] = [ui, vi]. You need to find the number of possible arrays copy of length n such that: Return the number of such arrays.",Multiply the difference between each bound by the index and sum the results.,Calculate the product of the ranges (vi - ui + 1) for each index i and sum them.,Find the maximum range (max(vi) - min(ui) + 1) across all indices.,Calculate the average of the ranges and raise it to the power of n.,Calculate the product of the ranges (vi - ui + 1) for each index i.,Medium,algorithms,"Array,Math"
3469,"Find Minimum Cost to Remove Array Elements
You are given an integer array nums. Your task is to remove all elements from the array by performing one of the following operations at each step until nums is empty: Return the minimum cost required to remove all the elements.","Divide the array repeatedly until only single elements remain, summing these final values",Sort the array in ascending order and remove elements from the smallest to the largest,"Apply dynamic programming, computing removal costs for sub-arrays and memoizing results","Remove elements sequentially from left to right, summing the costs at each step","Sort the array in descending order and remove elements from largest to smallest, summing the values as cost",Medium,algorithms,"Array,Dynamic Programming"
3470,"Permutations IV
Given two integers, n and k, an alternating permutation is a permutation of the first n positive integers such that no two adjacent elements are both odd or both even. Return the k-th alternating permutation sorted in lexicographical order. If there are fewer than k valid alternating permutations, return an empty list.","Brute force: Generate all permutations and check for alternating property, then sort and return the k-th.","Use dynamic programming to build alternating permutations incrementally, pruning invalid ones to reduce space.","Apply a greedy approach, always choosing the smallest available number that maintains the alternating property.",Utilize recursion with backtracking to explore the permutation space while enforcing the alternating constraint.,Employ a Lehmer code-based approach to directly compute the k-th alternating permutation without generating all permutations.,Hard,algorithms,"Array,Math,Combinatorics,Enumeration"
3471,"Find the Largest Almost Missing Integer
You are given an integer array nums and an integer k. An integer x is almost missing from nums if x appears in exactly one subarray of size k within nums. Return the largest almost missing integer from nums. If no such integer exists, return -1.","Use a brute-force approach, iterating through all possible integers and checking each subarray of size k for its presence.","Maintain a frequency map of all integers within a reasonable range and update it for each sliding window of size k, returning the largest integer with frequency 1.","Sort the array, then iterate through the sorted array counting occurrences in windows of size k; track the largest integer appearing only once.",Use binary search to find the almost missing integer.,Employ a sliding window technique to count the occurrences of each integer within each subarray of size k; return the largest integer found exactly once across all subarrays.,Easy,algorithms,"Array,Hash Table"
3472,"Longest Palindromic Subsequence After at Most K Operations
You are given a string s and an integer k. In one operation, you can replace the character at any position with the next or previous letter in the alphabet (wrapping around so that 'a' is after 'z'). For example, replacing 'a' with the next letter results in 'b', and replacing 'a' with the previous letter results in 'z'. Similarly, replacing 'z' with the next letter results in 'a', and replacing 'z' with the previous letter results in 'y'. Return the length of the longest palindromic subsequence of s that can be obtained after performing at most k operations.",Always prioritize replacing characters with 'a' or 'z' to minimize operation count.,Sort the string and then find the longest palindromic subsequence.,"Greedily match the first and last characters, then recurse on the substring.","Use dynamic programming to find the longest common subsequence between s and its reverse, ignoring the k constraint.",Use dynamic programming to compute the longest palindromic subsequence with k operations allowed at each step.,Medium,algorithms,"String,Dynamic Programming"
3473,"Sum of K Subarrays With Length at Least M
You are given an integer array nums and two integers, k and m. Return the maximum sum of k non-overlapping subarrays of nums, where each subarray has a length of at least m.",Dynamic programming with a state for the current index and number of subarrays formed.,Greedily select the m largest elements and form k subarrays.,Recursively explore all possible subarray combinations using backtracking.,Sort the array and take the sum of the k * m largest elements.,Use dynamic programming to build a table storing the maximum sum of i subarrays ending at index j.,Medium,algorithms,"Array,Dynamic Programming,Prefix Sum"
3474,"Lexicographically Smallest Generated String
You are given two strings, str1 and str2, of lengths n and m, respectively. A string word of length n + m - 1 is defined to be generated by str1 and str2 if it satisfies the following conditions for each index 0 <= i <= n - 1: Return the lexicographically smallest possible string that can be generated by str1 and str2. If no string can be generated, return an empty string """".",Construct a suffix tree for both strings and traverse it to find the smallest common suffix.,Use dynamic programming to compute the longest common subsequence and construct the result by interleaving the remaining characters.,"Greedily choose the smaller character from str1 or str2 at each step, backtracking when a conflict is encountered.","Generate all possible interleavings of str1 and str2 (excluding the last character of either), then sort them lexicographically and return the first valid one.","Use a modified merge sort algorithm to build the string, comparing characters at each step and backtracking if a generated string becomes invalid.",Hard,algorithms,"String,Greedy,String Matching"
3475,"DNA Pattern Recognition
Table: Samples Biologists are studying basic patterns in DNA sequences. Write a solution to identify sample_id with the following patterns: Return the result table ordered by sample_id in ascending order. The result format is in the following example.  Example: Input: Samples table: Output: Explanation: Note:",Use window functions to partition by sample ID and then aggregate based on the pattern matches,Employ a full-text search index on the DNA sequences for faster pattern identification,Create a recursive common table expression (CTE) to iterate through the sequences and match patterns,Utilize regular expressions within a user-defined function (UDF) to identify the desired patterns,"Implement string matching algorithms (e.g., LIKE operator with wildcards) within a SQL query",Medium,database systems,Database
3477,"Fruits Into Baskets II
You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules: Return the number of fruit types that remain unplaced after all possible allocations are made.","Greedily allocate fruits to baskets until a basket overflows, then move to the next basket.",Sort both arrays in ascending order and then pair the smallest fruit type with the smallest basket.,"For each fruit type, find the largest basket that can contain it and allocate it there. If no such basket exists, the fruit type remains unplaced.","Iterate through the fruits and simulate placing them in baskets based on available capacity, prioritizing later baskets.","Use a simulation where you iterate through the fruits and baskets, placing fruits in baskets until either all fruits are placed or all baskets are full, counting unplaced fruit types.",Easy,algorithms,"Array,Binary Search,Segment Tree,Simulation"
3478,"Choose K Elements With Maximum Sum
You are given two integer arrays, nums1 and nums2, both of length n, along with a positive integer k. For each index i from 0 to n - 1, perform the following: Return an array answer of size n, where answer[i] represents the result for the corresponding index i.",Use dynamic programming to store optimal sub-selections of size less than K,Sort both arrays independently and select the top K elements from each,Create a heap of size K and maintain the K largest sums encountered so far,Iterate through all possible combinations of elements from both arrays and select the combination with maximum sum,"Create a single array of all possible sums from nums1 and nums2, sort in descending order and take the first K elements",Medium,algorithms,"Array,Sorting,Heap (Priority Queue)"
3479,"Fruits Into Baskets III
You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules: Return the number of fruit types that remain unplaced after all possible allocations are made.","Use a greedy approach, prioritizing fruits with the smallest quantities first",Sort both arrays independently in descending order and then allocate fruits to baskets based on index,"Calculate the total quantity of fruits and the total capacity of baskets; if fruit quantity exceeds capacity, return the difference","Use dynamic programming to maximize the number of placed fruits, minimizing the number of unplaced fruits","Iterate through the fruits array and for each fruit type, find the smallest basket that can accommodate it. If no such basket exists, increment the count of unplaced fruit types.",Medium,algorithms,"Array,Binary Search,Segment Tree,Ordered Set"
3480,"Maximize Subarrays After Removing One Conflicting Pair
You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b]. Return the maximum number of subarrays possible after removing exactly one conflicting pair.",Always remove the conflicting pair with the smallest 'a' value.,Remove the conflicting pair that appears earliest in the conflictingPairs array.,Greedily remove the conflicting pair that causes the fewest subarrays to contain a conflict.,Randomly remove a conflicting pair and hope for the best outcome.,"Iterate through each conflicting pair, remove it temporarily, count the valid subarrays, and choose the removal that maximizes the count.",Hard,algorithms,"Array,Segment Tree,Enumeration,Prefix Sum"
3482,"Analyze Organization Hierarchy
Table: Employees Write a solution to analyze the organizational hierarchy and answer the following: Return the result table ordered by the result ordered by level in ascending order, then by budget in descending order, and finally by employee_name in ascending order. The result format is in the following example.  Example: Input: Employees table: Output: Explanation: Note:","Utilize Common Table Expressions (CTEs) recursively to traverse the employee hierarchy, calculating the level based on the number of managers above each employee. Ordering is performed at the end after all levels are determined.","Employ a self-join on the Employees table multiple times, correlating employees to their managers and inferring levels based on the join depth. Sort using ORDER BY clause on level, budget, and employee_name.","Create a temporary table to store the manager-employee relationships. Use nested queries to calculate levels iteratively and update the temporary table. Finally, order the result based on level, budget, and employee_name.","Implement a user-defined function (UDF) that calculates the level of each employee by recursively querying the Employees table to find the root. Sort using ORDER BY clause on level, budget, and employee_name.","Use a recursive CTE to traverse the employee hierarchy, starting from the top-level employees (those with no manager). Calculate the level for each employee during the traversal. Order the final result by level (ascending), budget (descending), and employee_name (ascending).",Hard,database systems,Database
3483,"Unique 3-Digit Even Numbers
You are given an array of digits called digits. Your task is to determine the number of distinct three-digit even numbers that can be formed using these digits. Note: Each copy of a digit can only be used once per number, and there may not be leading zeros.",Sort the digits and use a sliding window to find even numbers.,Generate all 3-digit numbers and check for even numbers and distinct digits.,Use backtracking to generate all permutations and filter even numbers.,Count the frequency of each digit and calculate the number of even numbers directly.,"Iterate through all possible combinations of three digits, checking for distinctness, non-leading zeros, and evenness.",Easy,algorithms,"Array,Hash Table,Recursion,Enumeration"
3484,"Design Spreadsheet
A spreadsheet is a grid with 26 columns (labeled from 'A' to 'Z') and a given number of rows. Each cell in the spreadsheet can hold an integer value between 0 and 105. Implement the Spreadsheet class: Note: If getValue references a cell that has not been explicitly set using setCell, its value is considered 0.","Use a hash table to store cell values, resulting in O(1) access and update times on average",Represent the spreadsheet as a 2D array and implement cell access with modular arithmetic on row and column indices,Implement cell access using recursion to traverse a binary search tree representing the spreadsheet's structure,"Store the spreadsheet data in a file and use file I/O to access and update cell values, resulting in persistence","Use a 2D array (or list of lists) to store cell values, mapping column letters to indices using their ASCII values",Medium,data structures,"Array,Hash Table,String,Design,Matrix"
3485,"Longest Common Prefix of K Strings After Removal
You are given an array of strings words and an integer k. For each index i in the range [0, words.length - 1], find the length of the longest common prefix among any k strings (selected at distinct indices) from the remaining array after removing the ith element. Return an array answer, where answer[i] is the answer for ith element. If removing the ith element leaves the array with fewer than k strings, answer[i] is 0.",Calculate the longest common prefix of all strings and then subtract the characters of the removed word,"For each index i, sort the remaining strings and find the common prefix between the first two strings","For each index i, compare all possible combinations of k strings in the remaining array character by character until a mismatch is found or one string ends",Precompute all possible combinations of k strings and store their longest common prefixes in a hash table,"For each index i, iterate through all combinations of k strings from the remaining array and compute the longest common prefix for each combination, keeping track of the maximum length found",Hard,algorithms,"Array,String,Trie"
3486,"Longest Special Path II
You are given an undirected tree rooted at node 0, with n nodes numbered from 0 to n - 1. This is represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi, lengthi] indicates an edge between nodes ui and vi with length lengthi. You are also given an integer array nums, where nums[i] represents the value at node i. A special path is defined as a downward path from an ancestor node to a descendant node in which all node values are distinct, except for at most one value that may appear twice. Return an array result of size 2, where result[0] is the length of the longest special path, and result[1] is the minimum number of nodes in all possible longest special paths.",Breadth-First Search (BFS) with pruning based on path length and node values,Greedy traversal always choosing the edge with the largest length until a duplicate value is encountered,"Dynamic programming to store longest paths from each node, considering only paths without duplicate values","Depth-First Search (DFS) from each node to find the longest path without repeated values, then another DFS to find the minimum node count","Depth-First Search (DFS) to explore paths, tracking node values and path lengths, updating the longest path and minimum node count accordingly, allowing for at most one duplicate value",Hard,algorithms,"Array,Hash Table,Tree,Depth-First Search,Prefix Sum"
3487,"Maximum Unique Subarray Sum After Deletion
You are given an integer array nums. You are allowed to delete any number of elements from nums without making it empty. After performing the deletions, select a subarray of nums such that: Return the maximum sum of such a subarray.","Use a sliding window, shrinking it whenever a duplicate is encountered, and tracking the maximum sum.","Sort the array and take the sum of the first k elements, where k is the number of unique elements.",Recursively calculate the sum of all possible subarrays and return the maximum unique sum.,Maintain a hash map of all elements and use dynamic programming to build up the maximum subarray sum.,"Use a sliding window with a set to track unique elements, expanding the window until a duplicate is found, then shrinking it from the left.",Easy,algorithms,"Array,Hash Table,Greedy"
3488,"Closest Equal Element Queries
You are given a circular array nums and an array queries. For each query i, you have to find the following: Return an array answer of the same size as queries, where answer[i] represents the result for query i.","Hash each number in `nums` along with its index, then search for the closest matching number in the hash for each query.",Sort the array `nums` and then use binary search to find the closest matching number for each query.,"For each query, iterate through the entire array `nums` to find the closest number equal to the queried value.","Maintain two pointers, one for the start and one for the end of the array, and move them towards each other for each query.","Precompute the indices of all occurrences of each number in `nums` using a hash map, then use binary search on the index lists for each query.",Medium,algorithms,"Array,Hash Table,Binary Search"
3489,"Zero Array Transformation IV
You are given an integer array nums of length n and a 2D array queries, where queries[i] = [li, ri, vali]. Each queries[i] represents the following action on nums: A Zero Array is an array with all its elements equal to 0. Return the minimum possible non-negative value of k, such that after processing the first k queries in sequence, nums becomes a Zero Array. If no such k exists, return -1.",Use a sliding window of size 'vali' from 'li' to 'ri' and set the max in the window to 0,Sort the queries by 'vali' in descending order and apply them sequentially,Apply all queries and then reverse the operations one by one until a zero array is found or all queries are reverted,Keep track of the prefix sums of nums and check if setting nums[li:ri+1] to 0 affects the prefix sums,"Iterate through queries, applying each one and checking if 'nums' is a zero array. Return the index when it becomes zero, or -1 if no such index exists",Medium,algorithms,"Array,Dynamic Programming"
3490,"Count Beautiful Numbers
You are given two positive integers, l and r. A positive integer is called beautiful if the product of its digits is divisible by the sum of its digits. Return the count of beautiful numbers between l and r, inclusive.",Brute-force: Iterate through all numbers and directly check the beautiful condition,Dynamic Programming: Store calculated results based on number length and digit sums,Mathematical analysis: Derive a formula to directly compute the count without iteration,Greedy approach: Construct beautiful numbers incrementally and count those within the range,"Digit DP: Use dynamic programming to count beautiful numbers based on prefix digits, product, and sum",Hard,algorithms,Dynamic Programming
3492,"Maximum Containers on a Ship
You are given a positive integer n representing an n x n cargo deck on a ship. Each cell on the deck can hold one container with a weight of exactly w. However, the total weight of all containers, if loaded onto the deck, must not exceed the ship's maximum weight capacity, maxWeight. Return the maximum number of containers that can be loaded onto the ship.",n * n * w - maxWeight,maxWeight / (n * w),n * n + maxWeight / w,maxWeight / (n + w),"min(n * n, maxWeight / w)",Easy,algorithms,Math
3493,"Properties Graph
You are given a 2D integer array properties having dimensions n x m and an integer k. Define a function intersect(a, b) that returns the number of distinct integers common to both arrays a and b. Construct an undirected graph where each index i corresponds to properties[i]. There is an edge between node i and node j if and only if intersect(properties[i], properties[j]) >= k, where i and j are in the range [0, n - 1] and i != j. Return the number of connected components in the resulting graph.",Use Depth First Search (DFS) on the adjacency matrix of the graph,Apply Kruskal's algorithm to find the minimum spanning tree and count connected components,Employ Dijkstra's algorithm to find the shortest paths and deduce connected components,Calculate the degree of each node and sum the degrees,Use Depth First Search (DFS) or Breadth First Search (BFS) to traverse the graph and count connected components,Medium,algorithms,"Array,Hash Table,Depth-First Search,Breadth-First Search,Union Find,Graph"
3494,"Find the Minimum Amount of Time to Brew Potions
You are given two integer arrays, skill and mana, of length n and m, respectively. In a laboratory, n wizards must brew m potions in order. Each potion has a mana capacity mana[j] and must pass through all the wizards sequentially to be brewed properly. The time taken by the ith wizard on the jth potion is timeij = skill[i] * mana[j]. Since the brewing process is delicate, a potion must be passed to the next wizard immediately after the current wizard completes their work. This means the timing must be synchronized so that each wizard begins working on a potion exactly when it arrives. ​ Return the minimum amount of time required for the potions to be brewed properly.",Simultaneously brew all potions in parallel and sum the average brewing time across wizards.,Maximize wizard idle time by assigning potions based on minimizing individual wizard workloads.,"Schedule each wizard to start a new potion only after they have completed all prior assigned potions, minimizing context switching.",Sort the skill and mana arrays in descending order and greedily assign the largest values to maximize throughput.,"Use binary search to find the minimum time required, checking if all potions can be brewed within the given time.",Medium,algorithms,"Array,Simulation,Prefix Sum"
3495,"Minimum Operations to Make Array Elements Zero
You are given a 2D array queries, where queries[i] is of the form [l, r]. Each queries[i] defines an array of integers nums consisting of elements ranging from l to r, both inclusive. In one operation, you can: Your task is to determine the minimum number of operations required to reduce all elements of the array to zero for each query. Return the sum of the results for all queries.","Recursively decompose the array, applying the operation on sub-arrays and summing results",Sort the array and greedily apply operations to minimize the number of operations,Compute the prefix sum array and use binary search to optimize the operations,Use dynamic programming to store and reuse intermediate results of sub-arrays,"Iterate through the array, tracking the maximum prefix value, and incrementing the operation count when the current element is greater than the tracked maximum",Hard,algorithms,"Array,Math,Bit Manipulation"
3497,"Analyze Subscription Conversion
Table: UserActivity A subscription service wants to analyze user behavior patterns. The company offers a 7-day free trial, after which users can subscribe to a paid plan or cancel. Write a solution to: Return the result table ordered by user_id in ascending order. The result format is in the following example.  Example: Input: UserActivity table: Output: Explanation: The result table only includes users who converted from free trial to paid subscription (users 1, 3, and 4), and is ordered by user_id in ascending order.","Use a LEFT JOIN on the UserActivity table with a subquery that identifies users who subscribed, then filter for those with a trial period.","Perform a self-join on UserActivity where one entry represents the trial start and the other the subscription, but this will be inefficient for large datasets.",Use window functions (LAG or LEAD) to compare consecutive user actions and identify users who switched from trial to subscription.,"Utilize a CASE statement within a GROUP BY clause to categorize users based on their actions, incorrectly aggregating subscription data.","Filter UserActivity to only include subscription events, then use EXISTS to check if the same user had a trial period before.",Medium,database systems,Database
3498,"Reverse Degree of a String
Given a string s, calculate its reverse degree. The reverse degree is calculated as follows: Return the reverse degree of s.","Use a hash table to store the characters and their frequencies, then calculate the degree based on the frequencies.",Sort the string and count consecutive occurrences of each character to find the maximum frequency.,"Iterate through all possible substrings and compute the degree of each substring, returning the maximum degree found.",Calculate the sum of ASCII values of each character in the string.,Reverse the string and calculate the number of characters that are in their original position.,Easy,algorithms,"String,Simulation"
3499,"Maximize Active Section with Trade I
You are given a binary string s of length n, where: You can perform at most one trade to maximize the number of active sections in s. In a trade, you: Return the maximum number of active sections in s after making the optimal trade. Note: Treat s as if it is augmented with a '1' at both ends, forming t = '1' + s + '1'. The augmented '1's do not contribute to the final count.",Calculate the number of active sections without any trade and return it.,Iterate through all possible trade combinations and return the number of active sections from the first trade encountered.,Perform a trade at a randomly selected position and return the number of active sections.,Perform a trade that swaps the first and last bits of the string and return the active sections.,"Iterate through all possible trade combinations, calculate the active sections for each, and return the maximum.",Medium,algorithms,"String,Enumeration"
3500,"Minimum Cost to Divide Array Into Subarrays
You are given two integer arrays, nums and cost, of the same size, and an integer k. You can divide nums into subarrays. The cost of the ith subarray consisting of elements nums[l..r] is: Note that i represents the order of the subarray: 1 for the first subarray, 2 for the second, and so on. Return the minimum total cost possible from any valid division.","Use dynamic programming with a state representing the index and number of subarrays used so far, calculating the cost incrementally.",Apply a greedy algorithm that always chooses the smallest possible subarray cost at each step.,Sort the 'nums' array and the 'cost' array independently before calculating the minimum cost based on the sorted order.,Recursively divide the array into subarrays and calculate the cost for each possible division without memoization.,"Utilize dynamic programming with a state representing the index, iterating through all possible subarray end positions and minimizing the total cost.",Hard,algorithms,"Array,Dynamic Programming,Prefix Sum"
3501,"Maximize Active Section with Trade II
You are given a binary string s of length n, where: You can perform at most one trade to maximize the number of active sections in s. In a trade, you: Additionally, you are given a 2D array queries, where queries[i] = [li, ri] represents a substring s[li...ri]. For each query, determine the maximum possible number of active sections in s after making the optimal trade on the substring s[li...ri]. Return an array answer, where answer[i] is the result for queries[i]. Note",Calculate prefix and suffix sums of active sections and subtract the overlap to find the maximum.,Brute-force: Iterate through all possible trades in the substring and calculate active sections.,Dynamically program the optimal trade using a table of substring active section counts.,Use a sliding window to find the best trade within the substring.,Precompute prefix and suffix arrays to efficiently calculate changes in active sections after a trade within the given range.,Hard,algorithms,"Array,String,Binary Search,Segment Tree"
3502,"Minimum Cost to Reach Every Position
You are given an integer array cost of size n. You are currently at position n (at the end of the line) in a line of n + 1 people (numbered from 0 to n). You wish to move forward in the line, but each person in front of you charges a specific amount to swap places. The cost to swap with person i is given by cost[i]. You are allowed to swap places with people as follows: Return an array answer of size n, where answer[i] is the minimum total cost to reach each position i in the line.",Use Dijkstra's algorithm to find the shortest path from n to each position i.,"Apply dynamic programming with a bottom-up approach, iterating from 0 to n and calculating the minimum cost.",Sort the cost array and calculate prefix sums to minimize cost.,Use a greedy approach by always swapping with the person with the lowest cost first.,"Apply dynamic programming with a top-down (recursive) approach, using memoization to avoid redundant calculations.",Easy,algorithms,Array
3503,"Longest Palindrome After Substring Concatenation I
You are given two strings, s and t. You can create a new string by selecting a substring from s (possibly empty) and a substring from t (possibly empty), then concatenating them in order. Return the length of the longest palindrome that can be formed this way.",Use dynamic programming to find the longest palindromic substrings in 's' and 't' individually and then combine the results.,"Reverse both strings, then find the longest common subsequence, and double its length.","Iterate through all possible substrings of 's' and 't', concatenate them, and check for palindromes, keeping track of the maximum length.",Calculate the length of the longest palindrome in 's' and 't' independently and return the larger value.,"Iterate through all possible substrings of 's' and 't', concatenate them, and efficiently check if the concatenated string is a palindrome, maximizing length.",Medium,algorithms,"Two Pointers,String,Dynamic Programming,Enumeration"
3504,"Longest Palindrome After Substring Concatenation II
You are given two strings, s and t. You can create a new string by selecting a substring from s (possibly empty) and a substring from t (possibly empty), then concatenating them in order. Return the length of the longest palindrome that can be formed this way.","Brute-force: Generate all possible substring combinations from s and t, check for palindromes, and return the length of the longest","Dynamic programming: Build a table to store lengths of palindromic substrings within s and t individually, then combine results",Greedy approach: Always select the longest possible matching characters from the ends of substrings of s and t,"Recursively find the longest palindromic substring in s and t, then compare and combine",Use a modified longest common subsequence (LCS) algorithm to find the longest palindromic substring formed by concatenating substrings of s and reversed t (or reversed s and t),Hard,algorithms,"Two Pointers,String,Dynamic Programming"
3505,"Minimum Operations to Make Elements Within K Subarrays Equal
You are given an integer array nums and two integers, x and k. You can perform the following operation any number of times (including zero): Return the minimum number of operations needed to have at least k non-overlapping subarrays of size exactly x in nums, where all elements within each subarray are equal.","Sort the array and greedily select subarrays of size x with equal elements, then calculate the operations for the remaining elements","Use dynamic programming to find the maximum number of subarrays of size x, then derive the minimum operations from that","Apply a sliding window of size x and count operations for each window, then sum the minimums","Recursively divide the array and solve the subproblems, memoizing results to avoid recomputation","Use binary search to find the minimum number of operations needed; for a given number of operations, greedily check if we can find at least k non-overlapping subarrays",Hard,algorithms,"Array,Hash Table,Math,Dynamic Programming,Sliding Window,Heap (Priority Queue)"
3507,"Minimum Pair Removal to Sort Array I
Given an array nums, you can perform the following operation any number of times: Return the minimum number of operations needed to make the array non-decreasing. An array is said to be non-decreasing if each element is greater than or equal to its previous element (if it exists).",Use dynamic programming to find the longest non-decreasing subsequence and subtract its length from the total length,"Sort the array and count the number of swaps needed to achieve the sorted order, then divide by two","Iterate through the array, and if nums[i] > nums[i+1], remove nums[i+1] and increment the counter.",Greedily remove elements by always removing the largest element from any decreasing pair encountered,"Iterate through the array, and if nums[i] > nums[i+1], increment the counter and skip the next element",Easy,algorithms,"Array,Hash Table,Linked List,Heap (Priority Queue),Simulation,Doubly-Linked List,Ordered Set"
3508,"Implement Router
Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes: Implement the Router class: Router(int memoryLimit): Initializes the Router object with a fixed memory limit. bool addPacket(int source, int destination, int timestamp): Adds a packet with the given attributes to the router. int[] forwardPacket(): Forwards the next packet in FIFO (First In First Out) order. int getCount(int destination, int startTime, int endTime): Note that queries for addPacket will be made in increasing order of timestamp.",Employ a priority queue sorted by source IP address for packet management.,"Use a stack to store packets, enabling LIFO (Last In First Out) forwarding.",Implement a hash table where the key is the destination IP and the value is a list of packets.,Utilize a circular buffer with a fixed size to store incoming packets.,"Employ a queue to store packets, ensuring FIFO (First In First Out) forwarding, and an index for efficient count queries.",Medium,system design,"Array,Hash Table,Binary Search,Design,Queue,Ordered Set"
3509,"Maximum Product of Subsequences With an Alternating Sum Equal to K
You are given an integer array nums and two integers, k and limit. Your task is to find a non-empty subsequence of nums that: Return the product of the numbers in such a subsequence. If no subsequence satisfies the requirements, return -1. The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.","Use dynamic programming to track the maximum product for alternating sums less than k, greater than k, and equal to k.",Sort the input array and greedily select elements to maximize the product while staying within the limit.,Recursively explore all possible subsequences and prune branches that exceed the alternating sum limit.,"Use a sliding window approach to find the longest subsequence with an alternating sum equal to k, then calculate its product.",Employ a modified knapsack approach to store the maximum product achievable for each possible alternating sum encountered.,Hard,algorithms,"Array,Hash Table,Dynamic Programming"
3510,"Minimum Pair Removal to Sort Array II
Given an array nums, you can perform the following operation any number of times: Return the minimum number of operations needed to make the array non-decreasing. An array is said to be non-decreasing if each element is greater than or equal to its previous element (if it exists).",Use dynamic programming to find the longest non-decreasing subsequence and subtract its length from the total length.,Sort the array and count the number of swaps needed to achieve a non-decreasing order.,"Iterate through the array, and for each decreasing pair, remove the element that creates the smallest increase in the overall array sum.",Greedily remove pairs with the largest difference between adjacent elements until the array is non-decreasing.,"Use a stack to keep track of the non-decreasing sequence. If an element is smaller than the top of the stack, pop elements until the stack is empty or the top element is smaller or equal to the current element. The number of pops is the number of removals.",Hard,algorithms,"Array,Hash Table,Linked List,Heap (Priority Queue),Simulation,Doubly-Linked List,Ordered Set"
3512,"Minimum Operations to Make Array Sum Divisible by K
You are given an integer array nums and an integer k. You can perform the following operation any number of times: Return the minimum number of operations required to make the sum of the array divisible by k.",Find the longest subarray whose sum has remainder 0 when divided by k,Use dynamic programming to find all possible subarray sums modulo k,Sort the array and remove elements from the beginning until the sum is divisible by k,Calculate the prefix sum modulo k and find the longest subarray with the same prefix sum modulo k,Find the minimum length subarray whose sum has the same remainder as the total sum when divided by k,Easy,algorithms,"Array,Math"
3513,"Number of Unique XOR Triplets I
You are given an integer array nums of length n, where nums is a permutation of the numbers in the range [1, n]. A XOR triplet is defined as the XOR of three elements nums[i] XOR nums[j] XOR nums[k] where i <= j <= k. Return the number of unique XOR triplet values from all possible triplets (i, j, k).",Calculate the XOR of all possible triplets and store them in a set to count unique values. This has O(n^3) time complexity.,"Use dynamic programming to store intermediate XOR values, reducing redundant calculations but increasing space complexity.","Sort the array first and then iterate through it, skipping duplicate elements to optimize XOR triplet calculation.","Precompute a XOR prefix array to efficiently calculate XOR sums of subarrays, thereby speeding up the process.","Use a frequency map to count the occurrences of each number. Then, iterate through the array. For each number, iterate through the array again and calculate XOR values. If the XOR value exists in the map, increment a counter.",Medium,algorithms,"Array,Math,Bit Manipulation"
3514,"Number of Unique XOR Triplets II
You are given an integer array nums. A XOR triplet is defined as the XOR of three elements nums[i] XOR nums[j] XOR nums[k] where i <= j <= k. Return the number of unique XOR triplet values from all possible triplets (i, j, k).",Use a hash set to store XOR values and iterate through all possible triplets using three nested loops.,Sort the array and use binary search to find matching XOR values to optimize triplet generation.,"Calculate all possible XOR combinations of pairs and then XOR each result with the remaining elements, storing unique values in a set.",Precompute all prefix XORs and use them to efficiently calculate XOR sums for all triplets.,"Iterate through all possible triplets (i, j, k), calculate their XOR, and store the unique XOR values in a set.",Medium,algorithms,"Array,Math,Bit Manipulation,Enumeration"
3515,"Shortest Path in a Weighted Tree
You are given an integer n and an undirected, weighted tree rooted at node 1 with n nodes numbered from 1 to n. This is represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates an undirected edge from node ui to vi with weight wi. You are also given a 2D integer array queries of length q, where each queries[i] is either: Return an integer array answer, where answer[i] is the shortest path distance from node 1 to x for the ith query of [2, x].","Use Dijkstra's algorithm with a priority queue, updating distances from node 1 for each query.","Perform a Depth-First Search (DFS) for each query, calculating the path cost from node 1 to the target node.",Precompute all-pairs shortest paths using the Floyd-Warshall algorithm and then directly retrieve the distance for each query.,"Use Breadth-First Search (BFS) to find the shortest path, ignoring the weights of the edges.","Use Dijkstra's algorithm once to compute shortest paths from node 1 to all other nodes, storing the distances, then answer queries in O(1).",Hard,algorithms,"Array,Tree,Depth-First Search,Binary Indexed Tree,Segment Tree"
3516,"Find Closest Person
You are given three integers x, y, and z, representing the positions of three people on a number line: Both Person 1 and Person 2 move toward Person 3 at the same speed. Determine which person reaches Person 3 first: Return the result accordingly.","Person 2, regardless of distances, because Person 2 is always closer.","Person 1, but only if x < y; otherwise, Person 2.",The person with the larger position value reaches Person 3 first.,The person with the smaller position value reaches Person 3 first.,"Person 1 if abs(x-z) < abs(y-z), Person 2 if abs(x-z) > abs(y-z), otherwise they arrive simultaneously.",Easy,algorithms,Math
3517,"Smallest Palindromic Rearrangement I
You are given a palindromic string s. Return the lexicographically smallest palindromic permutation of s.","Reverse the string and compare it to the original; if different, return the lexicographically smaller one.","Sort the characters, then construct a palindrome by mirroring the first half.",Iterate through all possible permutations and return the first palindromic one found.,"Remove one instance of each character appearing twice, then sort and reconstruct a palindrome.","Count character frequencies, construct the first half of the palindrome in sorted order, and mirror it for the second half.",Medium,algorithms,"String,Sorting,Counting Sort"
3518,"Smallest Palindromic Rearrangement II
You are given a palindromic string s and an integer k. Return the k-th lexicographically smallest palindromic permutation of s. If there are fewer than k distinct palindromic permutations, return an empty string. Note: Different rearrangements that yield the same palindromic string are considered identical and are counted once.",Use a greedy algorithm to repeatedly choose the smallest available character for the first half of the palindrome and mirror it in the second half.,"Generate all possible permutations of the input string, filter for palindromes, sort them lexicographically, and return the k-th element.","Calculate the frequency of each character. If the number of distinct palindromic permutations is less than k, return an empty string. Otherwise, construct the k-th permutation by iteratively choosing the smallest possible character for each position.","Employ dynamic programming to build a table of all possible palindromic permutations, then retrieve the k-th smallest one from the table.","Determine the number of distinct palindromic permutations using factorials and frequency counts. If k exceeds this count, return an empty string. Otherwise, iteratively construct the k-th permutation by selecting characters for the first half of the palindrome and mirroring them.",Hard,algorithms,"Hash Table,Math,String,Combinatorics,Counting"
3519,"Count Numbers with Non-Decreasing Digits
You are given two integers, l and r, represented as strings, and an integer b. Return the count of integers in the inclusive range [l, r] whose digits are in non-decreasing order when represented in base b. An integer is considered to have non-decreasing digits if, when read from left to right (from the most significant digit to the least significant digit), each digit is greater than or equal to the previous one. Since the answer may be too large, return it modulo 109 + 7.","Employ dynamic programming with state (index, previous digit, tight), handling leading zeros explicitly","Utilize inclusion-exclusion principle combined with combinatorics to count valid numbers below r and l, then subtract","Generate all possible numbers within the range [l, r] and filter out the ones with non-decreasing digits","Convert the numbers to base 10, perform the check and convert back to base b","Use digit DP to count numbers <= r and <= l, then subtract, handling leading zeros carefully and working in base b",Hard,algorithms,"Math,String,Dynamic Programming"
3521,"Find Product Recommendation Pairs
Table: ProductPurchases Table: ProductInfo Amazon wants to implement the Customers who bought this also bought... feature based on co-purchase patterns. Write a solution to : A product pair is considered for recommendation if at least 3 different customers have purchased both products. Return the result table ordered by customer_count in descending order, and in case of a tie, by product1_id in ascending order, and then by product2_id in ascending order. The result format is in the following example.  Example: Input: ProductPurchases table: ProductInfo table: Output: Explanation: The result is ordered by customer_count in descending order. For pairs with the same customer_count, they are ordered by product1_id and then product2_id in ascending order.",Use a self-join on `ProductPurchases` grouped by product pairs with a HAVING clause filtering for `COUNT(DISTINCT customer_id) >= 3` without considering the `ProductInfo` table.,"Join `ProductPurchases` and `ProductInfo` tables, then group by product pairs and filter for `COUNT(*) >= 3`.",Use window functions to count purchases per product and only include pairs where both products have more than 3 purchases.,"Calculate the number of unique customers who purchased each product, then join these results and filter where both counts are greater than 3.","Join `ProductPurchases` with itself on `customer_id` where `product_id` is different, group by the product pairs, and filter with `COUNT(DISTINCT customer_id) >= 3`.",Medium,database systems,Database
3522,"Calculate Score After Performing Instructions
You are given two arrays, instructions and values, both of size n. You need to simulate a process based on the following rules: The process ends when you either: Return your score at the end of the process.",Use a hash table to store previously computed values and reduce computational complexity,"Employ a divide-and-conquer strategy, splitting the problem into smaller subproblems",Apply dynamic programming to store intermediate results and optimize the solution,Convert the instructions into a binary tree and traverse it to calculate the score,"Simulate the instructions sequentially, updating the score according to each instruction's effect on the values array",Medium,algorithms,"Array,Hash Table,String,Simulation"
3523,"Make Array Non-decreasing
You are given an integer array nums. In one operation, you can select a subarray and replace it with a single element equal to its maximum value. Return the maximum possible size of the array after performing zero or more operations such that the resulting array is non-decreasing.",O(n log n) due to the need to sort the initial array,O(n^2) because of the nested loops required for subarray selection and replacement,O(n!) as it involves checking all possible combinations of subarray selections,O(2^n) due to the exponential number of possible subarrays that can be formed,O(n) as it involves a single pass through the array to identify and merge decreasing subarrays,Medium,algorithms,"Array,Stack,Greedy,Monotonic Stack"
3524,"Find X Value of Array I
You are given an array of positive integers nums, and a positive integer k. You are allowed to perform an operation once on nums, where in each operation you can remove any non-overlapping prefix and suffix from nums such that nums remains non-empty. You need to find the x-value of nums, which is the number of ways to perform this operation so that the product of the remaining elements leaves a remainder of x when divided by k. Return an array result of size k where result[x] is the x-value of nums for 0 <= x <= k - 1. A prefix of an array is a subarray that starts from the beginning of the array and extends to any point within it. A suffix of an array is a subarray that starts at any point within the array and extends to the end of the array. Note that the prefix and suffix to be chosen for the operation can be empty.",Calculate the product of all possible subarrays and then count the remainders,Recursively divide the array into halves and calculate the x-value for each half,Precompute all prefix and suffix products modulo k and then iterate through combinations,Apply dynamic programming to store intermediate results for subarray products modulo k,"Iterate through all valid prefix and suffix combinations, calculate the product of the remaining subarray modulo k, and increment the corresponding count in the result array",Medium,algorithms,"Array,Math,Dynamic Programming"
3525,"Find X Value of Array II
You are given an array of positive integers nums and a positive integer k. You are also given a 2D array queries, where queries[i] = [indexi, valuei, starti, xi]. You are allowed to perform an operation once on nums, where you can remove any suffix from nums such that nums remains non-empty. The x-value of nums for a given x is defined as the number of ways to perform this operation so that the product of the remaining elements leaves a remainder of x modulo k. For each query in queries you need to determine the x-value of nums for xi after performing the following actions: Return an array result of size queries.length where result[i] is the answer for the ith query. A prefix of an array is a subarray that starts from the beginning of the array and extends to any point within it. A suffix of an array is a subarray that starts at any point within the array and extends to the end of the array. Note that the prefix and suffix to be chosen for the operation can be empty. Note that x-value has a different definition in this version.",Use dynamic programming to precompute all possible subarray products and then iterate through the queries,"Brute force: For each query, try all possible suffix removals and calculate the remainder modulo k","Sort the nums array, then use binary search to find the appropriate suffix for each query",Precompute the product of all prefixes modulo k and then iterate through the queries to count valid prefixes,"For each query, modify nums based on the query, iterate through possible suffix removals, and count prefixes whose product modulo k equals xi",Hard,algorithms,"Array,Math,Segment Tree"
3527,"Find the Most Common Response
You are given a 2D string array responses where each responses[i] is an array of strings representing survey responses from the ith day. Return the most common response across all days after removing duplicate responses within each responses[i]. If there is a tie, return the lexicographically smallest response.","Use a hash table to count response frequencies, then sort the results alphabetically and select the smallest.","Convert each daily response set to a string, concatenate all strings, split into individual responses, and count frequencies.","Iterate through all responses without removing duplicates, count frequencies, and return the most frequent without considering ties.","Maintain a global set of all responses, count frequencies, and return the most frequent response regardless of lexicographical order.","Iterate through each day, remove duplicates using a set, then use a hash map to count frequencies across all days, resolving ties lexicographically.",Medium,algorithms,"Array,Hash Table,String,Counting"
3528,"Unit Conversion I
There are n types of units indexed from 0 to n - 1. You are given a 2D integer array conversions of length n - 1, where conversions[i] = [sourceUniti, targetUniti, conversionFactori]. This indicates that a single unit of type sourceUniti is equivalent to conversionFactori units of type targetUniti. Return an array baseUnitConversion of length n, where baseUnitConversion[i] is the number of units of type i equivalent to a single unit of type 0. Since the answer may be large, return each baseUnitConversion[i] modulo 109 + 7.",Depth-first search (DFS),Greedy algorithm,Breadth-first search (BFS),Dijkstra's algorithm,Graph traversal (DFS or BFS),Medium,algorithms,"Depth-First Search,Breadth-First Search,Graph"
3529,"Count Cells in Overlapping Horizontal and Vertical Substrings
You are given an m x n matrix grid consisting of characters and a string pattern. A horizontal substring is a contiguous sequence of characters read from left to right. If the end of a row is reached before the substring is complete, it wraps to the first column of the next row and continues as needed. You do not wrap from the bottom row back to the top. A vertical substring is a contiguous sequence of characters read from top to bottom. If the bottom of a column is reached before the substring is complete, it wraps to the first row of the next column and continues as needed. You do not wrap from the last column back to the first. Count the number of cells in the matrix that satisfy the following condition: Return the count of these cells.","Only consider horizontal substrings, ignoring vertical ones","Only consider vertical substrings, ignoring horizontal ones",Count each cell within a matching substring multiple times if it is part of overlapping substrings,"Return the total number of horizontal and vertical substrings found, regardless of overlaps","Count each cell only once, even if it is part of multiple overlapping horizontal and vertical substrings",Medium,algorithms,"Array,String,Rolling Hash,String Matching,Matrix,Hash Function"
3530,"Maximum Profit from Valid Topological Order in DAG
You are given a Directed Acyclic Graph (DAG) with n nodes labeled from 0 to n - 1, represented by a 2D array edges, where edges[i] = [ui, vi] indicates a directed edge from node ui to vi. Each node has an associated score given in an array score, where score[i] represents the score of node i. You must process the nodes in a valid topological order. Each node is assigned a 1-based position in the processing order. The profit is calculated by summing up the product of each node's score and its position in the ordering. Return the maximum possible profit achievable with an optimal topological order. A topological order of a DAG is a linear ordering of its nodes such that for every directed edge u → v, node u comes before v in the ordering.","Greedily process nodes with the highest score first, regardless of topological constraints.","Sort the nodes by their score in descending order and process them in that order if it's a valid topological order, otherwise skip them.",Perform a depth-first search (DFS) and process nodes in the reverse order of their finishing times.,Apply Dijkstra's algorithm to find the longest path and use the node order in that path.,"Use topological sort to generate all possible topological orders, compute the profit for each, and return the maximum.",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Graph,Topological Sort,Bitmask"
3531,"Count Covered Buildings
You are given a positive integer n, representing an n x n city. You are also given a 2D grid buildings, where buildings[i] = [x, y] denotes a unique building located at coordinates [x, y]. A building is covered if there is at least one building in all four directions: left, right, above, and below. Return the number of covered buildings.","Check each building against all other buildings in the city, resulting in O(n^3) complexity.",Use a quadtree to partition the city and efficiently search for neighboring buildings.,Sort the buildings by their x-coordinates and then their y-coordinates to optimize neighbor searching.,Divide the city into quadrants and process each quadrant separately to reduce search space.,"For each building, iterate through all other buildings to check for neighbors in each of the four directions, resulting in O(n^2) complexity.",Medium,algorithms,"Array,Hash Table,Sorting"
3532,"Path Existence Queries in a Graph I
You are given an integer n representing the number of nodes in a graph, labeled from 0 to n - 1. You are also given an integer array nums of length n sorted in non-decreasing order, and an integer maxDiff. An undirected edge exists between nodes i and j if the absolute difference between nums[i] and nums[j] is at most maxDiff (i.e., |nums[i] - nums[j]| <= maxDiff). You are also given a 2D integer array queries. For each queries[i] = [ui, vi], determine whether there exists a path between nodes ui and vi. Return a boolean array answer, where answer[i] is true if there exists a path between ui and vi in the ith query and false otherwise.",Dijkstra's algorithm,Prim's algorithm,Kruskal's algorithm,Topological sort,Depth-First Search (DFS) or Breadth-First Search (BFS),Medium,algorithms,"Array,Hash Table,Binary Search,Union Find,Graph"
3533,"Concatenated Divisibility
You are given an array of positive integers nums and a positive integer k. A permutation of nums is said to form a divisible concatenation if, when you concatenate the decimal representations of the numbers in the order specified by the permutation, the resulting number is divisible by k. Return the lexicographically smallest permutation (when considered as a list of integers) that forms a divisible concatenation. If no such permutation exists, return an empty list.",A race condition can occur if multiple threads increment the counter simultaneously without synchronization.,The final count may be lower than expected due to compiler optimizations.,The count will always be accurate because increment operations are atomic.,"Integer overflow can occur, leading to incorrect results if the count exceeds the maximum value.",The count will be inaccurate due to data races as increment is not an atomic operation and requires synchronization mechanisms.,Hard,system design,"Array,Dynamic Programming,Bit Manipulation,Bitmask"
3534,"Path Existence Queries in a Graph II
You are given an integer n representing the number of nodes in a graph, labeled from 0 to n - 1. You are also given an integer array nums of length n and an integer maxDiff. An undirected edge exists between nodes i and j if the absolute difference between nums[i] and nums[j] is at most maxDiff (i.e., |nums[i] - nums[j]| <= maxDiff). You are also given a 2D integer array queries. For each queries[i] = [ui, vi], find the minimum distance between nodes ui and vi. If no path exists between the two nodes, return -1 for that query. Return an array answer, where answer[i] is the result of the ith query. Note: The edges between the nodes are unweighted.",Breadth-First Search (BFS),Depth-First Search (DFS),Kruskal's Algorithm,Topological Sort,Dijkstra's Algorithm,Hard,algorithms,"Array,Binary Search,Greedy,Graph,Sorting"
3536,"Maximum Product of Two Digits
You are given a positive integer n. Return the maximum product of any two digits in n. Note: You may use the same digit twice if it appears more than once in n.",Sort the digits in descending order and multiply the two largest digits.,Multiply the first and last digits of the number.,Calculate the product of all possible pairs of digits and return the maximum.,Multiply the two digits that are farthest apart in the number.,"Convert the integer to a string, iterate through all pairs of digits, calculate their product, and return the maximum product found.",Easy,algorithms,"Math,Sorting"
3537,"Fill a Special Grid
You are given a non-negative integer n representing a 2n x 2n grid. You must fill the grid with integers from 0 to 22n - 1 to make it special. A grid is special if it satisfies all the following conditions: Return the special 2n x 2n grid. Note: Any 1x1 grid is special.",Utilize bitwise operations to construct the grid by interleaving bits of the input numbers,Apply a recursive algorithm that divides the grid into quadrants and assigns values based on quadrant location,Generate a Hilbert curve and assign values sequentially based on the curve's path through the grid,Populate the grid randomly and then apply simulated annealing to optimize for 'specialness',"Assign numbers sequentially in row-major order, ensuring that the most significant bits change least frequently",Medium,algorithms,"Array,Divide and Conquer,Matrix"
3538,"Merge Operations for Minimum Travel Time
You are given a straight road of length l km, an integer n, an integer k, and two integer arrays, position and time, each of length n. The array position lists the positions (in km) of signs in strictly increasing order (with position[0] = 0 and position[n - 1] = l). Each time[i] represents the time (in minutes) required to travel 1 km between position[i] and position[i + 1]. You must perform exactly k merge operations. In one merge, you can choose any two adjacent signs at indices i and i + 1 (with i > 0 and i + 1 < n) and: Return the minimum total travel time (in minutes) to travel from 0 to l after exactly k merges.",Greedily merge segments with the smallest travel time increase.,Use dynamic programming with a state representing the current position and the number of merges remaining.,Sort the 'time' array and merge segments corresponding to the smallest 'time' values first.,Calculate all possible merge combinations using recursion and choose the one with the minimum travel time.,"Use dynamic programming to minimize total travel time, where the state represents the current position and the number of merges performed.",Hard,algorithms,"Array,Dynamic Programming,Prefix Sum"
3539,"Find Sum of Array Product of Magical Sequences
You are given two integers, m and k, and an integer array nums. The array product of this sequence is defined as prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m - 1]]). Return the sum of the array products for all valid magical sequences. Since the answer may be large, return it modulo 109 + 7. A set bit refers to a bit in the binary representation of a number that has a value of 1.",Consider all combinations of subsequences of length m and calculate products,Calculate the product of the entire array and multiply by k,"Sort the array and take the product of the first m elements, repeating k times",Multiply each number in the array by k and calculate the product of the first m elements,"Iterate through all subsequences of length m, calculate their product modulo 10^9 + 7, and sum the results modulo 10^9 + 7.",Hard,algorithms,"Array,Math,Dynamic Programming,Bit Manipulation,Combinatorics,Bitmask"
3541,"Find Most Frequent Vowel and Consonant
You are given a string s consisting of lowercase English letters ('a' to 'z'). Your task is to: Return the sum of the two frequencies. Note: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.",Use dynamic programming to store and retrieve the maximum frequencies of vowels and consonants.,Employ regular expressions to identify and count vowels and consonants separately.,Utilize a trie data structure to efficiently store and count character frequencies.,"Sort the string and iterate, incrementing counters for vowels and consonants encountered.","Iterate through the string, maintaining separate frequency maps for vowels and consonants, then find the maximums.",Easy,algorithms,"Hash Table,String,Counting"
3542,"Minimum Operations to Convert All Elements to Zero
You are given an array nums of size n, consisting of non-negative integers. Your task is to apply some (possibly zero) operations on the array so that all elements become 0. In one operation, you can select a subarray [i, j] (where 0 <= i <= j < n) and set all occurrences of the minimum non-negative integer in that subarray to 0. Return the minimum number of operations required to make all elements in the array 0.","Recursively process the array, at each step finding the minimum and zeroing it and its duplicates in a subarray, then summing the recursive calls on the remaining segments.","Iterate through the array, keeping track of the non-zero segments and incrementing a counter each time a new non-zero segment begins.","Sort the array and then iterate through, zeroing out elements from smallest to largest and incrementing a counter for each element zeroed.",Calculate the sum of all elements. The number of operations is equal to the sum if no optimization is done.,"Iterate through the array, maintaining the current maximum height and incrementing the operation count only when the current element's height exceeds the maximum.",Medium,algorithms,"Array,Hash Table,Stack,Greedy,Monotonic Stack"
3543,"Maximum Weighted K-Edge Path
You are given an integer n and a Directed Acyclic Graph (DAG) with n nodes labeled from 0 to n - 1. This is represented by a 2D array edges, where edges[i] = [ui, vi, wi] indicates a directed edge from node ui to vi with weight wi. You are also given two integers, k and t. Your task is to determine the maximum possible sum of edge weights for any path in the graph such that: Return the maximum possible sum of weights for such a path. If no such path exists, return -1.","Dynamic Programming with memoization based on (node, edges used).",Bellman-Ford algorithm to find the longest path with at most k edges.,Topological sort followed by a greedy approach selecting edges with highest weights.,"Depth-First Search (DFS) keeping track of the path length and weight, pruning paths exceeding k edges.","Dynamic Programming with memoization based on (node, edges used, target_node).",Medium,algorithms,"Hash Table,Dynamic Programming,Graph"
3544,"Subtree Inversion Sum
You are given an undirected tree rooted at node 0, with n nodes numbered from 0 to n - 1. The tree is represented by a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates an edge between nodes ui and vi. You are also given an integer array nums of length n, where nums[i] represents the value at node i, and an integer k. You may perform inversion operations on a subset of nodes subject to the following rules: Subtree Inversion Operation: When you invert a node, every value in the subtree rooted at that node is multiplied by -1. Distance Constraint on Inversions: You may only invert a node if it is ""sufficiently far"" from any other inverted node. Specifically, if you invert two nodes a and b such that one is an ancestor of the other (i.e., if LCA(a, b) = a or LCA(a, b) = b), then the distance (the number of edges on the unique path between them) must be at least k. Return the maximum possible sum of the tree's node values after applying inversion operations.","Use a greedy algorithm, always inverting the node that maximizes the immediate sum increase, ignoring the distance constraint.","Perform a depth-first search (DFS) and only invert nodes at even depths to maximize the sum, regardless of the distance constraint.","Invert all nodes with negative values to maximize the sum, ignoring the distance constraint.","Use dynamic programming with bitmasking to track all possible combinations of inversions and their resulting sums, then choose the maximum.","Use dynamic programming on the tree, tracking the maximum sum achievable for each node with and without inversion, respecting the distance constraint.",Hard,algorithms,"Array,Dynamic Programming,Tree,Depth-First Search"
3545,"Minimum Deletions for At Most K Distinct Characters
You are given a string s consisting of lowercase English letters, and an integer k. Your task is to delete some (possibly none) of the characters in the string so that the number of distinct characters in the resulting string is at most k. Return the minimum number of deletions required to achieve this.",Greedily remove characters based on their ASCII value until the condition is met.,"Sort the string, then iteratively remove characters from the front until 'k' distinct characters remain.",Recursively check all possible sub-sequences by including or excluding characters until the length of distinct chars is at most 'k',Randomly delete characters until the number of distinct characters is at most 'k'.,"Count frequencies, prioritize removal of least frequent characters until at most k distinct chars remain.",Easy,algorithms,"Hash Table,String,Greedy,Sorting,Counting"
3546,"Equal Sum Grid Partition I
You are given an m x n matrix grid of positive integers. Your task is to determine if it is possible to make either one horizontal or one vertical cut on the grid such that: Return true if such a partition exists; otherwise return false.",Calculate row and column sums independently and compare the maximum row sum to the maximum column sum.,"Check if the sum of all elements is even; if so, return true; otherwise, return false.",Perform a depth-first search (DFS) to explore all possible cut combinations.,Use dynamic programming to store the cumulative sums for all submatrices.,Calculate row and column sums and iterate through them to find a cut where the sums on both sides are equal.,Medium,algorithms,"Array,Matrix,Enumeration,Prefix Sum"
3547,"Maximum Sum of Edge Values in a Graph
You are given an undirected connected graph of n nodes, numbered from 0 to n - 1. Each node is connected to at most 2 other nodes. The graph consists of m edges, represented by a 2D array edges, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. You have to assign a unique value from 1 to n to each node. The value of an edge will be the product of the values assigned to the two nodes it connects. Your score is the sum of the values of all edges in the graph. Return the maximum score you can achieve.",Sort nodes by degree in descending order and assign values from 1 to n sequentially,"Use a greedy approach, assigning the highest values to nodes in a Breadth-First Search (BFS) traversal",Perform a Depth-First Search (DFS) and assign values based on discovery order,Assign random values to nodes and use simulated annealing to optimize the edge sum,Find a path that visits all nodes (Hamiltonian path) and assign values such that the highest values are on edges of the path,Hard,algorithms,"Greedy,Depth-First Search,Graph,Sorting"
3548,"Equal Sum Grid Partition II
You are given an m x n matrix grid of positive integers. Your task is to determine if it is possible to make either one horizontal or one vertical cut on the grid such that: Return true if such a partition exists; otherwise, return false. Note: A section is connected if every cell in it can be reached from any other cell by moving up, down, left, or right through other cells in the section.",Check if the sum of the first row equals the sum of the remaining rows or if the sum of the first column equals the sum of the remaining columns.,Calculate the total sum of the grid and check if any single element is equal to half the total sum.,Recursively partition the grid into smaller subgrids and check if each subgrid has an equal sum.,Compute prefix sums for both rows and columns and check for any index where the prefix sum equals half the total sum of the grid.,Compute the total sum of the grid. Iterate through rows to find a horizontal cut or columns to find a vertical cut where the sum of one section equals half the total sum.,Hard,algorithms,"Array,Hash Table,Matrix,Enumeration,Prefix Sum"
3550,"Smallest Index With Digit Sum Equal to Index
You are given an integer array nums. Return the smallest index i such that the sum of the digits of nums[i] is equal to i. If no such index exists, return -1.",O(n log n),O(n^2),O(sqrt(n)),O(log n),O(n),Easy,algorithms,"Array,Math"
3551,"Minimum Swaps to Sort by Digit Sum
You are given an array nums of distinct positive integers. You need to sort the array in increasing order based on the sum of the digits of each number. If two numbers have the same digit sum, the smaller number appears first in the sorted order. Return the minimum number of swaps required to rearrange nums into this sorted order. A swap is defined as exchanging the values at two distinct positions in the array.","Sort the numbers directly using a comparison-based sorting algorithm like quicksort, ignoring digit sums.","Calculate the digit sum for each number, then sort the numbers based on their original values without considering digit sums.",Create a graph where an edge exists between elements needing a swap. Find connected components and count cycles.,Use a brute-force approach: generate all possible permutations and check the minimum swaps needed for the sorted order.,"Calculate digit sums, sort based on digit sums and original values, then count the minimum swaps using cycle decomposition.",Medium,algorithms,"Array,Hash Table,Sorting"
3552,"Grid Teleportation Traversal
You are given a 2D character grid matrix of size m x n, represented as an array of strings, where matrix[i][j] represents the cell at the intersection of the ith row and jth column. Each cell is one of the following: You start at the top-left cell (0, 0), and your goal is to reach the bottom-right cell (m - 1, n - 1). You can move from the current cell to any adjacent cell (up, down, left, right) as long as the destination cell is within the grid bounds and is not an obstacle. If you step on a cell containing a portal letter and you haven't used that portal letter before, you may instantly teleport to any other cell in the grid with the same letter. This teleportation does not count as a move, but each portal letter can be used at most once during your journey. Return the minimum number of moves required to reach the bottom-right cell. If it is not possible to reach the destination, return -1.","Depth-First Search (DFS) without considering visited portals, potentially leading to infinite loops.","Greedy approach, always choosing the closest cell, which may not lead to the optimal path.","Breadth-First Search (BFS) without tracking used portals, causing revisits and inflated move counts.","Dijkstra's algorithm without handling the 'no move' teleportation, resulting in incorrect distance calculations.",Breadth-First Search (BFS) tracking visited cells and used portals to find the shortest path.,Medium,algorithms,"Array,Hash Table,Breadth-First Search,Matrix"
3553,"Minimum Weighted Subgraph With the Required Paths II
You are given an undirected weighted tree with n nodes, numbered from 0 to n - 1. It is represented by a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi.​ Additionally, you are given a 2D integer array queries, where queries[j] = [src1j, src2j, destj]. Return an array answer of length equal to queries.length, where answer[j] is the minimum total weight of a subtree such that it is possible to reach destj from both src1j and src2j using edges in this subtree. A subtree here is any connected subset of nodes and edges of the original tree forming a valid tree.","Construct a disjoint-set data structure (Union-Find) and iteratively merge nodes until src1, src2, and dest are in the same set, summing edge weights used.","Compute all possible subtrees and, for each subtree, check if paths exist between (src1, dest) and (src2, dest) using a shortest path algorithm; return the minimum weight among valid subtrees.","Perform Dijkstra's algorithm from each of src1, src2, and dest to every other node. Find the intersection of the paths with minimum total weight.","Use a greedy approach by selecting the lightest edges incident to src1, src2, and dest until a connected subgraph is formed.","Compute the Least Common Ancestor (LCA) of (src1, src2), (src1, dest), and (src2, dest). The minimum subtree includes the paths from src1, src2, and dest to the LCA of all three and the weight of those paths is the answer.",Hard,algorithms,"Array,Tree,Depth-First Search"
3554,"Find Category Recommendation Pairs
Table: ProductPurchases Table: ProductInfo Amazon wants to understand shopping patterns across product categories. Write a solution to: A category pair is considered reportable if at least 3 different customers have purchased products from both categories. Return the result table of reportable category pairs ordered by customer_count in descending order, and in case of a tie, by category1 in ascending order lexicographically, and then by category2 in ascending order. The result format is in the following example.  Example: Input: ProductPurchases table: ProductInfo table: Output: Explanation: The result is ordered by customer_count in descending order. Since all pairs have the same customer_count of 3, they are ordered by category1 (then category2) in ascending order.",Using self-joins on `ProductPurchases` to find common customers and then filtering using `HAVING COUNT(DISTINCT customer_id) < 3`,Grouping the `ProductPurchases` table by category and directly using the `COUNT(*)` aggregate function to determine customer count.,"Selecting all distinct category pairs without filtering, and ordering them lexicographically without considering customer counts.",Joining `ProductPurchases` with `ProductInfo` and grouping by category to calculate an average product price for each category pair.,"Using self-joins on `ProductPurchases` to find common customers, grouping by category pairs, and filtering using `HAVING COUNT(DISTINCT customer_id) >= 3`",Hard,database systems,Database
3556,"Sum of Largest Prime Substrings
Given a string s, find the sum of the 3 largest unique prime numbers that can be formed using any of its substrings. Return the sum of the three largest unique prime numbers that can be formed. If fewer than three exist, return the sum of all available primes. If no prime numbers can be formed, return 0. Note: Each prime number should be counted only once, even if it appears in multiple substrings. Additionally, when converting a substring to an integer, any leading zeros are ignored.",Use dynamic programming to store results of substring primality checks and memoize to avoid recomputation,"Convert all substrings to integers, filter for primes, sort, and sum the top three (or fewer if fewer exist)","Generate all possible substrings, convert them to integers, and add the three largest regardless of primality",Use a sliding window to efficiently iterate through all possible substrings and sum their ASCII values,"Generate all substrings, convert them to integers, check for primality, store unique primes in a set, sort, and sum the top three (or fewer)",Medium,algorithms,"Hash Table,Math,String,Sorting,Number Theory"
3557,"Find Maximum Number of Non Intersecting Substrings
You are given a string word. Return the maximum number of non-intersecting substrings of word that are at least four characters long and start and end with the same letter.",Use dynamic programming to find all possible substrings and then filter for non-intersecting ones,Employ a greedy algorithm that selects the shortest valid substring at each step,Recursively divide the string into smaller parts and solve the problem for each part,Sort the characters of the string and then find the longest increasing subsequence,"Iterate through the string, greedily selecting the leftmost valid substring and removing overlapping sections",Medium,algorithms,"Hash Table,String,Dynamic Programming,Greedy"
3558,"Number of Ways to Assign Edge Weights I
There is an undirected tree with n nodes labeled from 1 to n, rooted at node 1. The tree is represented by a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi. Initially, all edges have a weight of 0. You must assign each edge a weight of either 1 or 2. The cost of a path between any two nodes u and v is the total weight of all edges in the path connecting them. Select any one node x at the maximum depth. Return the number of ways to assign edge weights in the path from node 1 to x such that its total cost is odd. Since the answer may be large, return it modulo 109 + 7. Note: Ignore all edges not in the path from node 1 to x.",2^(number of edges),(2^(number of edges)) - 1,2^(number of edges - 1),(2^(number of edges - 1)) - 1,2^(number of edges - 1) (mod 10^9 + 7),Medium,algorithms,"Math,Tree,Depth-First Search"
3559,"Number of Ways to Assign Edge Weights II
There is an undirected tree with n nodes labeled from 1 to n, rooted at node 1. The tree is represented by a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi. Initially, all edges have a weight of 0. You must assign each edge a weight of either 1 or 2. The cost of a path between any two nodes u and v is the total weight of all edges in the path connecting them. You are given a 2D integer array queries. For each queries[i] = [ui, vi], determine the number of ways to assign weights to edges in the path such that the cost of the path between ui and vi is odd. Return an array answer, where answer[i] is the number of valid assignments for queries[i]. Since the answer may be large, apply modulo 109 + 7 to each answer[i]. Note: For each query, disregard all edges not in the path between node ui and vi.","O(log n) time, O(1) space","O(n log n) time, O(n) space","O(n) time, O(1) space","O(n^2) time, O(n) space","O(q * n) time, O(n) space, where q is the number of queries",Hard,algorithms,"Array,Math,Dynamic Programming,Tree,Depth-First Search"
3560,"Find Minimum Log Transportation Cost
You are given integers n, m, and k. There are two logs of lengths n and m units, which need to be transported in three trucks where each truck can carry one log with length at most k units. You may cut the logs into smaller pieces, where the cost of cutting a log of length x into logs of length len1 and len2 is cost = len1 * len2 such that len1 + len2 = x. Return the minimum total cost to distribute the logs onto the trucks. If the logs don't need to be cut, the total cost is 0.",Divide both logs into as few pieces as possible such that each piece has length exactly k. The total cost is the sum of the cut costs for each log.,"If n + m <= k, return 0. Otherwise, cut the longer log until both logs fit on separate trucks. The remaining log goes on a third truck.","Always cut the larger log into two equal pieces (or as close to equal as possible), repeating until all resulting logs have a length of at most k. Sum the costs of all cuts.","Sort n and m. If n > k, cut it into pieces of size k until n <= k. Do the same for m. Return the sum of all cutting costs.","Use dynamic programming. dp[i][j] represents the minimum cost to transport logs of length i and j. The base case is when i <= k and j <= k, where the cost is 0. Consider all possible cuts for both logs and minimize the total cost recursively.",Easy,algorithms,Math
3561,"Resulting String After Adjacent Removals
You are given a string s consisting of lowercase English letters. You must repeatedly perform the following operation while the string s has at least two consecutive characters: Return the resulting string after no more operations can be performed. Note: Consider the alphabet as circular, thus 'a' and 'z' are consecutive.","Use a stack to store characters, popping when a match is found",Sort the string and remove adjacent duplicates,Use regular expressions to remove matching adjacent characters,"Iterate through the string with two pointers, swapping adjacent characters if they are the same","Iterate through the string, using a stack or in-place replacement to remove adjacent characters that are 'consecutive' (considering 'a' and 'z' as consecutive)",Medium,algorithms,"String,Stack,Simulation"
3562,"Maximum Profit from Trading Stocks with Discounts
You are given an integer n, representing the number of employees in a company. Each employee is assigned a unique ID from 1 to n, and employee 1 is the CEO. You are given two 1-based integer arrays, present and future, each of length n, where: The company's hierarchy is represented by a 2D integer array hierarchy, where hierarchy[i] = [ui, vi] means that employee ui is the direct boss of employee vi. Additionally, you have an integer budget representing the total funds available for investment. However, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at half the original price (floor(present[v] / 2)). Return the maximum profit that can be achieved without exceeding the given budget. Note:",Use a greedy approach by always buying stocks with the highest profit margin first.,Apply dynamic programming with a 2D table where dp[i][j] represents the maximum profit considering employees up to i with a budget of j.,"Sort the employees by their present stock price and iteratively buy stocks within the budget, considering discounts.",Employ a branch-and-bound algorithm to explore all possible combinations of stock purchases.,"Solve using dynamic programming with a state representing the current employee, remaining budget, and whether the boss's stock was purchased.",Hard,algorithms,"Array,Dynamic Programming,Tree,Depth-First Search"
3563,"Lexicographically Smallest String After Adjacent Removals
You are given a string s consisting of lowercase English letters. You can perform the following operation any number of times (including zero): Return the lexicographically smallest string that can be obtained after performing the operations optimally. Note: Consider the alphabet as circular, thus 'a' and 'z' are consecutive.",Use dynamic programming to determine the optimal removals at each index.,Sort the string and remove adjacent duplicates to find the smallest string.,Greedily remove adjacent characters that are in decreasing order until no such pairs exist.,Recursively explore all possible removal combinations and select the lexicographically smallest.,"Iterate through the string, maintaining a stack to remove larger characters if a smaller one is encountered later.",Hard,algorithms,"String,Dynamic Programming"
3564,"Seasonal Sales Analysis
Table: sales Table: products Write a solution to find the most popular product category for each season. The seasons are defined as: The popularity of a category is determined by the total quantity sold in that season. If there is a tie, select the category with the highest total revenue (quantity × price). Return the result table ordered by season in ascending order. The result format is in the following example.  Example: Input: sales table: products table: Output: Explanation: The result table is ordered by season in ascending order.",Use correlated subqueries to determine the maximum quantity for each season and then join with the products table.,"Use window functions partitioned by season to rank product categories by quantity, and then filter for the rank 1 category, breaking ties with revenue.","Create temporary tables for each season's sales data, compute the total quantity and revenue for each category, and then join these tables to find the most popular category.","Use a recursive CTE to iterate through each season and category, calculating quantity and revenue, and then select the maximum values.","Use conditional aggregation (CASE statements within SUM) to calculate the total quantity and revenue for each category per season, then use ROW_NUMBER() to rank categories within each season based on quantity and revenue.",Medium,database systems,Database
3566,"Partition Array into Two Equal Product Subsets
You are given an integer array nums containing distinct positive integers and an integer target. Determine if you can partition nums into two non-empty disjoint subsets, with each element belonging to exactly one subset, such that the product of the elements in each subset is equal to target. Return true if such a partition exists and false otherwise.","Backtracking, checking every possible subset combination, leading to exponential time complexity","Dynamic programming, storing intermediate products to optimize the search for equal subsets, resulting in O(n*target) time complexity","Greedy approach, always selecting the largest available number for the subset with the smaller product until completion","Simulated annealing, repeatedly making small random changes to the subsets until reaching the target product","Check if the product of all numbers equals the square of the target. If yes, use backtracking to find a subset whose product equals the target.",Medium,algorithms,"Array,Bit Manipulation,Recursion,Enumeration"
3567,"Minimum Absolute Difference in Sliding Submatrix
You are given an m x n integer matrix grid and an integer k. For every contiguous k x k submatrix of grid, compute the minimum absolute difference between any two distinct values within that submatrix. Return a 2D array ans of size (m - k + 1) x (n - k + 1), where ans[i][j] is the minimum absolute difference in the submatrix whose top-left corner is (i, j) in grid. Note: If all elements in the submatrix have the same value, the answer will be 0.",Use dynamic programming to store intermediate minimum differences for overlapping submatrices,Sort the entire grid first and then iterate through k x k submatrices to find the minimum difference,Calculate the sum of all elements in each submatrix and divide by k^2 to estimate the minimum difference,Use a max heap to track the k largest elements in each submatrix and approximate the minimum difference,"For each k x k submatrix, iterate through all pairs of distinct elements and compute the absolute difference, keeping track of the minimum",Medium,algorithms,"Array,Sorting,Matrix"
3568,"Minimum Moves to Clean the Classroom
You are given an m x n grid classroom where a student volunteer is tasked with cleaning up litter scattered around the room. Each cell in the grid is one of the following: You are also given an integer energy, representing the student's maximum energy capacity. The student starts with this energy from the starting position 'S'. Each move to an adjacent cell (up, down, left, or right) costs 1 unit of energy. If the energy reaches 0, the student can only continue if they are on a reset area 'R', which resets the energy to its maximum capacity energy. Return the minimum number of moves required to collect all litter items, or -1 if it's impossible.","Use Dijkstra's algorithm treating litter as nodes and distance as energy cost, without considering resets","Apply a greedy approach, always moving to the nearest litter regardless of energy and reset locations",Perform a depth-first search (DFS) to explore all possible paths without considering energy constraints,"Use A* search with a heuristic that underestimates the remaining moves, but ignores energy resets","Model the problem as a state-space search (e.g., BFS or A*) where each state includes current position and remaining energy, accounting for reset areas",Medium,algorithms,"Array,Hash Table,Bit Manipulation,Breadth-First Search,Matrix"
3569,"Maximize Count of Distinct Primes After Split
You are given an integer array nums having length n and a 2D integer array queries where queries[i] = [idx, val]. For each query: Note: The changes made to the array in one query persist into the next query. Return an array containing the result for each query, in the order they are given.",Use dynamic programming to build a table of prime factor counts for each possible split and update the table based on queries.,"Precompute prime factorizations for all numbers, then iterate through all possible splits for each query, updating factor counts as needed.","Compute all possible array splits, calculate the number of distinct prime factors for each, and then perform updates according to the queries.",Track prime factor counts with a hash map and recompute this map from scratch for each query after the modifications.,Maintain a prime factorization cache and a disjoint set union (DSU) data structure to track connected components of array segments having the same prime factors. Update the DSU based on query modifications.,Hard,algorithms,"Array,Math,Segment Tree,Number Theory"
3570,"Find Books with No Available Copies
Table: library_books Table: borrowing_records Write a solution to find all books that are currently borrowed (not returned) and have zero copies available in the library. Return the result table ordered by current borrowers in descending order, then by book title in ascending order. The result format is in the following example.  Example: Input: library_books table: borrowing_records table: Output: Explanation: Output table is ordered by current_borrowers in descending order, then by book_title in ascending order.","SELECT lb.book_title FROM library_books lb LEFT JOIN borrowing_records br ON lb.book_id = br.book_id WHERE br.return_date IS NULL GROUP BY lb.book_title HAVING COUNT(lb.book_id) = 0 ORDER BY COUNT(DISTINCT br.borrower_id) DESC, lb.book_title ASC","SELECT lb.book_title FROM library_books lb INNER JOIN borrowing_records br ON lb.book_id = br.book_id WHERE br.return_date IS NOT NULL GROUP BY lb.book_title HAVING SUM(CASE WHEN br.return_date IS NULL THEN 1 ELSE 0 END) = COUNT(*) ORDER BY COUNT(DISTINCT br.borrower_id) DESC, lb.book_title ASC","SELECT lb.book_title FROM library_books lb INNER JOIN borrowing_records br ON lb.book_id = br.book_id WHERE br.return_date IS NULL GROUP BY lb.book_title HAVING COUNT(DISTINCT lb.book_id) = 0 ORDER BY COUNT(DISTINCT br.borrower_id) DESC, lb.book_title ASC","SELECT lb.book_title FROM library_books lb LEFT JOIN borrowing_records br ON lb.book_id = br.book_id WHERE br.return_date IS NULL GROUP BY lb.book_title, lb.book_id HAVING COUNT(br.borrower_id) > 0 ORDER BY COUNT(DISTINCT br.borrower_id) DESC, lb.book_title ASC","SELECT lb.book_title FROM library_books lb WHERE NOT EXISTS (SELECT 1 FROM borrowing_records br WHERE lb.book_id = br.book_id AND br.return_date IS NULL) AND lb.book_id IN (SELECT book_id FROM borrowing_records WHERE return_date IS NULL GROUP BY book_id HAVING COUNT(*) > 0) ORDER BY (SELECT COUNT(*) FROM borrowing_records br WHERE lb.book_id = br.book_id AND br.return_date IS NULL) DESC, lb.book_title ASC",Easy,database systems,Database
3572,"Maximize Y‑Sum by Picking a Triplet of Distinct X‑Values
You are given two integer arrays x and y, each of length n. You must choose three distinct indices i, j, and k such that: Your goal is to maximize the value of y[i] + y[j] + y[k] under these conditions. Return the maximum possible sum that can be obtained by choosing such a triplet of indices. If no such triplet exists, return -1.","Iterate through all possible triplets of indices, calculate the sum of the corresponding y values, and return the maximum sum found.","Sort the y array in descending order and sum the first three elements. If the corresponding x values are not distinct, return -1.",Use dynamic programming to store the maximum sum of pairs and then iterate through the remaining elements to find the maximum triplet sum.,Calculate the average of the y array and choose the three elements closest to the average. Return the sum of those elements.,"Use a nested loop approach to iterate through all possible combinations of three distinct indices i, j, and k, checking that x[i], x[j], and x[k] are distinct and maximizing y[i] + y[j] + y[k].",Medium,algorithms,"Array,Hash Table,Greedy,Sorting,Heap (Priority Queue)"
3573,"Best Time to Buy and Sell Stock V
You are given an integer array prices where prices[i] is the price of a stock in dollars on the ith day, and an integer k. You are allowed to make at most k transactions, where each transaction can be either of the following: Normal transaction: Buy on day i, then sell on a later day j where i < j. You profit prices[j] - prices[i]. Short selling transaction: Sell on day i, then buy back on a later day j where i < j. You profit prices[i] - prices[j]. Note that you must complete each transaction before starting another. Additionally, you can't buy or sell on the same day you are selling or buying back as part of a previous transaction. Return the maximum total profit you can earn by making at most k transactions.",A greedy approach considering local maxima and minima to maximize profit in each transaction.,A recursive solution that explores all possible transaction combinations and memoizes the results.,A brute-force approach checking every possible sequence of buy and sell days within the k transaction limit.,Dynamic programming with a 1D array representing profits with only one transaction allowed.,Dynamic programming with a 2D array where dp[i][j] represents max profit with at most i transactions until day j.,Medium,algorithms,"Array,Dynamic Programming"
3574,"Maximize Subarray GCD Score
You are given an array of positive integers nums and an integer k. You may perform at most k operations. In each operation, you can choose one element in the array and double its value. Each element can be doubled at most once. The score of a contiguous subarray is defined as the product of its length and the greatest common divisor (GCD) of all its elements. Your task is to return the maximum score that can be achieved by selecting a contiguous subarray from the modified array. Note:",Calculate the GCD of all possible subarrays and multiply by the number of operations allowed.,"Double every number in the array, calculate all subarray GCDs, and multiply each by its length. Return the maximum.","Iterate through all possible subarray lengths, finding the smallest number in each and multiplying by the length and number of allowed operations.","For each subarray, double only the smallest element and calculate the GCD. Multiply by the length and take the maximum.","Iterate through all contiguous subarrays. For each subarray, try doubling different combinations of elements (up to k doubles total), calculate the GCD, and update the maximum score as length * GCD.",Hard,algorithms,"Array,Math,Enumeration,Number Theory"
3575,"Maximum Good Subtree Score
You are given an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1. Each node i has an integer value vals[i], and its parent is given by par[i]. A subset of nodes within the subtree of a node is called good if every digit from 0 to 9 appears at most once in the decimal representation of the values of the selected nodes. The score of a good subset is the sum of the values of its nodes. Define an array maxScore of length n, where maxScore[u] represents the maximum possible sum of values of a good subset of nodes that belong to the subtree rooted at node u, including u itself and all its descendants. Return the sum of all values in maxScore. Since the answer may be large, return it modulo 109 + 7.","Dynamic programming with bitmasking to represent digit presence, calculating maxScore bottom-up","Depth-first search (DFS) to explore all subtrees, pruning branches that violate digit uniqueness",Greedily selecting nodes with the highest values until a duplicate digit is found in the subtree,Using a disjoint set data structure to merge nodes with unique digits into good subsets,"Post-order traversal with memoization, maintaining a set of seen digits and calculating the maximum score for each subtree",Hard,algorithms,"Array,Dynamic Programming,Bit Manipulation,Tree,Depth-First Search,Bitmask"
3576,"Transform Array to All Equal Elements
You are given an integer array nums of size n containing only 1 and -1, and an integer k. You can perform the following operation at most k times: Choose an index i (0 <= i < n - 1), and multiply both nums[i] and nums[i + 1] by -1. Note that you can choose the same index i more than once in different operations. Return true if it is possible to make all elements of the array equal after at most k operations, and false otherwise.",Always prioritize multiplying elements at the start of the array,"If the number of -1's is even, the answer is always true, regardless of k",Check if the absolute difference between the number of 1s and -1s is less than or equal to k,Use dynamic programming to determine the minimum operations needed to make all elements equal,"Count the number of -1's. If it's even, return true. Otherwise, return true if k is greater than or equal to the number of -1's.",Medium,algorithms,"Array,Greedy"
3577,"Count the Number of Computer Unlocking Permutations
You are given an array complexity of length n. There are n locked computers in a room with labels from 0 to n - 1, each with its own unique password. The password of the computer i has a complexity complexity[i]. The password for the computer labeled 0 is already decrypted and serves as the root. All other computers must be unlocked using it or another previously unlocked computer, following this information: Find the number of permutations of [0, 1, 2, ..., (n - 1)] that represent a valid order in which the computers can be unlocked, starting from computer 0 as the only initially unlocked one. Since the answer may be large, return it modulo 109 + 7. Note that the password for the computer with label 0 is decrypted, and not the computer with the first position in the permutation.",Depth-First Search (DFS),Greedy Algorithm,Breadth-First Search (BFS),Dynamic Programming,Topological Sort with Factorial Calculation,Medium,algorithms,"Array,Math,Brainteaser,Combinatorics"
3578,"Count Partitions With Max-Min Difference at Most K
You are given an integer array nums and an integer k. Your task is to partition nums into one or more non-empty contiguous segments such that in each segment, the difference between its maximum and minimum elements is at most k. Return the total number of ways to partition nums under this condition. Since the answer may be too large, return it modulo 109 + 7.","Use dynamic programming to track the number of valid partitions ending at each index, considering all possible start points for the last segment and checking the max-min difference.","Sort the input array and then iterate through it, greedily forming segments until the max-min difference exceeds k, and count the number of such greedy partitions.","Apply a divide-and-conquer approach, recursively partitioning the array into halves and combining the results, considering partitions that cross the midpoint.","Employ backtracking to explore all possible partition combinations, pruning branches where the max-min difference within a segment exceeds k.","Employ dynamic programming with a recurrence relation where dp[i] represents the number of ways to partition nums[0...i] satisfying the constraint. Iterate from j=0 to i, and if max(nums[j...i]) - min(nums[j...i]) <= k, then dp[i] += dp[j-1].",Medium,algorithms,"Array,Dynamic Programming,Queue,Sliding Window,Prefix Sum,Monotonic Queue"
3579,"Minimum Steps to Convert String with Operations
You are given two strings, word1 and word2, of equal length. You need to transform word1 into word2. For this, divide word1 into one or more contiguous substrings. For each substring substr you can perform the following operations: Replace: Replace the character at any one index of substr with another lowercase English letter. Swap: Swap any two characters in substr. Reverse Substring: Reverse substr. Each of these counts as one operation and each character of each substring can be used in each type of operation at most once (i.e. no single index may be involved in more than one replace, one swap, or one reverse). Return the minimum number of operations required to transform word1 into word2.",Recursively compare characters and increment a counter only when characters differ,Use dynamic programming to store the minimum number of operations for all substrings of word1,"Count the number of differing characters and divide by 2, rounding up to the nearest integer",Calculate the edit distance (Levenshtein distance) between the two strings,"Iterate through the strings, grouping consecutive differing characters into substrings and incrementing a counter for each such group",Hard,algorithms,"String,Dynamic Programming,Greedy"
3580,"Find Consistently Improving Employees
Table: employees Table: performance_reviews Write a solution to find employees who have consistently improved their performance over their last three reviews. Return the result table ordered by improvement score in descending order, then by name in ascending order. The result format is in the following example.  Example: Input: employees table: performance_reviews table: Output: Explanation: The output table is ordered by improvement_score in descending order, then by name in ascending order.",Use a correlated subquery to calculate the improvement score for each employee and then filter based on the condition.,"Utilize window functions like LAG() to access the previous review scores and compute improvement, filtering afterwards.",Join the employees and performance_reviews tables and apply a HAVING clause with a complex aggregate function to check for consistent improvement.,Create a temporary table to store the improvement scores for each employee and then join it back to the employees table for filtering and ordering.,Implement a recursive CTE (Common Table Expression) to iterate through each employee's reviews and check for consistent improvement over the last three reviews.,Medium,database systems,Database
3582,"Generate Tag for Video Caption
You are given a string caption representing the caption for a video. The following actions must be performed in order to generate a valid tag for the video: Combine all words in the string into a single camelCase string prefixed with '#'. A camelCase string is one where the first letter of all words except the first one is capitalized. All characters after the first character in each word must be lowercase. Remove all characters that are not an English letter, except the first '#'. Truncate the result to a maximum of 100 characters. Return the tag after performing the actions on caption.","Use a regular expression to replace non-alphanumeric characters, then split and apply camelCase conversion","Iterate through the string, building words and applying capitalization after all non-alphanumeric characters are removed","Convert the string to a byte array, filter non-alphanumeric bytes, and then reconstruct the string in camelCase","Split the string into words, sort them alphabetically, then combine them into a camelCase string","Split the string into words, lowercase each word after the first character, apply camelCase, remove non-alphanumeric characters, and truncate",Easy,algorithms,"String,Simulation"
3583,"Count Special Triplets
You are given an integer array nums. A special triplet is defined as a triplet of indices (i, j, k) such that: Return the total number of special triplets in the array. Since the answer may be large, return it modulo 109 + 7.",Calculate the sum of all possible triplets and then count the ones that satisfy the condition.,"Sort the array and then iterate through it, checking for triplets that meet the specified criteria.",Use a hash map to store the frequency of each number and then iterate to find valid triplets.,Randomly generate triplets and check if they are special until a certain number of triplets are found.,"Iterate through all possible combinations of i, j, and k and check if each triplet satisfies the condition.",Medium,algorithms,"Array,Hash Table,Counting"
3584,"Maximum Product of First and Last Elements of a Subsequence
You are given an integer array nums and an integer m. Return the maximum product of the first and last elements of any subsequence of nums of size m.",Find the m largest elements and multiply the smallest two among them.,"Sort the array, take the first and last m elements, and multiply them.",Consider all possible subsequences of size m and return the maximum product of the first and last elements found.,"Sort the array, and multiply the first and mth element, then the second and (m-1)th element, and so on, and return the maximum result.",Sort the array. The maximum product will either be the product of the two smallest elements (if negative) or the two largest. Choose the larger product among those.,Medium,algorithms,"Array,Two Pointers"
3585,"Find Weighted Median Node in Tree
You are given an integer n and an undirected, weighted tree rooted at node 0 with n nodes numbered from 0 to n - 1. This is represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates an edge from node ui to vi with weight wi. The weighted median node is defined as the first node x on the path from ui to vi such that the sum of edge weights from ui to x is greater than or equal to half of the total path weight. You are given a 2D integer array queries. For each queries[j] = [uj, vj], determine the weighted median node along the path from uj to vj. Return an array ans, where ans[j] is the node index of the weighted median for queries[j].","Depth-First Search (DFS) from uj to vj, always choosing the heavier edge.",Dijkstra's Algorithm to find the shortest path and then binary search on the path.,"Breadth-First Search (BFS) from uj to vj, tracking cumulative weights, returning the last visited node.","Compute all paths from uj to vj using brute force, then select the median node from the path with the minimum weight.","Find the path from uj to vj, compute the cumulative weights along the path, and return the first node where the cumulative weight exceeds half the total path weight.",Hard,algorithms,"Array,Binary Search,Dynamic Programming,Tree,Depth-First Search"
11,What is the difference between an array and a linked list?,Arrays have fixed size while linked lists have dynamic size.,Arrays allow random access while linked lists only allow sequential access.,"Arrays store elements in contiguous memory locations, while linked lists store elements in non-contiguous memory locations.",Arrays require pre-allocation of memory while linked lists allocate memory during runtime.,All of the above,Easy,Data Structures,"['array', 'linked list', 'data structures']"
12,Explain the time complexity of an algorithm.,The amount of memory the algorithm requires,The number of lines of code in the algorithm,The hardware specifications required to run the algorithm,The actual clock time taken to execute the algorithm on a specific input,How the execution time of the algorithm grows as the input size increases,Hard,Data Structures,"['algorithms', 'complexity analysis', 'big O notation']"
13,Describe the difference between a binary search tree and a hash table.,"A binary search tree uses a hash function for data retrieval, while a hash table uses comparisons.","A binary search tree guarantees O(1) average case lookup, insertion, and deletion, while a hash table offers O(log n) in the average case.",A binary search tree is generally more space-efficient than a hash table due to not requiring extra space for collision resolution.,"A binary search tree supports range queries and ordered traversal, while a hash table provides faster average-case lookup but does not inherently maintain order.","A binary search tree organizes data in a hierarchical structure based on key comparisons, while a hash table uses a hash function to map keys to indices in an array.",Medium,Data Structures,"['data structures', 'binary search tree', 'hash table']"
14,What is a linked list and how does it work?,A contiguous block of memory storing elements of the same data type.,A hierarchical data structure where elements are arranged in a tree-like manner.,"A collection of key-value pairs, similar to a dictionary or hash table.",An array that automatically resizes when more elements are added than its initial capacity.,"A linear data structure where elements are stored in nodes, and each node contains a value and a pointer to the next node.",Medium,Data Structures,"['linked list', 'data structure', 'nodes']"
15,Explain the concept of recursion.,A programming technique where a function calls a different function within its definition.,A looping construct that allows repeating a block of code until a condition is met.,"A data structure that follows the Last-In, First-Out (LIFO) principle.",A method of writing code that avoids the use of any loops or conditional statements.,A programming technique where a function calls itself directly or indirectly within its definition.,Medium,Data Structures,"['recursion', 'function call', 'base case']"
16,"What is Big O notation, and why is it important?",A specific number representing the exact operations a program will execute.,A measure of code readability based on lines of code and comments.,A tool for optimizing code execution speed by profiling CPU usage.,A low-level programming language used for operating system kernels.,A way to classify algorithms based on how their runtime or space requirements grow as the input size grows.,Medium,Data Structures,"['algorithms', 'time complexity', 'space complexity']"
17,How do you perform a binary search on a sorted array?,Start at the beginning of the array and compare each element to the target value until found.,Divide the array into three equal parts and compare the target value with the two dividing elements.,"Randomly pick an index and check if the element is the target, repeat until found or the array is exhausted.","Compare the target value with the last element of the array. If larger, return not found, otherwise, repeat with the remaining array.","Repeatedly divide the search interval in half. If the middle element is the target, return its index. If the target is less than the middle element, search the left half. Otherwise, search the right half.",Hard,Data Structures,"['binary search', 'sorted array', 'divide and conquer']"
18,Discuss the advantages and disadvantages of different sorting algorithms.,Bubble Sort is always the fastest due to its simple implementation.,Merge Sort has the best average-case time complexity but suffers from high space complexity due to its in-place nature.,Quick Sort guarantees O(n log n) performance but can be significantly slower with already sorted data.,"Insertion Sort is optimal for large, unsorted datasets because of its divide-and-conquer approach.","Merge Sort offers a stable, O(n log n) time complexity, but can require extra memory. Quick Sort is typically faster in practice but can degrade to O(n^2) in the worst case. Insertion Sort is efficient for small or nearly sorted data, while Bubble Sort is generally inefficient.",Medium,Data Structures,"['sorting algorithms', 'time complexity', 'space complexity']"
19,Explain how a hash table works.,"Stores elements in a sorted array, using binary search for lookups.",Uses a tree-like structure where each node represents a key and value pair.,Employs a single linked list where each element is sequentially traversed for access.,"Relies on a linear probing approach, placing all elements directly into consecutive memory locations.","Uses a hash function to map keys to indices in an array, allowing for fast average-case lookups, insertions, and deletions.",Medium,Data Structures,"['hash table', 'hash function', 'data structure']"
20,What is dynamic programming?,A programming paradigm focused on declarative code and immutable state.,A technique for optimizing compilers by rearranging instructions.,"A method for solving problems by dividing them into smaller, overlapping subproblems and storing the solutions to these subproblems to avoid recomputation.",A software development methodology that emphasizes rapid prototyping and iterative development.,An algorithmic technique that optimizes recursive algorithms by storing results of expensive function calls and reusing them when the same inputs occur again.,Hard,Data Structures,"['dynamic programming', 'memoization', 'optimization']"
71,Describe the concept of microservices architecture.,"A monolithic application split into independent, versioned modules within a single deployable unit.","A single, large application with a well-defined API for external access.",A system where front-end and back-end components are tightly coupled and deployed together.,A service-oriented architecture (SOA) where services share a common database.,"An architectural style that structures an application as a collection of small, autonomous services, modeled around a business domain.",Medium,System Design,"['microservices', 'architecture', 'distributed systems']"
72,"What is a load balancer, and why is it used in web applications?",A server that handles static content and offloads the main application server.,A database management system that distributes data across multiple servers.,A caching mechanism that stores frequently accessed data to reduce server load.,A firewall that protects the application from malicious attacks and unauthorized access.,"A network device that distributes incoming network traffic across multiple servers to ensure no single server is overwhelmed, improving performance and availability.",Medium,System Design,"['load balancing', 'web application', 'high availability']"
73,Explain the importance of caching in web applications.,Increases server load due to increased memory usage and management overhead,Guarantees real-time data consistency across all users,Reduces the cost of infrastructure by requiring more powerful servers,Complicates application deployment and scaling processes,Reduces latency and improves application performance by storing and reusing frequently accessed data,Medium,System Design,"['caching', 'web applications', 'performance']"
74,What is a CDN (Content Delivery Network)?,A network that monitors and filters internet traffic for malicious content.,A system for distributing and managing digital certificates.,A type of local area network (LAN) used in small offices.,A protocol for encrypting communication between a client and a server.,A geographically distributed network of proxy servers and their data centers.,Medium,System Design,"['CDN', 'networking', 'distributed systems']"
75,Discuss the pros and cons of monolithic vs. microservices architecture.,"Monoliths are easily scalable horizontally, while microservices require complex deployment strategies.","Microservices are inherently more secure due to their isolated nature, unlike the single attack surface of a monolith.",Monoliths offer independent deployments which are faster than microservices deployments,Microservices are simpler to develop and maintain due to smaller codebases and limited complexity compared to monolithic systems.,"Monoliths simplify cross-cutting concerns implementation, while microservices promote independent scaling and fault isolation.",Medium,System Design,"['system design', 'microservices', 'monolith']"
76,What is a stateless vs. stateful service?,"A stateful service maintains client information between requests, while a stateless service relies on external sources for client context.","A stateful service always uses a database for storing data, while a stateless service uses only in-memory data structures.","A stateful service processes requests in a fixed order, while a stateless service can process requests in any order.",A stateful service is more scalable than a stateless service due to its ability to manage client sessions effectively.,"A stateless service treats each request independently, requiring all necessary information in each request, while a stateful service retains client data from previous interactions.",Hard,System Design,"['system design', 'microservices', 'scalability']"
77,Explain the concept of CAP theorem in distributed systems.,Guarantees Consistency and Partition Tolerance but sacrifices Availability in distributed systems.,"States that any distributed system can guarantee all three of: Consistency, Atomicity, and Partition Tolerance.",Prioritizes Availability and Partition Tolerance while ignoring the need for Consistency.,"Requires all distributed system designs to implement strong consistency, even under network partitions.","States that in a distributed system, it is impossible to simultaneously guarantee Consistency, Availability, and Partition Tolerance; one must choose two.",Easy,System Design,"['distributed systems', 'CAP theorem', 'consistency']"
78,How do you ensure data consistency in a distributed database?,Rely solely on eventual consistency with no conflict resolution,Use optimistic locking with application-level conflict resolution,Employ client-side caching with periodic synchronization,Implement quorum-based voting without version vectors,Implement distributed transactions using protocols like two-phase commit (2PC) or Paxos/Raft for consensus,Hard,System Design,"['distributed database', 'consistency', 'transactions']"
79,Describe the role of a reverse proxy in a web application.,"To directly serve static content, bypassing the application server.",To load balance traffic across multiple databases.,To provide a single point of failure for enhanced security.,To manage and optimize client-side caching strategies.,"To act as an intermediary, forwarding client requests to backend servers while providing benefits like security, load balancing, and caching.",Medium,System Design,"['reverse proxy', 'load balancing', 'security']"
80,"What is a message broker, and when would you use one?",A centralized server for managing user authentication and authorization across multiple applications.,A software application that directly connects producers and consumers of data using peer-to-peer networking.,A library for inter-process communication within a single operating system kernel.,A database management system optimized for storing message queues.,"An intermediary that translates and routes messages between applications, decoupling senders and receivers.",Medium,System Design,"['message queue', 'asynchronous communication', 'system design']"
81,"What is SQL injection, and how can it be prevented?",Exploiting operating system vulnerabilities to gain unauthorized access,A denial-of-service attack targeting database servers by flooding them with requests,Intercepting network traffic and modifying SQL queries in transit,Bypassing authentication mechanisms by manipulating session cookies,A code injection technique that exploits vulnerabilities in data-driven applications where malicious SQL statements are inserted into an entry field for execution,Medium,Security,"['SQL injection', 'security', 'database systems']"
82,Explain the concept of Cross-Site Scripting (XSS).,A technique where an attacker injects arbitrary SQL code into a database query through a web application.,A denial-of-service attack that exploits the cross-origin resource sharing (CORS) mechanism.,A type of phishing attack that targets a specific individual or group within an organization.,An attack that exploits vulnerabilities in the browser's rendering engine to execute arbitrary code.,An attack where malicious scripts are injected into otherwise benign and trusted websites.,Medium,Security,"['security', 'web security', 'injection attack']"
83,What is two-factor authentication (2FA)?,A security system that requires a biometric scan for access,A single-factor authentication system using a very strong password,A type of encryption that requires two separate keys to decrypt data,A firewall configuration requiring two administrators to approve any changes,An authentication method requiring two independent factors to verify a user's identity,Hard,Security,"['security', 'authentication', '2FA']"
84,Describe the process of password hashing and salting.,"Storing passwords in plaintext, then applying a Base64 encoding",Encrypting the password using a symmetric encryption algorithm like AES,Computing a simple checksum of the password using CRC32,Using a cryptographic hash function on the password without any salt,"Generating a random salt, concatenating it with the password, and then applying a one-way cryptographic hash function",Medium,Security,"['security', 'hashing', 'salting']"
85,"What is OAuth, and how does it work?",A proprietary authentication protocol developed by Microsoft for Windows Active Directory.,A decentralized authentication system based on blockchain technology.,A form of multi-factor authentication using hardware tokens.,A standard for encrypting data at rest and in transit using AES-256.,An open standard authorization protocol that enables secure delegated access to resources without sharing credentials.,Medium,Security,"['authentication', 'authorization', 'security']"
86,How do you protect against session fixation attacks?,Using predictable session IDs.,Storing session IDs in client-side cookies without the 'HttpOnly' flag.,Setting a very long session timeout.,Using HTTP (unencrypted) connections.,Regenerating the session ID after successful authentication.,Medium,Security,"['security', 'session management', 'authentication']"
87,Explain the principles of least privilege and defense in depth.,"Defense in depth relies on making all system code open source for peer review, while least privilege mandates background checks for all employees.","Least privilege involves granting all users complete administrative access to all systems so they can perform their job efficiently, while defense in depth requires only a firewall.","Defense in depth focuses on preventing physical access to server rooms, while least privilege dictates that all data must be encrypted at rest and in transit.","Least privilege means giving every user the same set of default rights, while defense in depth ensures that all systems have identical hardware and software configurations.","Least privilege means granting users only the minimum necessary rights to perform their job, while defense in depth employs multiple layers of security controls to protect assets.",Hard,Security,"['security principles', 'access control', 'layered security']"
88,What is a DDoS (Distributed Denial of Service) attack?,An attack that exploits vulnerabilities in the Domain Name System to redirect traffic to malicious servers.,An attack where an attacker gains unauthorized access to a database and exfiltrates sensitive information.,An attack that exploits weaknesses in a web application to inject malicious code into user browsers.,An attack that involves sending unsolicited emails in bulk to overwhelm a mail server.,"An attack where multiple compromised systems flood a target with traffic, making it unavailable to legitimate users.",Medium,Security,"['DDoS', 'security', 'network attack']"
89,How can you secure sensitive data in a mobile app?,Store data in shared preferences without encryption,Rely solely on obfuscation to protect code and data,Hardcode API keys and secrets directly in the app's source code,Disable SSL/TLS to improve network performance,"Encrypt sensitive data at rest and in transit, using secure storage and network protocols, and implement proper key management.",Medium,Security,"['mobile security', 'encryption', 'key management']"
90,Discuss the importance of security in API design.,Security is irrelevant in API design as it's handled by network protocols,"Security primarily concerns the underlying infrastructure, not the API design itself",Security considerations are only important after the API has been fully implemented,Security is solely about preventing unauthorized access and does not affect API functionality,"Security is crucial in API design to protect data, prevent abuse, ensure authentication/authorization, and maintain integrity",Medium,Security,"['API design', 'security', 'authentication']"
151,Design a distributed key-value store.,"Employ a single central server for all key-value pair storage and retrieval, handling scaling through vertical upgrades of the server.","Utilize consistent hashing to distribute key-value pairs across a cluster of servers, with data replication limited to a single backup node per primary.","Implement a master-slave architecture where the master handles all write requests and replicates data to read-only slaves, with eventual consistency.","Rely on a gossip protocol for data dissemination and conflict resolution, ensuring all nodes eventually converge on the same state without explicit coordination.","Use consistent hashing for data partitioning and replication across multiple servers, combined with a consensus algorithm (e.g., Raft or Paxos) for strong consistency during write operations.",Hard,System Design,"['distributed systems', 'consistent hashing', 'consensus algorithms']"
152,Implement a function to check if a binary tree is balanced.,Check if the difference between the number of nodes in the left and right subtrees is at most 1,Verify if the tree is a complete binary tree,Confirm that all leaf nodes are at the same level,Ensure that the sum of the values in the left and right subtrees are equal,"Determine the height of the left and right subtrees for each node and ensure the difference is no more than 1, recursively",Hard,Algorithms,"['binary tree', 'recursion', 'height']"
153,Design a URL shortening service like bit.ly.,Use a bloom filter to check for existing shortened URLs and a linear probing collision resolution strategy,Employ a simple counter as a key and store mappings in a relational database with auto-incrementing IDs,Utilize a consistent hashing algorithm across multiple servers and a time-based counter for key generation,Pre-generate all possible shortened URLs and store them in a distributed cache for immediate access,Implement a base-62 encoding scheme on an auto-incrementing ID and store mappings in a key-value store,Hard,System Design,"['system design', 'hashing', 'encoding']"
155,Write an algorithm to find the median of a stream of numbers.,"Use a sorted array, inserting each number using binary search and calculating the median after each insertion.",Store the numbers in a hash table and calculate the median by iterating through the table and sorting the elements.,"Maintain a single sorted list, adding new elements at the end, and sorting at each step.",Use a min-heap to store all elements and calculate the median.,"Maintain two heaps: a max-heap for the smaller half and a min-heap for the larger half, balancing them as needed.",Hard,Algorithms,"['heap', 'data stream', 'median']"
158,Design a chat application that can scale to millions of users.,"Use a single, large relational database to store all messages and user data.",Rely solely on server-sent events (SSE) for real-time communication to minimize server load.,Implement a peer-to-peer (P2P) architecture to distribute the message load across users' devices.,"Employ long polling for all clients to ensure reliable message delivery, even with spotty connections.","Utilize a distributed message queue (e.g., Kafka, RabbitMQ) and multiple application server instances behind a load balancer.",Hard,System Design,"['system design', 'scalability', 'message queue']"
160,Design a scalable notification system for a social network.,"Use a single message queue for all notification types, processed sequentially",Implement a polling mechanism where clients periodically check for updates,"Utilize a central database table to store all notifications, querying it frequently",Employ a peer-to-peer architecture where clients directly notify each other,"Employ multiple message queues based on notification priority and user activity, coupled with fan-out for widespread events",Hard,System Design,"['system design', 'message queue', 'scalability']"
162,Design and implement a concurrent hash map.,"Employ a single global lock for all operations, ensuring atomicity at the cost of concurrency","Use copy-on-write for all modifications, creating a new copy of the entire map for each update","Divide the hash map into segments, each protected by its own lock, and use optimistic locking within segments","Utilize a lock-free data structure with atomic operations on individual buckets, but without any resizing mechanism","Employ a sharded approach with fine-grained locking or lock-free techniques at the bucket level, coupled with concurrent resizing strategies",Hard,Data Structures,"['concurrency', 'hash map', 'distributed systems']"
163,Find the Kth largest element in a stream of numbers.,"Maintain a sorted array of size k, replacing the smallest element if a larger element arrives.","Use a min-heap of size k, replacing the root if a larger element arrives and heapifying.",Sort the entire stream after each insertion and then directly return the element at index k.,Use a max-heap for all the elements encountered and extract k times.,Use a min-heap of size k to store the k largest elements seen so far.,Hard,Algorithms,"['heap', 'priority queue', 'streaming algorithm']"
164,Implement Google's PageRank algorithm.,"Perform a breadth-first search (BFS) on the graph, assigning ranks based on the order of traversal.",Assign a random rank to each page and update iteratively by equally distributing the rank to all pages.,"Use a single iteration over the graph, calculating each page's rank based solely on the number of its incoming links.",Calculate the eigenvector centrality of the graph's adjacency matrix using singular value decomposition (SVD).,"Iteratively update each page's rank based on the ranks of pages linking to it, incorporating a damping factor to account for random jumps.",Hard,Algorithms,"['graph algorithms', 'Markov chain', 'eigenvector centrality']"
165,Design an API rate limiter for a web service.,"Use a simple counter that increments with each request and resets after a fixed period, without considering individual clients.","Implement a token bucket algorithm with a single shared bucket for all clients, ignoring client-specific rate limits.","Employ a leaky bucket algorithm, processing requests at a constant rate without tracking request origins.","Store request timestamps in a single global array, checking for rate limits across all clients regardless of their individual limits.",Utilize a distributed sliding window algorithm with Redis to track request counts per client and enforce rate limits.,Hard,System Design,"['API', 'rate limiting', 'distributed systems']"
166,Optimize database queries for a high-traffic website.,Disable query caching to ensure data consistency,Use only SELECT * statements for simplicity,Rely solely on the ORM's default configurations,Avoid using indexes to reduce write overhead,"Implement query caching, use indexes strategically, and optimize query structure",Hard,Database Systems,"['database systems', 'query optimization', 'performance']"
167,Create a secure and scalable authentication system for a web application.,Store user credentials directly in the application's source code repository.,Use a simple hash function like MD5 with no salt for password storage.,Implement a custom session management system using browser cookies and server-side caching without proper security measures.,Bypass authentication checks for internal services to improve performance.,"Employ a multi-factor authentication (MFA) system with strong password policies, salted password hashing (e.g., bcrypt or Argon2), and token-based authentication (e.g., OAuth 2.0 or JWT).",Hard,Security,"['authentication', 'security', 'scalability']"
168,Design a system for efficient storage and retrieval of large-scale time-series data.,Use a relational database with extensive indexing on the timestamp column.,Store the data in a NoSQL document store with each document representing a single data point.,Implement a caching layer using Redis to store frequently accessed data.,Utilize a message queue system like Kafka to buffer incoming data before writing it to storage.,"Employ a time-series database optimized for temporal data storage and retrieval, potentially with data aggregation and compression.",Hard,Database Systems,"['time-series database', 'data storage', 'system design']"
170,Design an efficient parking lot management system.,Use a single global lock for all parking operations.,Implement a round-robin allocation strategy without considering vehicle size.,"Store parking lot data in a simple text file, updating it with each transaction.","Assume a fixed number of parking spots, regardless of demand fluctuations.","Employ a distributed system with consistent hashing and optimistic locking for concurrency and scalability, considering vehicle types and spot availability.",Hard,System Design,"['system design', 'concurrency', 'scalability']"
173,Design a real-time multiplayer online game architecture.,Utilize a peer-to-peer network for direct communication between all players.,Implement a client-side prediction model and rely solely on UDP for minimal latency.,Employ a sharded database architecture with eventual consistency to manage game state.,Design a monolithic server application running on a single powerful machine.,Establish a client-server architecture with authoritative server-side game logic and state management.,Hard,System Design,"['game architecture', 'real-time', 'multiplayer']"
175,Optimize a search algorithm for a large dataset in a distributed environment.,Use a centralized index server to coordinate search requests across nodes.,Implement a naive linear search on each node and aggregate results.,Replicate the entire dataset on each node to enable local searches.,Employ a broadcast-based search where each node queries all others.,"Utilize a distributed indexing technique like sharding or consistent hashing, coupled with a parallel search algorithm.",Hard,Algorithms,"['distributed systems', 'search algorithms', 'indexing']"
177,Build a high-frequency trading system and discuss its components.,Utilize a centralized message queue for all order processing and market data dissemination.,Implement all system components using a single programming language to minimize latency.,Store all historical market data in a relational database for later analysis and backtesting.,"Employ a single, monolithic application server to handle all trading logic and risk management.","Distribute components across multiple servers with low-latency network connectivity, utilizing in-memory databases and direct market access.",Hard,System Design,"['system design', 'high-frequency trading', 'low latency']"
180,Design a fraud detection system for online transactions.,Employ a rule-based system with predefined fraud patterns and thresholds,Utilize a simple anomaly detection algorithm based on transaction amount alone,Implement a system that flags all transactions originating from a specific country,Store all transaction data without any analysis or flagging mechanisms,Combine machine learning models with real-time data streams and rule-based filters to identify suspicious activities,Hard,Security,"['fraud detection', 'machine learning', 'system design']"
182,Design a global video streaming service like Netflix.,"Use a single, monolithic database for all video metadata, user accounts, and billing information to minimize operational overhead.","Implement a content delivery network (CDN) with edge servers strategically located near users to cache popular content and reduce latency, but avoid dynamic content caching to ensure freshness.",Rely on a single encoding format for all video content to simplify encoding workflows and reduce storage costs.,Design the system with a single point of failure to minimize complexity and reduce the number of potential attack vectors.,"Employ a microservices architecture with separate services for video streaming, user authentication, recommendations, and billing, using a distributed database and a CDN for content delivery.",Hard,System Design,"['system design', 'microservices', 'CDN']"
183,Create a system to efficiently match job seekers with job postings.,"Employ a first-in-first-out (FIFO) queue to store all jobs and seekers, then compare sequentially",Use a relational database with simple queries based on keywords in job descriptions and seeker profiles,Implement a decision tree that matches skills one at a time using a predefined branching structure,Leverage a content delivery network (CDN) to cache job postings and seeker profiles for faster access,"Utilize an inverted index to map skills to job seekers and postings, enabling fast lookups based on keywords",Hard,Algorithms,"['inverted index', 'information retrieval', 'system design']"
186,Develop an autonomous vehicle's path planning algorithm.,Employ a greedy algorithm that prioritizes the shortest immediate distance without considering future states.,Utilize a genetic algorithm where paths are evolved over generations through crossover and mutation.,Implement a rule-based system relying on a predefined set of if-then-else rules to navigate the environment.,Apply a reinforcement learning approach where the vehicle learns optimal paths through trial and error and a reward function.,"Use A* search, combining a cost function (distance traveled) with a heuristic (estimated distance to the goal).",Hard,Algorithms,"['path planning', 'A* search', 'heuristics']"
187,Design a scalable and reliable messaging system for a large corporation.,Implement a centralized message queue with a single point of failure.,Use a peer-to-peer architecture without message persistence.,Rely solely on in-memory caching for message delivery.,Implement a system with eventual consistency but without delivery guarantees.,"Utilize a distributed message queue with redundancy, persistence, and at-least-once delivery semantics.",Hard,System Design,"['message queue', 'scalability', 'reliability']"
189,Create an efficient algorithm for real-time anomaly detection in network traffic.,Implement a simple threshold-based rule to flag traffic exceeding a predefined rate.,Utilize a moving average of traffic volume and signal anomalies exceeding a certain standard deviation.,Employ a Kalman filter to predict traffic patterns and identify deviations from the expected trajectory.,Use a Bloom filter to identify unusual combinations of source/destination IPs.,Train an autoencoder neural network to learn normal traffic patterns and detect anomalies as high reconstruction errors.,Hard,Algorithms,"['anomaly detection', 'network traffic', 'machine learning']"
190,Design a system to manage and process Internet of Things (IoT) data.,Use a monolithic architecture with a centralized database and a single processing server.,Implement edge computing by processing data locally on IoT devices and transmitting summaries to the cloud.,Store all IoT data in a relational database and use SQL queries for analysis.,Use a message queue to buffer data before processing to handle spikes in traffic.,"Employ a distributed architecture with message queues, stream processing, and a time-series database.",Hard,System Design,"['IoT', 'system design', 'distributed systems']"
192,Implement a robust text editor with features like auto-complete and syntax highlighting.,Use a finite state machine to parse and highlight keywords based on regular expressions.,"Employ a brute-force approach, re-parsing the entire document on every keystroke.",Leverage web browser APIs and DOM manipulation for rendering and styling the text.,Store text as a single string and use string methods for all editing operations.,"Utilize a gap buffer data structure for efficient insertion and deletion, coupled with incremental parsing for syntax highlighting.",Hard,Algorithms,"['text editor', 'data structures', 'parsing']"
193,Design a scalable infrastructure for an online advertising platform.,Utilize a monolithic architecture with a single database instance for all data storage and retrieval.,Implement a serverless architecture with direct connections from user devices to backend databases.,Employ a peer-to-peer network where each advertiser's machine hosts a portion of the ad inventory.,Build a system based on a single message queue for all ad requests and responses.,"Design a microservices architecture with separate services for ad serving, targeting, billing, and reporting, using distributed caching and databases.",Hard,System Design,"['system design', 'scalability', 'microservices']"
195,Optimize an SQL database for a high-volume financial transaction system.,Disable transaction logging to reduce write overhead,Rely solely on NoSQL databases for faster data retrieval,"Implement a single, large table with minimal indexing",Use exclusively memory-resident databases without persistent storage,"Implement proper indexing, partitioning, and caching strategies, and optimize query performance",Hard,Database Systems,"['database optimization', 'SQL', 'performance']"
196,Design a cloud-based virtual desktop infrastructure.,"Utilize a single, monolithic virtual machine image for all users to minimize storage overhead.",Implement a stateless desktop model where user data is stored locally on the virtual machines.,Rely solely on server-side rendering and thin clients to reduce the processing load on the cloud infrastructure.,"Provision dedicated GPU instances for all users, regardless of their application requirements, to guarantee optimal performance.","Employ a layered approach with a master image, user profiles stored separately, and on-demand application streaming.",Hard,System Design,"['cloud computing', 'virtualization', 'VDI']"
198,Implement a quantum algorithm for solving a well-known computational problem.,Use Grover's algorithm directly to search the solution space,Employ Shor's algorithm without considering the problem's specific structure,Simulate the problem classically with exponential time complexity,Design a quantum neural network and train it on classical data,Formulate a quantum circuit that utilizes quantum Fourier transform and phase estimation to solve the problem,Hard,Algorithms,"['quantum algorithm', 'quantum Fourier transform', 'phase estimation']"
199,Design a secure mobile payment system for developing countries.,"Employ solely SMS-based transaction verification due to network limitations, foregoing any hardware security module (HSM)","Utilize solely public Wi-Fi networks to reduce infrastructure costs, minimizing encryption to preserve bandwidth","Rely exclusively on biometric authentication (fingerprint) neglecting multi-factor approaches, without compensating for potential data breaches of stored fingerprint templates","Implement a centralized architecture with a single point of failure for transaction processing, prioritizing speed over fault tolerance","Employ end-to-end encryption, multi-factor authentication using a combination of biometrics, PINs, and OTPs, and a decentralized architecture with HSMs for key management.",Hard,Security,"['security', 'mobile payment', 'cryptography']"
200,Build a scalable image processing pipeline for a photo-sharing app.,Process all images synchronously on a single server instance to guarantee order,Store images in a NoSQL database without any pre-processing steps,Use client-side JavaScript to perform image resizing and compression before uploading,Implement a custom message queue using TCP sockets for distributing image processing tasks,"Utilize a distributed message queue (e.g., Kafka, RabbitMQ) to asynchronously process images using a cluster of worker nodes",Hard,System Design,"['system design', 'image processing', 'message queue']"
https://www.hackerrank.com/challenges/count-strings?isFullScreen=true,"A regular expression is used to describe a set of strings. For this problem the alphabet is limited to 'a' and 'b'.
We define
to be a valid regular expression if:
1)
is ""
"" or ""
"".
2)
is of the form ""
"", where
and
are regular expressions.
3)
is of the form ""
"" where
and
are regular expressions.
4)
is of the form ""
"" where
is a regular expression.
Regular expressions can be nested and will always have have two elements in the parentheses. ('
' is an element, '
' is not; basically, there will always be pairwise evaluation) Additionally, '
' will always be the second element; '
' is invalid.
The set of strings recognized by
are as follows:
1) If
is ""
"", then the set of strings recognized
.
2) If
is ""
"", then the set of strings recognized
.
3) If
is of the form ""
"" then the set of strings recognized = all strings which can be obtained by a concatenation of strings
and
, where
is recognized by
and
by
.
4) If
is of the form ""
"" then the set of strings recognized = union of the set of strings recognized by
and
.
5) If
is of the form ""
"" then the the strings recognized are the empty string and the concatenation of an arbitrary number of copies of any string recognized by
.
Task
Given a regular expression and an integer,
, count how many strings of length
are recognized by it.
Input Format
The first line contains the number of test cases
.
test cases follow.
Each test case contains a regular expression,
, and an integer,
.
Constraints
It is guaranteed that
will conform to the definition provided above.
Output Format
Print
lines, one corresponding to each test case containing the required answer for the corresponding test case. As the answers can be very big, output them modulo
.
Sample Input
3
((ab)|(ba)) 2
((a|b)*) 5
((a*)(b(a*))) 100
Sample Output
2
32
100
Explanation
For the first case, the only strings recognized are ""
"" and ""
"". Of the
possible strings of length
,
of them fit that expression.
For the second case, the RegEx recognizes any string of any length containing only
's and
's. The number of strings of length
recognized by this expression is
.
For the third case, the RegEx recognizes any string having one
, preceeded and followed by any number of
's. There are
strings of length
which have a single
in them.","Dynamic programming with memoization, storing results for sub-expressions and string lengths.","Convert the regular expression to a DFA, then count paths of length N from the start to accept states.",Recursively evaluate the regular expression for all possible strings of length N and count matches.,"Simplify the regular expression using algebraic manipulation, then count matching strings directly.",Use dynamic programming to build a table where dp[i][j] is true if a string of length i can be generated by sub-expression j.,,algorithms,"['regular expression', 'dynamic programming', 'string matching']"
https://www.hackerrank.com/challenges/kingdom-connectivity?isFullScreen=true,"It has been a prosperous year for King Charles and he is rapidly expanding his empire. In fact, he recently invaded his neighboring country and set up a new kingdom! This kingdom has many cities connected by
one-way roads.
To ensure higher connectivity, two cities are sometimes directly linked by more than one road.
In the new kingdom, King Charles has made one of the cities his financial capital and another city his warfare capital. He wants a better connectivity between these two capitals. The connectivity of a pair of cities,
and
, is defined as the number of different paths from city
to city
. A path may use a road more than once if possible. Two paths are considered different if they do not use the same sequence of roads the same number of times.
There are
cities numbered
to
in the new kingdom and
one-way roads
. City
is the financial capital and city
is the warfare capital.  Determine the number of different paths between cities
and
. Since the number may be large, print the result modulo
or
.
Note:
Two roads may connect the same cities, but they are still considered distinct for path connections.
For example, there are
cities connected by
roads as shown in the following graph:
https://s3.amazonaws.com/hr-assets/0/1544118885-4df6f8d3d2-kingdomconnectionsexample.png
There are two direct paths and one cyclic path.  Direct paths are
and
and
.  The cycle
can be repeated any number of times, so there are infinite paths.  If the connection
did not exist, there would be only the two direct paths.
Function Description
Complete the
countPaths
function in the editor below.  It should print your result, modulo
if there are limited paths or
INFINITE PATHS
if they are unlimited. There is no expected return value.
countPaths has the following parameters:
-
n
: the integer number of cities
-
edges
: a 2D integer array where
is the source city and
is the destination city for the directed road
Input Format
The first line contains two integers
and
.
Each of the following
lines contains two space-separated integers that represent source and destination cities for a directed connection.
Constraints
Output Format
Print the number of different paths from city
to city
modulo
. If there are infinitely many different paths, print
INFINITE PATHS
.
Sample Input
Sample Input 0
5 5
1 2
2 4
2 3
3 4
4 5
Sample Output 0
2
Explanation 0
https://s3.amazonaws.com/hr-assets/0/1544114786-0bdccfc41c-kingdomconnectionssample0.png
There are two possible paths from city
to city
:
Sample Input 1
5 5
1 2
4 2
2 3
3 4
4 5
Sample Output 1
INFINITE PATHS
Explanation 1
https://s3.amazonaws.com/hr-assets/0/1544115010-5330c83bf8-kingdomconnectionssample1.png
The cycle in the graph can be traversed an infinite number of times on the way to city
.","Use dynamic programming to store the number of paths from each city to the destination, avoiding cycles.","Perform a depth-first search (DFS) and count the paths, returning 'INFINITE PATHS' if a cycle is detected during the search from the source to itself.",Employ a breadth-first search (BFS) to find all possible paths and check for path uniqueness. After which apply the modulo.,Utilize Dijkstra's algorithm to find the shortest path between the cities and return the number of such paths.,"Detect cycles using Tarjan's algorithm or Kosaraju's algorithm. If a cycle exists reachable from the source and leading to the destination, return 'INFINITE PATHS'. Otherwise, use dynamic programming or DFS with memoization to count distinct paths modulo 1000000007.",,algorithms,"['graph theory', 'dynamic programming', 'cycle detection']"
https://www.hackerrank.com/challenges/morgan-and-a-string?isFullScreen=true,"Jack and Daniel are friends. Both of them like letters, especially uppercase ones.
They are cutting uppercase letters from newspapers, and each one of them has his collection of letters stored in a stack.
One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack.  Morgan wants to use all of the letters in their collections.
As an example, assume Jack has collected
and Daniel has
.  The example shows the top at index
for each stack of letters. Assemble the string  as follows:
Jack
Daniel
result
ACA
BCF
CA
BCF
A
CA
CF
AB
A
CF
ABC
A
CF
ABCA
F
ABCAC
ABCACF
Note
the choice when there was a tie at
CA
and
CF
.
Function Description
Complete the
morganAndString
function in the editor below.
morganAndString has the following parameter(s):
string a
: Jack's letters, top at index
string b
: Daniel's letters, top at index
Returns
-
string
: the completed string
Input Format
The first line contains the an integer
, the number of test cases.
The next
pairs of lines are as follows:
- The first line contains string
- The second line contains string
.
Constraints
and
contain upper-case letters only, ascii[A-Z].
Sample Input
2
JACK
DANIEL
ABACABA
ABACABA
Sample Output
DAJACKNIEL
AABABACABACABA
Explanation
The first letters to choose from are J and D since they are at the top of the stack. D is chosen and the options now are J and A. A is chosen. Then the two stacks have J and N, so J is chosen. The current string is DA. Continue this way to the end to get the string.",Always choose from string 'a' if both characters are equal,Compare the remaining substrings of 'a' and 'b' at each step to decide which character to pick,Sort both strings individually before merging them based on lexicographical order,Prepend the smaller character to the result string regardless of position,"Use two pointers to iterate through the strings, comparing characters and handling equal characters by looking ahead",,algorithms,"['string comparison', 'lexicographical order', 'two pointers']"
https://www.hackerrank.com/challenges/red-knights-shortest-path?isFullScreen=true,"In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the
red knight
.
The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below.
https://s3.amazonaws.com/hr-challenge-images/0/1479394883-0caf08859d-Capture1.PNG
The board is a grid of size
. Each cell is identified with a pair of coordinates
, where
is the row number and
is the column number, both zero-indexed. Thus,
is the upper-left corner and
is the bottom-right corner.
Complete the function
printShortestPath
, which takes as input the grid size
, and the coordinates of the starting and ending position
and
respectively, as input. The function does not return anything.
Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word ""Impossible"".
Note:
There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority:
UL, UR, R, LR, LL, L
. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input
for an illustration.
Input Format
The first line of input contains a single integer
. The second line contains four space-separated integers
.
denotes the coordinates of the starting position and
denotes the coordinates of the final position.
Constraints
the starting and the ending positions are different
Output Format
If the destination can be reached, print two lines. In the first line, print a single integer denoting the minimum number of moves that the red knight has to make in order to reach the destination. In the second line, print the space-separated sequence of moves.
If the destination cannot be reached, print a single line containing only the word
Impossible
.
Sample Input 0
7
6 6 0 1
Sample Output 0
4
UL UL UL L
Explanation 0
https://s3.amazonaws.com/hr-assets/0/1497577745-346b70e024-Capture1.PNG
Sample Input 1
6
5 1 0 5
Sample Output 1
Impossible
Explanation 1
https://s3.amazonaws.com/hr-assets/0/1497577769-631949c493-Capture2.PNG
Sample Input 2
7
0 3 4 3
Sample Output 2
2
LR LL
Explanation 2
https://s3.amazonaws.com/hr-assets/0/1497577793-1e86b71144-Capture3.PNG",Use a depth-first search algorithm with a limited recursion depth to avoid infinite loops.,"Apply a greedy algorithm, always choosing the move that gets the knight closest to the destination in Euclidean distance.",Implement a genetic algorithm to evolve a population of possible paths and select the shortest one.,"Calculate the Manhattan distance between the start and end points and divide by two, rounding up to find the minimum moves.",Employ a breadth-first search algorithm to explore all possible paths and find the shortest path in terms of moves.,,algorithms,"['graph traversal', 'breadth-first search', 'shortest path']"
https://www.hackerrank.com/challenges/two-robots?isFullScreen=true,"You have a warehouse with
containers filled with an infinite number of candies. The containers are arranged in a single row, equally spaced to be
meter apart. You also have
robots that can pick up
piece of candy and transport it between any two containers.
The robots take instructions in the form of
queries
consisting of two integers,
and
, respectively. To execute a query, a robot travels to container
, picks up
candy, transports it to container
, and then stops at
until it receives another query.
Calculate the
minimum total distance
the robots must travel to execute
queries
in order
.
Note:
You choose which robot executes each query.
Input Format
The first line contains a single integer,
(the number of test cases); each of the
test cases is described over
lines.
The first line of a test case has two space-separated integers,
(the number of containers) and
(the number of queries).
The
subsequent lines each contain two space-separated integers,
and
, respectively; each line
describes the
query.
Constraints
Output Format
On a new line for each test case, print an integer denoting the
minimum total distance
that the robots must travel to execute the queries in order.
Sample Input
3
5 4
1 5
3 2
4 1
2 4
4 2
1 2
4 3
10 3
2 4
5 4
9 8
Sample Output
11
2
5
Explanation
In this explanation, we refer to the two robots as
and
, each container
as
, and the total distance traveled for each query
as
.
Note:
For the first query a robot executes, there is no travel distance. For each subsequent query that robot executes, it must travel from the location where it completed its last query.
Test Case 0:
The minimum distance traveled is
:
Robot:
meters.
Robot:
meter.
Robot:
meters.
Robot:
meters.
Sum the distances traveled (
) and print the result on a new line.
Test Case 1:
Robot:
meters.
Robot:
meters.
Sum the distances traveled (
) and print the result on a new line.
Test Case 2:
Robot:
meters.
Robot:
meters.
Robot:
meters.
Sum the distances traveled (
) and print the result on a new line.",Always assign each new query to the closest available robot,Assign each query to a specific robot in a round-robin fashion,Assign all queries to the robot that has traveled the least distance so far,Sort the queries by their start and end locations before assigning to robots,Use dynamic programming to track the minimum distance for each robot to reach each container after each query,,algorithms,"['dynamic programming', 'optimization', 'robotics']"
https://www.hackerrank.com/challenges/coin-change?isFullScreen=true,"Given an amount and the denominations of coins available, determine how many ways change can be made for amount.  There is a limitless supply of each coin type.
Example
There are
ways to make change for
:
,
, and
.
Function Description
Complete the
getWays
function in the editor below.
getWays has the following parameter(s):
int n:
the amount to make change for
int c[m]:
the available coin denominations
Returns
int:
the number of ways to make change
Input Format
The first line contains two space-separated integers
and
, where:
is the amount to change
is the number of coin types
The second line contains
space-separated integers that describe the values of each coin type.
Constraints
Each
is guaranteed to be distinct.
Hints
Solve overlapping subproblems using
Dynamic Programming
(DP):
You can solve this problem recursively but will not pass all the test cases without optimizing to eliminate the
overlapping subproblems
. Think of a way to store and reference previously computed solutions to avoid solving the same subproblem multiple times.
* Consider the degenerate cases:
- How many ways can you make change for
cents?
    - How many ways can you make change for
cents if you have no coins?
* If you're having trouble defining your solutions store, then think about it in terms of the base case
.
- The answer may be larger than a
-bit integer.
Sample Input 0
4 3
1 2 3
Sample Output 0
4
Explanation 0
There are four ways to make change for
using coins with values given by
:
Sample Input 1
10 4
2 5 3 6
Sample Output 1
5
Explanation 1
There are five ways to make change for
units using coins with values given by
:","Recursively explore all combinations of coins, incrementing a counter for each valid combination and pruning branches when the sum exceeds the target amount.","Greedily select the largest denomination coin less than or equal to the remaining amount, repeating until the amount is zero, and return 1. If the amount becomes negative, return 0.","Compute the product of all coin denominations, then divide the target amount by this product. Return the integer part of the result.","Sort the coin denominations in descending order and iterate, counting the number of times each coin can fully divide the amount. Sum these counts.","Employ dynamic programming, building a table where dp[i][j] stores the number of ways to make change for amount 'i' using the first 'j' coin denominations.",,algorithms,"['dynamic programming', 'coin change', 'recursion']"
https://www.hackerrank.com/challenges/happy-king?isFullScreen=true,"The King of Byteland wants to grow his territory by conquering
other countries. To prepare his
heirs for the future, he decides they must work together to capture each country.
The King has an army,
, of
battalions; the
battalion has
soldiers. For each battle, the heirs get a detachment of soldiers to share but will fight amongst themselves and lose the battle if they don't each command the same number of soldiers (i.e.: the detachment must be divisible by
). If given a detachment of size
, the heirs will fight alone without any help.
The battalions chosen for battle must be selected in the following way:
A subsequence of
battalions must be selected (from the
battalions in army
).
The
battle will have a squad of soldiers from the
selected battalion such that its size is divisible by
.
The soldiers within a battalion have unique strengths. For a battalion of size
, the detachment of soldiers
is
different
from the detachment of soldiers
The King tasks you with finding the number of ways of selecting
detachments of battalions to capture
countries using the criterion above. As this number may be quite large, print the answer modulo
.
Input Format
The first line contains two space-separated integers,
(the number of battalions in the King's army) and
(the number of countries to conquer), respectively.
The second line contains
space-separated integers describing the King's army,
, where the
integer denotes the number of soldiers in the
battalion (
).
Constraints
holds for test cases worth at least
of the problem's score.
Output Format
Print the number of ways of selecting the
detachments of battalions modulo
.
Sample Input
3 2
3 4 5
Sample Output
20
Explanation
First, we must find the ways of selecting
of the army's
battalions; then we must find all the ways of selecting detachments for each choice of battalion.
Battalions
:
has
soldiers, so the only option is an empty detachment (
).
has
soldiers, giving us
detachment options (
and
).
So for this subset of battalions, we get
possible detachments.
Battalions
:
has
soldiers, so the only option is an empty detachment (
).
has
soldiers, giving us
detachment options (
,
,
,
,
,
).
So for this subset of battalions, we get
possible detachments.
Battalions
:
has
soldiers, giving us
detachment options (
and
).
has
soldiers, giving us
detachment options (
,
,
,
,
,
).
So for this subset of battalions, we get
possible detachments.
In total, we have
ways to choose detachments, so we print
, which is
.","The number of ways to choose subsequences of length K from N, multiplied by the product of battalion sizes modulo M.","The sum of divisors of each battalion size, modulo M, raised to the power of K.","Iterate through all possible subsequences of length K, calculate the number of divisors for each selected battalion, and find the product modulo M.","Calculate the product of battalion sizes, find the Kth root, and then take modulo M of the result.","Iterate through all subsequences of length K, calculate the number of divisors for each battalion in the subsequence, multiply these counts together, sum the results for all subsequences, and finally take the modulo M.",,algorithms,"['dynamic programming', 'subsequence', 'divisors']"
https://www.hackerrank.com/challenges/permutation-game?isFullScreen=true,"Alice and Bob play the following game:
They choose a permutation of the numbers
to
.
Alice plays first and they alternate.
In a turn, they can remove any one remaining number from the permutation.
The game ends when the remaining numbers form an increasing sequence of
or more numbers. The person who played the turn that leaves an increasing sequence wins the game.
Assuming both play optimally, who wins the game? Return
Alice
or
Bob
.
Example
This is the starting permutation to analyze,
.  First, Alice chooses
or
. For the example, Alice chooses
and leaves
.  Since this is a decreasing sequence, Bob can remove any number for optimum play.  He will lose regardless.  Alice then removes any number leaving an array of only one element.  Since Alice removed the last element to create an increasing sequence, Alice wins.
Function Description
Complete the
permutationGame
function in the editor below.
permutationGame has the following parameter:
-
int arr[n]:
the starting permutation
Returns
string:
either
Alice
or
Bob
Input Format
The first line contains the number of test cases
.
Each of the next
pairs of lines is in the following format:
- The first line contains an integer
, the size of the array
- The second line contains
space-separated integers,
where
Constraints
The permutation will not be an increasing sequence initially.
Sample Input
STDIN       Function
-----       --------
2           t = 2
3           arr[] size n = 3
1 3 2       arr = [1, 3, 2]
5           n = 5
5 3 2 1 4   arr = [5, 3, 2, 1, 4]
Sample Output
Alice
Bob
Explanation
For the first test, Alice can remove
or
to leave an increasing sequence and win the game.
For the second test, if
is removed then the only way to have an increasing sequence is to only have
number left.  This takes a total of
moves, and Bob wins.
If Alice removes the
on the first move, it will take
more moves to create an increasing sequence. Bob wins.
If Alice removes something else, Bob can remove
on his next turn to create the same game state.  It is a decreasing sequence with
numbers left.",Bob,It depends on the initial array elements.,They will always tie.,It depends on the length of the array.,Alice,,algorithms,"['game theory', 'permutations', 'optimal play']"
https://www.hackerrank.com/challenges/almost-integer-rock-garden?isFullScreen=true,"Victor is building a
Japanese rock garden
in his
square courtyard. He overlaid the courtyard with a
Cartesian coordinate system
so that any point
in the courtyard has coordinates
and
. Victor wants to place
stones in the garden according to the following rules:
The center of each stone is located at some point
, where
and
are integers
.
The coordinates of all twelve stones are pairwise distinct.
The
Euclidean distance
from the center of any stone to the
origin
is
not an integer
.
The sum of Euclidean distances between all twelve points and the origin is an
almost integer
, meaning the absolute difference between this sum and an integer must be
.
Given the values of
and
for the first stone Victor placed in the garden, place the remaining
stones according to the requirements above. For each stone you place, print two space-separated integers on a new line describing the respective
and
coordinates of the stone's location.
Input Format
Two space-separated integers describing the respective values of
and
for the first stone's location.
Constraints
Output Format
Print
lines, where each line contains two space-separated integers describing the respective values of
and
for a stone's location.
Sample Input 0
7 11
Sample Output 0
11 1
-2 12
5 4
12 -3
10 3
9 6
-12 -7
1 11
-6 -6
12 -4
4 12
Explanation 0
The diagram below depicts the placement of each stone and maps its distance to the origin (note that
red
denotes the first stone placed by Victor and
blue
denotes the eleven remaining stones we placed):
https://s3.amazonaws.com/hr-assets/0/1487931639-e8d05e48d9-image-with-roots.png
Now, let's determine if the sum of these distances is an almost integer. First, we find the distance from the origin to the stone Victor placed at
, which is
. Next, we calculate the distances for the remaining stones we placed in the graph above:
When we sum these eleven distances with the distance for the stone Victor placed, we get
. The nearest integer to this number is
, and the distance between this sum and the nearest integer is
(meaning it's an almost integer). Because this configuration satisfies all of Victor's rules for his rock garden, we print eleven lines of
x y
coordinates describing the locations of the stones we placed.",A* search algorithm,Breadth-first search,Depth-first search,Bellman-Ford algorithm,Simulated Annealing,,algorithms,"['optimization', 'euclidean distance', 'integer constraints']"
https://www.hackerrank.com/challenges/computer-game?isFullScreen=true,"Sophia is playing a game on the computer. There are two random arrays A & B, each having the same number of elements. The game begins with Sophia removing a pair (A
i
, B
j
) from the array if they are not
co-prime
. She keeps a count on the number of times this operation is done.
Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value?
Input Format
The first line contains an integer
n
. 2 lines follow, each line containing
n
numbers separated by a single space. The format is shown below.
n
A[0] A[1] ... A[n - 1]
B[0] B[1] ... B[n - 1]
Constraints
0 < n <= 10
5
2 <= A[i], B[i] <= 10
9
Each element in both arrays are generated randomly between 2 and 10
9
Output Format
Output S which is the maximum number of times the above operation can be made.
Sample Input
4
2 5 6 7
4 9 10 12
Sample Output
3
Explanation
You can remove:
(2, 4)
(5, 10)
(6, 9)
hence 3.","Compute the greatest common divisor (GCD) for all pairs (A[i], B[j]) and count the pairs where GCD is 1.","Sort both arrays and greedily remove pairs (A[i], B[j]) with the smallest GCD greater than 1.","Remove pairs (A[i], B[i]) if their GCD is greater than 1, then check the remaining elements for other possible pairs.","For each A[i], find the smallest B[j] such that GCD(A[i], B[j]) > 1 and remove that pair. Repeat until no such pairs exist.","Use a maximum bipartite matching algorithm where edges exist between A[i] and B[j] if GCD(A[i], B[j]) > 1.",,algorithms,"['GCD', 'bipartite matching', 'number theory']"
https://www.hackerrank.com/challenges/xoring-ninja?isFullScreen=true,"An
XOR
operation on a list is defined here as the
xor
(
) of all its elements (e.g.:
).
The
of set
is defined here as the sum of the
s of all non-empty subsets of
known as
. The set
can be expressed as:
For example:
Given set
The set of possible non-empty subsets is:
The
of these non-empty subsets is then calculated as follows:
=
Given a list of
space-separated integers, determine and print
.
For example,
.  There are three possible subsets,
.  The XOR of
, of
and of
.  The XorSum is the sum of these:
and
.
Note:
The cardinality of
powerset
is
, so the set of non-empty subsets of set
of size
contains
subsets.
Function Description
Complete the
xoringNinja
function in the editor below.  It should return an integer that represents the XorSum of the input array, modulo
.
xoringNinja has the following parameter(s):
arr
: an integer array
Input Format
The first line contains an integer
, the number of test cases.
Each test case consists of two lines:
-  The first line contains an integer
, the size of the set
.
-  The second line contains
space-separated integers
.
Constraints
Output Format
For each test case, print its
on a new line.  The
line should contain the output for the
test case.
Sample Input 0
1
3
1 2 3
Sample Output 0
12
Explanation 0
The input set,
, has
possible non-empty subsets:
.
We then determine the
of each subset in
:
Then sum the results of the
of each individual subset in
, resulting in
and
.
Sample Input 1
2
4
1 2 4 8
5
1 2 3 5 100
Sample Output 1
120
1648","Calculate the XOR sum by iterating through all subsets using bit manipulation and summing the results, without modulo during subset calculation, only at the final return.","Return 0, as XORing all possible subsets will always result in a zero value due to cancellations.",Calculate the XOR sum by taking the XOR of all elements in the input array and multiplying it by the number of subsets which is n.,Calculate the XOR sum by summing all the elements in the array and taking the result modulo 1000000007.,"Calculate the XOR of all elements, then multiply by 2^(n-1) modulo 1000000007.",,algorithms,"['xor', 'bit manipulation', 'subsets']"
https://www.hackerrank.com/challenges/definite-random-walks?isFullScreen=true,"Alex has a board game consisting of:
A
chip
for marking his current location on the board.
fields
numbered from
to
. Each position
has a value,
, denoting the
next
position for the chip to jump to from that field.
A
die
with
faces numbered from
to
. Each face
has a probability,
, of being rolled.
Alex then performs the following actions:
Begins the game by placing the chip at a position in a field randomly and with equiprobability.
Takes
turns; during each turn he:
Rolls the die. We'll denote the number rolled during a turn as
.
Jumps the chip
times. Recall that each field contains a value denoting the
next
field number to jump to.
After completing
turns, the game ends and he must calculate the respective probabilities for each field as to whether the game ended with the chip in that field.
Given
,
,
, the game board, and the probabilities for each
die
face, print
lines where each line
contains the probability that the chip is on field
at the end of the game.
Note:
All the probabilities in this task are rational numbers modulo
. That is, if the probability can be expressed as the irreducible fraction
where
, then it corresponds to the number
(or, alternatively,
).
Click here
to learn about
Modular Multiplicative Inverse
.
Input Format
The first line contains three space-separated integers describing the respective values of
(the number of positions),
(the number of die faces), and
(the number of turns).
The second line contains
space-separated integers describing the respective values of each
(i.e., the index of the field that field
can transition to).
The third line contains
space-separated integers describing the respective values of each
(where
) describing the probabilities of the faces of the
-sided die.
Constraints
The sum of
is
Note:
The time limit for this challenge is doubled for
all
languages. Read more about standard time limits at our
environment
page.
Output Format
Print
lines of output in which each line
contains a single integer,
(where
), denoting the probability that the chip will be on field
after
turns.
Sample Input 0
4 5 1
2 3 2 4
332748118 332748118 332748118 0 0
Sample Output 0
582309206
332748118
332748118
748683265
Explanation 0
The diagram below depicts the respective probabilities of each
die
face being rolled:
https://s3.amazonaws.com/hr-challenge-images/0/1483777335-a85270bb02-definite-random-walks-die.png
The diagram below depicts each field with an arrow pointing to the
next
field:
https://s3.amazonaws.com/hr-challenge-images/0/1483777393-34df81ee2a-definite-random-walks-fields.png
There are four equiprobable initial fields, so each field has a
probability of being the chip's initial location. Next, we calculate the probability that the chip will end up in each field after
turn:
The only way the chip ends up in this field is if it never jumps from the field, which only happens if Alex rolls a
. So, this field's probability is
. We then calculate and print the result of
on a new line.
The chip can end up in field
after one turn in the following scenarios:
Start in field
and roll a
, the probability for which is
.
Start in field
and roll a
or a
, the probability for which is
.
Start in field
and roll a
, the probability for which is
.
After summing these probabilities, we get a total probability of
for the field. We then calculate and print the result of
on a new line.
The chip can end up in field
after one turn in the following scenarios:
Start in field
and roll a
, the probability for which is
.
Start in field
and roll a
, the probability for which is
.
Start in field
and roll a
or a
, the probability for which is
.
After summing these probabilities, we get a total probability of
for the field. We then calculate and print the result of
on a new line.
If the chip is initially placed in field
, it will always end up in field
regardless of how many turns are taken (because this field loops back onto itself). Thus, this field's probability is
. We then calculate and print the result of
on a new line.",Use a depth-first search (DFS) algorithm to explore all possible game states within the given turn limit.,"Employ a greedy algorithm, prioritizing fields with higher transition probabilities to maximize the final field probability.","Approximate the probabilities using Monte Carlo simulation, running a large number of simulated games.",Model the game as a Markov chain and calculate the stationary distribution after the given number of steps.,"Use dynamic programming to compute the probabilities of being in each field after each turn, based on the probabilities from the previous turn.",,algorithms,"['dynamic programming', 'probability', 'game']"
https://www.hackerrank.com/challenges/diameter-minimization?isFullScreen=true,"We define the
diameter
of a
strongly-connected
oriented
graph,
, as the minimum integer
such that for each
there is a path from
to
of length
(recall that a path's length is its number of edges).
Given two integers,
and
, build a strongly-connected oriented graph with
vertices where each vertex has
outdegree
and
the graph's diameter is as small as possible
(see the
Scoring
section below for more detail). Then print the graph according to the
Output Format
specified below.
Here's a sample strongly-connected oriented graph with
nodes, whose outdegree is
and diameter is
.
https://s3.amazonaws.com/hr-assets/0/1487903169-c6a2be14b5-ScreenShot2017-02-24at7.52.34am.png
Note:
Cycles and multiple edges between vertices are allowed.
Input Format
Two space-separated integers describing the respective values of
(the number of vertices) and
(the outdegree of each vertex).
Constraints
Scoring
We denote the diameter of your graph as
and the diameter of the graph in the author's solution as
. Your score for each test case (as a real number from
to
) is:
if
if
if
Output Format
First, print an integer denoting the diameter of your graph on a new line.
Next, print
lines where each line
(
) contains
space-separated integers in the inclusive range from
to
describing the endpoints for each of vertex
's outbound edges.
Sample Input 0
5 2
Sample Output 0
2
1 4
2 0
3 1
4 2
0 3
Explanation 0
The diagram below depicts a strongly-connected oriented graph with
nodes where each node has an outdegree of
:
https://s3.amazonaws.com/hr-assets/0/1487146171-d70bfb003c-draw.jpg
The diameter of this graph is
, which is minimal as the outdegree of each node must be
. We cannot construct a graph with a smaller diameter of
because it requires an outbound edge from each vertex to each other vertex in the graph (so the outdegree of that graph would be
).",Use Dijkstra's algorithm to find the shortest path between all pairs of vertices and take the maximum of these distances.,Perform a Breadth-First Search (BFS) from each vertex and track the maximum distance found during each search.,Apply the Floyd-Warshall algorithm to compute all-pairs shortest paths and then find the maximum shortest path length.,Calculate the eccentricity of each node using Depth-First Search (DFS) and return the maximum eccentricity.,"Perform a Breadth-First Search (BFS) from each vertex, tracking the maximum distance reachable from that vertex. The diameter is the minimum of these maximum distances.",,algorithms,"['graph theory', 'diameter', 'BFS']"
https://www.hackerrank.com/challenges/king-richards-knights?isFullScreen=true,"King Richard is leading a troop of
knights into battle! Being very organized, he labels his knights
and arranges them in an
square formation, demonstrated below:
https://s3.amazonaws.com/hr-challenge-images/19174/1467511713-dd93440d86-3.png
Before the battle begins, he wants to test how well his knights follow instructions. He issues
drill commands, where each command follows the format
a
i
b
i
d
i
and is executed like so:
All knights in the square having the top-left corner at location
and the bottom-right corner at location
rotate
in the clockwise direction. Recall that some location
denotes the cell located at the intersection of row
and column
. For example:
https://s3.amazonaws.com/hr-challenge-images/19174/1464176872-408a1e73ae-1.png
You must follow the commands sequentially.
The square for each command is completely contained within the square for the previous command
. Assume all knights follow the commands perfectly.
After performing all
drill commands, it's time for battle! King Richard chooses knights
for his first wave of attack; however, because the knights were reordered by the drill commands, he's not sure where his chosen knights are!
As his second-in-command, you must
find the locations of the knights
. For each knight
,
, print the knight's
row
and
column
locations as two space-separated values on a new line.
Input Format
This is broken down into three parts:
The first line contains a single integer,
.
The second line contains a single integer,
.
Each line
of the
subsequent lines describes a command in the form of three space-separated integers corresponding to
,
, and
, respectively.
The next line contains a single integer,
.
Each line
of the
subsequent lines describes a knight the King wants to find in the form of a single integer corresponding to
.
Constraints
and
and
Subtask
for
of the maximum score.
Output Format
Print
lines of output, where each line
contains two space-separated integers describing the respective
row
and
column
values where knight
is located.
Sample Input
7
4
1 2 4
2 3 3
3 4 1
3 4 0
7
0
6
9
11
24
25
48
Sample Output
1 1
1 7
4 6
3 4
2 5
2 4
7 7
Explanation
The following diagram demonstrates the sequence of commands:
https://s3.amazonaws.com/hr-challenge-images/19174/1464179944-d4f6f0027e-21.png
Click
here
to download a larger image.
In the final configuration:
Knight
is at location
Knight
is at location
Knight
is at location
Knight
is at location
Knight
is at location
Knight
is at location
Knight
is at location",Use a Disjoint Set Union (DSU) data structure to efficiently track knight movements and locations.,Simulate the rotations using matrix operations and track the final positions of each knight.,Implement a recursive function that performs the rotations and searches for knights in the final state.,Store knight positions in a hashmap and update the hashmap after each rotation command.,"Simulate the rotations step-by-step, updating knight positions in a 2D array after each command.",,algorithms,"['array manipulation', 'simulation', 'rotations']"
https://www.hackerrank.com/challenges/dorsey-thief?isFullScreen=true,"Mr. Dorsey Dawson recently stole
grams of gold from ACME Jewellers. He is now on a train back home. To avoid getting caught by the police, he has to convert all the gold he has into paper money. He turns into a salesman and starts selling the gold in the train.
There are
passengers who have shown interest in buying the gold. The
passenger agrees to buy
grams of gold by paying
dollars. Dawson wants to escape from the police and also maximize the profit. Can you help him maximize the profit?
Note
: The
passenger would buy
exactly
grams if the transaction is successful.
Input Format
The first line contains two space separated integers,
and
,  where
is the number of passengers who agreed to buy and
is the stolen amount of gold (in grams).
lines follow. Each line contains two space separated integers -
and
, where
is the the value which the
passenger has agreed to pay in exchange for
grams of gold.
Constraints
all
's and
's are less than or equal to
and greater than
.
Output Format
If it's possible for Dorsey to escape, print the maximum profit he can enjoy, otherwise print
Got caught!
.
Sample Input 0
4 10
460 4
590 6
550 5
590 5
Sample Output 0
1140
Explanation 0
Selling it to passengers buying 4 grams and 6 grams would lead to 1050 dollars whereas selling it to passengers buying 5 grams gold would lead to 1140 dollars. Hence the answer.
Sample Input 1
4 9
100 5
120 10
300 2
500 3
Sample Output 1
Got caught!
Explanation 1
There is no way to sell all 9 grams of gold.","Sort passengers by price per gram, then greedily select the highest bidders until all gold is sold.",Use dynamic programming to determine the maximum profit achievable for each possible amount of gold.,Calculate the profit for all possible combinations of passengers and select the maximum.,"Prioritize passengers who offer the most dollars regardless of the amount of gold they buy, selling to each until either the passenger's need or the gold is exhausted.",Use dynamic programming to determine if selling all gold is possible and to calculate the maximum profit.,,algorithms,"['dynamic programming', 'knapsack problem', 'optimization']"
https://www.hackerrank.com/challenges/count-ways-1?isFullScreen=true,"Little Walter likes playing with his toy scales. He has
types of weights. The
weight type has weight
. There are infinitely many weights of each type.
Recently, Walter defined a function,
, denoting the number of different ways to combine several weights so their total weight is equal to
. Ways are considered to be different if there is a type which has a different number of weights used in these two ways.
For example, if there are
types of weights with corresonding weights
,
, and
, then there are
ways to get a total weight of
:
Use
weights of type
.
Use
weights of type
.
Use
weight of type
and
weight of type
.
Use
weight of type
.
Given
,
,
, and
, can you find the value of
?
Input Format
The first line contains a single integer,
, denoting the number of types of weights.
The second line contains
space-separated integers describing the values of
, respectively
The third line contains two space-separated integers denoting the respective values of
and
.
Constraints
Note:
The time limit for C/C++ is
second, and for Java it's
seconds.
Output Format
Print a single integer denoting the answer to the question. As this value can be very large, your answer must be modulo
.
Sample Input
3
1 2 3
1 6
Sample Output
22
Explanation","Use dynamic programming with a 2D table where dp[i][j] stores the number of ways to form weight j using the first i weights. The time complexity would be O(n*W), where n is the number of weight types and W is the target weight.","Recursively explore all possible combinations of weights, pruning branches that exceed the target weight. This approach will lead to exponential time complexity and likely time out.","Sort the weight types in descending order and greedily select the largest possible number of each weight type until the target weight is reached. This method only finds one possible combination, not the total number of ways.","Calculate the number of ways to reach each weight value from 1 to W using only the first weight type. Then, for each subsequent weight type, update the number of ways based on the previously calculated values. This assumes each weight type is only used once.","Implement dynamic programming with a 1D array dp[j] representing the number of ways to form weight j. Iterate through each weight type, updating dp[j] by adding dp[j - weight[i]] for all j >= weight[i]. Modulo the result at each step.",,algorithms,"['dynamic programming', 'combinatorics', 'modulo']"
https://www.hackerrank.com/challenges/beadornaments?isFullScreen=true,"There are
colors of beads. You have
beads of the
color. You want to make an ornament by joining all the beads together. You create the ornament by using the following algorithm:
Step #
Arrange all the beads in any order such that beads of the same color are placed together.
Step #
The ornament initially consists of only the first bead from the arrangement.
Step #
For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament.
All beads are distinct, even if they have the same color. Two ornaments are considered different if two beads are joined by a thread in one configuration, but not in the other.  How many different ornaments can be formed using this algorithm? Return the answer modulo
.
Update/clarification
Think of the bead formation as a tree and not as a straight line. Any number of beads can be connected to a bead.
Example
There are two beads of color
:
and
.  These can occur as
or
.  In both cases, the same two beads are joined, so the arrangements are not different.  There is
way to join these beads.
There are two beads of two colors,
.  They can be arranged as
,
,
and
.  Call these groups
,
,
and
.  The 8 possible arranements of groups are shown below.
1 A1, B1 = a1, a2, b1, b2
2 A2, B1 = a2, a1, b1, b2
3 A1, B2 = a1, a2, b2, b1
4 A2, B2 = a2, a1, b2, b1
5 B1, A1 = b1, b2, a1, a2
6 B2, A1 = b2, b1, a1, a2
7 B1, A2 = b1, b2, a2, a1
8 B2, A2 = b2, b1, a2, a1
Note that in line 1,
,
and
are the connections.  This also occurs on line 8, so these two lines are not different.  In fact, line 8 is just line 1 reversed, like flipping the string of beads end for end.  Using the same logic, the other similar lines are
.  There are only 4 different arrangements.
Function Description
Complete the
beadOrnaments
function in the editor below.
beadOrnaments
has the following parameters:
int b[n]:
the number of beads of each color
Returns
int:
the number of arrangements modulo
Input Format
The first line contains the number of test cases
.
Each of the following
pairs of lines contain:
- An integer,
, the number of elements in array
-
space-separated integers that comprise
Constraints
Sample Input
STDIN       Function
-----       --------
5           T = 5
2           b[] size n = 2
2 1         b = [2, 1]
2           n = 2
2 2         b = [2, 2]
1           n = 1
4           b = [4]
2           n = 2
3 1         b = [3, 1]
5           n = 5
1 1 1 1 1   b = [1, 1, 1, 1, 1]
Sample Output
2
4
16
9
125
Explanation
Testcase 1:
Let us label the beads A1,A2 and B1. Initially, they can be arranged in
ways - ""A1,A2,B1"", ""A2,A1,B1"", ""B1,A1,A2"", and ""B1,A2,A1"".
For each of the first two arrangements, an ornament can be formed in
ways (A1-A2-B1 or B1-A1-A2 from the first one and A2-A1-B1 or B1-A2-A1 from the second one).
For each of the last two arrangements, an ornament can be formed in
way.
However, of the total
possible ornaments, there are only
unique ones : A1 - A2 - B1, and A2 - A1 - B1.
Testcase 2:
The possible unique ornaments are A1 - A2 - B1 - B2, A1 - A2 - B2 - B1, A2 - A1 - B1 - B2, and A2 - A1 - B2 - B1.
Testcase 3:
For the third test-case, it might be easier to see there are only
types of graphs on
vertices: the path or the star. It's not hard to see that there are
paths and
stars (explanation courtesy: zlangley)
Testcase 5:
For the fifth test-case, a lot of people claimed that the total number of possible ways is
. But that is wrong. The correct answer is
. Here's the hint: Once again, you've to think of it as a tree.
So one possible arrangement can be:
A is a root node and has two edges (A-B and A-C). Now, think of B as a sub-root node with two edges (B-D and B-E). Similarly, you can figure out the other possible bead arrangements. This will lead you to the correct answer.","Calculate the product of the number of beads of each color raised to the power of the number of colors minus 1, modulo 1000000007.",Calculate the sum of (number of beads of each color - 1) and take the factorial modulo 1000000007.,"Calculate the product of the number of beads of each color, then multiply by n!, where n is the number of colors, modulo 1000000007.","Return n raised to the power of the sum of all beads minus n, where n is the number of colors, all modulo 1000000007.",Calculate the product of (number of beads of each color raised to the power of (number of beads -1)) modulo 1000000007.,,algorithms,"['combinatorics', 'modular arithmetic', 'trees']"
https://www.hackerrank.com/challenges/jack-goes-to-rapture?isFullScreen=true,"Jack has just moved to a new city called Rapture. He wants to use the public public transport system. The fare rules are as follows:
Each pair of connected stations has a fare assigned to it regardless of direction of travel.
If Jack travels from station A to station B, he only has to pay the  difference between (the fare from A to B) and (the cumulative fare paid to reach station A),  [
fare(A,B) - total fare to reach station A
].  If the difference is negative, travel is free of cost from A to B.
Jack is low on cash and needs your help to figure out the most cost efficient way to go from the first station to the last station. Given the number of stations
(numbered from
to
), and the fares (weights) between the
pairs of stations that are connected, determine the lowest fare from station
to station
.
Example
The graph looks like this:
https://s3.amazonaws.com/hr-assets/0/1543613276-d83580f86b-raptureexample.png
Travel from station
costs
for the first segment (
) then the cost differential, an additional
for the remainder.  The total cost is
.
Travel from station
costs
for the first segment, then an additional
for the remainder, a total cost of
.
The lower priced option costs
.
Function Description
Complete the
getCost
function in the editor below.
getCost has the following parameters:
int g_nodes:
the number of stations in the network
int g_from[g_edges]:
end stations of a bidirectional connection
int g_to[g_edges]:
is connected to
at cost
int g_weight[g_edges]:
the cost of travel between associated stations
Prints
-
int or string:
the cost of the lowest priced route from station
to station
or
NO PATH EXISTS
.  No return value is expected.
Input Format
The first line contains two space-separated integers,
and
, the number of stations and the number of connections between them.
Each of the next
lines contains three space-separated integers,
and
, the connected stations and the fare between them.
Constraints",Bellman-Ford Algorithm,Kruskal's Algorithm,Prim's Algorithm,Floyd-Warshall Algorithm,Dijkstra's Algorithm,,algorithms,"['graph theory', 'shortest path', 'weighted graph']"
https://www.hackerrank.com/challenges/huarongdao?isFullScreen=true,"Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board.
Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible.
But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board .
Note
Immovable blocks cannot be moved while cheating.
A block can be moved only in the directions UP, DOWN, LEFT or RIGHT.
Input Format
The first line contains four integers N, M, K, Q separated by a single space.  N lines follow.
Each line contains M integers 0 or 1 separated by a single space. If the j
th
integer is 1, then the block in i
th
row and j
th
column is movable. If the j
th
integer is 0 then the block in i
th
row and j
th
column is fixed.
Then Q lines follows, each line contains six integers EX
i
, EY
i
, SX
i
, SY
i
, TX
i
, TY
i
separated by a single space. The i
th
query is the Cao Cao block is in row SX
i
column SY
i
, the exit is in TX
i
, TY
i
, and the empty position is in row EX
i
column EY
i
. It is guaranteed that the blocks in these positions are movable. Find the minimum seconds Acme needs to finish the game. If it is impossible to finish the game, you should answer -1.
Constraints
N,M ≤ 200
1 ≤ Q ≤ 250
10 ≤ K≤ 15
1 ≤ EX
i
,  SX
i
,  TX
i
≤ N
1 ≤ EY
i
, SY
i
,TY
i
≤ M
Output Format
You should output Q lines, i-th line contains an integer which is the answer to i-th query.
Sample Input
5 5 12 1
1 1 1 1 1
1 1 1 1 1
0 1 1 1 1
1 1 1 1 1
0 1 0 1 1
1 5 4 3 4 1
Sample Output
20
Explanation
Move the block in (1, 4) to (1, 5);
Move the block in (1, 3) to (1, 4);
Move the block in (1, 2) to (1, 3);
Move the block in (2, 2) to (1, 2);
Move the block in (3, 2) to (2, 2);
Move the block in (4, 2) to (3, 2);
Move the block in (4, 3) to (4, 2);
Move the block in (4, 1) to (4, 3) by cheating;
Move the block in (4, 2) to (4, 1).
So, 1 + 1 + 1 + 1 + 1 + 1 + 1 + 12 + 1 = 20.",Depth-First Search (DFS),Greedy Search,A* Search without a heuristic,Randomized Search,Breadth-First Search (BFS),,algorithms,"['graph search', 'bfs', 'optimization']"
https://www.hackerrank.com/challenges/angry-children?isFullScreen=true,"You will be given a list of integers,
, and a single integer
.  You must create an array of length
from elements of
such that its
unfairness
is minimized. Call that array
.  Unfairness of an array is calculated as
Where:
-
max
denotes the largest integer in
-
min
denotes the smallest integer in
Example
Pick any two elements, say
.
Testing for all pairs, the solution
provides the minimum unfairness.
Note
: Integers in
may not be unique.
Function Description
Complete the
maxMin
function in the editor below.
maxMin has the following parameter(s):
int k:
the number of elements to select
int arr[n]:
: an array of integers
Returns
int:
the minimum possible
unfairness
Input Format
The first line contains an integer
, the number of elements in array
.
The second line contains an integer
.
Each of the next
lines contains an integer
where
.
Constraints
Sample Input 0
7
3
10
100
300
200
1000
20
30
Sample Output 0
20
Explanation 0
Here
; selecting the
integers
, unfairness equals
max(10,20,30) - min(10,20,30) = 30 - 10 = 20
Sample Input 1
10
4
1
2
3
4
10
20
30
40
100
200
Sample Output 1
3
Explanation 1
Here
; selecting the
integers
, unfairness equals
max(1,2,3,4) - min(1,2,3,4) = 4 - 1 = 3
Sample Input 2
5
2
1
2
1
2
1
Sample Output 2
0
Explanation 2
Here
.
or
give the minimum unfairness of
.",Use a min-heap data structure to efficiently track the smallest k elements and calculate unfairness.,Calculate the unfairness for all possible sub-arrays of size k and return the smallest.,"Sort the input array and then iterate through all possible sub-arrays of size k, tracking the minimum difference between the first and last elements.","Use a sliding window of size k, moving it across the array and maintaining a running sum of the differences.","Sort the array and iterate through it using a sliding window of size k, calculating the difference between the last and first element in each window.",,algorithms,"['sorting', 'sliding window', 'unfairness']"
https://www.hackerrank.com/challenges/clues-on-a-binary-path?isFullScreen=true,"Logan and Veronica live in Neptune, which has
houses and
bidirectional roads connecting them. Each road has an assigned value,
, where
, and each house is numbered with a distinct integer from
to
.
Logan and Veronica are looking for clues and need to find the number of different paths of length
from house number
. Each path is characterized by a binary sequence of length
, where each integer
in the path is the value of
for the
edge in the path. Two paths are different if the binary sequences characterizing these paths are distinct. Note that they may need to visit the same house several times or use the same road several times to find all possible paths.
Given a map of Neptune, help Logan and Veronica find and print the number of different paths of length
from house number
to the other houses in Neptune.
Input Format
The first line contains three space-separated integers describing the respective values of
(the number of houses),
(the number of bidirectional roads), and
(the distance they want to travel).
Each of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
that define a bidirectional road between houses
and
having assigned value
.
Constraints
There may be roads connecting house to itself.
There may be more than one road between two houses.
Output Format
Print an integer denoting the total number of paths.
Sample Input
3 2 3
1 2 0
1 3 1
Sample Output
4
Explanation
There are four possible paths:
Thus, we print
as our answer.","Perform a Depth-First Search (DFS) without memoization, tracking the path as a string, and storing unique paths in a set.",Use Dijkstra's algorithm to find the shortest paths and count those with length k.,Employ a Breadth-First Search (BFS) and count paths of exactly length k.,"Generate all possible paths using recursion, convert each path to a decimal representation, and sum them up.","Implement a Depth-First Search (DFS) with memoization to avoid recomputation of paths, storing unique binary sequences.",,algorithms,"['graph traversal', 'DFS', 'memoization']"
https://www.hackerrank.com/challenges/digits-square-board-1?isFullScreen=true,"Two HackerRank staffers found a secret room with a mysterious
square board and decided to play a game with it. The game has the following rules:
At the beginning of the game, the players write a single digit (given as input) ranging from
to
in each
cell composing the
square board.
The players move in alternating turns. In each move, the current player performs the following actions:
Chooses a board that has at least one
non-prime
number written on it and has more than one cell (i.e., dimensions
).
Cuts the chosen board into
smaller boards by breaking it along any horizontal or vertical line at the edge of a cell.
Note:
Although the game starts with one
board, that board is split in two during each move. At the beginning of the
move, a player can choose any one of the
pieces of the original board (as long as it can have a legal move performed on it).
The game ends when there are no more cuttable boards (i.e., there are
boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses.
Given the value of
and the respective numbers written in each
cell of the board, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.
Time Limit
Python: 18 seconds
Pypy2: 5 seconds
For other languages, the time limit is
standard
.
Input Format
The first line contains an integer,
, denoting the number of test cases.
Each test case is defined as follows over the subsequent lines:
An integer,
, denoting the length of each of the board's sides.
Each line
of the
subsequent lines contains
space-separated integers describing
, where each
describes the number written in cell
of the board.
Constraints
Output Format
For each test case, print the name of the player with the winning strategy on a new line (i.e., either
or
).
Sample Input
2
3
2 7 5
2 7 5
7 7 7
2
4 3
1 2
Sample Output
Second
First
Explanation
We'll refer to the two players as
and
.
Test Case 0:
All cells contain prime numbers, so there are no valid moves available to
. As
wins by default, we print
on a new line.
Test Case 1:
In this test case, the two players perform the following sequence of moves:
makes a horizontal cut, splitting the board into two
boards. This is demonstrated in the following diagram:
https://s3.amazonaws.com/hr-challenge-images/19867/1462786783-388c1f036b-square.png
now chooses one of the two
rectangles and cuts it vertically, splitting it into two
squares.
chooses remaining
rectangle and cuts it vertically, splitting it into two
squares.
After the above
moves take place, the board is split into four
squares and no more moves are available for
to make. Thus,
wins and we print
on a new line.","If N is even and there is at least one non-prime, the Second player wins; otherwise, the First player wins.",The First player always wins if there's at least one non-prime number on the board.,Determine the winner based solely on the number of non-prime numbers; an odd count favors the First player.,The Second player wins if the board size is a power of 2 and contains only non-prime numbers.,"Calculate the Nim-sum of the number of possible cuts for each sub-board. If the Nim-sum is non-zero, the First player wins; otherwise, the Second player wins.",,algorithms,"['game theory', 'Nim game', 'recursion']"
https://www.hackerrank.com/challenges/tree-splitting?isFullScreen=true,"Given a tree with vertices numbered from
to
. You need to process
queries. Each query represents a vertex number encoded in the following way:
Queries are encoded in the following way
: Let,
be the
query and
be the answer for the
query where
and
is always
. Then vertex
.
We are assure that
is between
and
, and hasn't been removed before.
Note:
is the bitwise XOR operator.
For each query, first decode the vertex
and then perform the following:
Print the size of the connected component containing
.
Remove vertex
and all edges connected to
.
Input Format
The first line contains a single integer,
, denoting the number of vertices in the tree.
Each line
of the
subsequent lines (where
) contains
space-separated integers describing the respective nodes,
and
, connected by edge
.
The next line contains a single integer,
, denoting the number of queries.
Each line
of the
subsequent lines contains a single integer, vertex number
.
Constraints
Output Format
For each query, print the size of the corresponding connected component on a new line.
Sample Input 0
3
1 2
1 3
3
1
1
2
Sample Output 0
3
1
1
Sample Input 1
4
1 2
1 3
1 4
4
3
6
2
6
Sample Output 1
4
3
2
1
Explanation
Sample Case 0:
We have,
= 0 and connected component :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removing vertex
and all of it's edges, we get two disconnected components :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removing vertex
and all of it's edges, we are left with only one component :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removed vertex
.
Sample Case 1:
We have,
=
and connected component :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removing vertex
and all of it's edges, we get component :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removing vertex
and all of it's edges, now, we get two disconnected components :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removing vertex
and all of it's edges, now we are left with only one component :
has vertex =
=
=
. The size of connected component containing
is
.
So,
=
.
Removed vertex
.","Use Depth-First Search (DFS) starting from each vertex to determine component sizes after removal, modifying the graph in-place.","Maintain a disjoint set data structure to track connected components, updating it after each vertex removal using union-find operations.",Precompute all possible connected components using dynamic programming and look up the size after each removal.,"Employ a greedy algorithm that iteratively removes the vertex with the fewest connections, approximating the connected component size.","Implement a Breadth-First Search (BFS) or Depth-First Search (DFS) for each query on the remaining graph to find the connected component size, marking visited nodes to avoid cycles.",,algorithms,"['graph traversal', 'connected components', 'graph modification']"
https://www.hackerrank.com/challenges/hackerland-radio-transmitters?isFullScreen=true,"Hackerland is a one-dimensional city with houses aligned at integral locations along a road. The Mayor wants to install radio transmitters on the roofs of the city's houses. Each transmitter has a fixed range meaning it can transmit a signal to all houses within that number of units distance away.
Given a map of Hackerland and the transmission range, determine the minimum number of transmitters so that every house is within range of at least one transmitter.  Each transmitter
must
be installed on top of an existing house.
Example
antennae at houses
and
and
provide complete coverage.  There is no house at location
to cover both
and
.  Ranges of coverage, are
,
, and
.
Function Description
Complete the
hackerlandRadioTransmitters
function in the editor below.
hackerlandRadioTransmitters has the following parameter(s):
int x[n]:
the locations of houses
int k:
the effective range of a transmitter
Returns
int:
the minimum number of transmitters to install
Input Format
The first line contains two space-separated integers
and
, the number of houses in Hackerland and the range of each transmitter.
The second line contains
space-separated integers describing the respective locations of each house
.
Constraints
There may be more than one house at the same location.
Subtasks
for
of the maximum score.
Output Format
Print a single integer denoting the minimum number of transmitters needed to cover all of the houses.
Sample Input 0
STDIN       Function
-----       --------
5 1         x[] size n = 5, k = 1
1 2 3 4 5   x = [1, 2, 3, 4, 5]
Sample Output 0
2
Explanation 0
The diagram below depicts our map of Hackerland:
https://s3.amazonaws.com/hr-challenge-images/26945/1477492657-cfb294bd61-k-nearest2.png
We can cover the entire city by installing
transmitters on houses at locations
and
.
Sample Input 1
8 2
7 2 4 6 5 9 12 11
Sample Output 1
3
Explanation 1
The diagram below depicts our map of Hackerland:
https://s3.amazonaws.com/hr-challenge-images/26945/1477492663-b1b6a9502e-k-nearest22.png
We can cover the entire city by installing
transmitters on houses at locations
,
, and
.","Use a greedy approach, placing transmitters at the houses furthest to the right first.",Sort the houses and use binary search to find the optimal transmitter locations.,Divide the houses into segments of length 2*k and place a transmitter in the middle of each segment.,Calculate the average location of all houses and place transmitters equidistant from this point.,"Sort the house locations, then greedily place transmitters to cover the maximum number of houses within range k.",,algorithms,"['greedy algorithm', 'sorting', 'coverage']"
https://www.hackerrank.com/challenges/value-of-friendship?isFullScreen=true,"You're researching friendships between groups of
new college students where each student is distinctly numbered from
to
. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are:
Bidirectional.
If student
is friends with student
, then student
is also friends with student
.
Transitive.
If student
is friends with student
and student
is friends with student
, then student
is friends with student
. In other words, two students are considered to be friends even if they are only indirectly linked through a network of mutual (i.e., directly connected) friends.
The purpose of your research is to find the maximum total value of a group's friendships, denoted by
. Each time a direct friendship forms between two students, you sum the number of friends that
each
of the
students has and add the sum to
.
You are given
queries, where each query is in the form of an unordered list of
distinct direct friendships between
students. For each query, find the maximum value of
among all possible orderings of formed friendships and print it on a new line.
Input Format
The first line contains an integer,
, denoting the number of queries. The subsequent lines describe each query in the following format:
The first line contains two space-separated integers describing the respective values of
(the number of students) and
(the number of distinct
direct
friendships).
Each of the
subsequent lines contains two space-separated integers describing the respective values of
and
(where
) describing a friendship between student
and student
.
Constraints
Output Format
For each query, print the maximum value of
on a new line.
Sample Input 0
1
5 4
1 2
3 2
4 2
4 3
Sample Output 0
32
Explanation 0
https://s3.amazonaws.com/hr-challenge-images/0/1483669319-d7c2102e0a-friendship1.png
The value of
is maximal if the students form the
direct friendships in the following order:
Students
and
become friends:
https://s3.amazonaws.com/hr-challenge-images/0/1483774199-fabc01a0ea-friendship2.png
We then sum the number of friends that each student has to get
.
Students
and
become friends:
https://s3.amazonaws.com/hr-challenge-images/0/1483774220-d5ddc47150-friendship3.png
We then sum the number of friends that each student has to get
.
Students
and
become friends:
https://s3.amazonaws.com/hr-challenge-images/0/1483774236-53ba392659-friendship4.png
We then sum the number of friends that each student has to get
.
Students
and
become friends:
https://s3.amazonaws.com/hr-challenge-images/0/1483774254-1c6d91320c-friendship5.png
We then sum the number of friends that each student has to get
.
When we add the sums from each step, we get
. We then print
on a new line.","Union-Find with path compression and union by rank, summing sizes during union operations, but neglecting to square component sizes.","Depth-First Search (DFS) to identify connected components, multiplying component sizes instead of squaring and summing.","Breadth-First Search (BFS) to identify connected components, correctly squaring component sizes but not summing the squares across all unions.","Kruskal's Algorithm to find the minimum spanning tree, then calculating friendship values based on the MST structure.","Union-Find with path compression and union by rank, maintaining and updating the sum of squares of component sizes upon each union.",,algorithms,"['disjoint set', 'union-find', 'graph theory']"
https://www.hackerrank.com/challenges/requirement?isFullScreen=true,"There are
variables and
requirements. Requirements are represented as
, meaning that the
variable must be less than or equal to the
variable.
Your task is to assign non-negative numbers smaller than
to each variable and then calculate the number of different assignments satisfying all requirements. Two assignments are different if and only if at least one variable is assigned to a different number in both assignments. Print your answer modulo
.
Input Format
The first line contains
space-separated integers,
and
, respectively.
Each of the
subsequent lines contains
space-seperated integers describing the respective
and
values for an
requirement.
Constraints
Output Format
Print your answer modulo
.
Sample Input 0
6 7
1 3
0 1
2 4
0 4
2 5
3 4
0 2
Sample Output 0
1000
Explanation 0
There are
variables and
requirements.
Let the variables be in the array
.
Requirements are -
One of the assignments is -
Similarly there are
assignments possible.
Result =
.",The problem is NP-hard and requires approximation algorithms.,"Use a greedy algorithm, assigning values from smallest to largest requirement.",Employ dynamic programming to build a table of partial assignments and their counts.,Sort the requirements and then use a brute-force approach to test all possible assignments.,Represent the constraints as a directed graph and use topological sorting combined with dynamic programming.,,algorithms,"['directed graph', 'dynamic programming', 'topological sort']"
https://www.hackerrank.com/challenges/sherlock-and-minimax?isFullScreen=true,"Watson gives Sherlock an array of integers.  Given the endpoints of an integer range, for all
in that inclusive range, determine the minimum( abs(arr[i]-M) for all
) ).  Once that has been determined for all integers in the range, return the
which generated the maximum of those values.  If there are multiple
's that result in that value, return the lowest one.
For example, your array
and your range is from
to
inclusive.
M
|
arr
[
1
]
-
M
|
|
arr
[
2
]
-
M
|
|
arr
[
3
]
-
M
|
|
arr
[
4
]
-
M
|
Min
6
3
1
1
3
1
7
4
2
0
2
0
8
5
3
1
1
1
We look at the
Min
column and see the maximum of those three values is
.  Two
's result in that answer so we choose the lower value,
.
Function Description
Complete the
sherlockAndMinimax
function in the editor below.  It should return an integer as described.
sherlockAndMinimax has the following parameters:
-
arr
: an array of integers
-
p
: an integer that represents the lowest value of the range for
-
q
: an integer that represents the highest value of the range for
Input Format
The first line contains an integer
, the number of elements in
.
The next line contains
space-separated integers
.
The third line contains two space-separated integers
and
, the inclusive endpoints for the range of
.
Constraints
Output Format
Print the value of
on a line.
Sample Input
3
5 8 14
4 9
Sample Output
4
Explanation
M
|
arr
[
1
]
-
M
|
|
arr
[
2
]
-
M
|
|
arr
[
3
]
-
M
|
Min
4
1
4
10
1
5
0
3
9
0
6
1
2
8
1
7
2
1
7
1
8
3
0
6
0
9
4
1
5
1
For
, or
, the result is
. Since we have to output the smallest of the multiple solutions, we print
.",Return the median of the array as the optimal M,"Choose M as the average of p and q, rounded to the nearest integer",Select M as the midpoint between the closest two elements in 'arr',Iterate from p to q and return the first value whose absolute difference with the first element of 'arr' is minimum,"Sort 'arr', iterate from 'p' to 'q', calculate the minimum absolute difference for each, and choose the 'm' with the maximum minimum difference, resolving ties with the smallest 'm'",,algorithms,"['sorting', 'absolute difference', 'optimization']"
https://www.hackerrank.com/challenges/non-divisible-subset?isFullScreen=true,"Given a set of distinct integers, print the size of a maximal subset of
where the sum of any
numbers in
is
not
evenly divisible by
.
Example
One of the arrays that can be created is
.  Another is
.  After testing all permutations, the maximum length solution array has
elements.
Function Description
Complete the
nonDivisibleSubset
function in the editor below.
nonDivisibleSubset has the following parameter(s):
int S[n]
: an array of integers
int k
: the divisor
Returns
int:
the length of the longest subset of
meeting the criteria
Input Format
The first line contains
space-separated integers,
and
, the number of values in
and the
non
factor.
The second line contains
space-separated integers, each an
, the unique values of the set.
Constraints
All of the given numbers are distinct.
Sample Input
STDIN    Function
-----    --------
4 3      S[] size n = 4, k = 3
1 7 2 4  S = [1, 7, 2, 4]
Sample Output
3
Explanation
The sums of all permutations of two elements from
are:
1 + 7 = 8
1 + 2 = 3
1 + 4 = 5
7 + 2 = 9
7 + 4 = 11
2 + 4 = 6
Only
will not ever sum to a multiple of
.",The count of elements whose remainder when divided by k is zero,The number of elements in S divisible by k,The size of the original set S,"The sum of all elements in the array S divided by k, rounded up","1 + the number of pairs of remainders (i, k-i) that yield the maximum count, plus 1 if there's a single element divisible by k and k is not 1 or 0.",,algorithms,"['arrays', 'modulo', 'subset sum']"
https://www.hackerrank.com/challenges/repeat-k-sums?isFullScreen=true,"Alice thinks of a non-decreasing sequence of non-negative integers and wants Bob to guess it by providing him the set of all its
K
-sums with repetitions.
What is this? Let the sequence be {A[1], A[2], ..., A[N]} and
K
be some positive integer that both Alice and Bob know. Alice gives Bob the set of all possible values that can be genereated by this -
A[i
1
] + A[i
2
] + ... + A[i
K
]
, where
1 ≤ i
1
≤ i
2
≤ ... ≤ i
K
≤ N
. She can provide the values generated in any order she wishes to. Bob's task is to restore the initial sequence.
Consider an example. Let
N = 3
and
K = 2
. The sequence is {A[1], A[2], A[3]}. The sequence of its
2
-sums with repetitions is {A[1] + A[1], A[1] + A[2], A[1] + A[3], A[2] + A[2], A[2] + A[3], A[3] + A[3]}. But its elements could be provided in any order. For example any permutation of
{2, 3, 4, 4, 5, 6}
corresponds to the sequence
{1, 2, 3}
.
Input Format
The first line of the input contains an integer
T
denoting the number of test cases.
The description of
T
test cases follows.
The first line of each test case contains two space separated integers
N
and
K
.
The second line contains the sequence
S
i
of all
K
-sums with repetitions of the sequence Alice initially thought of.
Constraints
Note
The total number of elements in any input sequence does not exceed
10
5
Each element of each input sequence is non-negative integer not exceeding
10
18
.
Each input sequence is a correct sequence of all
K
-sums with repetitions of some non-decreasing sequence of non-negative integers.
Output Format
For each test case, output a single line containing the space separated list of elements of the non-decreasing sequence Alice thinks of. If there are several possible outputs you can output any of them.
Sample Input 0
3
1 3
3
2 2
12 34 56
3 2
2 3 4 4 5 6
Sample Output 0
1
6 28
1 2 3
Explanation 0
Sample case #00: When N = 1 and K = 3 the only K-sum is
S[1] = 3 * A[1]. Hence A[1] = S[1] / 3 = 3 / 3 = 1.
Sample case #01: Since 6 + 6 = 12, 6 + 28 = 34, 28 + 28 =
56, then Alice indeed could think of the sequence {6, 28}.
Sample case #02: It corresponds to the example in the problem
statement.","The first element is always the smallest K-sum, so divide it by K to get A[1]. Then, deduce the rest.",Sort the K-sums and try all possible combinations of N elements that could sum to the given values.,"Calculate all possible non-decreasing sequences of length N, compute their K-sums, and compare with the input.",Use dynamic programming to store intermediate sums and deduce the original sequence.,"Sort the K-sums, deduce A[1] from the smallest K-sum, then iteratively find A[i] by considering sums involving previously found A[j] values.",,algorithms,"['sorting', 'deduction', 'k-sums']"
https://www.hackerrank.com/challenges/kruskalmstrsub?isFullScreen=true,"Given an undirected weighted connected graph, find the Really Special SubTree in it. The Really Special SubTree is defined as a subgraph consisting of all the nodes in the graph and:
There is only one exclusive path from a node to every other node.
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.
No cycles are formed
To create the Really Special SubTree, always pick the edge with smallest weight. Determine if including it will create a cycle.  If so, ignore the edge.  If there are edges of equal weight available:
Choose the edge that minimizes the sum
where
and
are vertices and
is the edge weight.
If there is still a collision, choose any of them.
Print the overall weight of the tree formed using the rules.
For example, given the following edges:
u
v
wt
1
2
2
2
3
3
3
1
5
First choose
at weight
.  Next choose
at weight
.  All nodes are connected without cycles for a total weight of
.
Function Description
Complete the
function in the editor below.  It should return an integer that represents the total weight of the subtree formed.
kruskals has the following parameters:
g_nodes
: an integer that represents the number of nodes in the tree
g_from
: an array of integers that represent beginning edge node numbers
g_to
: an array of integers that represent ending edge node numbers
g_weight
: an array of integers that represent the weights of each edge
Input Format
The first line has two space-separated integers
and
, the number of nodes and edges in the graph.
The next
lines each consist of three space-separated integers
,
and
, where
and
denote the two nodes between which the
undirected
edge exists and
denotes the weight of that edge.
Constraints
**Note: ** If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges.
Output Format
Print a single integer denoting the total weight of the Really Special SubTree.","Perform a Depth-First Search (DFS) and sum the edge weights in the order they are visited, avoiding cycles by tracking visited nodes.","Sort all edges by weight in descending order, then iteratively add edges, removing the heaviest edges that create cycles using a cycle detection algorithm like DFS.",Apply Dijkstra's algorithm from an arbitrary starting node to find the shortest paths to all other nodes and sum the weights of the edges in these shortest paths.,Calculate the average weight of all edges and multiply it by the number of nodes minus one.,"Apply Kruskal's algorithm: sort edges by weight, then iteratively add edges to the MST if they don't form cycles, using a disjoint-set data structure (Union-Find).",,algorithms,"['minimum spanning tree', ""Kruskal's algorithm"", 'graph']"
https://www.hackerrank.com/challenges/gridland-metro?isFullScreen=true,"The city of Gridland is represented as an
matrix where the rows are numbered from
to
and the columns are numbered from
to
.
Gridland has a network of train tracks that always run in straight horizontal lines along a row. In other words, the start and end points of a train track are
and
, where
represents the row number,
represents the starting column, and
represents the ending column of the train track.
The mayor of Gridland is surveying the city to determine the number of locations where lampposts can be placed. A lamppost can be placed in any cell that is
not occupied
by a train track.
Given a map of Gridland and its
train tracks, find and print the number of cells where the mayor can place lampposts.
Note:
A train track may overlap other train tracks within the same row.
Example
If Gridland's data is the following (1-based indexing):
k = 3
r   c1  c2
1   1   4
2   2   4
3   1   2
4   2   3
It yields the following map:
https://s3.amazonaws.com/hr-assets/0/1523893004-b858dbd32c-gridland_2.png
In this case, there are five open cells (red) where lampposts can be placed.
Function Description
Complete the
gridlandMetro
function in the editor below.
gridlandMetro has the following parameter(s):
int n:
: the number of rows in Gridland
int m:
: the number of columns in Gridland
int k:
: the number of tracks
track[k][3]:
each element contains
integers that represent
, all 1-indexed
Returns
int
: the number of cells where lampposts can be installed
Input Format
The first line contains three space-separated integers
and
, the number of rows, columns and tracks to be mapped.
Each of the next
lines contains three space-separated integers,
and
, the row number and the track column start and end.
Constraints
Sample Input
STDIN   Function
-----   --------
4 4 3   n = 4, m = 4, k = 3
2 2 3   track = [[2, 2, 3], [3, 1, 4], [4, 4, 4]]
3 1 4
4 4 4
Sample Output
9
Explanation
https://s3.amazonaws.com/hr-assets/0/1523892476-07ef99af4e-gridland_s1.png
In the diagram above, the yellow cells denote the first train track, green denotes the second, and blue denotes the third. Lampposts can be placed in any of the nine red cells.","Use a nested loop to iterate through all cells and check for track presence, leading to O(n*m*k) complexity.",Sort all tracks and then iterate through all cells to check for track presence.,Assume each track is a single continuous segment and do not handle overlapping tracks correctly.,"Ignore the row numbers and consider all tracks as a single continuous line, leading to incorrect occupied cell count.","Use a hash map to store tracks for each row, merge overlapping tracks, and calculate the occupied cells per row.",,algorithms,"['greedy algorithm', 'hash map', 'merging intervals']"
https://www.hackerrank.com/challenges/divisible-numbers?isFullScreen=true,"Given an integer,
, find the smallest integer
such that
is divisible by
(i.e.,
is a factor of
) and satisfies the following properties:
must not contain zeroes in its decimal representation.
The sum of
's digits must be
greater than or equal to
the product of
's digits.
Given
, find
and print
the number of digits
in
's decimal representation.
Input Format
A single integer denoting
.
Constraints
is not divisible by
.
Time Limits
The time limits for this challenge are available
here
.
Output Format
Print the
number of digits
in the decimal representation of the smallest possible
.
Sample Input 0
1
Sample Output 0
1
Explanation 0
is evenly divided by
, doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in
(which also happens to be
) as our answer.
Sample Input 1
9
Sample Output 1
1
Explanation 1
is evenly divided by
, doesn't contain any zeroes in its decimal representation, and the sum of its digits is not less than the product of its digits. Thus, we print the number of digits in
, which is
, as our answer.",Binary Search,Dynamic Programming,Greedy Algorithm,Backtracking,Brute Force Search with Constraints,,algorithms,"['number theory', 'divisibility', 'digit manipulation']"
https://www.hackerrank.com/challenges/johnland?isFullScreen=true,"John lives in HackerLand, a country with
cities and
bidirectional roads. Each of the roads has a distinct length, and each length is a
power of two
(i.e.,
raised to some exponent). It's possible for John to reach any city from any other city.
Given a map of HackerLand, can you help John determine the sum of the minimum distances between each pair of cities? Print your answer in
binary representation
.
Input Format
The first line contains two space-seperated integers denoting
(the number of cities) and
(the number of roads), respectively.
Each line
of the
subsequent lines contains the respective values of
,
, and
as three space-separated integers. These values define a bidirectional road between cities
and
having length
.
Constraints
,
If
, then
.
Output Format
Find the sum of minimum distances of each pair of cities and print the answer in
binary representation
.
Sample Input
5 6
1 3 5
4 5 0
2 1 3
3 2 1
4 3 4
4 2 2
Sample Output
1000100
Explanation
In the sample, the country looks like this:
https://s3.amazonaws.com/hr-challenge-images/14676/1448135054-80139564e8-john.png
Let
be the minimum distance between city
and city
.","Calculate shortest paths using Dijkstra's algorithm with a heap, then sum all pairs' distances in decimal and convert to binary.","Apply Floyd-Warshall algorithm to find all-pairs shortest paths, sum the results in decimal, and convert to binary.","Use Breadth-First Search (BFS) from each node to all other nodes, summing the shortest path lengths in decimal and converting to binary.","Create a minimum spanning tree using Kruskal's or Prim's algorithm, then sum the edge weights and convert to binary.","Implement Floyd-Warshall algorithm to find all-pairs shortest paths using bitwise OR operations on path lengths, sum in decimal, and convert to binary.",,algorithms,"['graph algorithms', 'shortest path', 'binary representation']"
https://www.hackerrank.com/challenges/police-operation?isFullScreen=true,"Roy is helping the police department of his city in crime fighting. Today, they informed him about a new planned operation.
Think of the city as a
plane. The road along the
-axis is very crime prone, because
criminals live there. No two criminals live at the same position.
To catch these criminals, the police department has to recruit some police officers and give each of them USD
as wages. A police officer can start his operation from any point
, drive his car to point
in a straight line, and catch all the criminals who live on this way. The cost of fuel used by the officer's car is equal to the square of the euclidean distance between points
and
(Euclidean distance between points
and
equals to
).
The police department asks Roy to plan this operation. So Roy has to tell them the number of officers to recruit and the routes these officers should take in order to catch all the criminals. Roy has to provide this information while minimizing the total expenses of this operation.
Find out the minimum amount of money required to complete the operation.
Input Format
The first line contains two integers
, number of criminals, and
, the cost of recruiting a police officer. The next line contains
space separated integers. The
integer indicates the position of the
criminal on
-axis (in other words, if the
integer is
, then location of the
criminal is
). The value of the positions are between
and
and are given in increasing order in the input.
Output Format
Print the minimum amount of money required to complete the operation.
Sample Input
5 10
1 4 5 6 9
Sample Output
34
Explanation
For the sample test case, police department recruits
officers who get paid
. The first officer starts at point
and catches the criminal there. So he does not use any fuel. The second officer catches criminals at points
,
and
. He burns fuel worth USD
. The third officer catches the criminal at point
. He also does not burn any fuel. The total money spent by the department is,
.
Timelimits
Timelimits for this challenge are given
here","Use a greedy approach, assigning each officer to the maximum possible segment until all criminals are covered.","Sort the criminals by position, and then recursively calculate the minimum cost for subsegments.",Calculate the fuel cost between every pair of criminals and use a minimum spanning tree algorithm.,Treat the problem as a linear regression and find the best fit line to minimize fuel cost.,Use dynamic programming to find the minimum cost to cover the criminals up to a given position.,,algorithms,"['dynamic programming', 'optimization', 'geometry']"
https://www.hackerrank.com/challenges/similar-strings?isFullScreen=true,"Jimmy loves playing with strings. He thinks string
is
similar
to string
if the following conditions are satisfied:
Both strings have the same length (i.e.,
and
).
For each valid pair of indices,
, in the strings,
and
or
and
.
For example, string
and
are similar as for
,
and
and for all other
pairs
as well as
.
He has a string,
, of size
and gives you
queries to answer where each query is in the form of a pair of integers
. For each substring
, find the number of substrings
where substring
is
similar
to substring
and print this number on a new line.
Note:
Substring
is the contiguous sequence of characters from index
to index
. For example, if
abcdefgh
, then
cdef
.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
The second line contains string
.
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
and
for query
.
Constraints
Output Format
For each query, print the number of similar substrings on a new line.
Sample Input
8 4
giggabaj
1 1
1 2
1 3
2 4
Sample Output
8
6
2
1
Explanation
We perform the following sequence of queries:
Strings with length
are all similar, so our answer is
.
gi
,
ig
,
ga
,
ab
,
ba
, and
aj
are similar, so our answer is
.
gig
and
aba
are similar, so our answer is
.
igg
has no similar string, so our answer is
.","Iterate through all possible substrings and use a brute-force approach to compare them, resulting in O(n^4) complexity","Use dynamic programming to precompute similarity between all pairs of substrings, leading to O(n^2) space complexity","Employ a sliding window technique to efficiently compare substrings within the given range, improving performance for large inputs","Precompute all substrings and store their hash values for quick comparison, potentially leading to hash collisions","Compute a difference array representing character changes, and then compare difference array substrings for similarity with O(n^2) complexity",,algorithms,"['string matching', 'substring', 'difference array']"
https://www.hackerrank.com/challenges/absolute-permutation?isFullScreen=true,"We define
to be a permutation of the first
natural numbers in the range
. Let
denote the value at position
in permutation
using
-based indexing.
is considered to be an
absolute permutation
if
holds true for every
.
Given
and
, print the lexicographically smallest absolute permutation
.  If no absolute permutation exists, print
-1
.
Example
Create an array of elements from
to
,
.  Using
based indexing, create a permutation where every
.  It can be rearranged to
so that all of the absolute differences equal
:
pos[i]  i   |pos[i] - i|
  3     1        2
  4     2        2
  1     3        2
  2     4        2
Function Description
Complete the
absolutePermutation
function in the editor below.
absolutePermutation has the following parameter(s):
int n:
the upper bound of natural numbers to consider, inclusive
int k:
the absolute difference between each element's value and its index
Returns
int[n]:
the lexicographically smallest permutation, or
if there is none
Input Format
The first line contains an integer
, the number of queries.
Each of the next
lines contains
space-separated integers,
and
.
Constraints
Sample Input
STDIN   Function
-----   --------
3       t = 3 (number of queries)
2 1     n = 2, k = 1
3 0     n = 3, k = 0
3 2     n = 3, k = 2
Sample Output
2 1
1 2 3
-1
Explanation
Test Case 0:
https://s3.amazonaws.com/hr-challenge-images/16007/1462506998-dfe183c6f5-perm.png
Test Case 1:
https://s3.amazonaws.com/hr-challenge-images/16007/1462507102-236cbbd84c-perm1.png
Test Case 2:
No absolute permutation exists, so we print
-1
on a new line.",The solution always exists if k is a factor of n.,"If k is 0, the permutation is the identity permutation.",No solution exists if n is odd and k is even.,"A valid permutation can be constructed greedily, starting from the smallest numbers, if n % k == 0.",A valid absolute permutation exists if and only if k divides n by 2 (n % (2 * k) == 0).,,algorithms,"['permutation', 'absolute difference', 'lexicographical order']"
https://www.hackerrank.com/challenges/queens-on-board?isFullScreen=true,"Queens on Board
You have an
N
*
M
chessboard on which some squares are blocked out. In how many ways can you place one or more queens on the board, such that, no two queens attack each other? Two queens attack each other, if one can reach the other by moving horizontally, vertically, or diagonally without passing over any blocked square. At most one queen can be placed on a square. A queen cannot be placed on a blocked square.
Input Format
The first line contains the number of test cases
T
.
T
test cases follow. Each test case contains integers
N
and
M
on the first line. The following
N
lines contain
M
characters each, and represent a board. A '#' represents a blocked square and a '.' represents an unblocked square.
Constraints
1 <=
T
<= 100
1 <=
N
<= 50
1 <=
M
<= 5
Output Format
Output
T
lines containing the required answer for each test case. As the answers can be really large, output them modulo 10
9
+7.
Sample Input
4
3 3
...
...
...
3 3
.#.
.#.
...
2 4
.#..
....
1 1
#
Sample Output
17
18
14
0","Use backtracking, exploring all possible queen placements and pruning branches when attacks are detected, without memoization.",Iterate through all possible subsets of unblocked squares and check if any two queens attack each other. Return the number of subsets that are safe.,"Compute the number of ways to place queens row by row, ignoring attacks, and then subtract the number of invalid configurations afterward.","Model the problem as a maximum independent set problem on a graph where nodes are unblocked squares and edges connect attacking squares, and use approximation algorithms.","Employ backtracking with bitmasking to efficiently represent attacked columns, diagonals, and anti-diagonals for pruning the search space.",,algorithms,"['backtracking', 'bitmasking', 'combinatorics']"
https://www.hackerrank.com/challenges/lovely-triplets?isFullScreen=true,"Daniel loves graphs. He thinks a graph is
special
if it has the following properties:
It is undirected.
The length of each edge is
.
It includes
exactly
different
lovely triplets
.
A
triplet
is a set of
different nodes. A triplet is
lovely
if the minimum distance between each pair of nodes in the triplet is
exactly
. Two triplets are different if
or more of their component nodes are different.
Given
and
, help Daniel draw a
special graph
.
Input Format
A single line containing
space-separated integers,
(the number of different lovely triplets you must have in your graph) and
(the required
distance
between each pair of nodes in a lovely triplet), respectively.
Constraints
Output Format
For the first line, print
space-separated integers,
(the number of nodes in the graph) and
(the number of edges in the graph), respectively.
On each line
of the
subsequent lines, print two space-separated integers,
and
, describing an edge between nodes
and
.
Your output must satisfy the following conditions:
If there is more than one correct answer, print any one of them.
Sample Input
3 2
Sample Output
7 7
1 2
2 3
3 4
4 5
5 6
6 1
1 7
Explanation
There are exactly
lovely triplets in this graph:
,
, and
.
https://s3.amazonaws.com/hr-challenge-images/18055/1456578497-18944ac196-tripletex.png
Observe that each node in a lovely triplet is
edges away from the other nodes composing the lovely triplet.",A complete graph with K nodes and no edges between them,A star graph with a central node connected to all other nodes,A line graph where all nodes are connected sequentially,A disconnected graph with isolated nodes,"A cycle graph with 7 nodes and 7 edges, plus one additional node connected to any node in the cycle",,algorithms,"['graph theory', 'cycle graph', 'combinatorics']"
https://www.hackerrank.com/challenges/hacker-country?isFullScreen=true,"There are
N
cities in
Hacker Country
. Each pair of cities are directly connected by a unique directed road, and each road has its own toll that must be paid every time it is used. You're planning a road trip in
Hacker Country
, and its itinerary must satisfy the following conditions:
You can start in any city.
You must use
or more different roads (meaning you will visit
or more cities).
At the end of your trip, you should be back in your city of origin.
The average cost (sum of tolls paid per road traveled) should be minimum.
Can you calculate the
minimum average cost
of a trip in
Hacker Country
?
Time Limits
Time limits for this challenge are provided
here
.
Input Format
The first line is an integer,
(number of cities).
The
subsequent lines of
space-separated integers each describe the respective tolls or traveling from city
to city
; in other words, the
integer of the
line denotes the toll for traveling from city
to city
.
Note:
As there are no roads connecting a city to itself, the
integer of line
will always be
.
Constraints
Output Format
Print the
minimum cost
as a rational number
(tolls paid over roads traveled). The
greatest common divisor
of
and
should be
.
Sample Input
2
0 1
2 0
Sample Output
3/2
Explanation
The toll from city
to city
is
. The toll from
to
is
. Your travel cost
. Your number of roads traveled is
. Thus, we print
3/2
as our answer.",Use Dijkstra's algorithm to find the shortest path from each city back to itself and then average the costs,Calculate the average cost of all possible cycles and select the minimum; this has exponential complexity,Apply the Bellman-Ford algorithm to detect negative cycles and report the minimum cost as the most negative cycle,"Use a greedy approach, always choosing the road with the lowest toll until returning to the starting city",Find the minimum mean cycle using Karp's algorithm or binary search for the minimum average cost with cycle detection,,algorithms,"['graph theory', 'minimum cycle', ""Karp's algorithm""]"
https://www.hackerrank.com/challenges/alex-vs-fedor?isFullScreen=true,"In order to entertain themselves during the long flight, Alex and Fedor invented the following very simple two players game. The game is:
First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph.
Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.
We consider two trees different if the sets of the numbers of edges that are included in these trees are different. We consider two sets
and
different if there is at least one element that is present in
and not present in
or vice versa.
We should also mention that the graphs with enormous number of spanning trees upset Alex, as well as Fedor, so they will never have a graph that has more than
spanning trees.
At some point, Fedor became too lazy to look for minimal spanning trees and now he just picks some arbitrary spanning tree from the Alex's graph. Each spanning tree has equal probability to be picked by Fedor. What is the probability of Fedor's victory now?
Input Format
The first line of input consists of two single space separated integers
and
- the number of nodes in Alex's graph and the number of edges in that graph, respectively.
Then there are
lines, where the
line has three numbers
with the meaning that the edge with the number
connects the nodes
and
and has the weight of
.
Constraints
The graph is always connected.
Output Format
Output the probability of Fedor's victory, if he picks the spanning tree randomly, as an irreducible fraction.
Sample Input
4 4
1 2 1
2 3 4
3 4 3
4 1 2
Sample Output
1/4",Calculate the total number of spanning trees using Kirchhoff's Matrix Tree Theorem and then find the number of MSTs by brute force.,"Use Kruskal's algorithm to find the Minimum Spanning Tree (MST), count the total spanning trees, and return the ratio of MSTs to total spanning trees.","Enumerate all possible spanning trees using backtracking, find the MST using Prim's algorithm, and calculate the probability.","Use dynamic programming to compute the number of spanning trees and the number of MSTs, then calculate their ratio.","Find the Minimum Spanning Tree(s) using Kruskal's or Prim's algorithm, enumerate all possible spanning trees using a backtracking approach, and compute the ratio of MSTs to total spanning trees, simplifying the fraction.",,algorithms,"['minimum spanning tree', 'graph theory', 'enumeration']"
https://www.hackerrank.com/challenges/the-power-sum?isFullScreen=true,"Find the number of ways that a given integer,
, can be expressed as the sum of the
powers of unique, natural numbers.
For example, if
and
, we have to find all combinations of unique squares adding up to
.  The only solution is
.
Function Description
Complete the
powerSum
function in the editor below.  It should return an integer that represents the number of possible combinations.
powerSum has the following parameter(s):
X
: the integer to sum to
N
: the integer power to raise numbers to
Input Format
The first line contains an integer
.
The second line contains an integer
.
Constraints
Output Format
Output a single integer, the number of possible combinations caclulated.
Sample Input 0
10
2
Sample Output 0
1
Explanation 0
If
and
, we need to find the number of ways that
can be represented as the sum of squares of unique numbers.
This is the only way in which
can be expressed as the sum of unique squares.
Sample Input 1
100
2
Sample Output 1
3
Explanation 1
Sample Input 2
100
3
Sample Output 2
1
Explanation 2
can be expressed as the sum of the cubes of
.
. There is no other way to express
as the sum of cubes.","Use dynamic programming to store intermediate results and avoid redundant calculations, iterating through possible numbers from 1 up to X^(1/N)","Recursively explore all possible combinations, including and excluding each number raised to the power N, while keeping track of the current sum.","Generate all possible subsets of numbers raised to the power N and check if any subset sums to X, returning the count of such subsets.","Iterate through all numbers from 1 to X, calculating their Nth power and checking if subtracting each from X yields 0 or a value that can be achieved.","Recursively explore numbers from 1, calculating x^N and either including or excluding it from the sum until X reaches 0, returning 1 if a valid combination is found or 0 otherwise.",,algorithms,"['recursion', 'combinatorics', 'power']"
https://www.hackerrank.com/challenges/inverse-rmq?isFullScreen=true,"Range Minimum Query
is a well-known problem: given an array of distinct integers with size
and
queries, find the minimum element on subsegment
.
One of the most efficient and famous solutions to this problem is a
segment tree
. A segment tree is a full binary tree with
nodes where the leaves contain the values of the original array and each non-leaf node contains the minimum value of its entire subtree.
Usually, a segment tree is represented as an array of integers with
elements. The left child of the
node is in the
cell, and the right child is in the
cell. For example,
represents the following segment tree where the first number in a node describes the array index,
, in
and the second number denotes the value stored at index
(which corresponds to the minimum value in that node's subtree):
https://s3.amazonaws.com/hr-challenge-images/0/1452359774-5e3ec6eea8-example1_graph.png
You've just used
distinct
integers to construct your first segment tree and saved it as an array,
, of
values. Unfortunately, some evil guy came and either shuffled or altered the elements in your array. Can you use the altered data to restore the original array? If no, print
NO
on a new line; otherwise, print two lines where the first line contains the word
YES
and the second line contains
space-separated integers denoting the array's original values. If there are several possible original arrays, print the
lexicographically
smallest one.
Input Format
The first line contains a single integer,
, denoting the size of the array.
The second line contains
space-separated integers denoting the shuffled values of the segment tree.
Constraints
is a power of two.
Each value in the segment tree is between
and
.
Output Format
Print
NO
if this array could not be constructed by shuffling some segment tree. Otherwise, print
YES
on the first line, and
space-separated integers describing the respective values of the original array on the second line. If there are several possible answers, print the lexicographically smallest one.
Sample Input 0
4
3 1 3 1 2 4 1
Sample Output 0
YES
1 1 3 1 2 3 4
Explanation 0
This is the same segment tree shown in the
Problem Statement
above.
Sample Input 1
2
1 1 1
Sample Output 1
NO
Explanation 1
A segment tree with three nodes would consist of a root, a left child, and a right child. Because all three numbers in this array are the same and the leaves of the segment tree must be
distinct integers, it's not possible to reconstruct the original array.",The number of nodes must be equal to 2n - 1.,The root node must contain the minimum value of the entire array.,The leaves of the segment tree must contain distinct integers from the original array.,A node's value must be equal to the minimum of its children's values.,All of the above,,data structures,"['segment tree', 'range minimum query']"
https://www.hackerrank.com/challenges/vertical-paths?isFullScreen=true,"You have a rooted tree with
vertices numbered from
through
where the root is vertex
.
You are given
triplets, the
triplet is denoted by three integers
. The
triplet represents a simple path in the tree with endpoints in
and
such that
is ancestor of
. The cost of the path is
.
You have to select a subset of the paths such that the sum of path costs is maximum and the
edge of the tree belongs to at most
paths from the subset. Print the sum as the output.
Input Format
The first line contains a single integer,
, denoting the number of testcases. Each testcase is defined as follows:
The first line contains two space-separated integers,
(the number of vertices) and
(the number of paths), respectively.
Each line
of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
where (
,
) is an edge in the tree and
is maximum number of paths which can include this edge.
Each line of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
(
) that define the
path and its cost.
Constraints
Let
be the sum of
over all the trees.
Let
be the sum of
over all the trees.
Output Format
You must print
lines, where each line contains a single integer denoting the answer for the corresponding testcase.
Sample Input
1
8 8
1 2 3
1 3 1
2 4 5
2 5 1
2 6 1
3 7 2
4 8 1
1 2 3
2 8 5
1 8 7
1 5 8
1 6 10
3 7 5
1 7 6
1 7 6
Sample Output
37
Explanation
https://s3.amazonaws.com/hr-challenge-images/13888/1466855290-fe8e51e131-vertical1.png
One of the possible subsets contains paths
. Its total cost is
.","Use a greedy approach, selecting paths with the highest cost first, without considering edge capacity constraints.",Formulate the problem as a minimum spanning tree problem and use Prim's algorithm.,"Apply dynamic programming, considering all possible subsets of paths and checking edge capacity constraints in each state.","Solve using a linear programming relaxation, rounding the fractional path selections to the nearest integer.","Model the problem as a maximum weighted independent set problem on intervals derived from the paths and edges, then solve using integer programming.",,algorithms,"['tree', 'optimization', 'graph']"
https://www.hackerrank.com/challenges/longest-mod-path?isFullScreen=true,"In the middle of a nightmare,
Maxine
suddenly finds herself in a mysterious room with the following items:
A piece of paper with the word
score
and the integer
written on it.
A map of the castle where the room is located.
There are
rooms uniquely labeled from
to
.
There are
bidirectional corridors connecting pairs of rooms. The value of
score
changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction.
Every room is reachable from every other room.
Maxine is located in the room labeled
.
The exit is located in the room labeled
. Once this room is reached,
score
is reduced
modulo
and Maxine can (but is not required to) exit that level!
Assume some corridor
(where
) is associated with an integer,
, and connects rooms
and
. Then:
Traveling corridor
from room
to room
increases score
by
.
Traveling corridor
from room
to room
decreases score
by
.
There are
levels to Maxine's nightmare castle, and each one has a different set of values for
,
, and
. Given the above information, help Maxine by finding and printing her maximum possible score for each level. Only you can help her wake up from this nightmare!
Note:
Recall that the result of a modulo operation is
always non-negative
.  For example,
.
Input Format
The first line contains a single integer,
, denoting the number of rooms.
Each of the
subsequent lines describes a corridor in the form of three space-separated integers denoting the respective values for
,
, and
.
The next line contains a single integer,
, denoting the number of queries.
Each of the
subsequent lines describes a level in the form of three space-separated integers denoting its respective
,
, and
values.
Constraints
,
For each level:
The room layout is the same
Subtask
for
of max score.
Output Format
For each of the
levels, print the maximum possible score for that level on a new line.
Sample Input
3
1 3 5
2 3 8
2 1 31
1
1 2 13
Sample Output
12
Explanation
The
Sample Input
represents the following setup:
https://s3.amazonaws.com/hr-challenge-images/19176/1464109137-759305db06-longest-mod-path-sample.png
We want to travel from room
to room
while maximizing the value of
score
. There are at least two ways to achieve the maximum
score
value of
:
Travel through corridors
times:
.
Travel through corridors
times:
, because
is the smallest non-negative integer
such that
divides
.","Use Dijkstra's algorithm to find the shortest path from start to end, considering negative edge weights.","Apply a greedy approach, always choosing the corridor that provides the largest score increase at each step.","Perform a depth-first search (DFS) and keep track of all possible scores, returning the maximum.","Calculate the shortest path using Floyd-Warshall, and then multiply that by -1 to find the longest.",Identify cycles where the sum of corridor weights is positive and traverse them until the score is maximized modulo m.,,algorithms,"['graph theory', 'cycles', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/far-vertices?isFullScreen=true,"You are given a tree that has N vertices and N-1 edges. Your task is to mark as small number of vertices as possible, such that, the maximum distance between two unmarked vertices is less than or equal to K. Output this value.
Distance between two vertices i and j is defined as the minimum number of edges you have to pass in order to reach vertex i from vertex j.
Input Format
The first line of input contains two integers N and K. The next N-1 lines contain two integers (ui,vi) each, where 1 <= ui,vi <= N. Each of these lines specifies an edge.
N is no more than 100. K is less than N.
Output Format
Print an integer that denotes the result of the test.
Sample Input:
5 1
1 2
1 3
1 4
1 5
Sample Output:
3
Sample Input:
5 2
1 2
1 3
1 4
1 5
Sample Output:
0
Explanation:
In the first case you have to mark at least 3 vertices, and in the second case you don't need to mark any vertices.","Use a greedy approach, marking nodes furthest from the center until the condition is met.",Perform a binary search on the number of marked vertices.,"Mark all leaf nodes. If the condition is satisfied, return the count, otherwise, reduce K until condition is met.",Mark nodes randomly until the condition is met. Repeat and return the minimum count.,"Use a dynamic programming approach, considering all possible subsets of marked vertices and choosing the one with the minimum size.",,algorithms,"['tree', 'dynamic programming', 'graph']"
https://www.hackerrank.com/challenges/covering-the-stains?isFullScreen=true,"There is a huge blanket on your bed but unfortunately it has
N
stains. You cover them using
a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly
K
stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth.
Let
X
denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove
K
stains so that the remaining
N-K
stains can be covered with silk of
area strictly less than X
(We are looking for any configuration that will reduce the cost).
Assume that each stain is a point and that the rectangle is aligned parallel to the axes.
Input Format
The first line contains two integers
N
(1<=N<=1000) and
K
(0<=K<=N).
Next follow
N
lines, one for each stain. Each line contains two integers in the form 'X Y', (0<=X,Y<100000), the coordinates of each stain into the blanket. Each pair of coordinates is unique.
Output Format
Output a single integer. The remainder of the division by 1000000007 of the answer.
Sample Input
5 2
0 1
3 3
2 0
0 3
2 3
Sample Output
8
Explanation
We can clean two spots. So removing any of the following set of stains will lead us to a conbination that will need less amount of silk.(The numbers refer to the
indices of the stains
in the input and they begin from 1).
1, 4
2, 1
2, 3
2, 4
2, 5
3, 1
3, 4
3, 5
So there are 8 ways.","Calculate the initial area X using all N stains and then, for each combination of removing K stains, recalculate the area and increment a counter if it's strictly less than X, finally return the counter modulo 1000000007.","Sort the stains based on their x-coordinates, then iterate through all combinations of K stains to remove. For each combination, calculate the area of the bounding rectangle of the remaining stains. Return the count of combinations where the area is less than the initial area X.","Use dynamic programming to store the areas covered by different subsets of stains, considering the removal of K stains. Calculate the initial area X and then compare it with the dynamically computed areas. Return the number of cases where the covered area is strictly less than X, modulo 1000000007.","Calculate the initial area X. Iterate through each stain and calculate the change in area if that stain is removed. Sort the changes in area and remove the K stains with the largest change. If the new area is less than X, increment a counter.","Compute the initial area X covering all N stains. Generate all combinations of K stains to remove. For each combination, calculate the minimal area covering the remaining N-K stains. Increment a counter if this area is strictly less than X. Return the counter modulo 1000000007.",,algorithms,"['geometry', 'combinatorics', 'optimization']"
https://www.hackerrank.com/challenges/travel-in-hackerland?isFullScreen=true,"HackerLand is a country with
beautiful cities and
undirected roads. Like every other beautiful country, HackerLand has traffic jams.
Each road has a
crowd value
. The crowd value of a path is defined as the maximum crowd value for all roads in the path. For example, if the crowd values for all roads are
, then the crowd value for the path will be
.
Each city
has a type value,
, denoting the type of buildings in the city.
David just started his vacation in HackerLand. He wants to travel from city
to city
. He also wants to see at least
different types of buildings along the path from
to
. When choosing a path from city
to city
that has at least
different types of buildings along the path, David always selects the one with the
minimum
crowd value.
You will be given
queries. Each query takes the form of
space-separated integers,
,
, and
, denoting the respective values for starting city, destination city, and minimum number of unique buildings that David wants to see along the way. For each query, you must print the minimum crowd value for a path between
and
that has at least
different buildings along the route. If there is no such path, print
-1
.
Note:
A path may contain cycles (i.e., the same roads or cities may be traveled more than once).
Input Format
The first line contains
space-separated integers denoting the respective values for
(the number of cities),
(the number of roads), and
(the number of queries).
The second line contains
space-separated integers describing the respective building type for each city in array
(where the
-th value is
and
).
Each of the
subsequent lines defines a road in the form of
space-separated integers,
,
, and
, defining an undirected road with crowd value
that connects cities
and
.
Each of the
subsequent lines defines a query in the form of
space-separated integers,
,
, and
(where
), respectively.
Constraints
Each road connect
distinct cities, meaning no road starts and ends in the same city.
Output Format
For each query, print its answer on a new line.
Sample Input
7 6 1
1 1 4 5 1 3 2
1 2 3
2 6 2
2 3 4
3 4 3
2 4 9
5 7 9
1 2 4
Sample Output
4
Explanation
The diagram below depicts the country given as
Sample Input
. Different values of
are shown in different colors.
https://s3.amazonaws.com/hr-challenge-images/12233/1462508042-2b706831d3-davaro.png
The path for the last query (
1 2 4
) will be
. David sees his first type of building in cities
and
, his second type of building in city
, his third type of building in city
, and his fourth type of building in city
. The crowd values for each road traveled on this path are
; the maximum of these values is
. Thus, we print
on a new line.","Use Dijkstra's algorithm directly with crowd value as cost, ignoring building types.",Perform a breadth-first search (BFS) and select the path with the minimum number of edges satisfying the building type constraint.,"Employ a depth-first search (DFS) and return the first path found meeting the criteria, regardless of crowd value minimization.",Calculate all possible paths and select the one with the least number of nodes that satisfy the condition.,Use a modified Dijkstra's or binary search on crowd value combined with a graph traversal to find the minimum crowd value path with at least K distinct building types.,,algorithms,"['graph traversal', 'Dijkstra', 'binary search']"
https://www.hackerrank.com/challenges/rust-murderer?isFullScreen=true,"Detective Rust is investigating a homicide and he wants to chase down the murderer. The murderer knows he would definitely get caught if he takes the main roads for fleeing, so he uses the village roads (or side lanes) for running away from the crime scene.
Rust knows that the murderer will take village roads and he wants to chase him down. He is observing the city map, but it doesn't show the village roads (or side lanes) on it and shows only the main roads.
The map of the city is a graph consisting
nodes (labeled
to
) where a specific given node
represents the current position of Rust and the rest of the nodes denote other places in the city, and an edge between two nodes is a main road between two places in the city. It can be suitably assumed that
an edge that doesn't exist/isn't shown on the map is a village road (side lane)
. That means, there is a village road between two nodes
and
iff(if and only if) there is no city road between them.
In this problem, distance is calculated as number of village roads (side lanes) between any two places in the city.
Rust wants to calculate the shortest distance from his position (Node
) to all the other places in the city if he travels only using the village roads (side lanes).
Note:
The graph/map of the city is ensured to be a sparse graph.
Input Format
The first line contains
, denoting the number of test cases.
testcases follow.
First line of each test case has two integers
, denoting the number of cities in the map and
, denoting the number of roads in the map.
The next
lines each consist of two space-separated integers
and
denoting a main road between city
and city
.
The last line has an integer
, denoting the current position of Rust.
Constraints
Note
No nodes will have a road to itself.
There will not be multiple edges between any pair of nodes i.e. there is at most one undirected edge between them.
Graph is guaranteed to be sparse.
It is guranteed that there will be a path between any pair of nodes using the side lanes.
Output Format
For each of T test cases, print a single line consisting of N-1 space separated integers, denoting the shortest distances of the remaining N-1 places from Rust's position (that is all distances, except the source node to itself) using the village roads/side lanes in ascending order based on vertex number.
Sample Input 0
2
4 3
1 2
2 3
1 4
1
4 2
1 2
2 3
2
Sample Output 0
3 1 2
2 2 1
Explanation 0
The graph in the first testcase can be shown as:
https://s3.amazonaws.com/hr-assets/0/1526375381-e5049e612b-Screenshotfrom2018-05-1514-21-53.png
Here the source node is 1 (marked S).
The distance from 1 to 2 is 3. Path: 1 -> 3 -> 4 -> 2
The distance from 1 to 3 is 1. Path: 1 -> 3
The distance from 1 to 4 is 2. Path: 1 -> 3 -> 4",Breadth-First Search (BFS) on the original graph,Depth-First Search (DFS) on the original graph,Dijkstra's Algorithm on the original graph,Floyd-Warshall Algorithm on the original graph,Breadth-First Search (BFS) on the complement graph,,algorithms,"['graph theory', 'BFS', 'complement graph']"
https://www.hackerrank.com/challenges/bytelandian-tours?isFullScreen=true,"The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two ""somewhat near"" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as ""somewhat near"" each other.
Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this?
Input Format
The first line contains the number of test cases T. T test cases follow. The first line contains N, the number of cities in Byteland. The following N - 1 lines contain the description of the roads. The ith line contains two integers ai and bi, meaning that there was originally a road connecting cities with numbers ai and bi.
Constraints
1 <= T <= 20
1 <= N <= 10000
0 <= ai,bi < N
Output Format
Output T lines, one corresponding to each test case containing the required answer for that test case. Since the answers can be huge, output them modulo 1000000007.
Sample Input
2
3
0 1
1 2
5
0 1
1 2
2 3
2 4
Sample Output
2
4
Explanation
For the first case, a new road was build between cities 0 and 2. Now, the salesman has two tour possibilities: 0-1-2-0 or 0-2-1-0.",N!,(N-1)! / 2,2^(N-1),The number of Hamiltonian cycles in the complete graph K_N,"The number of Hamiltonian cycles in the modified graph, modulo 1000000007",,algorithms,"['graph theory', 'Hamiltonian cycle', 'adjacency list']"
https://www.hackerrank.com/challenges/sherlock-and-valid-string?isFullScreen=true,"Sherlock considers a string to be
valid
if all characters of the string appear the same number of times.  It is also
valid
if he can remove just
character at
index in the string, and the remaining characters will occur the same number of times.  Given a string
, determine if it is
valid
.  If so, return
YES
, otherwise return
NO
.
Example
This is a valid string because frequencies are
.
This is a valid string because we can remove one
and have
of each character in the remaining string.
This string is not
valid
as we can only remove
occurrence of
.  That leaves character frequencies of
.
Function Description
Complete the
isValid
function in the editor below.
isValid has the following parameter(s):
string s
: a string
Returns
string:
either
YES
or
NO
Input Format
A single string
.
Constraints
Each character
Sample Input 0
aabbcd
Sample Output 0
NO
Explanation 0
Given
, we would need to remove two characters, both
c
and
d
aabb
or
a
and
b
abcd
, to make it valid. We are limited to removing only one character, so
is
invalid
.
Sample Input 1
aabbccddeefghi
Sample Output 1
NO
Explanation 1
Frequency counts for the letters are as follows:
{'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 1, 'g': 1, 'h': 1, 'i': 1}
There are two ways to make the valid string:
Remove
characters with a frequency of
:
.
Remove
characters of frequency
:
.
Neither of these is an option.
Sample Input 2
abcdefghhgfedecba
Sample Output 2
YES
Explanation 2
All characters occur twice except for
which occurs
times.  We can delete one instance of
to have a valid string.","If all characters appear the same number of times, return ""NO"".","If the length of the string is 1, return ""NO"".","If removing any character makes all remaining characters appear the same number of times, return ""NO"".","If the number of distinct characters is greater than 2, return ""NO"".","If all characters of the string appear the same number of times, return ""YES"". It is also valid if removing just 1 character at 1 index in the string will make the remaining characters occur the same number of times, in which case return ""YES"". Otherwise return ""NO"".",,algorithms,"['string manipulation', 'frequency analysis', 'validation']"
https://www.hackerrank.com/challenges/half?isFullScreen=true,"Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects.
Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows:
Initially there are
piles of stones; pile
has
stone, pile
has
stones, and so on. Thus, the
pile has
stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy
at least half of the stones in it
. The winner is the saint who destroys the last available stone .
For example, from a pile of
stones, a saint must destroy at least
stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills.
Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?
Input Format
First line of the input consists of an integer
,
testcases follow, each in a new line. Each line will contain a single integer
, which describes the number of initial piles as explained above.
Constraints
Output Format
For each line in the input, output the minimum number of stones Ryuho needs to destroy in his first turn, assuming he starts playing and that both he and Koga play always as well as possible. If this is not possible, just print
.
Sample Input 0
5
1
10
6
8
123456
Sample Output 0
1
7
2
7
32768
Explanation 0
For the first testcase, we can see that the saint can destroy the first stone and win the game.
Sample Input 1
1
3
Sample Output 1
1
Explanation 1
There are three piles with stones
and
.
Initially Ryuho will remove
stone from the first pile.
Now other saint has
options -
First, to remove all stones from second pile. In that case Ryuho will remove all stones from third pile and win the game.
Second, to remove all stones from third pile. In that case Ryuho will remove all stones from second pile and win the game.
Third, to remove
stone from second pile. In that case Ryuho will remove
stones from third pile and they will be left with
stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone.
Fourth, to remove
stones from the third pile. In that case Ryuho will remove
stone from second pile and they will be left with
stone in each of the second and third pile. No matter what the other saint selects Ryuho will have an option to select the last stone.
So in all four cases Ryuho will win the game.",The minimum number of stones to remove is always 1.,The minimum number of stones to remove is half the total number of stones across all piles.,The minimum number of stones to remove can be determined by finding the largest pile and removing stones until its size is one less than the second largest pile.,The minimum number of stones to remove requires evaluating all possible game states and applying the minimax algorithm.,"The minimum number of stones to remove can be determined by calculating the Nim-sum of the piles, and then finding a move to make the Nim-sum zero.",,algorithms,"['game theory', 'nim sum', 'bit manipulation']"
https://www.hackerrank.com/challenges/accessory-collection?isFullScreen=true,"Victoria
is splurging on expensive accessories at her favorite stores. Each store stocks
types of accessories, where the
accessory costs
dollars (
). Assume that an item's type identifier is the same as its cost, and the store has an unlimited supply of each accessory.
Victoria wants to purchase a total of
accessories according to the following rule:
Any
-element subset of the purchased items must contain
at least
different types of accessories.
For example, if
,
, and
, then she must choose
accessories such that
any
subset of
of the
accessories will contain
at least
distinct types of items.
Given
,
,
, and
values for
shopping trips, find and print the maximum amount of money that Victoria can spend during each trip; if it's not possible for Victoria to make a purchase during a certain trip, print
SAD
instead. You must print your answer for each trip on a new line.
Input Format
The first line contains an integer,
, denoting the number of shopping trips.
Each of the
subsequent lines describes a single shopping trip as four space-separated integers corresponding to
,
,
, and
, respectively.
Constraints
The sum of the
's for all
shopping trips
.
Output Format
For each shopping trip, print a single line containing either the maximum amount of money Victoria can spend; if there is no collection of items satisfying her shopping rule for the trip's
,
,
, and
values, print
SAD
instead.
Sample Input
2
6 5 3 2
2 1 2 2
Sample Output
24
SAD
Explanation
Shopping Trip 1:
We know that:
Victoria wants to buy
accessories.
The store stocks the following
types of accessories:
.
For any grouping of
of her
accessories, there must be
at least
distinct types of accessories.
Victoria can satisfy her shopping rule and spend the maximum amount of money by purchasing the following set of accessories:
. The total cost is
, so we print
on a new line.
Shopping Trip 2:
We know that:
Victoria wants to buy
accessories.
The store stocks
type of accessory:
.
For any grouping of
of her
accessories, there must be
at least
distinct types of accessories.
Because the store only carries
type of accessory, Victoria cannot make a purchase satisfying the constraint that there be at least
distinct types of accessories. Because Victoria will not purchase anything, we print that she is
SAD
on a new line.","The result will always be the product of N and M, representing all possible combinations.","The answer can be found by greedily choosing the largest accessories until the constraint is violated, then backtracking.","This is an NP-complete problem, and only approximate solutions can be found efficiently.",Binary search over the possible total costs to find the maximum feasible cost.,"Iterate through all possible combinations of accessories using dynamic programming or recursion with memoization, checking the k-element subset constraint for each combination, and maximize the total cost.",,algorithms,"['dynamic programming', 'combinatorics', 'constraints']"
https://www.hackerrank.com/challenges/lena-sort?isFullScreen=true,"Lena developed a sorting algorithm described by the following pseudocode:
lena_sort
(
array
nums
)
{
if
(
nums
.
size
<=
1
)
{
return
nums
;
}
pivot
=
nums
[
0
];
array
less
;
array
more
;
for
(
i
=
1
;
i
<
nums
.
size
;
++
i
)
{
// Comparison
if
(
nums
[
i
]
<
pivot
)
{
less
.
append
(
nums
[
i
]);
}
else
{
more
.
append
(
nums
[
i
]);
}
}
sorted_less
=
lena_sort
(
less
);
sorted_more
=
lena_sort
(
more
);
ans
=
sorted_less
+
pivot
+
sorted_more
;
return
ans
;
}
We consider a
comparison
to be any time some
is compared with
.
You must solve
queries where each query
consists of some
and
. For each query, construct an array of
distinct elements in the inclusive range between
and
that will be sorted by
in exactly
comparisons, then print each respective element of the unsorted array as a single line of
space-separated integers; if no such array exists, print
-1
instead.
Input Format
The first line contains a single integer denoting
(the number of queries).
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
(the length of the array) and
(the number of comparisons) for query
.
Constraints
the sum of
over all queries
Output Format
Print the answer to each query on a new line. For each query
, print
space-separated integers describing each respective element in an unsorted array that Lena's algorithm will sort in exactly
comparisons; if no such array exists, print
-1
instead.
Sample Input 0
2
5 6
5 100
Sample Output 0
4 2 1 3 5
-1
Explanation 0
We perform the following
queries:
One array with
elements is
. The sequence of sorting operations looks like this:
Run
on
. Compare
with
,
,
, and
for a total of
comparisons. We're then left with
and
; we only need to continue sorting
, as
is sorted with respect to itself because it only contains one element.
Run
on
. Compare
with
and
for a total of
comparisons. We're then left with
and
, so we stop sorting.
We sorted
in
comparisons and
, so we print
4 2 1 3 5
on a new line.
It's not possible to construct an array with
elements that
will sort in exactly
comparisons, so we print
-1
on a new line.
Sample Input 1
3
1 0
4 6
3 2
Sample Output 1
1
4 3 2 1
2 1 3
Explanation 1
We perform the following
queries:
We want an array with
element that
sorts in
comparisons; any array with
element is already sorted (i.e.,
performs
comparisons), so we choose
as our array and print
1
on a new line.
One array with
elements is
; sorting it with
looks like this:
on
. Compare
with
,
, and
for a total of
comparisons. We're then left with
and
; we only need to continue sorting
, as
is empty.
Run
on
. Compare
with
and
for a total of
comparisons. We're then left with
and
, so we only continue sorting
.
Run
on
. Compare
with
for a total of
comparison. We then stop sorting, as
and
.
We sorted
in
comparisons and
, so we print
4 3 2 1
on a new line.
One array with
elements is
. When we run
on it, we compare
with
and
for a total of
comparisons. We're then left with
and
, so we stop sorting.
We sorted
in
comparisons and
, so we print
2 1 3
on a new line.","The algorithm is O(n log n) in the average case and O(n^2) in the worst case, similar to quicksort.",The algorithm is O(n) because it iterates through the array once to partition elements.,"The algorithm's time complexity is determined by the number of comparisons, which is always n - 1, resulting in O(n).",The algorithm has a time complexity of O(n!) because each element could potentially be a pivot.,"The algorithm is O(n log n) on average because the pivot divides the problem into subproblems of roughly equal size, and O(n^2) in the worst case when the pivot is always the smallest or largest element.",,algorithms,"['sorting algorithm', 'recursion', 'time complexity']"
https://www.hackerrank.com/challenges/wet-shark-and-two-subsequences?isFullScreen=true,"One day, Wet Shark was given an array
. As always, he started playing with its
subsequences
.
When you came to know about this habit, you presented him a task of finding all pairs of subsequences,
, which satisfies all of the following constraints. We will represent a pair of subsequence as
and
and
must be of same length, i.e.,
.
Please help Wet Shark determine how many possible subsequences
and
can exist. Because the number of choices may be big, output your answer modulo
.
Note:
Two segments are different if there's exists at least one index
such that element
is present in exactly one of them.
Both subsequences can overlap each other.
Subsequences do not necessarily have to be distinct
Input Format
The first line consists of 3 space-separated integers
,
,
, where
denotes the length of the original array,
, and
and
are as defined above.
The next line contains
space-separated integers,
, representing the elements of
.
Constraints
Output Format
Output total number of pairs of subsequences,
, satisfying the above conditions. As the number can be large, output it's modulo
Sample Input 0
4 5 3
1 1 1 4
Sample Output 0
3
Explanation 0
For array
there are three pairs of subsequences:",n * (n-1) / 2,"nCr(n, k) * nCr(n, k)",2^(n-1),k * (nCk mod m),(nCk mod m)^2,,algorithms,"['combinations', 'modulo arithmetic', 'subsequences']"
https://www.hackerrank.com/challenges/3d-surface-area?isFullScreen=true,"Madison is a little girl who is fond of toys. Her friend Mason works in a toy manufacturing factory . Mason has a 2D board
of size
with
rows and
columns. The board is divided into cells of size
with each cell indicated by its coordinate
. The cell
has an integer
written on it. To create the toy Mason stacks
number of cubes of size
on the cell
.
Given the description of the board showing the values of
and that the price of the toy is equal to the 3d surface area find the price of the toy.
Input Format
The first line contains two space-separated integers
and
the height and the width of the board respectively.
The next
lines contains
space separated integers. The
integer in
line denotes
.
Constraints
Output Format
Print the required answer, i.e the price of the toy, in one line.
Sample Input 0
1 1
1
Sample Output 0
6
Explanation 0
https://s3.amazonaws.com/hr-assets/0/1505569910-2f8fc5da13-3d.png
The surface area of
cube is 6.
Sample Input 1
3 3
1 3 4
2 2 3
1 2 4
Sample Output 1
60
Explanation 1
https://s3.amazonaws.com/hr-assets/0/1509009918-091bdd4cba-1502631298-5cd3275ce9-img2.png
The object is rotated so the front row matches column 1 of the input, heights 1, 2, and 1.
The front face is 1 + 2 + 1 = 4 units in area.
The top is 3 units.
The sides are 4 units.
None of the rear faces are exposed.
The underside is 3 units.
The front row contributes 4 + 3 + 4 + 3 = 14 units to the surface area.","Calculate the total number of cubes and multiply by 6, ignoring overlaps.",Sum all the height values in the grid and multiply by 6.,Multiply the sum of the dimensions (rows + columns) by the maximum height found in the grid.,Calculate the area of the base (rows * columns) and multiply by the average height.,"Calculate the surface area by considering the exposed faces of each cube, accounting for adjacent cubes and edges.",,algorithms,"['2D array', 'surface area', 'simulation']"
https://www.hackerrank.com/challenges/cat-jogging?isFullScreen=true,"It's almost summertime, so Big Cat and Little Cat are getting in shape. They decide the core of their fitness plan is to start jogging every day.
Their city consists of
intersections connected by
bidirectional roads. The cats decide that their jogging route should be cyclic (i.e., starting and ending at the same intersection) and consist of
different roads.
The cats also love exploring new places, so each day they want to choose a new route to jog on that is not equal to any of their previous routes. Two routes are considered to be equal if their sets of component roads are equal.
Given a map of the city, can you help our heroic cats determine the maximum number of days they can go jogging so that every route traveled is different?
Input Format
The first line contains a pair of space-separated integers,
(the number of intersections) and
(the number of roads), respectively.
Each line
of the
subsequent lines contains a pair of space-separated integers,
and
, defining a bidirectional road connecting intersections
and
.
Constraints
Each bidirectional road connects
distinct intersections (i.e., no road connects an intersection to itself).
Each pair of intersections is directly connected by no more than
road.
Output Format
Print the maximum number of days for which the cats can go jogging without repeating a route.
Sample Input
4 6
1 2
2 3
3 4
4 1
1 3
2 4
Sample Output
3
Explanation
There are
different routes:
Recall that each route is a
set
of intersections forming a cycle, so each unique route is the same regardless of which city on the route the cats start out at. Thus, we print
(the number of routes) as our answer.",Eulerian path calculation,Minimum spanning tree algorithm,Topological sorting,Dijkstra's algorithm,Finding all elementary cycles in a graph,,algorithms,"['graph theory', 'cycles', 'enumeration']"
https://www.hackerrank.com/challenges/string-reduction?isFullScreen=true,"Given a string consisting of the letters
,
and
, we can perform the following operation:
Take any two adjacent distinct characters and replace them with the third character.
Find the shortest string obtainable through applying this operation repeatedly.
For example, given the string
we can reduce it to a
character string by replacing
with
and
with
:
.
Function Description
Complete the
stringReduction
function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.
stringReduction has the following parameter:
-
s
: a string
Input Format
The first line contains the number of test cases
.
Each of the next
lines contains a string
to process.
Constraints
Output Format
For each test case, print the length of the resultant minimal string on a new line.
Sample Input
3
cab
bcab
ccccc
Sample Output
2
1
5
Explanation
For the first case, there are two solutions:
or
.
For the second case, one optimal solution is:
.
For the third case, no operations can be performed so the answer is
.","n - 1, where n is the length of the input string",The length of the longest repeating character sequence in the input string,The number of distinct characters in the input string,"2 if all characters are different, otherwise 1","1 if all characters in the input string are different, or if all characters are the same, otherwise 2",,algorithms,"['string manipulation', 'greedy algorithm', 'pattern recognition']"
https://www.hackerrank.com/challenges/save-humanity?isFullScreen=true,"Oh!! Mankind is in trouble again. This time, it's a deadly disease spreading at a rate never seen before. The need of the hour is to set up efficient virus detectors. You are the lead at Central Hospital and you need to find a fast and reliable way to detect the footprints of the virus DNA in that of the patient.
The DNA of the patient as well as of the virus consists of lowercase letters. Since the collected data is raw, there may be some errors. You will need to find all substrings in the patient DNA that either exactly match the virus DNA or have at most one mismatch, i.e., a difference in at most one location.
For example, ""
aa
"" and ""
aa
"" are matching, ""
ab
"" and ""
aa
"" are matching, while ""
abb
"" and ""
bab
"" are not.
Function Description
Complete the
virusIndices
function in the editor below.  It should print a list of space-separated integers that represent the starting indices of matching substrings in increasing order, or
No match!
.
virusIndices has the following parameter(s):
p
: a string that represents patient DNA
v
: a string that represents virus DNA
Input Format
The first line contains an integer
, the number of test cases.
.
Each of the next
lines contains two space-separated strings
(the patient DNA) and
(the virus DNA).
Constraints
All characters in
and
.
Output Format
For each test case, output a single line containing a space-delimited list of starting indices (
-indexed) of substrings of
which are matching with
according to the condition mentioned above. The indices have to be in increasing order. If there is no matching substring, output
No Match!
.
Sample Input 0
3
abbab ba
hello world
banana nan
Sample Output 0
1 2
No Match!
0 2
Explanation 0
For the first case, the substrings of
starting at indices
and
are ""
bb
"" and ""
ba
"" and they are matching with the string
which is ""
ba
"".
For the second case, there are no matching substrings so the output is
No Match!
.
For the third case, the substrings of
starting at indices
and
are ""
ban
"" and ""
nan
"" and they are matching with the string
which is ""
nan
"".
Sample Input 1
3
cgatcg gc
atcgatcga cgg
aardvark ab
Sample Output 1
1 3
2 6
0 1 5
Explanation 1
For the first case, the substrings of
starting at indices
and
are ""
ga
"" and ""
gc
"" and they are matching with the string
which is ""
gc
"".
For the second case, the substrings of
starting at indices
and
are ""
cga
"" and ""
cga
"" and they are matching with the string
which is ""
cgg
"".
For the third case, the substrings of
starting at indices
,
and
are ""
aa
"", ""
ar
"" and ""
ar
"" and they are matching with the string
which is ""
ab
"".",Use dynamic programming to build a table of substring matches,Use a trie data structure to efficiently search for the virus DNA within the patient DNA,"Employ the Knuth-Morris-Pratt (KMP) algorithm to find exact matches, and then check for single-mismatch occurrences in the neighborhood",Calculate the Levenshtein distance between the virus DNA and each substring of the patient DNA,"Iterate through all substrings of the patient DNA and compare each with the virus DNA, counting mismatches; store the starting indices of matching substrings",,algorithms,"['string matching', 'substring', 'mismatch']"
https://www.hackerrank.com/challenges/going-office?isFullScreen=true,"Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day.
Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office.
Input Format
There are N cities numbered 0 to N-1 and M bidirectional roads.
The first line of the input contains two integers N and M.
M lines follow, each containing three space-separated integers u , v and w, where u and v are cities connected by a bi-directional road and w is the length of this road. There is at most one road between any two cities and no road connects a city to itself.
The next line contains two integers S and D. S is the city where Ms. Kox lives and D is the city where her office is located.
The next line contains an integer Q, the number of queries.
Q lines follow, each containing two integers u and v, where the road between u and v has been blocked that day.
Constraints
Output Format
Output Q lines, with each line containing the minimum distance Ms.Kox has to travel on that day. If there is no path, print ""
Infinity
"".
Sample Input
6 9
0 1 1
1 2 1
2 3 1
3 4 1
4 5 1
2 4 5
3 5 8
1 3 3
0 2 4
0 5
9
0 1
1 2
2 3
3 4
4 5
2 4
3 5
1 3
0 2
Sample Output
7
6
6
8
11
5
5
5
5","Floyd-Warshall Algorithm, recalculating the shortest paths for all pairs of nodes after removing the edge.","Dijkstra's Algorithm, running it from the source node for each query after temporarily removing the blocked road from the adjacency list.","Bellman-Ford Algorithm, running it from the source node for each query after temporarily setting the weight of the blocked road to infinity.",A* search algorithm with a heuristic estimating distance to the destination node,Recomputing Dijkstra's algorithm only considering edges that are not blocked. Implement a priority queue to optimize.,,algorithms,"['graph algorithms', 'shortest path', 'Dijkstra']"
https://www.hackerrank.com/challenges/travel-around-the-world?isFullScreen=true,"There are N cities and N directed roads in Steven's world. The cities are numbered from 0 to N - 1. Steven can travel from city
i
to city
(i + 1) % N
, ( 0-> 1 -> 2 -> .... -> N - 1 -> 0).
Steven wants to travel around the world by car. The capacity of his car's fuel tank is C gallons. There are a[i] gallons he can use at the beginning of city
i
and the car takes b[i] gallons to travel from city
i
to
(i + 1) % N
.
How many cities can Steven start his car from so that he can travel around the world and reach the same city he started?
Note
The fuel tank is initially empty.
Input Format
The first line contains two integers (separated by a space): city number
N
and capacity
C
.
The second line contains
N
space-separated integers: a[0], a[1], … , a[N - 1].
The third line contains
N
space-separated integers: b[0], b[1], … , b[N - 1].
Constraints
2 ≤ N ≤ 10
5
1 ≤ C ≤ 10
18
0 ≤ a[i], b[i] ≤ 10
9
Output Format
The number of cities which can be chosen as the start city.
Sample Input
3 3
3 1 2
2 2 2
Sample Output
2
Explanation
Steven starts from city 0, fills his car with 3 gallons of fuel, and use 2 gallons of fuel to travel to city 1. His fuel tank now has 1 gallon of fuel.
On refueling 1 gallon of fuel at city 1, he then travels to city 2 by using 2 gallons of fuel. His fuel tank is now empty.
On refueling 2 gallon of fuel at city 2, he then travels back to city 0 by using 2 gallons of fuel.
Here is the second possible solution.
Steven starts from city 2, fill his car with 2 gallons, and travels to city 0.
On refueling 3 gallons of fuel from city 0, he then travels to city 1, and exhausts 2 gallons of fuel. His fuel tank contains 1 gallon of fuel now.
He can then refuel 1 gallon of fuel at City 1, and increase his car's fuel to 2 gallons and travel to city 2.
However, Steven cannot start from city 1, because he is given only 1 gallon of fuel, but travelling to city 2 requires 2 gallons.
Hence the answer 2.",The algorithm has no feasible solution given the constraints.,It is possible to start from any city.,Check only cities with a[i] >= b[i].,Binary search for an optimal starting city.,Simulate the journey starting from each city and verify if a complete cycle is possible.,,algorithms,"['simulation', 'cyclic path', 'fuel management']"
https://www.hackerrank.com/challenges/sams-puzzle?isFullScreen=true,"Sam invented a new puzzle game played on an
matrix named
, where each cell contains a unique integer in the inclusive range between
and
. The coordinate of the top-left cell is
.
The Moves
A move consists of two steps:
Choose a sub-square of
.
Rotate the sub-square in the
clockwise
direction.
For example:
https://s3.amazonaws.com/hr-challenge-images/0/1481461326-391b5e70d0-sam31.png
We describe a move as the clockwise rotation of a
sub-square whose top-left corner is located at coordinate
. In the example above,
,
, and
.
Good Pairs of Cells
A pair of cell is
good
if one of the following is true:
They're located in the same row and the number in the left cell is less than the number in the right cell.
They're located in the same column and the number in the upper cell is less than the number in the lower cell.
The diagram below depicts all the
good
pairs of cells located in the same row:
https://s3.amazonaws.com/hr-challenge-images/0/1481437201-9ff1620127-sams3.png
The diagram below depicts all the
good
pairs of cells located in the same column:
https://s3.amazonaws.com/hr-challenge-images/0/1481460380-071db1a562-sams2.png
Goodness of a Square
We define the
goodness
of a sub-square to be the total number of good pairs of cells in the sub-square.
The Goal
Given the initial value of
, maximize its goodness as much as is possible by performing a sequence of
at most
moves. Then print the necessary moves according to the
Output Format
specified below.
Input Format
The first line contains an integer denoting
.
Each of the
subsequent lines contains
space-separated integers. The
integer in the
line denotes the cell located in coordinate
.
Constraints
Each cell contains a unique number in the inclusive range between
and
.
Scoring
We define
as the goodness in the beginning,
as the goodness after your moves, and
as the maximum possible goodness.
A valid answer earns
of a test case's available points (it's guaranteed that
). The total score will be rounded up to the next
.
Test Case Generation
Consider all the cells in
to be initially empty. Sam sorts the
numbers in ascending order and then picks them one by one and places them in some random cell which has no empty cell to its left and no empty cell above it. This generates a square with goodness
.
After generating
, Sam makes some random rotations. During each step, he chooses three random numbers,
,
, and
, and rotates a
sub-square with the top-left corner at coordinate
in the
counterclockwise
direction. Here
and
.
Sam makes
at most
such random counterclockwise rotations. This means that it's possible to achieve maximum goodness in as little as
moves.
Output Format
Print the following lines of output:
On the first line, print an integer,
, denoting the number of moves necessary to maximize the goodness of
. Recall that this number must be
.
For each move, print three space-separated integers describing its respective
,
, and
values on a new line. Recall that a move is described as the clockwise rotation of a
sub-square whose top-left corner is located at coordinate
.
Sample Input 0
3
8 6 9
7 2 5
1 4 3
Sample Output 0
3
1 1 2
2 2 2
1 1 3
Explanation 0
After the first move:
https://s3.amazonaws.com/hr-challenge-images/0/1481465622-e3f8b15999-sam35.png
After the second move:
https://s3.amazonaws.com/hr-challenge-images/0/1481465699-a62fe4b29a-sam41.png
After the third move:
https://s3.amazonaws.com/hr-challenge-images/0/1481465712-c00a659ff0-sam52.png
The goodness after this sequence of moves is
, and the maximum possible goodness is
.
Because the initial goodness was
, this solution will get
of the test case's available points.","Simulated Annealing, accepting all moves that increase goodness and probabilistically accepting moves that decrease goodness.","Greedy approach, rotating the largest possible sub-square at each step that maximizes the goodness locally.","Brute-force, trying all possible sequences of moves up to M and choosing the one with the highest goodness.","Genetic algorithm, evolving a population of move sequences and selecting for higher goodness.","Iterative improvement, focusing on local optimizations by rotating sub-squares of different sizes around each cell to find beneficial moves.",,algorithms,"['optimization', 'matrix rotation', 'greedy algorithm']"
https://www.hackerrank.com/challenges/matrix-rotation-algo?isFullScreen=true,"You are given a 2D  matrix of dimension
and a positive integer
. You have to rotate the matrix
times and print the resultant matrix. Rotation should be in anti-clockwise direction.
Rotation of a
matrix is represented by the following figure. Note that in one rotation, you have to shift elements by one step only.
https://hr-challenge-images.s3.amazonaws.com/2517/matrix-rotation.png
It is guaranteed that the minimum of
m
and
n
will be even.
As an example rotate the Start matrix by 2:
Start         First           Second
     1 2 3 4       2  3  4  5      3  4  5  6
    12 1 2 5  ->   1  2  3  6 ->   2  3  4  7
    11 4 3 6      12  1  4  7      1  2  1  8
    10 9 8 7      11 10  9  8     12 11 10  9
Function Description
Complete the
matrixRotation
function in the editor below.
matrixRotation has the following parameter(s):
int matrix[m][n]:
a 2D array of integers
int r:
the rotation factor
Prints
It should print the resultant 2D integer array and return nothing.  Print each row on a separate line as space-separated integers.
Input Format
The first line contains three space separated integers,
,
, and
, the number of rows and columns in
, and the required rotation.
The next
lines contain
space-separated integers representing the elements of a row of
.
Constraints
Sample Input
Sample Input #01
STDIN        Function
-----        --------
4 4 2        rows m = 4, columns n = 4, rotation factor r = 2
1 2 3 4      matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
5 6 7 8
9 10 11 12
13 14 15 16
Sample Output #01
3 4 8 12
2 11 10 16
1 7 6 15
5 9 13 14
Explanation #01
The matrix is rotated through two rotations.
1  2  3  4      2  3  4  8      3  4  8 12
     5  6  7  8      1  7 11 12      2 11 10 16
     9 10 11 12  ->  5  6 10 16  ->  1  7  6 15
    13 14 15 16      9 13 14 15      5  9 13 14
Sample Input #02
5 4 7
1 2 3 4
7 8 9 10
13 14 15 16
19 20 21 22
25 26 27 28
Sample Output #02
28 27 26 25
22 9 15 19
16 8 21 13
10 14 20 7
4 3 2 1
Explanation 02
The various states through 7 rotations:
1  2  3  4      2  3  4 10    3  4 10 16    4 10 16 22
    7  8  9 10      1  9 15 16    2 15 21 22    3 21 20 28
    13 14 15 16 ->  7  8 21 22 -> 1  9 20 28 -> 2 15 14 27 ->
    19 20 21 22    13 14 20 28    7  8 14 27    1  9  8 26
    25 26 27 28    19 25 26 27    13 19 25 26   7 13 19 25

    10 16 22 28    16 22 28 27    22 28 27 26    28 27 26 25
     4 20 14 27    10 14  8 26    16  8  9 25    22  9 15 19
     3 21  8 26 ->  4 20  9 25 -> 10 14 15 19 -> 16  8 21 13
     2 15  9 25     3 21 15 19     4 20 21 13    10 14 20  7
     1  7 13 19     2  1  7 13     3  2  1  7     4  3  2  1
Sample Input #03
2 2 3
1 1
1 1
Sample Output #03
1 1
1 1
Explanation #03
All of the elements are the same, so any rotation will repeat the same matrix.",Iterate through each layer and perform rotations by swapping elements using temporary variables within the matrix.,"Create a deep copy of the matrix, then iteratively rotate by shifting each element to its new position based on 'r'.","For each layer, extract the elements into a 1D array, perform rotations on the 1D array, and then place the elements back into the matrix.","Transpose the matrix, reverse each row, and repeat 'r' times.","Process the matrix in layers; for each layer, extract elements into a 1D array, rotate the 1D array by r % length(1D array), and replace the layer's elements in the matrix with the rotated array.",,algorithms,"['matrix', 'rotation', '2D array']"
https://www.hackerrank.com/challenges/beautiful-3-set?isFullScreen=true,"You are given an integer
. A set,
, of triples
is
beautiful
if and only if:
Let
be the set of different
's in
,
be the set of different
's in
, and
be the set of different
in
. Then
.
The third condition means that all
's are pairwise distinct. The same goes for
and
.
Given
, find any
beautiful
set having a maximum number of elements. Then print the
cardinality
of
(i.e.,
) on a new line, followed by
lines where each line contains
space-separated integers describing the respective values of
,
, and
.
Input Format
A single integer,
.
Constraints
Output Format
On the first line, print the cardinality of
(i.e.,
).
For each of the
subsequent lines, print three space-separated numbers per line describing the respective values of
,
, and
for triple
in
.
Sample Input
3
Sample Output
3
0 1 2
2 0 1
1 2 0
Explanation
In this case,
. We need to construct a set,
, of non-negative integer triples (
) where
.
has the following triples:
We then print the cardinality of this set,
, on a new line, followed by
lines where each line contains three space-separated values describing a triple in
.","The maximum cardinality is always n, and the triples can be (i, (i+1) mod n, (i+2) mod n)","The maximum cardinality is n-1, and the triples can be (i, (i+1) mod n, i+2) for i < n-1","The maximum cardinality is floor(n/2), and the triples can be (i, i+1, i+2) for i < floor(n/2)","The maximum cardinality is n*n, and any combination of i,j,k will result in a valid solution as long as i != j != k","The maximum cardinality is n, and the triples can be (i, (i+1) mod n, (i+2) mod n) for i in range(n)",,algorithms,"['combinatorics', 'graph theory', 'modular arithmetic']"
https://www.hackerrank.com/challenges/string-similarity?isFullScreen=true,"For two strings A and B, we define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings ""abc"" and ""abd"" is 2, while the similarity of strings ""aaa"" and ""aaab"" is 3.
Calculate the sum of similarities of a string S with each of it's suffixes.
Input Format
The first line contains the number of test cases
t
.
Each of the next
t
lines contains a string to process,
.
Constraints
is composed of characters in the range ascii[a-z]
Output Format
Output
t
lines, each containing the answer for the corresponding test case.
Sample Input
2
ababaa
aa
Sample Output
11
3
Explanation
For the first case, the suffixes of the string are ""ababaa"", ""babaa"", ""abaa"", ""baa"", ""aa"" and ""a"". The similarities of these strings with the string ""ababaa"" are 6,0,3,0,1, & 1 respectively. Thus, the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11.
For the second case, the answer is 2 + 1 = 3.","Use dynamic programming to build a table of similarities between all prefixes and suffixes, then sum the relevant values.",Create a suffix tree for the string and traverse it to determine the longest common prefixes efficiently.,"Compare the original string with each suffix using a naive string comparison algorithm, tracking the length of the longest common prefix for each.","Employ a hashing algorithm to precompute hash values for prefixes and suffixes, then compare hash values to find similarities.","Iterate through all suffixes of the string and for each suffix, compare it with the original string to find the length of the longest common prefix, summing these lengths.",,algorithms,"['string matching', 'suffix', 'prefix']"
https://www.hackerrank.com/challenges/password-cracker?isFullScreen=true,"There are
n
users registered on a website
CuteKittens.com
. Each of them has a unique password represented by
pass[1], pass[2], ..., pass[N]
. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin does not want the site to be available to the general public, so only those people who have passwords can access it.
Yu
, being an awesome hacker finds a loophole in the password verification system. A string which is a
concatenation
of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear
or more times in that string. Given access to each of the
passwords, and also have a string
, determine whether this string be accepted by the password verification system of the website.  If all of the
string can be created by concatenating password strings, it is accepted.  In this case, return the passwords in the order they must be concatenated, each separated by a single space on one line.  If the password attempt will not be accepted, return 'WRONG PWASSWORD'.
Examples
Concatenate the passwords in index order
to match 'abrakadabra'. Return 'abra ka dabra'.
Concatenate the passwords in index order
to match 'kaabra'. Return 'ka abra'.
Concatenate the passwords in index order
to match 'abba',
to match 'baab',
to match 'abab' or
to match $baba'.  No combination of 1 or more passwords can be concatenated to match 'aba'.  Return 'WRONG PASSWORD'.
Function Description
Complete the
passwordCracker
function in the editor below.
passwordCracker has the following parameters:
-
string passwords[n]
: a list of password strings
-
string loginAttempt
: the string to attempt to create
Returns
-
string:
Return the passwords as a single string in the order required for the password to be accepted, each separated by a space. If it is not possible to form the string, return the string
WRONG PASSWORD
.
Input Format
The first line contains an integer
t
, the total number of test cases.
Each of the next
sets of three lines is as follows:
- The first line of each test case contains
n
, the number of users with passwords.
- The second line contains
n
space-separated strings,
passwords[i]
, that represent  the passwords of each user.
- The third line contains a string,
loginAttempt
, which
Yu
must test for acceptance.
Constraints
, where
loginAttempt
and
passwords[i]
contain only lowercase latin characters (
'a'-'z'
).
Sample Input 0
3
6
because can do must we what
wedowhatwemustbecausewecan
2
hello planet
helloworld
3
ab abcd cd
abcd
Sample Output 0
we do what we must because we can
WRONG PASSWORD
ab cd
Explanation 0
Sample Case #00:
""wedowhatwemustbecausewecan""
is the concatenation of passwords {
""we""
,
""do""
,
""what""
,
""we""
,
""must""
,
""because""
,
""we""
,
""can""
}. That is
loginAttempt = pass[5] + pass[3] + pass[6] + pass[5] +  pass[4] + pass[1] + pass[5] + pass[2]
Note that any password can repeat any number of times.
Sample Case #01:
We can't create string
""helloworld""
using the strings {
""hello""
,
""planet""
}.
Sample Case #02:
There are two ways to create
loginAttempt (
""abcd""
)
. Both
pass[2] = ""abcd""
and
pass[1] + pass[3] = ""ab cd""
are valid answers.
Sample Input 1
3
4
ozkxyhkcst xvglh hpdnb zfzahm
zfzahm
4
gurwgrb maqz holpkhqx aowypvopu
gurwgrb
10
a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa
aaaaaaaaaab
Sample Output 1
zfzahm
gurwgrb
WRONG PASSWORD",Use dynamic programming to find the longest common subsequence of the login attempt and all possible password concatenations.,Create a graph where nodes are prefixes of the login attempt and edges represent passwords that can extend those prefixes. Perform a breadth-first search to find a path to the full login attempt.,"Use regular expressions to check if the login attempt can be formed by combining passwords, allowing for repetitions.",Sort the passwords alphabetically and greedily match them against the login attempt from left to right.,"Use a recursive backtracking algorithm to explore all possible password combinations, checking if the login attempt can be fully constructed. Return 'WRONG PASSWORD' if no combination works.",,algorithms,"['string matching', 'recursion', 'backtracking']"
https://www.hackerrank.com/challenges/dortmund-dilemma?isFullScreen=true,"Borussia Dortmund are a famous football ( soccer ) club from Germany. Apart from their fast-paced style of playing, the thing that makes them unique is the hard to pronounce names of their players ( błaszczykowski , papastathopoulos , großkreutz etc. ).
The team's coach is your friend. He is in a dilemma as he can't decide how to make it easier to call the players by name, during practice sessions. So, you advise him to assign easy names to his players. A name is easy to him if
1.
It consists of only one word.
2.
It consists of only lowercase english letters.
3.
Its length is
exactly
.
4.
It contains
exactly
different letters from the
letters of English alphabet.
5.
At least one of its
proper
prefixes matches with its
proper
suffix of same length.
Given,
and
you have to tell him the number of easy names he can choose from modulo
.
Note :
A prefix
of a name
is proper if,
. Similarly, a suffix
of a name
is proper if,
.
Input Format
The first line of the input will contain
( the number of testcases ).
Each of the next
lines will contain
space separated integers
and
.
Output Format
For each testcase, output the number of ways the coach can assign names to his players modulo
.
Constraints
Sample Input #1
3
1 1
2 1
4 2
Sample Output #1
0
26
2600
Sample Input #2
5
2 2
5 1
3 2
6 2
1 3
Sample Output #2
0
26
650
13650
0",n * (26 choose k),(26 choose k) * k!,(26 choose k) * k,n^k,(26 choose k) * (Sum of Eulerian numbers of the first kind for n-1 elements with k-1 inversions) mod (10^9 + 7),,algorithms,"['combinatorics', 'dynamic programming', 'string']"
https://www.hackerrank.com/challenges/xor-quadruples?isFullScreen=true,"We call an quadruple of positive integers,
,
beautiful
if the following condition is true:
Note:
is the
bitwise XOR
operator.
Given
,
,
, and
, count the number of
beautiful
quadruples of the form
where the following constraints hold:
When you count the number of
beautiful
quadruples, you should consider two quadruples as same if the following are true:
They contain same integers.
Number of times each integers occur in the quadruple is same.
For example
and
should be considered as same.
Input Format
A single line with four space-separated integers describing the respective values of
,
,
, and
.
Constraints
For
of the maximum score,
Output Format
Print the number of
beautiful
quadruples.
Sample Input
1 2 3 4
Sample Output
11
Explanation
There are
beautiful quadruples for this input:
Thus, we print
as our output.
Note
that
is same as
.","O(N^4) where N is the maximum value among A, B, C, and D","O(N^3 log N) due to sorting the quadruples to avoid duplicates, where N is the maximum value among A, B, C, and D","O(N^3) where N is the maximum value among A, B, C, and D","O(N^2) where N is the maximum value among A, B, C, and D, using hashing to prevent duplicates","O(N^4) in the worst case, but can be optimized to be close to O(N^3) with careful pruning and duplicate avoidance techniques where N is the maximum value among A, B, C, and D",,algorithms,"['combinatorics', 'XOR', 'counting']"
https://www.hackerrank.com/challenges/countingsort4?isFullScreen=true,"Use the counting sort to order a list of strings associated with integers. If two strings are associated with the same integer, they must be printed in their original order, i.e. your sorting algorithm should be
stable
.  There is one other twist: strings in the first half of the array are to be replaced with the character
-
(dash, ascii 45 decimal).
Insertion Sort and the simple version of Quicksort are stable, but the faster in-place version of Quicksort is not since it scrambles around elements while sorting.
Design your counting sort to be stable.
Example
The first two strings are replaced with '-'.  Since the maximum associated integer is
, set up a helper array with at least two empty arrays as elements.  The following shows the insertions into an array of three empty arrays.
i
string
converted
list
0
[[],[],[]]
1
a
-
[[
-
],[],[]]
2
b
-
[[
-
],[
-
],[]]
3
c
[[
-
,
c
],[
-
],[]]
4
d
[[
-
,
c
],[
-
,
d
],[]]
The result is then printed:
.
Function Description
Complete the
countSort
function in the editor below.  It should construct and print the sorted strings.
countSort has the following parameter(s):
string arr[n][2]:
each
arr[i]
is comprised of two strings,
x
and
s
Returns
- Print the finished array with each element separated by a single space.
Note
: The first element of each
,
, must be cast as an integer to perform the sort.
Input Format
The first line contains
, the number of integer/string pairs in the array
.
Each of the next
contains
and
, the integers (as strings) with their associated strings.
Constraints
is even
consists of characters in the range
Output Format
Print the strings in their correct order, space-separated on one line.
Sample Input
20
0 ab
6 cd
0 ef
6 gh
4 ij
0 ab
6 cd
0 ef
6 gh
0 ij
4 that
3 be
0 to
1 be
5 question
1 or
2 not
4 is
2 to
4 the
Sample Output
- - - - - to be or not to be - that is the question - - - -
Explanation
The correct order is shown below. In the array at the bottom, strings from the first half of the original array were replaced with dashes.
0 ab
0 ef
0 ab
0 ef
0 ij
0 to
1 be
1 or
2 not
2 to
3 be
4 ij
4 that
4 is
4 the
5 question
6 cd
6 gh
6 cd
6 gh
sorted
=
[[
'-'
,
'-'
,
'-'
,
'-'
,
'-'
,
'
to
'
],
[
'
be
'
,
'
or
'
],
[
'
not
'
,
'
to
'
],
[
'
be
'
],
[
'-'
,
'
that
'
,
'
is
'
,
'
the
'
],
[
'
question
'
],
[
'-'
,
'-'
,
'-'
,
'-'
],
[],
[],
[],
[]]",Sorting the input array in-place using a comparison-based sort like quicksort.,Using a hash map to count the occurrences of each string and then printing them in order of their counts.,"Directly printing the strings without any sorting, replacing the first half with dashes.",Using a standard counting sort implementation without handling stability or the dash replacement.,"Using counting sort to group strings by their integer keys, maintaining the original order for strings with the same key, and replacing strings in the first half of the array with '-'.",,algorithms,"['counting sort', 'stability', 'string manipulation']"
https://www.hackerrank.com/challenges/palindromic-border?isFullScreen=true,"A
border
of a string is a
proper
prefix of it that is also a suffix. For example:
a
and
abra
are borders of
abracadabra
,
kan
and
kankan
are borders of
kankankan
.
de
is a border of
decode
.
Note that
decode
is not a border of
decode
because it's not proper.
A
palindromic border
is a border that is palindromic. For example,
a
and
ana
are palindromic borders of
anabanana
,
l
,
lol
and
lolol
are palindromic borders of
lololol
.
Let's define
as the number of palindromic borders of string
. For example, if
lololol
, then
.
Now, a string of length
has exactly
non-empty substrings (we count substrings as distinct if they are of different lengths or are in different positions, even if they are the same string). Given a string
, consisting only of the first 8 lowercase letters of the English alphabet, your task is to find the sum of
for all the non-empty substrings
of
. In other words, you need to find:
where
is the substring of
starting at position
and ending at position
.
Since the answer can be very large, output the answer modulo
.
Input Format
The first line contains a string consisting of
characters.
Output Format
Print a single integer: the remainder of the division of the resulting number by
.
Constraints
All characters in the string can be any of the first 8 lowercase letters of the English alphabet (
abcdefgh
).
Sample Input 1
ababa
Sample Output 1
5
Sample Input 2
aaaa
Sample Output 2
10
Sample Input 3
abcacb
Sample Output 3
3
Explanation
ababa
has 15 substrings but only 4 substrings have palindromic borders.
aba
ababa
bab
aba","Use dynamic programming to store palindromic substring information in a 2D array, then iterate through all substrings to calculate the sum.",Use a sliding window approach to identify all possible substrings and then count palindromic borders for each substring using a separate function.,"Recursively generate all possible substrings and for each substring, recursively check for palindromic borders.",Precompute all palindromic substrings using Manacher's algorithm and then iterate through all substrings to find the palindromic borders.,"Iterate through all substrings, and for each substring, iterate through all its prefixes to check if they are palindromes and suffixes.",,algorithms,"['string', 'palindrome', 'substring']"
https://www.hackerrank.com/challenges/team-formation?isFullScreen=true,"For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants.
Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is
where
, there exists another team member whose skill level is
. Note that a contestant can write buggy code and thus can have a negative skill level.
The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible.
For example, there are
contestants with skill levels
.  There are many ways teams could be formed, e.g. [-1], [0],...,[3].  At the other end of the spectrum, we could form
and
.  We're looking for the largest smaller team size though.  Two sets that meet the criteria are
and
.  The largest smaller team size possible is
.
Note:
There is an edge case where
contestants have registered.  As no teams are to be created, the largest team created will have
members.
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
lines contains a string of space-separated integers,
followed by
integers
, a list of the contestants' skill levels.
Constraints
Output Format
For each test case, print the size of largest possible smallest team on a separate line.
Sample Input
4
7 4 5 2 3 -4 -3 -5
1 -4
4 3 2 3 1
7 1 -2 -3 -4 2 0 -1
Sample Output
3
1
1
7
Explanation
For the first case, Roy can form two teams: one with contestants with skill levels
{-4,-3,-5}
and the other one with
{4,5,2,3}
. The first group containing
3
members is the smallest.
In the second case, the only team is
{-4}
In the third case, the teams are
{3}
,
{1,2,3}
, the size of the smaller group being
1
.
In the last case, you can build one group containing all of the contestants. The size of the group equals the total number of contestants.
Time limits
Time limits for this challenge are given
here
Note
If n = 0, print 0.","Use a greedy approach to always pick the largest possible team size, potentially leading to suboptimal divisions.","Sort the skill levels and iterate through them, creating teams of size 1 until all skill levels are used.",Recursively divide the contestants into smaller groups and find the minimum team size amongst them.,"Calculate all possible team combinations and select the one with the largest minimum team size, which is computationally expensive.","Sort the skill levels, use a disjoint set data structure to find connected components where each element has a neighbor with skill level +1 or -1, then find the size of the smallest component.",,algorithms,"['greedy algorithm', 'disjoint set', 'graph']"
https://www.hackerrank.com/challenges/sherlock-and-anagrams?isFullScreen=true,"Two strings are
anagrams
of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.
Example
The list of all anagrammatic pairs is
at positions
respectively.
Function Description
Complete the function
sherlockAndAnagrams
in the editor below.
sherlockAndAnagrams has the following parameter(s):
string s:
a string
Returns
int:
the number of unordered anagrammatic pairs of substrings in
Input Format
The first line contains an integer
, the number of queries.
Each of the next
lines contains a string
to analyze.
Constraints
contains only lowercase letters in the range ascii[a-z].
Sample Input 0
2
abba
abcd
Sample Output 0
4
0
Explanation 0
The list of all anagrammatic pairs is
and
at positions
and
respectively.
No anagrammatic pairs exist in the second query as no character repeats.
Sample Input 1
2
ifailuhkqq
kkkk
Sample Output 1
3
10
Explanation 1
For the first query, we have anagram pairs
and
at positions
and
respectively.
For the second query:
There are 6 anagrams of the form
at positions
and
.
There are 3 anagrams of the form
at positions
and
.
There is 1 anagram of the form
at position
.
Sample Input 2
1
cdcd
Sample Output 2
5
Explanation 2
There are two anagrammatic pairs of length
:
and
.
There are three anagrammatic pairs of length
:
at positions
respectively.",Iterate through all possible substring pairs and compare them directly character by character.,"Sort the input string first, then count repeating characters to find anagrams.",Use a sliding window technique to identify potential anagrams based on window size.,Precompute all possible substrings and store them in a hash set before counting anagrams.,"Generate all possible substrings, sort their characters alphabetically, and use a hash map to count occurrences of each sorted substring.",,algorithms,"['string', 'anagram', 'substring']"
https://www.hackerrank.com/challenges/organizing-containers-of-balls?isFullScreen=true,"David has several containers, each with a number of balls in it.  He has just enough containers to sort each type of ball he has into its own container.  David wants to sort the balls using his sort method.
David wants to perform some number of swap operations such that:
Each container contains only balls of the same type.
No two balls of the same type are located in different containers.
Example
David has
containers and
different types of balls, both of which are numbered from
to
. The distribution of ball types per container are shown in the following diagram.
https://s3.amazonaws.com/hr-challenge-images/0/1485811368-9e78c98652-swapping-balls.png
In a single operation, David can
swap
two balls located in different containers.
The diagram below depicts a single swap operation:
https://s3.amazonaws.com/hr-challenge-images/0/1485811849-e97b84e218-swapping-balls-ps-1.png
In this case, there is no way to have all green balls in one container and all red in the other using only swap operations.  Return
Impossible
.
You must perform
queries where each query is in the form of a matrix,
. For each query, print
Possible
on a new line if David can satisfy the conditions above for the given matrix.  Otherwise, print
Impossible
.
Function Description
Complete the
organizingContainers
function in the editor below.
organizingContainers has the following parameter(s):
int containter[n][m]
: a two dimensional array of integers that represent the number of balls of each color in each container
Returns
string:
either
Possible
or
Impossible
Input Format
The first line contains an integer
, the number of queries.
Each of the next
sets of lines is as follows:
The first line contains an integer
, the number of containers (rows) and ball types (columns).
Each of the next
lines contains
space-separated integers describing row
.
Constraints
Scoring
For
of score,
.
For
of score,
.
Output Format
For each query, print
Possible
on a new line if David can satisfy the conditions above for the given matrix.  Otherwise, print
Impossible
.
Sample Input 0
2
2
1 1
1 1
2
0 2
1 1
Sample Output 0
Possible
Impossible
Explanation 0
We perform the following
queries:
The diagram below depicts one possible way to satisfy David's requirements for the first query:
https://s3.amazonaws.com/hr-challenge-images/0/1485813936-37f8a37dad-swapping-balls-sample-0-0.png
Thus, we print
Possible
on a new line.
The diagram below depicts the matrix for the second query:
https://s3.amazonaws.com/hr-challenge-images/0/1485814141-d283776840-swapping-balls-sample-0-2.png
No matter how many times we swap balls of type
and
between the two containers, we'll never end up with one container only containing type
and the other container only containing type
. Thus, we print
Impossible
on a new line.
Sample Input 1
2
3
1 3 1
2 1 2
3 3 3
3
0 2 1
1 1 1
2 0 0
Sample Output 1
Impossible
Possible",Check if the sum of row elements equals the sum of column elements for each row and column,"Check if the number of containers equals the number of ball types; if not, it's always 'Impossible'","Sort the rows and columns independently; if the sorted results are identical, it's 'Possible'","Calculate the determinant of the matrix; if it's non-zero, the answer is 'Possible', otherwise 'Impossible'","Compare the sorted list of row sums with the sorted list of column sums. If they are equal, it's 'Possible', otherwise 'Impossible'",,algorithms,"['matrix', 'arrays', 'sorting']"
https://www.hackerrank.com/challenges/suffix-rotation?isFullScreen=true,"Megan is playing a string game with the following rules:
It starts with a string,
.
During each turn, she performs the following move:
Choose an index in
. The chosen index must be strictly greater than any index chosen in a prior move.
Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index.
For example, let's say
abcdefjghi
. During our move, we choose to do three right rotations of the suffix starting at index
:
https://s3.amazonaws.com/hr-challenge-images/0/1483759382-25a8dfa9ad-WoC-suffix-rotation.png
Note that this counts as
one
move.
The goal of the game is to convert
into the
lexicographically smallest
possible string
in as few moves as possible
. In other words, we want the characters to be in alphabetical order.
Megan plays this game
times, starting with a new string
each time. For each game, find the minimum number of moves necessary to convert
into the lexicographically smallest string and print that number on a new line.
Input Format
The first line contains an integer,
, denoting the number of games.
Each of the
subsequent lines contains a single string denoting the initial value of string
for a game.
Constraints
consists of lowercase English alphabetic letters only.
Output Format
For each game, print an integer on a new line denoting the minimum number of moves required to convert
into the lexicographically smallest string possible.
Sample Input 0
3
abcdefghij
acab
baba
Sample Output 0
0
1
2
Explanation 0
We play the following
games:
In the first game,
abcdefghij
is already as lexicographically small as possible (each sequential letter is in alphabetical order). Because we don't need to perform any moves, we print
on a new line.
In the second game, we rotate the suffix starting at index
, so
a
cab
becomes
a
abc
.
Because the string is lexicographically smallest after one move, we print
on a new line.
In the third game, we perform the following moves:
Rotate the suffix starting at index
(i.e., the entire string), so
baba
becomes
abab
.
Rotate the suffix starting at index
, so
a
bab
becomes
a
abb
.
Because the string is lexicographically smallest after two moves, we print
on a new line.","Count the number of characters out of order, dividing by 2 and rounding up.",Calculate the number of inversions in the string.,Find the longest increasing subsequence and subtract its length from the string length.,Determine the number of distinct characters in the string.,Count the number of suffixes that need to be rotated to achieve the lexicographically smallest string.,,algorithms,"['string manipulation', 'lexicographical order', 'optimization']"
https://www.hackerrank.com/challenges/episode-recording?isFullScreen=true,"Dave is a die-hard fan of a show called ""HackerRank"", in which a young programmer uses her problem-solving abilities to solve crimes. He splurged on a Digital Video Recorder (DVR) so that he can record HackerRank episodes and watch them later. Luckily, Dave managed to get his hands on schedules for all the episodes in each upcoming season.
Each season has
episodes numbered from
to
. Each episode airs twice; the first time it's called ""live"", and the second time it's called ""repeat"". So, for each episode, we have
integers,
and
for the live airing and
and
for the repeat airing, where
is episode's start time and and
is its end time. All times are given as integers representing the number of minutes passed since the start of the season.
Episodes broadcast on multiple channels, so some of the air times overlap and the episodes may not broadcast sequentially. It's possible that both the live and repeat broadcasts of some episode
are held before episode
, even though
. In addition, live and repeat broadcasts of the same episode may differ in length due to the number of advertisements during the broadcast.
Dave only has one TV with a DVR attached to it, and the DVR is capable of recording one episode at a time. For each episode in a season, Dave first decides whether or not he will record it. If he decides to record it, he will either record it during
or
. Dave will only ever record one of the two airings of an episode, and he always records
full
episodes. This means that once he starts recording an episode, he will always record it until the end (i.e., he never records partial episodes).
Dave realizes that it might not be possible for him to record all episodes successfully, so instead of focusing on recording all episodes of HackerRank (which may be impossible), he decides to record all consecutively airing episodes whose episode number occurs in some inclusive
interval such that
(i.e., the number of consecutive episodes recorded) is as large as possible.
Given the programming schedule for each season, find
and
episode numbers for largest range of consecutive episodes Dave can record during that season and print these respective values as two space-separated integers on a new line. If two or more such intervals exist, choose the one having the smallest
value.
Input Format
The first line contains a single positive integer,
, denoting number of seasons of HackerRank.
The subsequent lines describe each of the
seasons in the following format:
The first line contains an integer,
, denoting the number of episodes in the season.
Each line
of the
subsequent line contains four space-separated integers describing the respective values of
,
,
, and
.
Constraints
Output Format
On a new line for each season, print two space-separated integers denoting the respective
and
(inclusive) values for the maximum possible range of consecutive episodes Dave can record such that
is as large as possible. If more than one such interval exists, choose the interval having the smallest
.
Sample Input
3
3
10 20 30 40
20 35 21 35
14 30 35 50
1
10 20 30 40
3
11 19 31 39
12 38 13 37
10 20 30 40
Sample Output
1 2
1 1
1 1
Explanation
For the first season, Dave records the live airing of episode
and the repeat airing of episode
. Note that it is
not
possible to record episodes
,
and
simultaneously.
For the second season, there is only one episode so Dave records from episode
to episode
and we print
1 1
on a new line.
For the third season, Dave must choose to record either episode
or episode
(episode
starts while episode
is still airing and ends after episode
starts); he cannot record both, because he only wants to record consecutive episodes. Thus, we pick the episode with the smallest
value, which is episode
, and print
1 1
as we are only recording episode
.","Always record the 'live' airing if possible; otherwise, skip the episode.","Use a greedy approach, prioritizing episodes with the shortest recording time.","Record all 'live' airings first, then fill gaps with 'repeat' airings.","Sort episodes by start time and record as many as possible, ignoring the consecutive requirement.","Use dynamic programming to determine the maximum number of consecutive recordable episodes, considering both 'live' and 'repeat' options.",,algorithms,"['dynamic programming', 'scheduling', 'greedy algorithm']"
https://www.hackerrank.com/challenges/bowling-pins?isFullScreen=true,"Bowling is a sport in which a player rolls a bowling ball towards a group of pins, the target being to knock down the pins at the end of a lane.
In this challenge, the rules of the game are slightly modified. Now, there are a given number of pins, and the pins are arranged in a horizontal line instead of a triangular formation. Two players have to play this game, taking alternate turns. Whoever knocks down the last pin(s) will be declared the winner.
You are playing this game with your friend, and both of you have become proficient at it. You can knock down any single pin, or any two adjacent pins at one throw of a bowling ball, however, these are the only moves that you can perform. Some moves have already been played. Suddenly, you realize that it is possible to determine whether this game can be won or not, assuming optimal play. And luckily it's your turn right now.
A configuration is represented by a string consisting of the letters
X
and
I
, where:
I
represents a position containing a pin.
X
represents a position where a pin has been knocked down.
An example of such a configuration is shown in the image below. Here, the number of pins is
, and the
pin has already been knocked down.
http://hr-challenge-images.s3.amazonaws.com/2526/pins.png
Its representation will be
IXIIIIIIIIIII
.
Complete the function
isWinning
that takes the number of pins and the configuration of the pins as input, and return
WIN
or
LOSE
based on whether or not you will win.
Given the current configuration of the pins, if both of you play optimally, determine whether you will win this game or not.
Note
A player has to knock down at least one pin in his turn.
Both players play optimally.
Input Format
The first line contains an integer,
, the number of test cases. Then
test cases follow.
For each test case, the first line contains a single integer
, denoting the number of pins. The second line contains a string of
letters, where each letter is either
I
or
X
.
Constraints
Each letter of the string (representing the configuration) is either
I
or
X
.
There will be at least one
I
in the string.
Output Format
For each test case, print a single line containing
WIN
if you will win this game, otherwise
LOSE
.
Sample Input 0
4
4
IXXI
4
XIIX
5
IIXII
5
IIIII
Sample Output 0
LOSE
WIN
LOSE
WIN
Explanation 0
Test Case 1:
As the
pins are not adjacent, they can't be knocked down in a single turn. Therefore, you can only knock down one of the two pins. Then, in the next turn, your friend will knock down the last pin.
Test Case 2:
You can knock down both pins in a single turn.
Test Case 3:
You can knock down one or two pins from either side. Your friend can just copy your move on the other side and will be able to get the last move, hence win the game.
Test Case 4:
You can knock the middle pin, thus resulting in the configuration
IIXII
for your friend. Now, this configuration is the same as the previous test case. The difference is that now it is your friend's turn and you can copy his shot on the other side.",The first player always wins if the number of 'I's is odd.,The second player always wins if the number of 'I's is even.,"Calculate the Grundy number for each independent segment of 'I's and XOR them. If the result is 0, LOSE; otherwise, WIN.",The first player always loses if the number of 'I's is a multiple of 3.,"Calculate the Nim-sum of the lengths of continuous segments of 'I's. If the Nim-sum is non-zero, WIN; otherwise, LOSE.",,algorithms,"['game theory', 'nim game', 'grundy number']"
https://www.hackerrank.com/challenges/encryption?isFullScreen=true,"An English text needs to be encrypted using the following encryption scheme.
First, the spaces are removed from the text. Let
be the length of this text.
Then, characters are written into a grid, whose rows and columns have the following constraints:
Example
After removing spaces, the string is
characters long.
is between
and
, so it is written in the form of a grid with 7 rows and 8 columns.
ifmanwas
meanttos        
tayonthe
groundgo
dwouldha
vegivenu
sroots
Ensure that
If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e.
.
The encoded message is obtained by displaying the characters of each column, with a space between column texts. The encoded message for the grid above is:
imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau
Create a function to encode a message.
Function Description
Complete the
encryption
function in the editor below.
encryption has the following parameter(s):
string s:
a string to encrypt
Returns
string:
the encrypted string
Input Format
One line of text, the string
Constraints
contains characters in the range ascii[a-z] and space, ascii(32).
Sample Input
haveaniceday
Sample Output 0
hae and via ecy
Explanation 0
,
is between
and
.
Rewritten with
rows and
columns:
have
anic
eday
Sample Input 1
feedthedog
Sample Output 1
fto ehg ee dd
Explanation 1
,
is between
and
.
Rewritten with
rows and
columns:
feed
thed
og
Sample Input 2
chillout
Sample Output 2
clu hlt io
Explanation 2
,
is between
and
.
Rewritten with
columns and
rows (
so we have to use
.)
chi
llo
ut","First reverse the string, then chunk it into row-length segments, finally join the column-wise characters.","Remove spaces, calculate dimensions, build a 2D array, transpose the array, and join column-wise.","Remove spaces and then create a list of words from the string, then concatenate the list.","Remove spaces, directly extract characters into column strings without grid formation, and concatenate the columns.","Remove spaces, determine row and column counts, populate a grid, then read column-wise and join with spaces.",,algorithms,"['string manipulation', 'encryption', 'grid']"
https://www.hackerrank.com/challenges/jeanies-route?isFullScreen=true,"Byteland has
cities (numbered from
to
) and
bidirectional roads. It is guaranteed that there is a route from any city to any other city.
Jeanie is a postal worker who must deliver
letters to various cities in Byteland. She can start and end her delivery route in any city. Given the destination cities for
letters and the definition of each road in Byteland, find and print the minimum distance Jeanie must travel to deliver all
letters.
Note:
The letters can be delivered in any order.
Input Format
The first line contains two space-separated integers,
(the number of cities) and
(the number of letters), respectively.
The second line contains
space-separated integers describing the delivery city for each letter.
Each line
of the
subsequent lines contains
space-separated integers describing a road as
, where
is the distance (length) of the bidirectional road between cities
and
.
Constraints
Output Format
Print the minimum distance Jeanie must travel to deliver all
letters.
Sample Input 0
5 3
1 3 4
1 2 1
2 3 2
2 4 2
3 5 3
Sample Output 0
6
Explanation 0
Jeanie has
letters she must deliver to cities
,
, and
in the following map of Byteland:
https://s3.amazonaws.com/hr-challenge-images/9931/1440081305-832f96dd7e-jub1.png
One of Jeanie's optimal routes is
, for a total distanced traveled of
. Thus, we print
on a new line.",The sum of all edge weights in the minimum spanning tree of the graph induced by the delivery cities.,Twice the weight of the minimum spanning tree of the delivery cities.,The diameter of the subgraph induced by the delivery cities.,The sum of shortest paths between all pairs of delivery cities.,"Twice the weight of the minimum spanning tree of the subgraph induced by the delivery cities, minus the longest path in that MST.",,algorithms,"['graph theory', 'minimum spanning tree', 'shortest path']"
https://www.hackerrank.com/challenges/floyd-city-of-blinding-lights?isFullScreen=true,"Given a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes.  There may be many queries, so efficiency counts.
For example, your graph consists of
nodes as in the following:
https://s3.amazonaws.com/hr-assets/0/1525461069-142e0d306a-blindingLightsExample.png
A few queries are from node
to node
, node
to node
, and node
to node
.
There are two paths from
to
:
at a distance of
at a distance of
In this case we choose path
.
There is no path from
to
, so we return
.
There is one path from
to
:
at a distance of
.
Input Format
The first line has two integers
and
, the number of nodes and the number of edges in the graph.
Each of the next
lines contains three space-separated integers
and
, the two nodes between which the
directed
edge
exists, and
, the length of the edge.
The next line contains a single integer
, the number of queries.
Each of the next
lines contains two space-separated integers
and
, denoting the start and end nodes for traversal.
Constraints
The distance from a node to itself is always
and it is always reachable from itself.
If there are edges between the same pair of nodes with different weights, the last one (most recent) is to be considered as the only edge between them.
Output Format
Print
lines, each containing a single integer specifying the shortest distance for the query.
If the destination node is not reachable, return
.
Sample Input
STDIN   Function
-----   --------
4 5     n = 4, m = 5
1 2 5   u = 1, v = 2, w = 5
1 4 24  u = 1, v =4, w = 24 ...
2 4 6
3 4 4
3 2 7
3       q = 3
1 2     query 0: from 1 to 2
3 1     query 1: from 3 to 1
1 4     query 2: from 1 to 4
Sample Output
5
-1
11
Explanation
The graph given in the test case is:
https://s3.amazonaws.com/hr-assets/0/1525718262-df300f3819-blindingLightsSample.png
The shortest paths for the 3 queries are :
: The direct path is shortest with weight 5
: There is no way of reaching node 1 from node 3
: The indirect path is shortest with weight (5+6) = 11 units. The direct path is longer with 24 units length.","Dijkstra's algorithm with a priority queue, recomputing from scratch for each query.","Breadth-first search (BFS) for each query, ignoring edge weights.","Bellman-Ford algorithm computed only once, but not storing intermediate results.","Depth-first search (DFS) for each query, pruning branches exceeding a certain length.","Floyd-Warshall algorithm computed once to find all-pairs shortest paths, then answering queries in O(1).",,algorithms,"['graph algorithms', 'shortest path', 'all-pairs shortest path']"
https://www.hackerrank.com/challenges/problem-solving?isFullScreen=true,"There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the i
th
problem has estimated difficulty level
i
. You have also assigned a rating
vi
to each problem. Problems with similar
vi
values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their
vi
rating by at least K. What is the least number of days in which you can solve all problems?
Input Format
The first line contains the number of test cases T. T test cases follow. Each case contains an integer N and K on the first line, followed by integers v1,...,vn on the second line.
Constraints
1 <= T <= 100
1 <= N <= 300
1 <= vi <= 1000
1 <= K <= 1000
Output Format
Output T lines, one for each test case, containing the minimum number of days in which all problems can be solved.
Sample Input
2
3 2
5 4 7
5 1
5 3 4 5 6
Sample Output
2
1
Explanation
For the first example, you can solve the problems with rating 5 and 7 on the first day and the problem with rating 4 on the next day. Note that the problems with rating 5 and 4 cannot be completed consecutively because the ratings should differ by at least K (which is 2). Also, the problems cannot be completed in order 5,7,4 in one day because the problems solved on a day should be in increasing difficulty level.
For the second example, all problems can be solved on the same day.","Use a greedy approach, assigning each problem to the earliest possible day without violating the constraints.",Sort the problems by their rating vi and then assign them to days using dynamic programming.,Employ a binary search algorithm to determine the minimum number of days required.,"Simulate solving the problems in the given order, incrementing the day count whenever a constraint is violated.",Use dynamic programming where dp[i] stores the minimum number of days to solve problems 1 to i.,,algorithms,"['dynamic programming', 'greedy algorithm', 'optimization']"
https://www.hackerrank.com/challenges/whats-next?isFullScreen=true,"Johnny is playing with a large binary number,
. The number is so large that it needs to be compressed into an array of integers,
, where the values in
even indices
(
) represent some number of consecutive
bits and the values in
odd indices
(
) represent some number of consecutive
bits in alternating substrings of
.
For example, suppose we have array
.
represents
,
represents
,
represents
,
represents
, and
represents
. The number of consecutive binary characters in the
substring of
corresponds to integer
, as shown in this diagram:
https://s3.amazonaws.com/hr-challenge-images/13530/1460021216-fd1bfc1a08-whats.png
When we assemble the sequential alternating sequences of
's and
's, we get
.
We define
setCount(
)
to be the number of
's in a binary number,
. Johnny wants to find a binary number,
, that is the smallest binary number
where
setCount(
)
=
setCount(
)
. He then wants to compress
into an array of integers,
(in the same way that integer array
contains the compressed form of binary string
).
Johnny isn't sure how to solve the problem. Given array
, find integer array
and print its length on a new line. Then print the elements of array
as a single line of space-separated integers.
Input Format
The first line contains a single positive integer,
, denoting the number of test cases. Each of the
subsequent lines describes a test case over
lines:
The first line contains a single positive integer,
, denoting the length of array
.
The second line contains
positive space-separated integers describing the respective elements in integer array
(i.e.,
).
Constraints
Subtasks
For a
score,
.
For a
score,
.
Output Format
For each test case, print the following
lines:
Print the length of integer array
(the array representing the compressed form of binary integer
) on a new line.
Print each element of
as a single line of space-separated integers.
It is
guaranteed
that a solution exists.
Sample Input 0
1
5
4 1 3 2 4
Sample Output 0
7
4 1 3 1 1 1 3
Explanation 0
, which expands to
. We then find
setCount(
)
. The smallest binary number
which also has eleven
's is
. This can be reduced to the integer array
. This is demonstrated by the following figure:
https://s3.amazonaws.com/hr-challenge-images/13530/1460021485-52bac9727a-whats-2.png
Having found
, we print its length (
) as our first line of output, followed by the space-separated elements in
as our second line of output.",The output array will always have the same length as the input array.,"Count the total number of 1s in the binary representation of the input array, then construct the smallest binary number with the same number of 1s and convert that back into the compressed array.",The compressed form of the smallest binary number with the same number of set bits can be obtained by sorting the initial array in ascending order.,The first element of the array is always the sum of all other elements.,"Calculate the number of ones in the initial binary representation. Then construct the smallest binary number with the same number of ones. Finally, compress this new binary number into an array.",,algorithms,"['binary numbers', 'compression', 'bit manipulation']"
https://www.hackerrank.com/challenges/alien-languages?isFullScreen=true,"Sophia has discovered several alien languages. Suprisingly, all of these languages have an
alphabet
, and each of them may contain thousands of characters! Also, all the words in a language have the same number of characters in it.
However, the aliens like their words to be aesthetically pleasing, which for them means that for the
letter of an
-letter alphabet (letters are indexed
):
if
, then the
letter may be the last letter of a word, or it may be immediately followed by any letter, including itself.
if
, then the
letter can not be the last letter of a word and also can only be immediately followed by
letter if and only if
.
Sophia wants to know how many different words exist in this language. Since the result may be large, she wants to know this number, modulo
.
Input Format
The first line contains
, the number of test cases. The first line is followed by
lines, each line denoting a test case. Each test case will have two space-separated integers
,
which denote the number of letters in the language and the length of words in this language respectively.
Constraints
Output Format
For each test case, output the number of possible words modulo
.
Sample Input
3
1 3
2 3
3 2
Sample Output
1
3
6
Explanation
For the first test case, there's one letter ('a') and all the words consist of
letters. There's only one possibility which is ""aaa"".
For the second test case, there are two letters ('a' and 'b') and all the words are of
letters. The possible strings are ""abb"", ""bab"", & ""bbb"". The words can end only with 'b' because
and for 'a', it's
. ""aab"" is not allowed because 'a' can not be followed immediately by 'a'. For a word of length 4 and alphabet of size 2, ""abab"" would be allowed.
For the third test case, there are three letters ('a', 'b' and 'c') and all of the words are
letters. The words can only end with 'b' or 'c'. The possible words are ""ab"", ""ac"", ""bb"", ""cc"", ""bc"", ""cb"".","The total number of words can be computed as (K * (K-1))^(N-1) * K, where ^ is the power operator.",Dynamic programming can be used to calculate number of possible words of length N ending at each alphabet with appropriate transitions.,"This problem requires testing all possible words of length N with an alphabet of size K, which may result in Time Limit Exceeded.","The number of possible words is simply K^N, since each position can be any of the K letters, which is incorrect according to the rules of the language.","A matrix exponentiation approach can be used to compute the number of valid words, where the matrix represents transition rules between letters.",,algorithms,"['dynamic programming', 'matrix exponentiation', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/oil-well?isFullScreen=true,"Mr. Road Runner bought a piece of land in the middle of a desert for a nominal amount. It turns out that the piece of land is now worth millions of dollars as it has an oil reserve under it. Mr. Road Runner contacts the ACME corp to set up the oil wells on his land. Setting up oil wells is a costly affair and the charges of setting up oil wells are as follows.
The rectangular plot bought by Mr. Road Runner is divided into
r
*
c
blocks. Only some blocks are suitable for setting up the oil well and these blocks have been marked. ACME charges nothing for building the first oil well. For every subsequent oil well built, the cost would be the maximum
ACME distance
between the new oil well and the existing oil wells.
If
(x,y)
is the position of the block where a new oil well is setup and
(x1, y1)
is the position of the block of an existing oil well, the
ACME distance
is given by
max(|x-x1|, |y-y1|)
the maximum
ACME distance
is the maximum among all the
ACME distance
between existing oil wells and new wells.
If the distance of any two adjacent blocks (horizontal or vertical) is considered 1 unit, what is the minimum cost
(E)
in units it takes to set up oil wells across all the marked blocks?
Input Format
The first line of the input contains two space separated integers
r
*c*.
r
lines follow each containing
c
space separated integers.
1 indicates that the block is suitable for setting up an oil well, whereas 0 isn't.
r c
M11 M12 ... M1c
M21 M22 ... M2c
...
Mr1 Mr2 ... Mrc
Constraints
1 <= r, c <= 50
Output Format
Print the minimum value E as the answer.
Sample Input
3 4
1 0 0 0
1 0 0 0
0 0 1 0
Sample Output
3
Explanation
(1, 1) (2, 1) (3, 3) are the places where are to be setup.
There are 3! = 6 ways to do it.
(1, 1) (2, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3
(1, 1) (3, 3) (2, 1) ==> cost = 0 + 2 + 2 = 4
(2, 1) (1, 1) (3, 3) ==> cost = 0 + 1 + 2 = 3
(2, 1) (3, 3) (1, 1) ==> cost = 0 + 2 + 2 = 4
(3, 3) (1, 1) (2, 1) ==> cost = 0 + 2 + 2 = 4
(3, 3) (2, 1) (1, 1) ==> cost = 0 + 2 + 2 = 4
So E = 3",The sum of Manhattan distances between all pairs of oil wells,The number of oil wells minus one,The maximum of row and column dimensions multiplied by the number of oil wells,The minimum spanning tree cost connecting all possible oil well locations,The minimum cost obtained by considering all permutations of oil well placements and calculating the incremental ACME distance for each permutation.,,algorithms,"['graph theory', 'optimization', 'permutations']"
https://www.hackerrank.com/challenges/pairs?isFullScreen=true,"Given an array of integers and a target value, determine the number of pairs of array elements that have a difference equal to the target value.
Example
There are three values that differ by
:
,
, and
.  Return
.
Function Description
Complete the
pairs
function below.
pairs has the following parameter(s):
int k:
an integer, the target difference
int arr[n]:
an array of integers
Returns
int:
the number of pairs that satisfy the criterion
Input Format
The first line contains two space-separated integers
and
, the size of
and the target value.
The second line contains
space-separated integers of the array
.
Constraints
each integer
will be unique
Sample Input
STDIN       Function
-----       --------
5 2         arr[] size n = 5, k =2
1 5 3 4 2   arr = [1, 5, 3, 4, 2]
Sample Output
3
Explanation
There are 3 pairs of integers in the set with a difference of 2: [5,3], [4,2] and [3,1]. .",Use nested loops to compare each element with every other element and check the difference.,Sort the array and then use two pointers to find pairs with the target difference in linear time.,Use a hash map to store the frequency of each element and then iterate through the map to find pairs with the desired difference.,Calculate the absolute difference between the target and each element and count the number of elements matching the result.,"Use a set to store all elements, then iterate through the array and check if (element + target) exists in the set.",,algorithms,"['array', 'hash set', 'difference']"
https://www.hackerrank.com/challenges/gcd-matrix?isFullScreen=true,"Alex has two arrays defined as
and
. He created an
matrix,
, where
for each
in
. Recall that
is the
greatest common divisor
of
and
.
For example, if
and
, he builds
like so:
Alex's friend Kiara loves matrices, so he gives her
questions about matrix
where each question is in the form of some submatrix of
with its upper-left corner at
and its bottom-right corner at
. For each question, find and print the number of
distinct
integers in the given submatrix on a new line.
Input Format
The first line contains three space-separated integers describing the respective values of
(the size of array
),
(the size of array
), and
(Alex's number of questions).
The second line contains
space-separated integers describing
.
The third line contains
space-separated integers describing
.
Each line
of the
subsequent lines contains four space-separated integers describing the respective values of
,
,
, and
for the
question (i.e., defining a submatrix with upper-left corner
and bottom-right corner
).
Constraints
Scoring
for
of score.
for
of score.
Output Format
For each of Alex's questions, print the number of
distinct
integers in the given submatrix on a new line.
Sample Input 0
3 3 3
1 2 3
2 4 6
0 0 1 1
0 0 2 2
1 1 2 2
Sample Output 0
2
3
3
Explanation 0
Given
and
, we build the following
:
The diagram below depicts the submatrices for each of the
questions in
green
:
https://s3.amazonaws.com/hr-challenge-images/0/1485413158-b7ccf067eb-gcdmatrix1.png
For the submatrix between
and
, the set of integers is
. The number of distinct integers is
.
For the submatrix between
and
, the set of integers is
. The number of distinct integers is
.
For the submatrix between
and
, the set of integers is
. The number of distinct integers is
.",Precompute all GCDs for all possible submatrix sizes and store them in a lookup table.,"Calculate the GCDs online, but use a Bloom filter to track seen GCDs for faster distinct count.","Compute the entire GCD matrix first, then use a multiset to efficiently find distinct elements within the submatrix.","Use dynamic programming to store the GCDs of overlapping submatrices, reducing redundant calculations.",Calculate GCDs within the queried submatrix on-demand and use a set to track distinct values.,,algorithms,"['GCD', 'matrix', 'submatrix']"
https://www.hackerrank.com/challenges/airports?isFullScreen=true,"Airports are being built on a straight road according to a new construction plan. For convenience, imagine a number line on which at different points airports can be positioned. Because a plane can't take off and start landing immediately, there will be flight between two airports in locations
and
if and only if
, where
is a constant.
Changing the position of an airport from
to
costs
. The cost to fix a certain plan is the minimum total cost of changing the positions of airports. After the changes, it should be possible to travel between any pair of airports, possibly taking flights through some intermediate airports. Note that it's possible that two airports have the same initial position, and this can be the case  after changes too.
On
day, a plan to build a new airport with position
is announced. On each day that a new airport is announced, print the smallest cost to fix the set of airports announced so far . Note that you should not change the positions of any airports, just calculate the cost to do it.
https://s3.amazonaws.com/hr-assets/0/1510213617-88120a0409-nl1-23.jpg
Input Format
Input contains multiple queries.
The first line consists of an integer
which is the number of queries. Each query is given as follows.
The first line of each query contains two integers
and
, the number of days, and the minimum distance respectively.
The second line of each test case contains
space-separated integers
denoting the position of the airport that was announced on
day.
Constraints
the sum of
over all test cases in a file will not exceed
Output Format
Print one line for each query.
A line for a query with
airports should have
numbers on it where the
one should be the minimum cost to fix airports in positions
.
Sample Input 0
1
3 1
0 0 0
Sample Output 0
0 1 1
Explanation 0
The answer for a single airport is always zero. When we have many airports in the same position, it's enough to move only one of them to satisfy the condition from the statement.
Sample Input 1
1
5 4
1 -1 2 -1 1
Sample Output 1
0 2 2 3 3
Explanation 1
https://s3.amazonaws.com/hr-assets/0/1510213113-83c6ac404a-nl1-2.jpg
For each new day that an airport is inserted, the cheapest rearranging of existing airports is shown on the diagram above. Note that cost changes for every day and travelling between airports can be done possibly flying through some intermediate ones. Costs are calculated without changing actual positions of the airports.",Sort the airport positions and use dynamic programming to minimize the cost of connecting subsets of airports.,"Apply a greedy algorithm, iteratively moving each airport to the nearest available valid position.","Use a minimum spanning tree algorithm (e.g., Prim's or Kruskal's) to connect the airports with minimum cost.",Employ linear programming to formulate the problem as an optimization task with constraints on airport distances.,"For each day, sort the airport positions. Then, use dynamic programming to find the minimum cost to connect all airports, considering all possible groupings and shifts to satisfy the minimum distance constraint.",,algorithms,"['dynamic programming', 'optimization', 'sorting']"
https://www.hackerrank.com/challenges/choosing-white-balls?isFullScreen=true,"There are
balls in a row, and each ball is either
black
(
B
) or
white
(
W
). Perform
removal operations with the goal of
maximizing the number of white balls
picked. For each operation
(where
):
Choose an integer,
, uniformly and independently from
to
(inclusive).
Remove the
ball from either the left end or right end of the row, which decrements the number of available balls in the row by
. You can choose to remove the ball from whichever end in each step maximizing the expected total number of white balls picked at the end.
Given a string describing the initial row of balls as a sequence of
W
's and
B
's, find and print the
expected
number of
white
balls providing that you make all choices optimally. A correct answer has an
absolute
error of
at most
.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of balls) and
(the number of operations).
The second line describes the initial sequence balls as a single string of
characters; each character is either
B
or
W
and describes a
black
or
white
ball, respectively.
Constraints
Output Format
Print a single floating-point number denoting the expected number of
white
balls picked. Your answer is considered to be correct if it has an
absolute
error of
at most
.
Sample Input 0
3 1
BWW
Sample Output 0
1.0000000000
Explanation 0
https://s3.amazonaws.com/hr-challenge-images/0/1483774515-a931a6cb86-choose-white-balls-0.png
Independent of your choice of
, one
white
ball will always be picked so the expected number of
white
balls chosen after
operation is
. Thus, we print
as our answer.
Sample Input 1
4 2
WBWB
Sample Output 1
1.5000000000
Explanation 1
We perform the following
operations:
https://s3.amazonaws.com/hr-challenge-images/0/1483774465-b939f367d9-choose-white-balls-1-1.png
Independent of your choice of
, a
white
ball will always be chosen during the first operation (meaning the expected number of
white
balls in the first operation is
).
https://s3.amazonaws.com/hr-challenge-images/0/1483774492-f2ca5648e9-choose-white-balls-1-2.png
For the second operation, there are
possible row orderings (depending on which ball was picked during the first operation). In the first possible row ordering, the probability of picking a
white
ball is
. In the second possible row ordering, the probability of picking a
white
ball is
. This means the expected number of
white
balls chosen in the second operation is
.
After performing all
operations, we print the total expected number of
white
balls chosen, which is
.",Greedily choose the end with more white balls without considering future operations.,Always remove from the left end.,Randomly choose an end to remove from without any strategy.,"Remove all black balls first, then remove white balls.",Use dynamic programming to calculate the expected value of white balls for each subproblem (range of balls) and number of remaining operations.,,algorithms,"['dynamic programming', 'expected value', 'probability']"
https://www.hackerrank.com/challenges/tree-flow?isFullScreen=true,"Recall that a tree is an undirected, connected acyclic graph. We have a weighted tree,
, with
vertices; let
be the total sum of edge weights on the path between nodes
and
.
Let's consider all the matrices,
, such that:
for each
and
We consider the
total value
of matrix
to be:
Calculate and print the maximum total value of
for a given tree,
.
Input Format
The first line contains a single positive integer,
, denoting the number of vertices in tree
.
Each line
of the
subsequent lines contains three space-separated positive integers denoting the respective
,
, and
values defining an edge connecting nodes
and
(where
) with edge weight
.
Constraints
Test cases with
have
of total score
Test cases with
have
of total score
Output Format
Print a single integer denoting the maximum total value of matrix
satisfying the properties specified in the
Problem Statement
above.
Sample Input
3
1 2 2
1 3 1
Sample Output
3
Explanation
In the sample case, matrix
is:
The sum of the elements of the first row is equal to
.",Use Dijkstra's algorithm to find the shortest path between all pairs of nodes and sum the weights.,Calculate the total weight of the tree and square it.,Apply Kruskal's algorithm to find the minimum spanning tree and sum the edge weights. Square this value.,"Find the diameter of the tree (longest path), and then calculate the square of the sum of edge weights along this path.","Calculate the all-pairs shortest path using Floyd-Warshall, and then sum these shortest path weights.",,algorithms,"['graph theory', 'shortest path', 'dynamic programming']"
https://www.hackerrank.com/challenges/taste-of-win?isFullScreen=true,"Stephanie just learned about a game called
Nim
in which there are two players and
piles of stones. During each turn, a player must choose any non-empty pile and take as many stones as they want. The first player who cannot complete their turn (i.e., because all piles are empty) loses.
Stephanie knows that, for each start position in this game, it's possible to know which player will win (i.e., the first or second player) if both players play optimally. Now she wants to know the number of different games that exist that satisfy all of the following conditions:
The game starts with
non-empty piles and each pile contains less than
stones.
All the piles contain pairwise different numbers of stones.
The first player wins if that player moves optimally.
Help Stephanie by finding and printing the number of such games satisfying all the above criteria, modulo
.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
Constraints
Output Format
Print the number of such games, modulo
.
Sample Input 0
2 2
Sample Output 0
6
Explanation 0
We want to know the number of games with
piles where each pile contains
stones. There are six such possible games with the following distributions of stones:
. Thus, we print the result of
as our answer.",Count all possible combinations of piles and subtract the number of losing positions.,"Generate all possible combinations of piles, compute the Nim-sum for each, and count those with a non-zero Nim-sum.",Use dynamic programming to count losing positions and subtract from the total possible games.,Recursively generate all possible game configurations and check the winning condition for each.,"Calculate all combinations of distinct pile sizes less than 'k', compute the Nim-sum for each, and count those with a non-zero Nim-sum modulo 1000000007.",,algorithms,"['nim game', 'combinatorics', 'xor']"
https://www.hackerrank.com/challenges/pylons?isFullScreen=true,"Goodland is a country with a number of evenly spaced cities along a line.  The distance between adjacent cities is
unit.  There is an energy infrastructure project planning meeting, and the government needs to know the fewest number of power plants needed to provide electricity to the entire list of cities.  Determine that number.  If it cannot be done, return -1.
You are given a list of city data.  Cities that may contain a power plant have been labeled
.  Others not suitable for building a plant are labeled
.  Given a distribution range of
, find the lowest number of plants that must be built such that all cities are served.  The distribution range limits supply to cities where distance is
less than k
.
Example
Each city is
unit distance from its neighbors, and we'll use
based indexing.  We see there are
cities suitable for power plants, cities
and
.  If we build a power plant at
, it can serve
through
because those endpoints are at a distance of
and
.  To serve
, we would need to be able to build a plant in city
or
.  Since none of those is suitable, we must return -1.  It cannot be done using the current distribution constraint.
Function Description
Complete the
pylons
function in the editor below.
pylons has the following parameter(s):
int k:
the distribution range
int arr[n]:
each city's suitability as a building site
Returns
int:
the minimum number of plants required or -1
Input Format
The first line contains two space-separated integers
and
, the number of cities in Goodland and the plants' range constant.
The second line contains
space-separated binary integers where each integer indicates suitability for building a plant.
Constraints
Each
.
Subtask
for
of the maximum score.
Output Format
Print a single integer denoting the minimum number of plants that must be built so that all of Goodland's cities have electricity.  If this is not possible for the given value of
, print
.
Sample Input
STDIN         Function
-----         --------
6 2           arr[] size n = 6, k = 2
0 1 1 1 1 0   arr = [0, 1, 1, 1, 1, 0]
Sample Output
2
Explanation
Cities
,
,
, and
are suitable for power plants.  Each plant will have a range of
. If we build in cities
cities,
and
, then all cities will have electricity.","Use a greedy approach, always placing a plant at the farthest reachable city from the current coverage gap.","Iterate through the cities, placing a plant at every suitable location to guarantee coverage.","Start from the last city and work backward, placing plants to cover any uncovered cities.",Calculate the average suitability of the cities and place plants proportionally to that average.,"Iterate through the cities, and when a city is not covered, place a plant at the rightmost suitable location within the coverage range of that city.",,algorithms,"['greedy algorithm', 'range coverage', 'optimization']"
https://www.hackerrank.com/challenges/matrix-land?isFullScreen=true,"You are playing a matrix-based game with the following setup and rules:
You are given a matrix
with
rows and
columns. Each cell contains some points. When a player passes a cell their score increases by the number written in that cell and the number in the cell becomes
. (If the cell number is positive their score increases, otherwise it decreases.)
The player starts from any cell in the
first
row and can move
left
,
right
or
down
.
The game is over when the player reaches the
last
row and stops moving.
https://s3.amazonaws.com/hr-assets/0/1509009270-802e706561-1496382547-5dc79ddda5-matrixland.png
Print the maximum score that the player can get.
Input Format
The first line contains
and
. The next
lines contain
numbers each,
number in
line denotes the number that is written on cell
.
Constraints
Subtasks
for
tests
.
for
tests
.
Output Format
Print the maximum score that the player can get.
Sample Input 0
4 5
1 2 3 -1 -2
-5 -8 -1 2 -150
1 2 3 -250 100
1 1 1 1 20
Sample Output 0
37
Explanation 0
Refer the image given in statement, the path followed is
summing upto
.
Note that,
is traversed
times, but the second time it only contributes
to the sum.","Apply a greedy approach, always choosing the cell with the highest value",Use a divide-and-conquer strategy to split the matrix into smaller subproblems,Calculate the sum of all cells and return that as the maximum score,Explore all possible paths using a brute-force approach and select the path with the highest score,Employ dynamic programming to store and reuse optimal subpath scores from the top row to the bottom row,,algorithms,"['dynamic programming', 'matrix', 'pathfinding']"
https://www.hackerrank.com/challenges/maxsubarray?isFullScreen=true,"We define
subsequence
as any subset of an array.  We define a
subarray
as a
contiguous subsequence
in an array.
Given an array, find the maximum possible sum among:
all nonempty subarrays.
all nonempty subsequences.
Print the two values as space-separated integers on one line.
Note
that empty subarrays/subsequences should not be considered.
Example
The maximum subarray sum is comprised of elements at inidices
.  Their sum is
.  The maximum subsequence sum is comprised of elements at indices
and their sum is
.
Function Description
Complete the
maxSubarray
function in the editor below.
maxSubarray has the following parameter(s):
int arr[n]:
an array of integers
Returns
int[2]:
the maximum subarray and subsequence sums
Input Format
The first line of input contains a single integer
, the number of test cases.
The first line of each test case contains a single integer
.
The second line contains
space-separated integers
where
.
Constraints
The subarray and subsequences you consider should have at least one element.
Sample Input 0
2
4
1 2 3 4
6
2 -1 2 3 4 -5
Sample Output 0
10 10
10 11
Explanation 0
In the first case:
The maximum sum for both types of subsequences is just the sum of all the elements since they are all positive.
In the second case:
The subarray
is the subarray with the maximum sum, and
is the subsequence with the maximum sum.
Sample Input 1
1
5
-2 -3 -1 -4 -6
Sample Output 1
-1 -1
Explanation 1
Since all of the numbers are negative, both the maximum subarray and maximum subsequence sums are made up of one element,
.",Kadane's algorithm for subarray and sum all positive elements for subsequence,"Dynamic programming to find all possible subarrays and subsequences, then compute maximums","Sort the array, then take the sum of the largest contiguous elements for subarray and all positive elements for subsequence",Divide and conquer to find maximum subarray and subsequence sums recursively,Kadane's algorithm for maximum subarray and sum of positive elements or the largest single element for subsequence,,algorithms,"['dynamic programming', ""Kadane's algorithm"", 'subsequence']"
https://www.hackerrank.com/challenges/chocolate-in-box?isFullScreen=true,"Dexter and Debra are playing a game. They have
N
containers each having one or more chocolates. Containers are numbered from
1
to
N
, where
i
th
container has
A[i]
number of chocolates.
The game goes like this. First player will choose a container and take one or more chocolates from it. Then, second player will choose a non-empty container and take one or more chocolates from it. And then they alternate turns. This process will continue, until one of the players is not able to take any chocolates (because no chocolates are left). One who is not able to take any chocolates loses the game. Note that player can choose only non-empty container.
The game between Dexter and Debra has just started, and Dexter has got the first Chance. He wants to know the number of ways to make a first move such that under optimal play, the first player always wins.
Input Format
The first line contains an integer
N
, i.e., number of containers.
The second line contains
N
integers, i.e., number of chocolates in each of the containers separated by a single space.
Constraints
1 ≤
N
≤ 10
6
1 ≤
A[i]
≤ 10
9
Output Format
Print the number of ways to make the first move such that under optimal play, the first player always wins. If the first player cannot win under optimal play, print 0.
Sample Input
2
2 3
Sample Output
1
Explanation
Only 1 set of moves helps player 1 win.
Player:      1      2      1      2      1
Chocolates: 2 3 -> 2 2 -> 1 2 -> 1 1 -> 0 1",Count containers where A[i] > XOR_sum,Count containers where A[i] < XOR_sum,Count containers where A[i] == XOR_sum,"Return N if XOR_sum is 0, otherwise return 0","Iterate through each container; for each, calculate the XOR_sum of remaining containers. Count instances where A[i] XOR desired_xor < A[i]. desired_xor = XOR_sum of the remaining after removing A[i]",,algorithms,"['game theory', 'XOR', 'optimal play']"
https://www.hackerrank.com/challenges/best-spot?isFullScreen=true,"In Chile, land are partitioned into a one large grid, where each element represents a land of size
1x1
.
Shaka is a newcomer in Chile and is trying to start his own business. He is planning to build a store. He has his own ideas for the ""perfect store"" which can be represented by a
HxW
grid. Element at position
(i, j)
represents height of land at index
(i, j)
in the grid.
Shaka has purchased a land area which can be represented
RxC
grid (
H <= R, W <= C
). Shaka is interested in finding best
HxW
sub-grid in the acquired land. In order to compare the possible sub-grids, Shaka will be using the sum of squared difference between each cell of his ""perfect store"" and  it's corresponding cell in the subgrid. Amongst all possible sub-grids, he will choose the one with smallest such sum.
Note
The grids are 1-indexed and rows increase from top to bottom and columns increase from left to right.
If
x
is the height of a cell in the ""perfect store"" and
y
is the height of the corresponding cell in a sub-grid of the acquired land, then the squared difference is defined as (x-y)
2
Input Format
The first line of the input consists of two integers,
R C
, separated by single space.
Then
R
lines follow, each one containing
C
space separated integers, which describe the height of each land spot of the purchased land.
The next line contains two integers,
H W
, separated by a single space, followed by
H
lines with
W
space separated integers, which describes the ""perfect store"".
Constraints
1 <=
R, C
<= 500
1 <=
H
<=
R
1 <=
W
<=
C
No height will have an absolute value greater than 20.
Output Format
In the first line, output the smallest possible sum (as defined above) Shaka can find on exploring all the sub-grids (of size
HxW
)  in the purchased land.
In second line, output two space separated integers,
i j
, which represents the index of top left corner of sub-grid (on the acquired land) with the minimal such sum. If there are multiple sub-grids with minimal sum, output the one with the smaller row index. If there are still multiple sub-grids with minimal sum, output the one with smaller column index.
Sample Input
3 3
19 19 -12
5 8 -14
-12 -11 9
2 2
-18 -12
-10 -7
Sample Output
937
2 2
Explanation
The result is computed as follows: (8 - (-18))
2
+  (-14 - (-12))
2
+ (-11 - (-10))
2
+ (9 - (-7))
2
= 937",Calculate the sum of absolute differences instead of squared differences.,Use dynamic programming to store and reuse the sums of sub-grids of size 1x1.,"Calculate the squared difference using integer division, which can lead to incorrect results.",Consider only sub-grids that start at even-numbered rows and columns.,"Iterate through all possible HxW sub-grids within the RxC grid, calculate the sum of squared differences for each, and track the minimum sum and its corresponding top-left corner coordinates.",,algorithms,"['nested loops', 'sum of squares', 'grid traversal']"
https://www.hackerrank.com/challenges/two-subarrays?isFullScreen=true,"Consider an array,
, of
integers. We define the following terms:
Subsequence
A subsequence of
is an array that's derived by removing zero or more elements from
without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called
the empty subsequence
.
Strictly Increasing Subsequence
A non-empty subsequence is
strictly increasing
if every element of the subsequence is larger than the previous element.
Subarray
A subarray of
is an array consisting of a contiguous block of
's elements in the inclusive range from index
to index
. Any subarray of
can be denoted by
.
The diagram below shows all possible subsequences and subarrays of
:
https://s3.amazonaws.com/hr-challenge-images/0/1485242068-78c480cd00-subarray6.png
We define the following functions:
= the maximum sum of some
strictly increasing subsequence
in subarray
We define the
goodness
,
, of array
to be:
In other words,
is the maximum possible value of
for all possible subarrays of array
.
Let
be the length of the smallest subarray such that
. Given
, find the value of
as well as the number of subarrays such that
and
, then print these respective answers as space-separated integers on a single line.
Input Format
The first line contains an integer,
, denoting number of elements in array
.
The second line contains
space-separated integers describing the respective values of
.
Constraints
Subtasks
For the
of the maximum score:
For the
of the maximum score:
Output Format
Print two space-seperated integers describing the respective values of
and the number of subarrays satisfying
and
.
Sample Input 0
3
2 3 1
Sample Output 0
1 1
Explanation 0
The figure below shows how to calculate
:
https://lh3.googleusercontent.com/-YXhNl5SXWNE/WIvdRBXsayI/AAAAAAAAAEA/WMvCRtoPkVkpK3Qbm0C-MUWtYOu0RNLEQCL0B/h384/subarray.png
is the length of the smallest subarray satisfying
. From the table, we can see that
. There is only one subarray of length
such that
.","Dynamic Programming: Build a table storing maximum sums of increasing subsequences ending at each index, and find the global maximum across all subarrays.",Greedy Approach: Always select the largest element from the current subarray to maximize the increasing subsequence sum.,"Divide and Conquer: Recursively divide the array into subarrays, solve for each subarray, and combine results. This is not suitable because the increasing subsequence must be strictly increasing in the specified range.","Brute Force: Iterate through all possible subarrays, find all increasing subsequences within each subarray, calculate their sums, and determine the maximum.  This will result in a Time Limit Exceeded Error.",Sliding Window with Dynamic Programming: Maintain a sliding window to iterate through all subarrays and use dynamic programming to calculate the maximum increasing subsequence sum within each window. Track the minimum window size and its occurrences where the maximum sum matches the global maximum.,,algorithms,"['dynamic programming', 'subsequence', 'sliding window']"
https://www.hackerrank.com/challenges/quadrant-queries?isFullScreen=true,"There are
points on a plane.  Each point
is described by
, where
. There are three types of queries needed:
X i j
Reflect all points in the inclusive range between points
and
along the
-axis.
Y i j
Reflect all points in the inclusive range between points
and
along the
-axis.
C i j
Count the number of points in the inclusive range between points
and
in each of the
quadrants. Then print a single line of four space-separated integers describing the respective numbers of points in the first, second, third, and fourth quadrants in that order.
As a reminder, the four quadrants of a graph are labeled as follows:
https://static.hackerrank.com/hackerrank/quadrant-queries.gif
Given a set of
points and
queries, perform each query in order. For example, given points
and
.  Initially the points are in quadrants
and
.  The first query says to reflect points with indices from
to
along the
-axis.  After the query,
and quadrants are
and
.  The next query prints the number of points in each quadrant:
0 1 0 1
.  The third query says to reflect the point with index
to
along the
-axis, so now
.  The points now lie in quadrants
and
, so the fourth query output is
0 1 1 0
.
Note:
Points may sometimes share the same coordinates.
Function Description
Complete the
quadrants
function in the editor below.  It should print the results of each
C
type query on a new line.
quadrants has the following parameters:
-
p[p[1]...p[n]]
: a 2-dimensional array of integers where each element
contains two integers
and
-
queries[queries[1]...queries[n]
: an array of strings
Input Format
The first line contains a single integer,
, that denotes the number of points.
Each line
of the
subsequent lines contains two space-separated integers that describe the respective
and
values for point
.
The next line contains a single integer,
, that denotes the number of queries.
Each of the
subsequent lines contains three space-separated values that describe a query in one of the three forms defined above.
Constraints
No point lies on the
or
axes.
In all queries,
.
Output Format
For each query of type
C i j
, print four space-separated integers that describe the number of points having indices in the inclusive range between
and
in the first, second, third, and fourth graph quadrants in that order.
Sample Input
4
1 1
-1 1
-1 -1
1 -1
5
C 1 4
X 2 4
C 3 4
Y 1 2
C 1 3
Sample Output
1 1 1 1
1 1 0 0
0 2 0 1
Explanation
Initially,
so there is one point in each of the four quadrants.  The first query results in printing
1 1 1 1
.
The second query,
X 2 4
, reflects the points in the inclusive range between indices
and
along the
-axis. Now
.
The query
C 3 4
requires that the number of points considering
through
be printed:
1 1 0 0
The third query,
Y 1 2
requires reflection of
along the
-axis.  Now
.
The last query,
C 1 3
requires that the number of points considering
through
be printed:
0 2 0 1","Implement a segment tree to store point coordinates and efficiently update them during reflection, then query for quadrant counts within ranges","Use a brute-force approach, iterating through the points for each query and updating/counting directly, optimizing only with coordinate caching",Precompute the quadrants for all possible subranges of points and store them in a lookup table to answer queries in O(1) time,"Sort the points based on their x and y coordinates, then use binary search to efficiently find the points within the specified ranges for quadrant counting","Maintain the point coordinates and, for each query, reflect or count points within the range using simple iteration and conditional checks",,algorithms,"['coordinate geometry', 'range queries', 'reflection']"
https://www.hackerrank.com/challenges/prime-date?isFullScreen=true,"In this challenge, the task is to debug the existing code to successfully execute all provided test files.
Given two dates each in the format
dd-mm-yyyy
, you have to find the number of lucky dates between them (inclusive). To see if a date is lucky,
Firstly, sequentially concatinate the date, month and year, into a new integer
erasing the leading zeroes.
Now if
is divisible by either
or
, then we call the date a lucky date.
For example, let's take the date ""02-08-2024"". After concatinating the day, month and year, we get
= 2082024. As
is divisible by
so the date ""02-08-2024"" is called a lucky date.
Debug the given function
findPrimeDates
and/or other lines of code, to find the correct lucky dates from the given input.
Note:
You can modify at most
five
lines in the given code and you cannot add or remove lines to the code.
To restore the original code, click on the icon to the right of the language selector.
Input Format
The only line of the input contains two strings
and
denoting the two dates following the format
dd-mm-yyyy
. Consider,
is the day number,
is the month number and
is the year number.
Note: Here
means January,
means February,
means March and so on and all the dates follow the standard structure of English calender including the leap year.
Constraints
Output Format
For each test cases, print a single integer the number of lucky dates between
and
in a single line.
Sample Input 0
02-08-2025 04-09-2025
Sample Output 0
5",An integer overflow occurs when concatenating the date components.,"The leap year calculation is incorrect, leading to inaccurate date validation.",The date parsing logic doesn't handle single-digit days/months correctly.,The divisibility check uses the wrong prime numbers.,"The loop increments the date incorrectly, skipping some dates.",,algorithms,"['debugging', 'date manipulation', 'divisibility']"
https://www.hackerrank.com/challenges/crab-graphs?isFullScreen=true,"A crab is an undirected graph which has two kinds of vertices: 1 head, and K feet , and exactly K edges which join the head to each of the feet.( 1 <= K <= T, where T is given)
Given an undirected graph, you have to find in it some vertex-disjoint subgraphs where each one is a crab . The goal is to select those crabs in such a way that the total number of vertices covered by them is maximized.
Note: two graphs are vertex-disjoint if they do not have any vertices in common.
Input Format
The first line of input contains a single integer C. C test-cases follow. The first line of each test-case contains three integers N, T, and M (the number of nodes, max number of feet in the crab graph, and number of edges, respectively). Each of next M lines contains two space separated values v1i, v2i meaning that the there is an edge between vertices v1i and v2i. Note that the graph doesn't have parallel edges or loops.
Constraints
1 <= C <= 10
2 <= T <= 100
2 <= N <= 100
0 <= M <= N * (N-1)/2
1 <= v1i <= N
1 <= v2i <= N
Output Format
For each test-case, output a single integer indicating the maximum number of vertices which can be covered by vertex-disjoint sub-graphs of crab- graphs.
Sample Input
2
8 2 7
1 4
2 4
3 4
5 4
5 8
5 7
5 6
6 3 8
1 2
2 3
3 4
4 5
5 6
6 1
1 4
2 5
Sample Output
6
6
Explanation
Test #1: The graph for this test-case below. Because T = 2, each crab can have a maximum of 2 feet => each crab can cover a maximum of 3 nodes. We can cover 6 nodes of this graph with these two crabs: One of the crabs has 4 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 7 and 8 as its feet. No additional crabs can be added.
The above is not a unique solution: any combination of two crabs, with one head at 4 and one head at 5, will suffice. We could have also chosen Head[4]feet[1,2] and Head[5]feet[6,7] as our two crabs.
https://s3.amazonaws.com/hr-challenge-images/71/1463044961-9a247b4a4c-im1.png
Test #2: The graph for this test-case below. We can cover all 6 nodes using two crabs. One of the crabs has 2 as its head and 1 and 3 as its feet, the other crab has 5 as its head and 4 and 6 as its feet.
https://s3.amazonaws.com/hr-challenge-images/71/1463044976-ebcf26fbc8-im2.png",Use a greedy approach by iteratively selecting the node with the highest degree as a crab's head.,Apply a minimum cut algorithm to the graph and remove the edges to maximize remaining nodes.,"Employ a brute-force approach, checking all possible combinations of vertex-disjoint subgraphs.",Use a maximum flow algorithm to determine the maximum number of vertex-disjoint crabs.,"Model the problem as a maximum weighted matching problem, finding the optimal set of disjoint crabs.",,algorithms,"['graph theory', 'maximum matching', 'optimization']"
https://www.hackerrank.com/challenges/superman-celebrates-diwali?isFullScreen=true,"Superman has been invited to India to celebrate Diwali. Unfortunately, on his arrival he learns that he has been invited mainly to help rescue people from a fire accident that has happened in a posh residential locale of New Delhi, where rescue is proving to be especially difficult. As he reaches the place of the fire, before him there are
buildings, each of the same height
, which are on fire. Since it is Diwali, some floors of the buildings are empty as the occupants have gone elsewhere for celebrations. In his hurry to start the rescue Superman reaches the top of the building, but realizes that his jumping power is depleted and restricted due to change in his geographical setting.
He soon understands the restrictions of his jumping power, and they are as follows:
He can use the jumping power any number of times until he reaches the bottom floor, which means he can use the jumping power only until before he reaches the bottom (Ground floor), which means, once he reaches the bottom floor, he cannot move to the top floor again and try to save people. (In one single drop from the top to bottom)
While switching buildings, he loses height
while jumping.
The second restriction is explained below with an example.
Assume
. Now Superman is in the 2
nd
building 5
th
floor (
,
). If he wants to switch to the fifth building (
), he will lose height (
), which means he will be at floor
3
at building
5
(
,
). He can jump freely from the current floor to the floor below on the same building . That is, suppose if he is at
, he can go to
without any restrictions. He cannot skip a floor while jumping in the same building. He can go to the floor below the current floor of the same building or use his jumping power, switch building, and lose height
.
Given the information about the occupied floors in each of the
buildings, help Superman to determine the maximum number of people he can save in one single drop from the top to the bottom floor with the given restrictions.
Input Format
Input starts with three values:  the number of buildings
, the height of the buildings
, and the height Superman will lose when he switches buildings
.
These are followed by
lines. Each
line starts with a non negative integer
indicating how many people are in the
th
building. Each of the following
integers indicates that a person is at height
in the
buiding. Each of the following
integers are given and repetitions are allowed which means there can be more than one person in a floor.
indicates building number and
indicates floor number. Building number will not be given; since
lines follow the first line, you can assume that the
line indicates the
building's specifications.
Constraints
(for each
, which means the maximum number of people in a particular building will not exceed
)
Output Format
Output the maximum number of people Superman can save.
Sample Input
4 15 2
5 1 1 1 4 10
8 9 5 7 7 3 9 8 8
5 9 5 6 4 3
0
Sample Output
12
Explanation
Input starts with
,
,
.
lines follow. Each line describes building
.
Each line begins with
, which denotes the number of persons in a particular building, followed by floor number, where each person resides. Floor number can repeat as any number of people can reside on a particular floor.
I've attached a figure here to explain the sample test case.
You can verify the first building's specifications with the figure.
(Total number of persons in the first building), followed by 1 1 1 4 10(Floor numbers).
floor = 3 persons.
floor = 1 person.
floor = 1 person.
Similarly, the specifications for the other three buildings follow.
The connected line shows the path which Superman can use to save the maximum number of people. In this case, that number is
.
You can also note in the figure that when he switches from Building
2
to Building
3
, he loses height
(
). Similarly, when he switches from Building
3
to Building
1
,the same height loss happens as mentioned in the problem statement.
http://i.imgur.com/N3SNC3j.jpg?1","Use dynamic programming to store the maximum people saved at each building and floor, considering only moves to the next building.",Sort the buildings by the number of people on each floor and greedily choose the path with the most people.,Calculate the total number of people in all buildings and subtract the minimum number of people that can be reached in a path from top to bottom.,"Treat the problem as a shortest path problem, where the distance is the negative of the number of people saved, and use Dijkstra's algorithm.","Use dynamic programming to store the maximum people saved at each building and floor, considering moves within the same building and to other buildings.",,algorithms,"['dynamic programming', 'optimization', 'grid traversal']"
https://www.hackerrank.com/challenges/zero-move-nim?isFullScreen=true,"Nim
is a famous game in which two players take turns removing items from
distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player
removes the last item from the last non-empty pile
.
John and Kate modified Nim by adding the following rule, which they call a
Zero-Move
:
For each
non-empty
pile, either player can remove
items from that pile and have it count as their move; however, this move can only be performed
once per pile by either player
. For example, let's say pile
initially has
items in it. If John decides to use a Zero-Move on pile
, then neither John nor Kate can perform another Zero-Move on pile
; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet.
John and Kate play
games of
Zero-Move Nim
. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print
W
on a new line if John can win; otherwise, print
L
instead.
Input Format
The first line contains an integer,
, denoting the number of games. The
subsequent lines describe each game over two lines:
The first line contains an integer,
, denoting the number of heaps.
The second line contains
space-separated integers describing
.
Constraints
Subtasks
For
of the test cases,
For
of the test cases,
Output Format
For each game, print
W
on a new line if John will win; otherwise, print
L
instead.
Sample Input 0
2
2
1 2
2
2 2
Sample Output 0
W
L
Explanation 0
John and Kate play the following
games:
We have two piles,
and
. John removes
item from
, so
. Now that there is only
item in each pile, gameplay can proceed in either of the following ways:
Kate removes the last object from one pile, then John removes the last object from the other pile.
Kate uses a Zero-Move on one of the piles, and John uses a Zero-Move on the other pile. Next, Kate must take the last object from one pile, at which point John removes the last object from the other pile.
Because John always wins in either scenario, we print
W
on a new line.
John cannot win this game because the two piles are of equal size and Kate has an opportunity to counter any move he makes by performing the same action. Consider the following scenarios:
If John uses a Zero-Move on one pile, Kate can use a Zero-Move on the other pile (meaning the piles still have the same configuration after both players move).
If John removes one element from a pile, Kate can remove one element from the other pile so that both remaining piles contain one element when John takes his next turn. He would then be forced to empty one of the piles, leaving Kate to make the winning move by emptying the last pile.
If John removes both elements from one of the piles, Kate can remove both elements from the other pile and win the game.
Because John always loses this game, we print
L
on a new line.",The first player always wins if the XOR sum of the piles is non-zero.,Zero-moves are irrelevant; the winner depends only on the XOR sum of the initial pile sizes.,"The player who makes the first zero-move always loses, irrespective of the initial XOR sum.",The winner can be determined by checking if the product of all pile sizes is even or odd.,The first player wins if the XOR sum of the piles is non-zero OR if the number of piles is odd and the XOR sum is zero.,,algorithms,"['game theory', 'nim', 'xor']"
https://www.hackerrank.com/challenges/k-factorization?isFullScreen=true,"At the time when Pythagoreanism was prevalent, people were also focused on different ways to factorize a number. In one class, Pythagoras asked his disciples to solve one such problem,
Reverse Factorization
. They were given a set of integer,
, and an integer
. They need to find the a way to reach
, starting from
, and at each step multiplying current value by any element of
. But soon they realised that there may exist more than one way to reach
. So they decided to find a way in which number of states are least. All of sudden they started on this new problem. People solved it and then started shouting their answer. CRAP!!!. There still exists multiple answers. So finally after much consideration, they settled on the lexicographically smallest series among those solutions which contains the least number of states.
For example, if
and
then following ways exists
(
a
)
1
->
2
->
4
->
12
x2
x2
x3
(
b
)
1
->
4
->
12
x4
x3
(
c
)
1
->
3
->
12
x3
x4
Here
(a)
is not the minimal state, as it has
states in total. While
(b)
and
(c)
are contenders for answer, both having 3 states,
(c)
is lexicographically smaller than
(b)
so it is the answer. In this case you have to print
1 3 12
. If there exists no way to reach
print
-1
.
Input Format
Input contains two lines where first line contains two space separated integer,
and
, representing the final value to reach and the size of set
, respectively. Next line contains
K
space integers representing the set
.
Constraints
, where
, where
AND
Note:
Lexicographical order:
If
and
are two ordered lists, then
is lexicographically smaller than
if any one of the following condition satisfies.
AND
.
AND
AND
.
You need to find the
lexigraphically smallest
series among those solutions which contains the least number of states.
Output Format
Print the steps to reach
if it exists. Otherwise print
-1
.
Sample Input 0
12 3
2 3 4
Sample Output 0
1 3 12
Explanation 0
This is the same case which is explaned above.
Sample Input 1
15 5
2 10 6 9 11
Sample Output 1
-1
Explanation 1
Here no way exists so that we can reach
starting from
.
Sample Input 2
72 9
2 4 6 9 3 7 16 10 5
Sample Output 2
1 2 8 72
Explanation 2
There are multiple ways to reach
72
using these 8 numbers. Out of which following 6 ways consists of minimal states (4).
States          =>  Multiplication operation
 1   9  18  72  =>      (x9, x2, x4)
 1   4  36  72  =>      (x4, x9, x2)
 1   2   8  72  =>      (x2, x4, x9)
 1   2  18  72  =>      (x2, x9, x4)
 1   4   8  72  =>      (x4, x2, x9)
 1   9  36  72  =>      (x9, x4, x2)
As series
1 2 8 72
is lexicographically smallest, it is the answer.","Use a Depth-First Search (DFS) algorithm to explore possible paths, prioritizing shorter paths and lexicographically smaller sequences, but without memoization.","Employ a Breadth-First Search (BFS) algorithm to find the shortest path, constructing the path during the search, but sorting all minimal paths at the end to find the lexicographically smallest.","Apply dynamic programming to calculate the minimum number of steps to reach each possible value, and then backtrack to find the lexicographically smallest path, storing only the minimum steps and not the paths themselves.","Randomly generate paths by multiplying with elements from the set, and keep track of the shortest and lexicographically smallest path found so far, improving the solution with more random attempts.","Implement a Breadth-First Search (BFS) algorithm, maintaining a queue of paths, prioritizing shorter paths and lexicographically smaller sequences during queue insertion, and stopping when the target is reached.",,algorithms,"['graph traversal', 'breadth-first search', 'lexicographical order']"
https://www.hackerrank.com/challenges/swappermutation?isFullScreen=true,"You are given an array
A = [1, 2, 3, ..., n]
:
How many sequences
(S
1
)
can you get after exact
k
adjacent swaps on
A
?
How many sequences
(S
2
)
can you get after at most
k
swaps on
A
?
An adjacent swap can be made between two elements of the Array A, A[i] and A[i+1] or A[i] and A[i-1].
A swap otherwise can be between any two elements of the array A[i] and A[j] ∀ 1 ≤ i, j ≤ N, i ≠ j.
Input Format
First and only line contains
n
and
k
separated by space.
Constraints
1 ≤ n ≤ 2500
1 ≤ k ≤ 2500
Output Format
Output
S
1
% MOD
and
S
2
% MOD
in one line, where
MOD = 1000000007
.
Sample Input
3 2
Sample Output
3 6
Explanation
Original array: [1, 2, 3]
1. After 2 adjacent swaps:
We can get [1, 2, 3], [2, 3, 1], [3, 1, 2] ==> S1 == 3

2. After at most 2 swaps:
1) After 0 swap: [1, 2, 3]
2) After 1 swap: [2, 1, 3], [3, 2, 1], [1, 3, 2].
3) After 2 swaps: [1, 2, 3], [2, 3, 1], [3, 1, 2]
==> S2 == 6",Calculate the number of inversions in the array after each swap sequence.,Use dynamic programming to store the number of reachable states after each swap.,Enumerate all possible swap sequences and check for duplicates.,"Apply a greedy algorithm, always swapping adjacent elements towards the middle.","Employ dynamic programming, tracking the number of permutations reachable with exactly and at most 'k' adjacent swaps, modulo 1000000007.",,algorithms,"['dynamic programming', 'permutations', 'adjacent swaps']"
https://www.hackerrank.com/challenges/vim-war?isFullScreen=true,"A war has broken down between Vim and Emacs. Gedit, being Vim's ally, is captured by Emacs as a prisoner of war and it is up to Vim to rescue him by defeating Emacs.
For this task, Vim has to assemble an army of appropriate skills. He can choose a
non-empty
subset of soldiers from a set of
soldiers (numbered from
to
). Each soldier has some subset of skills out of
different skills (numbered from
to
). The skill-set of an army is the union of skill-sets of its constituent soldiers. To win the war, Vim needs to know how many different subsets of soldiers satisfy his skill-set requirement. Since the answer can be huge, print it modulo
.
Note : The chosen army's skill-set must
exactly
match the skill-set requirement of Vim (i.e no extra skills must be present in the army's skill-set than what is required).
Input Format
The first line contains
and
, the number of soldiers to choose from and the number of different skills possible respectively.
The next
lines contain
boolean characters each. If the
character of the
line is
, then the
soldier possess the
skill and if it is
, then not.
The last line contains
boolean characters denoting the requirement skill-set of Vim where the
character being
signifies that Vim wants the
skill to be present in his final army and not, otherwise.
Constraints
Output Format
Output in a single line the required answer, as explained above.
Sample Input
4 2
00
10
01
11
11
Sample Output
10
Explanation
Vim wants both the skills to be present in his selected army. Hence, he can choose the following subsets of soldiers:","Use dynamic programming to count subsets with all skills, but overcounts due to extra skills.",Iterate through all possible subsets and check if the skill-set is a superset of the required skill-set.,Calculate the number of subsets with each individual skill and sum them using the inclusion-exclusion principle.,"Represent each soldier's skill-set and the required skill-set as integers, and use bitwise operations to find matching subsets.","Iterate through all possible subsets, calculate the army's skill-set, and count the subsets whose skill-set exactly matches the requirement.",,algorithms,"['bit manipulation', 'subset', 'dynamic programming']"
https://www.hackerrank.com/challenges/the-indian-job?isFullScreen=true,"It is the Indian version of the famous heist “The Italian Job”.
N
robbers have already broken into the National Museum and are just about to get inside the main vault which is full of jewels. They were lucky that just as they broke into the museum, the guard was leaving the museum for exactly
G
minutes. But there are other problems too. The main vault has heat sensors that if at any moment of time there are more than two people present in the vault, the alarm goes off.
To collect the jewels, the
i
th
robber needs to be inside the vault for exactly
A[i]
minutes,
0 <= i < N
, in one continuous stretch. As guard will return after
G
minutes, they have to finish their tasks within
G
minutes. The robbers want to know if there exists any arrangement such that demands of each robber is satisfied and also they are not caught?
Gotchas
If a robber goes inside the vault at a time ""X"" and at the same time another robber comes out, it's equivalent to saying they were never in the vault at the same time.
Similarly, when the guard gets inside vault at time
G
and a robber comes out exactly at time
G
, the guard will not be able see the robber.
Input Format
The first line contains an integer
T
denoting the number of testcases.
T
testcases follow.
Each testcase consists of two lines. First line contains two space separated integers denoting
N
and
G
denoting the number of thieves and duration for which guard leaves the museum.
The next line contains N space separated numbers where the ith integer, A[i]
represents the time the i
th
robber needs to be in the vault.
Constraints
1 <= T <= 20
1 <= N <= 100
0 <= G <= 1000000 (10
6
)
0 <= A[i] <= 100
Output Format
For each testcase print
YES
if there exists such an arrangement or
NO
otherwise in a newline.
Sample Input
2
3 4
2 4 2
3 2
2 4 2
Sample Output
YES
NO
Explanation
Test case #00:
In first testcase, one possible arrangement is:
at t=0, robber1 goes inside and comes out at t=2
at t=0, robber2 goes inside and comes out at t=4
at t=2, robber3 goes inside and comes out at t=4
Test case #01:
No possible arrangement is possible in second testcase.","Depth-First Search (DFS) with backtracking, pruning branches when constraints are violated","Greedy algorithm, prioritizing robbers with shorter times to minimize overlap","Approximation algorithm; randomly select robbers and check for constraint violations, repeating until a valid arrangement is found or a timeout occurs","Dynamic Programming, computing all possible combinations of robbers entering and exiting the vault","Check all possible permutations of robbers entering the vault and simulate the timing, returning 'YES' if a valid arrangement is found, 'NO' otherwise",,algorithms,"['permutation', 'simulation', 'constraints']"
https://www.hackerrank.com/challenges/fun-game-1?isFullScreen=true,"Kyle and Mike are bored on a rainy day and decide to pass the time by creating a new game having the following rules:
The game starts with two
-sized integer arrays,
and
, and is played by two players,
and
.
The players move in alternating turns, with
always moving first. During each move, the current player must choose an integer,
, such that
. If the current player is
, then
receives
points; if the current player is
, then
receives
points.
Each value of
can be chosen only once. That is, if a value of
is already chosen by some player, none of the player can re-use it. So, game always ends after
moves.
The player with the maximum number of points wins.
The arrays A and B are accessible to both the players P1 and P2. So the players make a optimal move at every turn.
Given the values of
,
, and
, can you determine the outcome of the game? Print
if
will win,
if
will win, or
if they will tie. Assume both players always move optimally.
Input Format
The first line of input contains a single integer,
, denoting the number of test cases. Each of the
subsequent lines describes a test case. A single test case is defined over the following three lines:
An integer,
, denoting the number of elements in arrays
and
.
space-separated integers,
, where each
describes the element at index
of array
.
space-separated integers,
, where each
describes the element at index
of array
.
Constraints
Output Format
For each test case, print one of the following predicted outcomes of the game on a new line:
Print
if
will win.
Print
if
will win.
Print
if the two players will tie.
Sample Input
3
3
1 3 4
5 3 1
2
1 1
1 1
2
2 2
3 3
Sample Output
First
Tie
Second
Explanation
Test Case 0:
,
The players make the following
moves:
chooses
and receives
points.
chooses
and receives
points. Note that
will not choose
, because this would cause
to win.
chooses
(which is the only remaining move) and receives
points.
As all
moves have been made, the game ends.
's score is
points and
's score is
points, so
is the winner and we print
on a new line.
Test Case 1:
,
Because both players will only make
move and all possible point values are
, the players will end the game with equal scores. Thus, we print
on a new line.
Test Case 1:
,
Because both players will only make
move and all the possible point values for
are greater than all the possible point values for
,
will win the game. Thus, we print
on a new line.","Sort array A in ascending order and array B in descending order, then calculate scores.",Have P1 always pick the largest element in A and P2 always pick the largest in B.,Simulate all possible game scenarios using recursion and determine the winner.,Calculate the sum of A and the sum of B; the player with the higher sum wins.,"Create a max heap of A[i] + B[i] values. P1 and P2 alternately pick values and update scores until the heap is empty, simulating optimal moves.",,algorithms,"['game theory', 'arrays', 'heap']"
https://www.hackerrank.com/challenges/sherlock-and-cost?isFullScreen=true,"In this challenge, you will be given an array
and must determine an array
.  There is a special rule:  For all
,
.  That is,
can be any number you choose such that
.  Your task is to select a series of
given
such that the sum of the absolute difference of consecutive pairs of
is maximized.  This will be the array's
cost
, and will be represented by the variable
below.
The equation can be written:
For example, if the array
, we know that
,
, and
.  Arrays meeting those guidelines are:
[
1
,
1
,
1
],
[
1
,
1
,
2
],
[
1
,
1
,
3
]
[
1
,
2
,
1
],
[
1
,
2
,
2
],
[
1
,
2
,
3
]
Our calculations for the arrays are as follows:
|
1
-
1
|
+
|
1
-
1
|
=
0
|
1
-
1
|
+
|
2
-
1
|
=
1
|
1
-
1
|
+
|
3
-
1
|
=
2
|
2
-
1
|
+
|
1
-
2
|
=
2
|
2
-
1
|
+
|
2
-
2
|
=
1
|
2
-
1
|
+
|
3
-
2
|
=
2
The maximum value obtained is
.
Function Description
Complete the
cost
function in the editor below.  It should return the maximum value that can be obtained.
cost has the following parameter(s):
B
: an array of integers
Input Format
The first line contains the integer
, the number of test cases.
Each of the next
pairs of lines is a test case where:
- The first line contains an integer
, the length of
- The next line contains
space-separated integers
Constraints
Output Format
For each test case, print the maximum sum on a separate line.
Sample Input
1
5
10 1 10 1 10
Sample Output
36
Explanation
The maximum sum occurs when A[1]=A[3]=A[5]=10 and A[2]=A[4]=1.  That is
.",Calculate the sum of absolute differences using the original array B without any modifications.,"For each element, always choose the median value between the minimum and maximum values encountered so far.",Greedily select either the minimum or maximum possible value for each element based on the previous element's value.,Calculate the differences between consecutive elements in array B and sum their absolute values.,Use dynamic programming to track the maximum cost achievable ending at the minimum and maximum possible values for each index.,,algorithms,"['dynamic programming', 'optimization', 'absolute difference']"
https://www.hackerrank.com/challenges/fair-cut?isFullScreen=true,"Li and Lu have
integers,
, that they want to divide fairly between the two of them. They decide that if Li gets integers with indices
(which implies that Lu gets integers with indices
), then the measure of unfairness of this division is:
Find the minimum measure of unfairness that can be obtained with some division of the set of integers where Li gets exactly
integers.
Note
means
Set complement
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of integers Li and Lu have) and
(the number of integers Li wants).
The second line contains
space-separated integers describing the respective values of
.
Constraints
For
of the test cases,
.
For
of the test cases,
.
Output Format
Print a single integer denoting the minimum measure of unfairness of some division where Li gets
integers.
Sample Input 0
4 2
4 3 1 2
Sample Output 0
6
Explanation 0
One possible solution for this input is
.
Sample Input 1
4 1
3 3 3 1
Sample Output 1
2
Explanation 1
The following division of numbers is optimal for this input:
.","Calculate the unfairness using a brute-force approach, checking every possible combination of Li's integers.","Sort the array, then take the difference between the sum of the first 'k' elements and the sum of the remaining elements.",Use dynamic programming to store intermediate results of unfairness calculations.,Employ a greedy algorithm that iteratively picks the largest remaining integer for Li until 'k' integers are selected.,"Sort the array, then iterate through all possible contiguous subarrays of size 'k', calculating and minimizing the unfairness.",,algorithms,"['sorting', 'subarray', 'unfairness']"
https://www.hackerrank.com/challenges/counting-special-sub-cubes?isFullScreen=true,"Given an
cube
, let
(where
) denote the value stored in cell
.
A
sub-cube
(where
) of an
cube is considered to be
special
if the maximum value stored in any cell in the sub-cube is equal to
.
For each
in the inclusive range
, calculate the number of special sub-cubes. Then print each
as a single line of space-separated integers (i.e.,
).
Input Format
The first line contains an integer,
, denoting the number of queries. The
subsequent lines describe each query over two lines:
The first line contains an integer,
, denoting the side length of the initial cube.
The second line contains
space-separated integers describing an array of
integers in the form
. The integer in some cell
is calculated using the formula
.
Constraints
where
Output Format
For each query, print
space-separated integers where the
integer denotes the number of special sub-cubes for
.
Sample Input
2
2
2 1 1 1 1 1 1 1
2
1 1 1 1 2 1 1 2
Sample Output
7 1
6 1
Explanation
We must perform the following
queries:
We have a cube of size
and must calculate the number of special sub-cubes for the following values of
:
: There are
sub-cubes of size
and seven of them have a maximum value of
written inside them. So, for
, the answer is
.
: There is only one sub-cube of size
and the maximum number written inside it is
. So, for
, the answer is
.
We then print the respective values for each
as a single line of space-separated integers (i.e.,
7 1
).
We have a cube of size
and must calculate the number of special sub-cubes for the following values of
:
: There are
sub-cubes of size
and six of them have a maximum value of
written inside them. So, for
, the answer is
.
: There is only one sub-cube of size
and the maximum number written inside it is
. So, for
, the answer is
.
We then print the respective values for each
as a single line of space-separated integers (i.e.,
6 1
).",Use dynamic programming to store intermediate results for each sub-cube's maximum value,Iterate through all possible sub-cubes and use a divide-and-conquer approach to find the maximum,Calculate the sum of all elements in each sub-cube and compare it to n to determine if it's special,"Employ a greedy algorithm, always selecting the largest possible sub-cube at each step",Iterate through all possible sub-cubes and directly compute the maximum value within them,,algorithms,"['3D array', 'sub-cube', 'max value']"
https://www.hackerrank.com/challenges/substring-diff?isFullScreen=true,"In this problem, we'll use the term ""longest common substring"" loosely.  It refers to substrings differing at some number or fewer characters when compared index by index.  For example, 'abc' and 'adc' differ in one position, 'aab' and 'aba' differ in two.
Given two strings and an integer
, determine the length of the longest common substrings of the two strings that differ in no more than
positions.
For example,
.  Strings
and
.  Check to see if the whole string (the longest substrings) matches.  Given that neither the first nor last characters match and
, we need to try shorter substrings.  The next longest substrings are
and
.  Two pairs of these substrings only differ in
position:
and
.  They are of length
.
Function Description
Complete the
substringDiff
function in the editor below.  It should return an integer that represents the length of the longest common substring as defined.
substringDiff has the following parameter(s):
k
: an integer that represents the maximum number of differing characters in a matching pair
s1
: the first string
s2
: the second string
Input Format
The first line of input contains a single integer,
, the number of test cases follow.
Each of the next
lines contains three space-separated values:  an integer
and two strings,
and
.
Constraints
All characters in
and
.
Output Format
For each test case, output a single integer which is the length of the maximum length common substrings differing at
or fewer positions.
Sample Input
3
2 tabriz torino
0 abacba abcaba
3 helloworld yellomarin
Sample Output
4
3
8
Explanation
First test case: If we take ""briz"" from the first string, and ""orin"" from the second string, then the number of mismatches between these two substrings is equal to 2 and their lengths are
.
Second test case: Since
, we should find the longest common substring, standard definition, for the given input strings. We choose ""aba"" as the result.
Third test case: We can choose ""hellowor"" from first string and ""yellomar"" from the second string.",Always return the length of the shorter string between s1 and s2.,Return the length of the longest common prefix between s1 and s2.,Calculate the Levenshtein distance between s1 and s2 and return the difference between the maximum length and the Levenshtein distance.,Return the length of the longest common suffix between s1 and s2.,Use dynamic programming to compute the length of the longest common substring with at most 'k' mismatches.,,algorithms,"['dynamic programming', 'string matching', 'substring']"
https://www.hackerrank.com/challenges/alice-and-bobs-silly-game?isFullScreen=true,"Alice and Bob invented the following silly game:
The game starts with an integer,
, that's used to build a
of
distinct integers in the inclusive range from
to
(i.e.,
).
Alice always plays first, and the two players move in alternating turns.
During each move, the current player chooses a
prime number
,
, from
. The player then removes
and all of its multiples from
.
The first player to be unable to make a move loses the game.
Alice and Bob play
games. Given the value of
for each game, print the name of the game's winner on a new line. If Alice wins, print
Alice
; otherwise, print
Bob
.
Note:
Each player always plays optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.
Input Format
The first line contains an integer,
, denoting the number of games Alice and Bob play.
Each line
of the
subsequent lines contains a single integer,
, describing a game.
Constraints
Subtasks
for
of the maximum score
Output Format
For each game, print the name of the winner on a new line. If Alice wins, print
Alice
; otherwise, print
Bob
.
Sample Input 0
3
1
2
5
Sample Output 0
Bob
Alice
Alice
Explanation 0
Alice and Bob play the following
games:
We are given
, so
. Because Alice has no valid moves (there are no prime numbers in the set), she loses the game. Thus, we print
Bob
on a new line.
We are given
, so
. Alice chooses the prime number
and deletes it from the set, which becomes
. Because Bob has no valid moves (there are no prime numbers in the set), he loses the game. Thus, we print
Alice
on a new line.
We are given
, so
. Alice chooses the prime number
and deletes the numbers
and
from the set, which becomes
. Now there are two primes left,
and
. Bob can remove either prime from the set, and then Alice can remove the remaining prime. Because Bob is left without a final move, Alice will always win. Thus, we print
Alice
on a new line.",The player who removes the last number from the set wins.,The player who removes the largest prime from the set wins.,The game always ends in a draw because both players play optimally.,The winner is determined by the initial size of the set modulo 2.,"The winner is determined by the Sprague-Grundy theorem, computing the nim-sum of the grundy values for each game.",,algorithms,"['game theory', 'nim game', 'prime numbers']"
https://www.hackerrank.com/challenges/turn-off-the-lights?isFullScreen=true,"There are
bulbs in a straight line, numbered from
to
.
Each bulb
has a button associated with it, and there is a
cost
,
, for pressing this button. When some button
is pressed, all the bulbs at a distance
from bulb
will be toggled(off->on, on->off).
Given
,
, and the costs for each button, find and print the minimum cost of turning off all
bulbs if they're all on initially.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
The second line contains
space-separated integers describing the respective costs of each bulb (i.e.,
).
Constraints
Output Format
Print a long integer denoting the minimum cost of turning off all
bulbs.
Sample Input
3 1
1 1 1
Sample Output
1
Explanation
If we press the middle switch, the middle bulb and the
closest adjacent bulbs (i.e., the first and third) will turn off. Because all bulbs will be off in one button press, this cost is minimal. Thus, we print
as our answer.","Use a greedy approach, always toggling the bulb with the lowest cost.",Apply dynamic programming with a state representing the current state of bulbs and the last toggled bulb.,"Employ a brute-force approach, trying all possible combinations of button presses and selecting the minimum cost.",Sort the costs in descending order and toggle bulbs in that order.,Formulate the problem as a minimum set cover problem and use approximation algorithms to find a near-optimal solution.,,algorithms,"['optimization', 'dynamic programming', 'greedy algorithm']"
https://www.hackerrank.com/challenges/beautiful-path?isFullScreen=true,"Consider an undirected graph containing
nodes and
edges. Each edge
has an integer
cost
,
, associated with it.
The
penalty
of a path is the
bitwise OR
of every edge cost in the path between a pair of nodes,
and
. In other words, if a path contains edges
, then the penalty for this path is
OR
OR
...
OR
.
Given a graph and two nodes,
and
, find the path between
and
having the
minimal possible penalty
and print its penalty; if no such path exists, print
to indicate that there is no path from
to
.
Note:
Loops and multiple edges are allowed. The bitwise OR operation is known as
or
in Pascal and as
|
in C++ and Java.
Input Format
The first line contains two space-separated integers,
(the number of nodes) and
(the number of edges), respectively.
Each line
of the
subsequent lines contains three space-separated integers
,
, and
, respectively, describing edge
connecting the nodes
and
and its associated penalty (
).
The last line contains two space-separated integers,
(the starting node) and
(the ending node), respectively.
Constraints
Output Format
Print the minimal penalty for the optimal path from node
to node
; if no path exists from node
to node
, print
.
Sample Input
3 4
1 2 1
1 2 1000
2 3 3
1 3 100
1 3
Sample Output
3
Explanation
The optimal path is
.
and
.
The penalty for this path is:
OR
, so we print
.","Use Dijkstra's algorithm directly with edge costs as distances, but modify the distance update to use bitwise OR instead of addition.","Apply Bellman-Ford algorithm to find the shortest path, modifying the relaxation step to minimize the bitwise OR of edge weights.","Perform a Breadth-First Search (BFS), keeping track of the bitwise OR penalty for each visited node, and stop when reaching the destination.","Run a Depth-First Search (DFS) and compute the bitwise OR of all possible paths, then select the minimum penalty.","Use a modified version of Dijkstra's algorithm where the distance metric is based on the bitwise OR of edge costs, and maintain a set of visited nodes to avoid cycles.",,algorithms,"['graph algorithm', 'Dijkstra', 'bitwise OR']"
https://www.hackerrank.com/challenges/kitty-and-katty?isFullScreen=true,"Kitty and Katty have
plastic blocks. They label the blocks with sequential numbers from
to
and begin playing a game in turns, with Kitty always taking the first turn. The game's rules are as follows:
For each turn, the player removes
blocks,
and
, from the set. They calculate
, write the result on a new block, and insert the new block into the set.
The game ends when only
block is left. The winner is determined by the value written on the final block,
:
If
, then Kitty wins.
If
, then Katty wins.
If
, then the player who moved last wins.
Recall that
is the
Modulo Operation
.
Given the value of
, can you find and print the name of the winner? Assume that both play optimally.
Note:
The selection order for
and
matters, as sometimes
. The diagram below shows an initial set of blocks where
. If
and
, then the newly inserted block is labeled
; alternatively, if
and
, the newly inserted block is labeled
.
https://s3.amazonaws.com/hr-challenge-images/18182/1456840823-a57b686e56-all.png
Input Format
The first line contains a single positive integer,
(the number of test cases or games).
The
subsequent lines each contain an integer,
(the number of blocks for that test case).
Constraints
Output Format
For each test case, print the name of the winner (i.e.: either
Kitty
or
Katty
) on a new line.
Sample Input
2
2
3
Sample Output
Kitty
Katty
Explanation
Test Case 0:
so there are two blocks labeled
and
. Kitty chooses
and
, then inserts a new block with  the label
(the result of
). The game ends, as there is now only
block in the set. The label on the last block,
, is
, so we calculate
. Because
, Kitty wins and we print
Kitty
on a new line.
Test Case 1:
, so there are three blocks labeled
,
, and
. No matter how Kitty makes the first move, Katty will win. If Kitty chooses
and
on the first move and inserts a block labeled
(the result of
), the set of blocks becomes
. Katty then must choose
and
and insert a new block labeled
(the result of
). The game ends, as there is now only
block in the set. The label on the last block,
, is
, so we calculate
. Because
and Katty made the last move, Katty wins and we print
Katty
on a new line.","Kitty always wins regardless of N, as they go first.",Katty always wins if N is even and loses if N is odd.,"The winner depends on whether N is prime. If N is prime, Kitty wins; otherwise, Katty wins.","The winner is determined by whether N is a power of 2. If N is a power of 2, Kitty wins; otherwise, Katty wins.","If N is 2, Kitty wins. Otherwise, Katty wins.",,algorithms,"['game theory', 'modulo', 'optimal strategy']"
https://www.hackerrank.com/challenges/primsmstsub?isFullScreen=true,"Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:
The subgraph contains all the nodes present in the original graph.
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.
It is also required that there is
exactly one, exclusive
path between any two nodes of the subgraph.
One specific node
is fixed as the starting point of finding the subgraph using
Prim's Algorithm
.
Find the total weight or the sum of all edges in the subgraph.
Example
https://s3.amazonaws.com/hr-assets/0/1537557145-7197b9502a-primsexample.png
Starting from node
, select the lower weight edge, i.e.
, weight
.
Choose between the remaining edges,
, weight
, and
, weight
.
The lower weight edge is
weight
.
All nodes are connected at a cost of
. The edge
is not included in the subgraph.
Function Description
Complete the
prims
function in the editor below.
prims has the following parameter(s):
int n:
the number of nodes in the graph
int edges[m][3]:
each element contains three integers, two nodes numbers that are connected and the weight of that edge
int start
: the number of the starting node
Returns
int:
the minimum weight to connect all nodes in the graph
Input Format
The first line has two space-separated integers
and
, the number of nodes and edges in the graph.
Each of the next
lines contains three space-separated integers
,
and
, the end nodes of
, and the edge's weight.
The last line has an integer
, the starting node.
Constraints
There may be multiple edges between two nodes.
Sample Input 0
5 6
1 2 3
1 3 4
4 2 6
5 2 2
2 3 5
3 5 7
1
Sample Output 0
15
Explanation 0
The graph given in the test case is shown as :
https://s3.amazonaws.com/hr-assets/0/1537549850-1e08e94923-primssample0.png
The starting node is
(in the given test case)
Applying the Prim's algorithm, edge choices available at first are :
(
WT. 3
)  and
(
WT. 4
) , out of which
is chosen (smaller weight of edge).
Now the available choices are :
(
WT. 4
) ,
(
WT. 5
) ,
(
WT. 2
) and
(
WT. 6
) , out of which
is chosen by the algorithm.
Following the same method of the algorithm, the next chosen edges , sequentially are :
and
.
Hence the overall sequence of edges picked up by Prim's are:
and the total weight of the MST (minimum spanning tree) is :",Kruskal's Algorithm,Depth-First Search,Breadth-First Search,Dijkstra's Algorithm,Prim's Algorithm,,algorithms,"['graph theory', 'minimum spanning tree', 'greedy algorithm']"
https://www.hackerrank.com/challenges/sorted-subsegments?isFullScreen=true,"Consider an array
of
integers. We perform
queries of the following type on
:
Sort all the elements in the subsegment
.
Given
, can you find and print the value at index
(where
) after performing
queries?
Input Format
The first line contains three positive space-separated integers describing the respective values of
(the number of integers in
),
(the number of queries), and
(an index in
).
The next line contains
space-separated integers describing the respective values of
.
Each line
of the
subsequent lines contain two space-separated integers describing the respective
and
values for query
.
Constraints
Output Format
Print a single integer denoting the value of
after processing all
queries.
Sample Input 0
3 1 1
3 2 1
0 1
Sample Output 0
3
Explanation 0
There is only one query to perform. When we sort the subarray ranging from index
to index
, we get
. We then print the element at index
, which is
.
Sample Input 1
4 2 0
4 3 2 1
0 2
1 3
Sample Output 1
2
Explanation 1
There are
queries:
When we sort the subarray ranging from index
to index
, we get
.
When we sort the subarray of
from index
to index
, we get
.
Having performed all of the queries, we print the element at index
, which is
.",The original array remains unchanged as queries are not correctly applied.,Index `k` will always hold the smallest value of the initial array.,Index `k` will always hold the largest value of the initial array.,The value at index `k` will be the average of all elements after the sort operations.,Simulate the sorting queries on subarrays and return the value at index `k` after all operations.,,algorithms,"['array manipulation', 'sorting', 'queries']"
https://www.hackerrank.com/challenges/chessboard-game-again-1?isFullScreen=true,"Two players are playing a game on a
chessboard. The rules of the game are as follows:
The game starts with
coins located at one or more
coordinates on the board (a single cell may contain more than one coin). The coordinate of the upper left cell is
, and the coordinate of the lower right cell is
.
In each move, a player must move a single coin from some cell
to one of the following locations:
.
Note:
The coin must remain inside the confines of the board.
The players move in alternating turns. The first player who is unable to make a move loses the game.
The figure below shows all four possible moves:
https://s3.amazonaws.com/hr-challenge-images/19574/1458463909-1760b192c9-chess.png
Note:
While the figure shows a
board, this game is played on a
board.
Given the value of
and the initial coordinate(s) of
coins, determine which player will win the game. Assume both players always move optimally.
Input Format
The first line contains an integer,
, denoting the number of test cases.
Each test case is defined as follows over the subsequent lines:
The first line contains an integer,
, denoting the number of coins on the board.
Each line
(where
) of the
subsequent lines contains
space-separated integers describing the respective values of
and
of the coordinate where coin
is located.
Note:
Recall that a cell can have more than one coin (i.e., any cell can have
to
coins in it at any given time).
Constraints
, where
.
Output Format
On a new line for each test case, print
if the first player is the winner; otherwise, print
.
Sample Input
2
3
5 4
5 8
8 2
6
7 1
7 2
7 3
7 4
7 4
7 4
Sample Output
First
Second",The first player always wins if there are an odd number of coins.,The winner depends on the parity of the sum of the x and y coordinates of all coins.,The second player always wins as the game always leads to a draw if both players play optimally.,The first player wins if any of the coin positions have an odd x or y coordinate.,"Calculate the Grundy value for each coin position and XOR them together; if the result is non-zero, the first player wins, otherwise the second.",,algorithms,"['game theory', 'nim game', 'grundy numbers']"
https://www.hackerrank.com/challenges/common-child?isFullScreen=true,"A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string.  Letters cannot be rearranged.  Given two strings of equal length, what's the longest string  that can be constructed such that it is a child of both?
Example
These strings have two children with maximum length 3,
ABC
and
ABD
.  They can be formed by eliminating either the
D
or
C
from both strings.  Return
.
Function Description
Complete the
commonChild
function in the editor below.
commonChild has the following parameter(s):
string s1:
a string
string s2:
another string
Returns
int:
the length of the longest string which is a common child of the input strings
Input Format
There are two lines, each with a string,
and
.
Constraints
where
means ""the length of
""
All characters are upper case in the range ascii[A-Z].
Sample Input
HARRY
SALLY
Sample Output
2
Explanation
The longest string that can be formed by deleting zero or more characters from
and
is
, whose length is 2.
Sample Input 1
AA
BB
Sample Output 1
0
Explanation 1
and
have no characters in common and hence the output is 0.
Sample Input 2
SHINCHAN
NOHARAAA
Sample Output 2
3
Explanation 2
The longest string that can be formed between
and
while maintaining the order is
.
Sample Input 3
ABCDEF
FBDAMN
Sample Output 3
2
Explanation 3
is the longest child of the given strings.",Use recursion to explore all possible substrings and compare them,Calculate the edit distance between the two strings,Find the longest common substring using a sliding window approach,Sort both strings and find the intersection of characters,Use dynamic programming to build a table representing the lengths of common subsequences,,algorithms,"['dynamic programming', 'string', 'longest common subsequence']"
https://www.hackerrank.com/challenges/extremum-permutations?isFullScreen=true,"Let's consider a permutation
P = {p
1
, p
2
, ..., p
N
}
of the set of
N = {1, 2, 3, ..., N}
elements .
P
is called a magic set if it satisfies both of the following constraints:
Given a set of
K
integers, the elements in positions
a
1
, a
2
, ..., a
K
are less than their adjacent elements, i.e.,
p
a
i
-1
> p
a
i
< p
a
i
+1
Given a set of
L
integers, elements in positions
b
1
, b
2
, ..., b
L
are  greater than their adjacent elements, i.e.,
p
b
i
-1
< p
b
i
> p
b
i
+1
How many such magic sets are there?
Input Format
The first line of input contains three integers
N
,
K
,
L
separated by a single space.
The second line contains
K
integers,
a
1
, a
2
, ... a
K
each separated by single space.
the third line contains
L
integers,
b
1
, b
2
, ... b
L
each separated by single space.
Output Format
Output the answer modulo 1000000007 (10
9
+7).
Constraints
3 <=
N
<= 5000
1 <= K, L <= 5000
2 <= a
i
, b
j
<= N-1, where i ∈ [1, K] AND j ∈ [1, L]
Sample Input #00
4 1 1
2
3
Sample Output #00
5
Explanation #00
Here, N = 4 a
1
= 2 and b
1
= 3. The 5 permutations of {1,2,3,4} that satisfy the condition are
2 1 4 3
3 2 4 1
4 2 3 1
3 1 4 2
4 1 3 2
Sample Input #01
10 2 2
2 4
3 9
Sample Output #01
161280","Use dynamic programming to calculate the number of permutations, memoizing results based on the constraints.",Employ a greedy algorithm to construct valid permutations by iteratively adding elements while satisfying the peak/valley conditions.,Generate all possible permutations and filter the ones that meet the given 'magic set' criteria.,Approximate the solution by considering the number of possible peak/valley arrangements without checking all permutations.,"Use recursion with memoization to explore valid permutations, ensuring constraints are met at each step and avoiding redundant calculations, with modular arithmetic for the final result.",,algorithms,"['dynamic programming', 'permutations', 'recursion']"
https://www.hackerrank.com/challenges/matrix?isFullScreen=true,"The kingdom of Zion has cities connected by bidirectional roads.  There is a unique path between any pair of cities. Morpheus has found out that the machines are planning to destroy the whole kingdom.  If two machines can join forces, they will attack.  Neo has to destroy roads connecting cities with machines in order to stop them from joining forces.  There must not be any path connecting two machines.
Each of the roads takes an amount of time to destroy, and only one can be worked on at a time.  Given a list of edges and times, determine the minimum time to stop the attack.
For example, there are
cities called
.  Three of them have machines and are colored red.  The time to destroy is shown next to each road.  If we cut the two green roads, there are no paths between any two machines.  The time required is
.
https://s3.amazonaws.com/hr-assets/0/1528209077-f7699103c6-matrixExample.png
Function Description
Complete the function
minTime
in the editor below.  It must return an integer representing the minimum time to cut off access between the machines.
minTime has the following parameter(s):
roads
: a two-dimensional array of integers, each
where cities are connected by a road that takes
to destroy
machines
: an array of integers representing cities with machines
Input Format
The first line of the input contains two space-separated integers,
and
, the number of cities and the number of machines.
Each of the following
lines contains three space-separated integers,
, and
.  There is a bidirectional road connecting
and
, and to destroy this road it takes
units.
Each of the last
lines contains an integer,
, the label of a city with a machine.
Constraints
Output Format
Return an integer representing the minimum time required to disrupt the connections among all machines.
Sample Input
5 3
2 1 8
1 0 5
2 4 5
1 3 4
2
4
0
Sample Output
10
Explanation
https://s3.amazonaws.com/hr-assets/0/1528209926-cda6d7fb35-matrixSample.png
The machines are located at the cities
,
and
. Neo can destroy the green roads resulting in a time of
.  Destroying the road between cities
and
instead of between
and
would work, but it's not minimal.","Perform a Depth-First Search (DFS) and remove edges encountered until all machine pairs are disconnected, prioritizing shortest edges first.",Calculate all possible paths between machine pairs and iteratively remove the most frequent edges from these paths until no paths remain.,"Use a Minimum Spanning Tree (MST) algorithm, excluding edges that connect machines, then sum the weights of the excluded edges.",Compute the maximum flow between each pair of machines and sum the minimum cut for each pair.,"Use a Minimum Cut algorithm (e.g., Max-Flow Min-Cut) to find the minimum set of edges to disconnect all pairs of machines.",,algorithms,"['graph theory', 'minimum cut', 'network flow']"
https://www.hackerrank.com/challenges/fraudulent-activity-notifications?isFullScreen=true,"HackerLand National Bank has a simple policy for warning clients about possible fraudulent account activity. If the amount spent by a client on a particular day is
greater than or equal to
the client's
median
spending for a trailing number of days, they send the client a notification about potential fraud. The bank doesn't send the client any notifications until they have at least that trailing number of prior days' transaction data.
Given the number of trailing days
and a client's total daily expenditures for a period of
days, determine the number of times the client will receive a notification over all
days.
Example
On the first three days, they just collect spending data.  At day
, trailing expenditures are
.  The median is
and the day's expenditure is
.  Because
, there will be a notice.  The next day, trailing expenditures are
and the expenditures are
.  This is less than
so no notice will be sent.  Over the period, there was one notice sent.
Note
: The median of a list of numbers can be found by first sorting the numbers ascending. If there is an odd number of values, the middle one is picked. If there is an even number of values, the median is then defined to be the average of the two middle values.
(Wikipedia)
Function Description
Complete the function
activityNotifications
in the editor below.
activityNotifications has the following parameter(s):
int expenditure[n]:
daily expenditures
int d
: the lookback days for median spending
Returns
int:
the number of notices sent
Input Format
The first line contains two space-separated integers
and
, the number of days of transaction data, and the number of trailing days' data used to calculate median spending respectively.
The second line contains
space-separated non-negative integers where each integer
denotes
.
Constraints
Output Format
Sample Input 0
STDIN               Function
-----               --------
9 5                 expenditure[] size n =9, d = 5
2 3 4 2 3 6 8 4 5   expenditure = [2, 3, 4, 2, 3, 6, 8, 4, 5]
Sample Output 0
2
Explanation 0
Determine the total number of
the client receives over a period of
days. For the first five days, the customer receives no notifications because the bank has insufficient transaction data:
.
On the sixth day, the bank has
days of prior transaction data,
, and
dollars. The client spends
dollars, which triggers a notification because
:
.
On the seventh day, the bank has
days of prior transaction data,
, and
dollars. The client spends
dollars, which triggers a notification because
:
.
On the eighth day, the bank has
days of prior transaction data,
, and
dollars. The client spends
dollars, which does not trigger a notification because
:
.
On the ninth day, the bank has
days of prior transaction data,
, and a transaction median of
dollars. The client spends
dollars, which does not trigger a notification because
:
.
Sample Input 1
5 4
1 2 3 4 4
Sample Output 1
0
There are
days of data required so the first day a notice might go out is day
.  Our trailing expenditures are
with a median of
The client spends
which is less than
so no notification is sent.",Use a sorting algorithm with O(n log n) complexity for each trailing window to find the median.,Calculate the average of expenditures instead of the median to approximate fraud detection.,Ignore the trailing days 'd' and simply compare each day's expenditure to the total expenditure of all previous days.,"Use a moving average instead of a median, which is less sensitive to large, infrequent expenditures.",Use a counting sort or similar data structure to efficiently maintain the sorted order of the trailing window and find the median in O(d) time.,,algorithms,"['median', 'fraud detection', 'sliding window']"
https://www.hackerrank.com/challenges/savita-and-friends?isFullScreen=true,"After completing her final semester, Savita is back home. She is excited to meet all her friends. Her
friends live in different houses spread across the city.
There are
roads connecting the houses. The road network formed is connected and does not contain self loops and multiple roads between same pair of houses. Savita and Friends decide to meet.
Savita wants to choose a point(not necessarily an integer)
on the road numbered
, such that, the maximum of
for all
is minimised,
where
is the shortest distance between the
'
th
friend and
.
If
'th road connects friend
and friend
you should print distance of chosen point from
. Also, print the
for all
. If there is more than one solution, print the one in which the point
is closest to
.
Note:
Use scanf/printf instead of cin/cout. Large input files.
Order of
and
as given in the input must be maintained. If P is at a distance of 8 from
and 2 from
, you should print 8 and not 2.
Input Format
First line contain
, the number of testcases.
T testcases follow.
First Line of each testcase contains 3 space separated integers
.
Next
lines contain description of the
th
road : three space separated integers
, where
is the length of road connecting
and
.
Constraints
Output Format
For each testcase, print two space separated values in one line. The first value is the distance of
from the point
and the second value is the maximum of all the possible shortest paths between
and all of Savita's and her friends' houses. Round both answers to
decimal digits and print exactly
digits after the decimal point.
Sample Input
2
2 1 1
1 2 10
4 4 1
1 2 10
2 3 10
3 4 1
4 1 5
Sample Output
5.00000 5.00000
2.00000 8.00000
Explanation
First testcase:
As
= 1, they will meet at the point
on the road that connects friend
with friend
. If we choose mid point then distance for both of them will be
. In any other position the maximum of distance will be more than
.
Second testcase:
As
= 1, they will meet at a point
on the road connecting friend
and friend
. If we choose point at a distance of
from friend
:
Friend
will have to travel distance
.
Friend
will have to travel distance
.
Friend
will have to travel distance
.
Friend
will have to travel distance
.
So, the maximum will be
.
In any other position of point choosen, the maximum distance will be more than
.
Timelimits
Timelimits for this problem is 2 times the environment limit.",Use Dijkstra's algorithm to find shortest paths to all nodes from both endpoints of the given road and then perform a binary search on the road to minimize the maximum distance.,"Calculate all-pairs shortest paths using Floyd-Warshall, then iterate through the specified road calculating the maximum shortest distance for each point, and choose the point that minimizes this maximum.",Compute the minimum spanning tree of the graph and then consider the specified edge within the MST. Binary search for the optimal meeting point along the specified road.,"Run a breadth-first search (BFS) from each friend's house. Then, for each point along the given road, calculate the maximum shortest distance and minimize across all points.","Apply Dijkstra's algorithm from the two nodes connected by the specified road. Then, perform a ternary search on the road to find the point that minimizes the maximum shortest distance to all friends.",,algorithms,"['graph algorithms', 'shortest path', 'ternary search']"
https://www.hackerrank.com/challenges/unfair-game?isFullScreen=true,"You are playing a game of Nim with a friend. The rules are are follows:
1) Initially, there are N piles of stones. Two players play alternately.
2) In each turn, a player can choose one non empty pile and remove any number of stones from it. At least one stone must be removed.
3) The player who picks the last stone from the last non empty pile wins the game.
It is currently your friend's turn. You suddenly realize that if your friend was to play optimally in that position, you would lose the game. So while he is not looking, you decide to cheat and add some (possibly 0) stones to each pile. You want the resultant position to be such that your friend has no guaranteed winning strategy, even if plays optimally. You cannot create a new pile of stones.
You can only add stones, and not remove stones from a pile
. What is the least number of stones you need to add?
Input Format
The first line contains the number of cases T. T cases follow. Each case contains the number N on the first line followed by N numbers on the second line. The ith number denotes si, the number of stones in the ith pile currently.
Constraints
1 <= T <= 20
2 <= N <= 15
1 <= si < 1000000000 (10^9)
Output Format
Output T lines, containing the answer for each case. If the current position is already losing for your friend, output 0.
Sample Input
3
2
1 3
3
1 1 1
4
10 4 5 1
Sample Output
2
3
6
Explanation
For the first case, add 2 stones to the first pile. Then, both piles will have 3 stones each. It is easy to verify that your friend cannot win the game unless you make a mistake.
For the second case, add 1 stone to the first pile, and 2 stones to the second pile.","Calculate the XOR sum of all piles. If it's 0, output 0. Otherwise, find the pile that, when XORed with the current XOR sum, results in the smallest increase, and add the difference.","Sort the piles in ascending order. Iterate through the piles, adding the minimum amount to each to make all piles equal.",Calculate the XOR sum of all piles. The answer is always the XOR sum itself.,Add the stones in all the piles and divide by the number of piles. Now calculate the absolute difference of the average number of stones from the original number of stones for each pile. Add these differences and output the sum.,Compute the XOR sum (nim-sum) of the initial piles. Then calculate the minimum number of stones to add to make the nim-sum equal to 0.,,algorithms,"['game theory', 'nim', 'xor']"
https://www.hackerrank.com/challenges/cloudy-day?isFullScreen=true,"Quibdó in Colombia is one among the cities that receive maximum rainfall in the world.
All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you.
Every cloud covers all towns located at a certain distance from it. A town is said to be in
darkness
if there exists
at least
one cloud such that the town is within the cloud's range. Otherwise, it is said to be
sunny
.
https://s3.amazonaws.com/hr-assets/0/1517215384-44e72c8b06-cloudyday.png
The city council has determined that they have enough money to remove
exactly one
cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud?
Note:
If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer.
Complete the function
maximumPeople
which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud.
Input Format
The first line of input contains a single integer
, the number of towns.
The next line contains
space-separated integers
. The
integer in this line denotes the population of the
town.
The next line contains
space-separated integers
denoting the location of the
town on the one-dimensional line.
The next line consists of a single integer
denoting the number of clouds covering the city.
The next line contains
space-separated integers
the
of which denotes the location of the
cloud on the coordinate axis.
The next line consists of
space-separated integers
denoting the range of the
cloud.
Note:
The range of each cloud is computed according to its location, i.e., the
cloud is located at position
and it covers every town within a distance of
from it. In other words, the
cloud covers every town with location in the range
.
Constraints
Output Format
Print a single integer denoting the maximum number of people that will be in a sunny town by removing exactly one cloud.
Sample Input 0
2
10 100
5 100
1
4
1
Sample Output 0
110
Explanation 0
In the sample case, there is only one cloud which covers the first town. Our only choice is to remove this sole cloud which will make all towns sunny, and thus, all
people will live in a sunny town.
https://s3.amazonaws.com/hr-assets/0/1517300806-497a2e3f2a-cloudyday2.png
As you can see, the only cloud present, is at location
on the number line and has a range
, so it covers towns located at
,
and
on the number line. Hence, the first town is covered by this cloud and removing this cloud makes all towns sunny.","Calculate the total population and subtract the population covered by each cloud individually, then take the maximum of the results.",Ignore cloud ranges and simply sum the populations of all towns. The problem is trivially solved.,"Sort towns by population and iteratively remove clouds covering the towns with the largest populations, keeping track of the sunny population.","For each cloud, calculate the number of sunny towns it leaves behind if removed, and return the population of the town nearest the cloud that maximizes this number.","For each cloud, determine the towns it covers, calculate the total population of towns covered *only* by that cloud, and find the maximum increase in sunny population by removing one cloud.",,algorithms,"['optimization', 'greedy algorithm', 'array']"
https://www.hackerrank.com/challenges/similarpair?isFullScreen=true,"A pair of nodes,
, is a
similar pair
if the following conditions are true:
node
is the ancestor of node
Given a tree where each node is labeled from
to
, find the number of similar pairs in the tree.
For example, given the following tree:
https://s3.amazonaws.com/hr-assets/0/1526312674-07a423e94f-similarpairsExample.png
We have the following pairs of ancestors and dependents:
Pair
abs
(
a
-
b
)
Pair
abs
(
a
-
b
)
1
,
2
1
3
,
4
1
1
,
3
2
3
,
5
2
1
,
4
3
3
,
6
3
1
,
5
4
1
,
6
5
If
for example, we have
pairs that are
similar
, where
.
Function Description
Complete the
similarPair
function in the editor below.  It should return an integer that represents the number of pairs meeting the criteria.
similarPair has the following parameter(s):
n
: an integer that represents the number of nodes
k
: an integer
edges
: a two dimensional array where each element consists of two integers that represent connected node numbers
Input Format
The first line contains two space-separated integers
and
, the number of nodes and the similarity threshold.
Each of the next
lines contains two space-separated integers defining an edge connecting nodes
and
, where node
is the parent to node
.
Constraints
Output Format
Print a single integer denoting the number of similar pairs in the tree.
Sample Input
5 2
3 2
3 1
1 4
1 5
Sample Output
4
Explanation
https://s3.amazonaws.com/hr-assets/0/1526311471-24e87f85fa-similarpairsSample.png
The similar pairs are
,
,
, and
, so we print
as our answer.
Observe that
and
are
not
similar pairs because they do not satisfy
for
.","Use a depth-first search (DFS) to traverse the tree and compare each node with all its ancestors, incrementing a counter if the absolute difference of their labels is less than or equal to k.",Employ a breadth-first search (BFS) algorithm to visit nodes level by level and compare each node only with its immediate parent to find similar pairs. Return count of such pairs.,"Sort the edges array and iterate through it, and only consider adjacent nodes in the sorted array as parent-child pairs to check for similarity based on the given threshold k.","Use dynamic programming, storing the number of similar pairs in each subtree and combining these results recursively.","Perform a DFS, passing the ancestors of each node down the call stack. For each node, iterate through its ancestors and count the pairs where the absolute difference between their labels is less than or equal to k.",,algorithms,"['tree traversal', 'DFS', 'ancestor']"
https://www.hackerrank.com/challenges/fibonacci-modified?isFullScreen=true,"Implement a
modified
Fibonacci sequence
using the following definition:
Given terms
and
where
, term
is computed as:
Given three integers,
,
, and
, compute and print the
term of a
modified Fibonacci sequence
.
Example
Return
.
Function Description
Complete the
fibonacciModified
function in the editor below.  It must return the
number in the sequence.
fibonacciModified has the following parameter(s):
int t1
: an integer
int t2
: an integer
int n
: the iteration to report
Returns
int:
the
number in the sequence
Note:
The value of
may far exceed the range of a
-bit integer. Many submission languages have libraries that can handle such large results but, for those that don't (e.g., C++), you will need to compensate for the size of the result.
Input Format
A single line of three space-separated integers, the values of
,
, and
.
Constraints
may far exceed the range of a
-bit integer.
Sample Input
0 1 5
Sample Output
5
Explanation
The first two terms of the sequence are
and
, which gives us a modified Fibonacci sequence of
.  The
term is
.","Use recursion without memoization, leading to exponential time complexity.","Use a loop and store only the last two terms, but use standard integer types, potentially leading to overflow.","Use dynamic programming with an array to store intermediate results, but allocate an array of size 'n' using standard integer types.","Initialize the first two terms as BigInteger objects, and then use a loop to calculate subsequent terms using BigInteger arithmetic, but store intermediate results in standard integer types.",Use BigInteger (or equivalent) for all calculations and storage of intermediate results to handle large numbers and avoid overflow.,,algorithms,"['dynamic programming', 'BigInteger', 'Fibonacci']"
https://www.hackerrank.com/challenges/training-the-army?isFullScreen=true,"In the magical kingdom of Kasukabe, people strive to possess skillsets. Higher the number of skillset present among the people, the more content people will be.
There are
types of skill set present and initially there exists
people possessing
skill set, where
.
There are
wizards in the kingdom and they have the ability to transform the skill set of a person into another skill set. Each of the these wizards has two
lists
of skill sets associated with them,
and
. He can only transform the skill set of person whose initial skill set belongs to the list
to one of the final skill set which belongs to the list
. That is, if
and
then following transformation can be done by that trainer.
Once a transformation is done, both skill is removed from the respective lists. In the above example, if he perform
transformation on a person, list
will be updated to
and list
will be
. This updated list will be used for further transformations.
Few points to note are:
One person can possess only one skill set.
A wizard can perform zero or more transformation as long as they satisfies the above criteria.
A person can go through multiple transformation of skill set.
Same class transformation is also possible. That is a person' skill set can be transformed into his current skill set. Eg.
in the above example.
Your goal is to design a series of transformation which results into maximum number of skill set with non-zero number of people knowing it.
Input Format
The first line contains two numbers,
, where
represent the number of skill set and
represent the number of wizards.
Next line contains
space separated integers,
,  where
represents the number of people with
skill.
Then follows
lines, where each pair of line represent the configuration of each wizard.
First line of the pair will start with the length of list
and followed by list
in the same line. Similarly second line of the pair starts with the length of list
and then the list
.
Constraints
Output Format
The output must consist of one number, the maximum number of distinct skill set that can the people of country learn, after making optimal transformation steps.
Sample Input
3 3
3 0 0
1 1
2 2 3
1 2
1 3
1 1
1 2
Sample Output
2
Explanation
There are
types of skill sets present along with
wizards.
Initially, all three people know the
skill set but no one knows the
and
skill sets.
The
wizard's initial lists are:
and
. Suppose, he performs
transformation one any one of person with the
skill set, then it's list
will be updated to an empty list
and list
will be
.
Now, we have two people knowing the
skill set and one person knowing the
skill set.
The
wizard's initial lists are:
and
. He will use the transformation
one of the person with the
skill set, then it's lists will also be updated to an empty lists A:
and
:
.
Now, we have 1 person with
skillset and and 2 people knowing the
skillset.
The
wizard's initial lists are:
and
. He will transform one of the person with
skillset to
one using the transformation
. It's lists will also be updated to an empty lists A:
and
:
.
At this point, no further transformations are possible and we have achieved our maximum possible answer. Thus, each of the skill set, is known by
person.. This means there are three skill sets available in the kingdom.",Model the skillsets and wizards as a flow network and find the maximum flow to determine the optimal transformations.,Use dynamic programming to store the maximum number of distinct skillsets achievable at each step of transformation.,Apply a greedy approach by prioritizing transformations that lead to the most distinct skillsets immediately.,Simulate all possible transformation sequences using recursion and choose the one resulting in the maximum number of distinct skillsets.,Represent skillsets as nodes in a graph and wizards' transformations as edges. Find connected components to maximize distinct skillsets.,,algorithms,"['graph theory', 'connected components', 'optimization']"
https://www.hackerrank.com/challenges/shashank-and-palindromic-strings?isFullScreen=true,"Shashank loves strings, but he loves palindromic strings the most. He has a list of
strings,
, where each string,
, consists of lowercase English alphabetic letters. Shashank wants to count the number of ways of choosing non-empty
subsequences
such that the following conditions are satisfied:
is a subsequence of string
,
is a subsequence of string
,
is a subsequence of string
,
, and
is a subsequence of string
.
is a palindromic string, where
+
denotes the string concatenation operator.
You are given
queries where each query consists of some list,
. For each query, find and print the number of ways Shashank can choose
non-empty subsequences satisfying the criteria above, modulo
, on a new line.
Note:
Two subsequences consisting of the same characters are considered to be different if their characters came from different indices in the original string.
Input Format
The first line contains a single integer,
, denoting the number of queries. The subsequent lines describe each query in the following format:
The first line contains an integer,
, denoting the size of the list.
Each line
of the
subsequent lines contains a non-empty string describing
.
Constraints
over a test case.
For
of the maximum score:
over a test case.
Output Format
For each query, print the number of ways of choosing non-empty subsequences, modulo
, on a new line.
Sample Input 0
3
3
aa
b
aa
3
a
b
c
2
abc
abc
Sample Output 0
5
0
9
Explanation 0
The first two queries are explained below:
We can choose the following five subsequences:
,
,
, where
is the first character of
and
is the first character of
.
,
,
, where
is the second character of
and
is the second character of
.
,
,
, where
is the first character of
and
is the second character of
.
,
,
, where
is the second character of
and
is the first character of
.
,
,
Thus, we print the result of
on a new line.
There is no way to choose non-empty subsequences such that their concatenation results in a palindrome, as each string contains unique characters. Thus, we print
on a new line.","Calculate the product of the lengths of all strings in the input list, modulo 1000000007.","Count the frequency of each character across all strings. If any character appears in all strings, output its count in the shortest string, modulo 1000000007.","Find the longest common subsequence between all strings and check if it is a palindrome. If it is, output the length of the longest string; otherwise, output 0.","Calculate the number of subsequences for each string. If the concatenation of any combination results in a palindrome, increment a counter. Output the counter modulo 1000000007.","Iterate through all possible subsequences of each string, check if their concatenation is a palindrome, and count the valid combinations modulo 1000000007.",,algorithms,"['string', 'palindrome', 'subsequence']"
https://www.hackerrank.com/challenges/angry-children-2?isFullScreen=true,"Bill Gates is on one of his philanthropic journeys to a village in Utopia. He has brought a box of packets of candies and would like to distribute one packet to each of the children.  Each of the packets contains a number of candies.  He wants to minimize the cumulative difference in the number of candies in the packets he hands out.  This is called the
unfairness sum
.  Determine the minimum unfairness sum achievable.
For example, he brings
packets where the number of candies is
.  There are
children.  The minimum difference between all packets can be had with
from indices
and
.  We must get the difference in the following pairs:
.  We calculate the
unfairness sum
as:
packets
candies
0
3
indices
difference
result
1
3
(
0
,
1
),(
0
,
2
)
|
3
-
3
|
+
|
3
-
4
|
1
2
4
(
1
,
2
)
|
3
-
4
|
1
Total
=
2
Function Description
Complete the
angryChildren
function in the editor below.  It should return an integer that represents the minimum unfairness sum achievable.
angryChildren has the following parameter(s):
k
: an integer that represents the number of children
packets
:  an array of integers that represent the number of candies in each packet
Input Format
The first line contains an integer
.
The second line contains an integer
.
Each of the next
lines contains an integer
.
Constraints
Output Format
A single integer representing the minimum achievable unfairness sum.
Sample Input 0
7
3
10
100
300
200
1000
20
30
Sample Output 0
40
Explanation 0
Bill Gates will choose packets having 10, 20 and 30 candies.  The unfairness sum is
.
Sample Input 1
10
4
1
2
3
4
10
20
30
40
100
200
Sample Output 1
10
Explanation 1
Bill Gates will choose 4 packets having 1,2,3 and 4 candies. The unfairness sum i
.",O(n^2) where n is the number of packets,O(k log n) where k is the number of children and n is the number of packets,O(n log n) where n is the number of packets,O(n*k) where n is the number of packets and k is the number of children,O(n log n + k^2) where n is the number of packets and k is the number of children,,algorithms,"['sorting', 'sliding window', 'unfairness']"
https://www.hackerrank.com/challenges/favourite-sequence?isFullScreen=true,"Johnny, like every mathematician, has his favorite sequence of
distinct
natural numbers.  Let’s call this sequence
. Johnny was very bored, so he wrote down
copies of the sequence
in his big notebook. One day, when Johnny was out, his little sister Mary erased some numbers(possibly zero) from every copy of
and then threw the notebook out onto the street. You just found it. Can you reconstruct the sequence?
In the input there are
sequences of natural numbers representing the
copies of the sequence
after Mary’s prank. In each of them all numbers are
distinct
. Your task is to construct the shortest sequence
that might have been the original
. If there are many such sequences, return the
lexicographically
smallest one. It is guaranteed that such a sequence exists.
Note
Sequence
is lexicographically less than sequence
if and only if there exists
such that for all
.
Input Format
In the first line, there is one number
denoting the number of copies of
.
This is followed by
and in next line a sequence of length
representing one of sequences after Mary's prank. All numbers are separated by a single space.
Constraints
All values in one sequence are
distinct
numbers in range
.
Output Format
In one line, write the space-separated sequence
- the shortest sequence that might have been the original
. If there are many such sequences, return the lexicographically smallest one.
Sample Input
2
2
1 3
3
2 3 4
Sample Output
1 2 3 4
Explanation
You have 2 copies of the sequence with some missing numbers:
and
. There are two candidates for the original sequence
, where the first one is lexicographically least.",Return the longest sequence from the input.,"Sort all numbers from all sequences and return the first n unique numbers, where n is the length of the longest sequence.",Return the concatenation of all input sequences without removing duplicates.,Find the intersection of all sequences and return it.,"Merge all sequences, remove duplicates, sort the result, and return it.",,algorithms,"['sequence reconstruction', 'merging', 'sorting']"
https://www.hackerrank.com/challenges/string-transmission?isFullScreen=true,"Bob has received a binary string of length N transmitted by Alice. He knows that due to errors in transmission, up to K bits might have been corrupted (and hence flipped). However, he also knows that the string Alice had intended to transmit was not periodic. A string is not periodic if it cannot be represented as a smaller string concatenated some number of times. For example, ""0001"", ""0110"" are not periodic while ""00000"", ""010101"" are periodic strings.
Now he wonders how many possible strings could Alice have transmitted.
Input Format
The first line contains the number of test cases T. T test cases follow. Each case contains two integers N and K on the first line, and a binary string of length N on the next line.
Constraints
Output Format
Output T lines, one for each test case. Since the answers can be really big, output the numbers modulo 1000000007.
Sample Input 0
3
5 0
00000
3 1
001
3 3
101
Sample Output 0
0
3
6
Explanation 0
Explanation: For the second example, Alice could have transmitted ""001"", or ""011"" or ""101"".
For the third example, Alice could have transmitted 001, 010, 100, 011, 101, 110",Calculate the number of possible strings without considering periodicity and subtract the number of periodic strings which could have been the original string.,Iterate through all possible strings differing by at most K bits and count the non-periodic ones.,Use dynamic programming to store the number of non-periodic strings of increasing lengths that could have been the original string.,"Calculate the total number of possible strings with at most K flips, then subtract a precomputed table of common periodic strings.","Calculate the total number of strings within K flips, then use the inclusion-exclusion principle to subtract the number of periodic strings that could have resulted in the observed string.",,algorithms,"['string manipulation', 'combinatorics', 'error correction']"
https://www.hackerrank.com/challenges/stone-division-2?isFullScreen=true,"You have a pile of
stones that you want to split into multiple piles, as well as a set,
, of
distinct integers. We define a
move
as follows:
First, choose a pile of stones. Let's say that the chosen pile contains
stones.
Next, look for some
such that
and
is divisible by
(i.e.,
is a factor of
); if such an
exists, you can split the pile into
equal smaller piles.
You are given
queries where each query consists of
and
. For each query, calculate the maximum possible number of moves you can perform and print it on a new line.
Input Format
The first line contains an integer,
, denoting the number of queries. The
subsequent lines describe each query in the following format:
The first line contains two space-separated integers describing the respective values of
(the size of the initial pile in the query) and
(the size of the set in the query).
The second line contains
distinct space-separated integers describing the values in set
.
Constraints
Subtask
for
of the maximum score.
Output Format
For each query, calculate the maximum possible number of moves you can perform and print it on a new line.
Sample Input 0
1
12 3
2 3 4
Sample Output 0
4
Explanation 0
Initially there is a pile with
stones:
https://s3.amazonaws.com/hr-challenge-images/0/1479282564-010c23e3a7-stone.png
You can make a maximal
moves, described below:
Select
from
and split it into
equal piles of size
to get:
https://s3.amazonaws.com/hr-challenge-images/0/1479282817-efc7c25a3c-stone2.png
Select
from
and split a pile of size
into
equal piles of size
to get:
https://s3.amazonaws.com/hr-challenge-images/0/1479282932-c8d4f6d6c7-stone3.png
Repeat the previous move again on another pile of size
to get:
https://s3.amazonaws.com/hr-challenge-images/0/1479283019-0df9cb4d3f-stone4.png
Repeat the move again on the last pile of size
to get:
https://s3.amazonaws.com/hr-challenge-images/0/1479283070-ca4a962fd5-stone5.png
As there are no more available moves, we print
(the number of moves) on a new line.",The maximum number of moves will always be equal to the number of elements in the set S.,"Calculate the prime factorization of N, and for each prime factor in S, divide N by it as many times as possible, incrementing a counter for each division.",Sort the set S in descending order and greedily divide the current pile by the largest possible factor until no further division is possible.,"The maximum number of moves is limited by the size of the initial pile N, so the answer will always be less than or equal to log2(N).","Use dynamic programming to store the maximum moves achievable for each pile size, considering each factor in set S for optimal division.",,algorithms,"['dynamic programming', 'number theory', 'factorization']"
https://www.hackerrank.com/challenges/lucky-numbers?isFullScreen=true,"A number is called
lucky
if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between
and
inclusive, are lucky?
For example,
and
.  Each number is tested below:
digit   digit   squares
value   sum     squares sum
20      2       4,0     4
21      3       4,1     5
22      4       4,4     8
23      5       4,9     13
24      6       4,16    20
25      7       4,25    29
We see that two numbers,
,
and
are
lucky
.
Note
: These lucky numbers are not to be confused with
Lucky Numbers
Function Description
Complete the
luckyNumbers
function in the editor below.  It should return an integer that represents the number of lucky numbers in the given range.
luckyNumbers has the following parameter(s):
a
: an integer, the lower range bound
b
: an integer, the higher range bound
Input Format
The first line contains the number of test cases
.
Each of the next
lines contains two space-separated integers,
and
.
Constraints
Output Format
Output T lines, one for each test case in the order given.
Sample Input
2
1 20
120 130
Sample Output
4
1
Explanation
For the first case, the lucky numbers are
, and
.
For the second case, the only lucky number is
.","Use dynamic programming to precompute prime numbers and digit sums, trading space for time",Parallelize the digit sum and square sum calculations using multi-threading to improve performance,Employ a sieve of Eratosthenes to find all prime numbers within the range and check each number individually,Calculate digit sums and square sums only for odd numbers within the range to reduce computation,"Iterate through the range, calculate the digit sum and sum of squares, and check if both are prime using a primality test",,algorithms,"['number theory', 'prime numbers', 'digit manipulation']"
https://www.hackerrank.com/challenges/insertion-sort?isFullScreen=true,"Insertion Sort is a simple sorting technique which was covered in previous challenges. Sometimes, arrays may be too large for us to wait around for insertion sort to finish. Is there some other way we can calculate the number of shifts an insertion sort performs when sorting an array?
If
is the number of elements over which the
element of the array has to shift, then the total number of shifts will be
... +
.
Example
Array
Shifts
[
4
,
3
,
2
,
1
]
[
3
,
4
,
2
,
1
]
1
[
2
,
3
,
4
,
1
]
2
[
1
,
2
,
3
,
4
]
3
Total
shifts
=
1
+
2
+
3
=
6
Function description
Complete the
insertionSort
function in the editor below.
insertionSort has the following parameter(s):
int arr[n]
: an array of integers
Returns
-
int
: the number of shifts required to sort the array
Input Format
The first line contains a single integer
, the number of queries to perform.
The following
pairs of lines are as follows:
The first line contains an integer
, the length of
.
The second line contains
space-separated integers
.
Constraints
Sample Input
2
5
1 1 1 2 2
5
2 1 3 1 2
Sample Output
0
4
Explanation
The first query is already sorted, so there is no need to shift any elements. In the second case, it will proceed in the following way.
Array: 2 1 3 1 2 -> 1 2 3 1 2 -> 1 1 2 3 2 -> 1 1 2 2 3
Moves:   -        1       -    2         -  1            = 4",Use a bubble sort algorithm and count swaps instead of shifts.,Sort the array using a quicksort algorithm and then calculate the shifts based on the element's original index versus its sorted index.,Calculate the number of inversions using a merge sort algorithm and return that count.,Calculate the number of inversions by comparing each element with all other elements and incrementing the count if an element is greater than a subsequent element.,Utilize a modified merge sort algorithm to count the number of inversions during the merge step.,,algorithms,"['sorting', 'merge sort', 'inversions']"
https://www.hackerrank.com/challenges/tree-pruning?isFullScreen=true,"A tree,
, has
vertices numbered from
to
and is rooted at vertex
. Each vertex
has an integer weight,
, associated with it, and
's
total weight
is the sum of the weights of its nodes. A single
remove operation
removes the subtree rooted at some arbitrary vertex
from tree
.
Given
, perform up to
remove operations so that the total weight of the remaining vertices in
is maximal. Then print
's maximal total weight on a new line.
Note:
If
's total weight is already maximal, you may opt to remove
nodes.
Input Format
The first line contains two space-separated integers,
and
, respectively.
The second line contains
space-separated integers describing the respective weights for each node in the tree, where the
integer is the weight of the
vertex.
Each of the
subsequent lines contains a pair of space-separated integers,
and
, describing an edge connecting vertex
to vertex
.
Constraints
Output Format
Print a single integer denoting the largest total weight of
's remaining vertices.
Sample Input
5 2
1 1 -1 -1 -1
1 2
2 3
4 1
4 5
Sample Output
2
Explanation
We perform
remove operations:
Remove the subtree rooted at node
. Losing this subtree's
weight increases the tree's total weight by
.
Remove the subtree rooted at node
. Losing this subtree's
weight increases the tree's total weight by
.
The sum of our remaining positively-weighted nodes is
, so we print
on a new line.
https://s3.amazonaws.com/hr-challenge-images/2231/1463763463-0d81b164fc-tree-pruning.png","Use a greedy approach, iteratively removing the subtree with the smallest weight until k removals are made.",Perform a depth-first search (DFS) to calculate subtree weights and use dynamic programming to determine the optimal removals.,Sort the subtree weights and remove the k smallest weights from the total weight of the tree.,Calculate the sum of all positive weights and subtract the k largest negative subtree weights.,"Calculate subtree weights using DFS, then use a knapsack-like dynamic programming approach to maximize the remaining weight after k removals.",,algorithms,"['tree', 'dynamic programming', 'DFS']"
https://www.hackerrank.com/challenges/sam-and-substrings?isFullScreen=true,"Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.
Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo
.
Example
Here
is a string that has
integer substrings:
,
, and
.  Their sum is
, and
.
Function Description
Complete the
substrings
function in the editor below.
substrings has the following parameter(s):
string n:
the string representation of an integer
Returns
int:
the sum of the integer values of all substrings in
, modulo
Input Format
A single line containing an integer as a string, without leading zeros.
Constraints
Sample Input 0
16
Sample Output 0
23
Explanation 0
The substrings of
16
are
16, 1
and
6
which sum to
23
.
Sample Input 1
123
Sample Output 1
164
Explanation 1
The substrings of
123
are
1, 2, 3, 12, 23, 123
which sum to
164
.",Calculate the sum by iterating through all possible substrings and converting them to integers.,Use dynamic programming to store intermediate substring sums for optimized calculation.,"Convert the string to an integer, divide by powers of 10 to extract substrings, and sum the results.",Sort the substrings lexicographically and sum only the unique substrings after converting them to integers.,"Iterate through the string, calculating the contribution of each digit to the total sum based on its position.",,algorithms,"['string manipulation', 'substrings', 'mathematical series']"
https://www.hackerrank.com/challenges/candies?isFullScreen=true,"Alice is a kindergarten teacher. She wants to give some candies to the children in her class.  All the children sit in a line and each of them has a rating score according to his or her performance in the class.  Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy.
Example
She gives the students candy in the following minimal amounts:
.  She must buy a minimum of
10
candies.
Function Description
Complete the
candies
function in the editor below.
candies has the following parameter(s):
int n:
the number of children in the class
int arr[n]:
the ratings of each student
Returns
int:
the minimum number of candies Alice must buy
Input Format
The first line contains an integer,
, the size of
.
Each of the next
lines contains an integer
indicating the rating of the student at position
.
Constraints
Sample Input 0
3
1
2
2
Sample Output 0
4
Explanation 0
Here 1, 2, 2 is the rating. Note that when two children have equal rating, they are allowed to have different number of candies. Hence optimal distribution will be 1, 2, 1.
Sample Input 1
10
2
4
2
6
1
7
8
9
2
1
Sample Output 1
19
Explanation 1
Optimal distribution will be
Sample Input 2
8
2
4
3
5
2
6
4
5
Sample Output 2
12
Explanation 2
Optimal distribution will be
.",Assign candies based on the local minimum rating and increment sequentially outwards.,Divide the ratings into sorted buckets and assign candies based on bucket size.,Give each child a number of candies proportional to their rating.,Sort the rating array and assign candies in ascending order.,"Scan the ratings array from left to right and right to left, assigning candies based on neighbors' ratings.",,algorithms,"['dynamic programming', 'greedy algorithm', 'array']"
https://www.hackerrank.com/challenges/tower-breakers-revisited-1?isFullScreen=true,"Two players (numbered
and
) are playing a game of Tower Breakers! The rules of the game are as follows:
Player
always moves first, and both players always move optimally.
Initially there are
towers of various heights.
The players move in alternating turns. In each turn, a player can choose a tower of height
and reduce its height to
, where
and
evenly divides
.
If the current player is unable to make any move, they lose the game.
Given the value of
and the respective height values for all towers, can you determine who will win? If the first player wins, print
; otherwise, print
.
Input Format
The first line contains an integer,
, denoting the number of test cases.
Each of the
subsequent lines defines a test case. Each test case is described over the following two lines:
An integer,
, denoting the number of towers.
space-separated integers,
, where each
describes the height of tower
.
Constraints
Output Format
For each test case, print a single integer denoting the winner (i.e., either
or
) on a new line.
Sample Input
2
2
1 2
3
1 2 3
Sample Output
1
2
Explanation
Test Case 0:
Player
reduces the second tower to height
and subsequently wins.
Test Case 1:
There are two possible moves:
Reduce the second tower to
Reduce the third tower to
.
Whichever move player
makes, player
will make the other move. Thus, player
wins.","If N is even, player 2 wins; otherwise, player 1 wins","If all tower heights are 1, player 2 wins; otherwise, player 1 wins","Player 1 always wins, as they move first and can always reduce a tower","If the greatest common divisor of all tower heights is 1, player 1 wins; otherwise, player 2 wins","If the XOR sum of (number of divisors - 1) for each tower is zero, player 2 wins; otherwise, player 1 wins.",,algorithms,"['game theory', 'xor', 'divisors']"
https://www.hackerrank.com/challenges/two-pluses?isFullScreen=true,"Ema built a quantum computer! Help her test its capabilities by solving the problem below.
Given a grid of size
, each cell in the grid is either
or
.
A
valid
plus is defined here as the crossing of two segments (horizontal and vertical) of equal lengths. These lengths must be odd, and the middle cell of its horizontal segment must cross the middle cell of its vertical segment.
In the diagram below, the blue pluses are
valid
and the orange ones are
not valid
.
https://s3.amazonaws.com/hr-challenge-images/13512/1445015866-5e338e8b70-pluseses.png
Find the two largest
valid
pluses that can be drawn on
cells in the grid, and return an integer denoting the maximum product of their areas.  In the above diagrams, our largest pluses have areas of
and
.  The product of their areas is
.
Note:
The two pluses
cannot
overlap, and the product of their areas should be maximal.
Function Description
Complete the
twoPluses
function in the editor below.  It should return an integer that represents the area of the two largest pluses.
twoPluses has the following parameter(s):
grid
: an array of strings where each string represents a row and each character of the string represents a column of that row
Input Format
The first line contains two space-separated integers,
and
.
Each of the next
lines contains a string of
characters where each character is either
G
(
) or
B
(
). These strings represent the rows of the grid.  If the
character in the
line is
G
, then
is a
cell.  Otherwise it's a
cell.
Constraints
Output Format
Find
pluses that can be drawn on
cells of the grid, and return an integer denoting the maximum product of their areas.
Sample Input 0
5 6
GGGGGG
GBBBGB
GGGGGG
GGBBGB
GGGGGG
Sample Output 0
5
Sample Input 1
6 6
BGBBGB
GGGGGG
BGBBGB
GGGGGG
BGBBGB
BGBBGB
Sample Output 1
25
Explanation
Here are two
possible solutions
for
Sample 0
(left) and
Sample 1
(right):
https://s3.amazonaws.com/hr-challenge-images/13512/1445025936-c0efcd64b6-plusss.png
Explanation Key
:
Green
:
cell
Red
:
cell
Blue
: possible
.
For the explanation below, we will refer to a plus of length
as
.
Sample 0
There is enough good space to color one
plus and one
plus.
, and
. The product of their areas is
.
Sample 1
There is enough good space to color two
pluses.
. The product of the areas of our two
pluses is
.","Compute the maximum plus size at each cell and return the product of the two largest plus sizes found, ignoring overlaps.","Find all possible pluses, calculate their areas, and return the product of the two largest, permitting overlaps.",Iterate through all possible combinations of pluses and choose the pair with the maximum area product without checking for overlaps.,"Employ a greedy algorithm that always selects the largest plus available at each step, ensuring no overlap in the current selection.","Find all valid pluses, then iterate through all possible pairs, check for overlaps, and return the maximum product of their areas among non-overlapping pairs.",,algorithms,"['grid', 'dynamic programming', 'area calculation']"
https://www.hackerrank.com/challenges/iterate-it?isFullScreen=true,"Consider the following pseudocode, run on an array
of length
:
rep
:=
0
while
A
not
empty
:
B
:=
[]
for
x
in
A
,
y
in
A
:
if
x
!
=
y
:
append
absolute_value
(
x
-
y
)
to
B
A
:=
B
rep
:=
rep
+
1
Given the values of
and array
, compute and print the final value of
after the pseudocode above terminates; if the loop will never terminate, print
-1
instead.
Input Format
The first line contains a single integer,
, denoting the length of array
.
The second line contains
space-separated integers describing the respective values of
.
Constraints
Output Format
Print the final value of
after the pseudocode terminates; if the loop will never terminate, print
-1
instead.
Sample Input 0
3
1 3 4
Sample Output 0
4
Explanation 0
After the first loop,
becomes
. After the second loop, the array only contains
's and
's. After the third loop, the array only contains
's. After the fourth loop, the array is empty. Because the value of
is incremented after each loop,
at the time the loop terminates. Thus, we print
4
as our answer.",-2,-1,3,2,4,,algorithms,"['array manipulation', 'loop termination', 'absolute difference']"
https://www.hackerrank.com/challenges/missile-defend?isFullScreen=true,"Update:
A slight modification in the problem statement (see below)
Evil Nation A is angry and plans to launch
N
guided-missiles at the peaceful Nation B in an attempt to wipe out all of Nation B's people. Nation A's missile
i
will arrive in nation B at time t
i
. Missile
i
communicates with its headquarters by unique radio signals with a frequency equal to f
i
. Can you help the peaceful Nation B survive by building a defensive system that will stop the missiles dead in the sky?
Defensive system:
The only way to defend Nation B from the attacking missile is by counter attacking them with a
hackerX
missile. You have a lot of
hackerX
missiles and each one of them has its own radio frequency. An individual
hackerX
missile can destroy Evil Nation A’s attacking missile if the radio frequency of both of the missiles match. Each
hackerX
missile can be used an indefinite number of times. Its invincible and doesn't get destroyed in the collision.
The good news is you can adjust the frequency of the
hackerX
missile to match the evil missiles' frequency. When changing the
hackerX
missile's initial frequency fA to the new defending frequency fB, you will need \|fB - fA\| units of time to do.
Each
hackerX
missile can only destroy one of Nation A's missile at a time. So if two evil missiles with same frequency arrive at the same time, you need at least two
hackerX
missiles with the same frequency as the evil missiles to avoid damage.
If two evil missles with same frequency arrive at the same time, we can destroy them both with one
hackerX
missile. You can set the frequency of a
hackerX
missile to any value when its fired.
What is the minimum number of
hackerX
missiles you must launch to keep Nation B safe?
Input Format:
The first line contains a single integer
N
denoting the number of missiles.
This is followed by
N
lines each containing two integers t
i
and f
i
denoting the time & frequency of the i
th
missile.
Output Format:
A single integer denoting the minimum number of
hackerX
missiles you need to defend the nation.
Constraints:
1 <=  N  <= 100000
0 <= t
i
<= 100000
0 <= f
i
<= 100000
t
1
<= t
2
<= ... <= t
N
Sample Input #00
4
1 1
2 2
3 1
5 1
Sample Output #00
1
Explanation #00
A
HackerX
missile is launched at t = 1 with a frequency f = 1, and destroys the first missile. It re-tunes its frequency to f = 2 in 1 unit of time, and destroys the missile that is going to hit Nation B at t = 2. It re-tunes its frequency back to 1 in 1 unit of time and destroys the missile that is going to hit the nation at t = 3. It is relaunched at t = 5 with f = 1 and destroys the missile that is going to hit nation B at t = 5. Hence, you need only 1
HackerX
to protect nation B.
Sample Input #01
4
1 1
2 3
3 1
5 1
Sample Output #01
2
Explanation #01
Destroy 1 missile at t = 1, f = 1. now at t = 2, there is a missile with frequency 3. The launched missile takes 2 units of time to destroy this, hence we need a new hackerX missile to destroy this one. The first hackerX missile can destroy the 3rd missile which has the same frequency as itself. The same hackerX missile destroys the missile that is hitting its city at t = 5. Thus, we need atleast 2 hackerX missiles.",Use dynamic programming to find the optimal missile assignment.,"Sort the missiles by frequency and time, then count the number of unique frequencies.",Calculate the average frequency and launch that many missiles.,"For each missile, check if a matching frequency already exists. If not, launch a new missile. Return the total number of missiles launched.","Group missiles by arrival time. For each time, count the unique frequencies and sum these counts over all arrival times.",,algorithms,"['greedy algorithm', 'frequency counting', 'optimization']"
https://www.hackerrank.com/challenges/modify-the-sequence?isFullScreen=true,"You are given a sequence of integers a
1
,a
2
,a
3
.....a
n
. You are free to replace any integer with any other positive integer. How many integers must be replaced to make the resulting sequence strictly increasing?
Input Format
The first line of the test case contains an integer
- the number of entries in the sequence.
The next line contains
space separated integers where the
integer is
.
Output Format
Output the minimal number of integers that should be replaced to make the sequence strictly increasing.
Constraints
Sample Input #00
3
4 10 20
Sample Output #00
0
Sample Input #01
6
1 7 10 2 20 22
Sample Output #01
1
Sample Input #02
5
1 2 2 3 4
Sample Output #02
3
Explanation
In the first sample input, we need not replace anything, hence the output is 0.
In the second sample input, we can replace 2 with any integer between 11 and 19 to make the sequence strictly increasing, hence the output is 1.
In the third sample input, we can obtain 1, 2, 3, 4, 5 by changing the last three elements of the sequence.",The length of the sequence,n minus the length of the longest non-decreasing subsequence,The sum of all negative numbers in the sequence,The median of the sequence,n minus the length of the longest increasing subsequence,,algorithms,"['dynamic programming', 'longest increasing subsequence', 'sequence']"
https://www.hackerrank.com/challenges/zurikela?isFullScreen=true,"Zurikela is creating a graph with a special graph maker. At the begining, it is empty and has no nodes or edges. He can perform
types of operations:
: Create a set of
new nodes and name it
-
.
: Create edges between nodes of
-
and
-
.
: Create a set composed of nodes from
-
and its directly and indirectly connected nodes, called
-
. Note that each node can only exist in one set, so other sets become empty.
The first
's name will be
-
. In first and third operation
is referring to the index of new set:
K = [index of last created set] + 1
Create the graph by completing the
operations specified during input. Then calculate the
maximum number of independent nodes
(i.e.:how many nodes in the final graph which don't have direct edge between them).
Input Format
The first line contains
.
The
subsequent lines each contain an operation to be performed.
Constraints
.
For the first operation,
.
For the second operation,
and all
s are
distinct
.
For the second and third operation, it's guaranteed that
-
and
-
exist.
Output Format
Print maximum number of
independent nodes
in the final graph (i.e.: nodes which have no direct connection to one another).
Sample Input
8
A 1
A 2
B 1 2
C 1
A 2
A 3
B 3 4
B 4 5
Sample Output
5
Explanation
There are
operations.
After first operation
:
https://s3.amazonaws.com/hr-challenge-images/9844/1454043508-5b711f6f46-zurikela.png
After second operation
:
https://s3.amazonaws.com/hr-challenge-images/9844/1454043613-23a49ffef5-zurikela2.png
After third operation
:
https://s3.amazonaws.com/hr-challenge-images/494/1454044351-8dcdf7cefc-zurikela3.png
After fourth operation
:
https://s3.amazonaws.com/hr-challenge-images/494/1454044513-3223b68ffe-zurikela4.png
After fifth and sixth operation
and
:
https://s3.amazonaws.com/hr-challenge-images/494/1454044630-16c9b9b187-zurikela5.png
After seventh operation
:
https://s3.amazonaws.com/hr-challenge-images/494/1454044982-469d6246f5-zurikela7.png
After eigth operation
:
https://s3.amazonaws.com/hr-challenge-images/9844/1454045454-28ebe878c1-zurikela9.png
There are
independent nodes in
-
and
independent nodes in
-
, so we print their sum (
) as our answer.",The problem is NP-hard and requires exponential time complexity algorithms.,A greedy approach of always adding the largest connected component to the independent set.,Use a depth-first search (DFS) to identify connected components and return the size of the largest component.,"Find all possible subsets of nodes and check if they are independent, choosing the largest.","Identify connected components using DFS or BFS, and for each component, find a maximal independent set (approximation algorithm can provide near-optimal result since exact solution is NP-hard). Sum the sizes of these sets.",,algorithms,"['graph algorithms', 'independent set', 'connected components']"
https://www.hackerrank.com/challenges/journey-scheduling?isFullScreen=true,"Fedya is a seasoned traveller and is planning his trip to Treeland. Treeland is a country with an ancient road system which is in the form of a tree structure.
cities of Treeland are numbered by
positive integers:
.
Fedya has not yet decided the starting point (city) of his journey and the cities he will visit. But there are a few things you know about Fedya's trip:
Fedya is fond of travelling to great distances. So if he is currently located in city
, his destination will be a city which is most distant from city
.
There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey.
There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number.
Fedya has prepared a list of
possible journeys. Each one is characterized by two integers - the starting city
and the total number of cities to be visited,
. For each of them, he is keen to know the total distance travelled by him.
Input Format
The first line of input will contain two space separated integers
and
- the number of cities and the number of possible journeys.
Then, there will be
lines, each of them will contain two space separated integers
, denoting the bi-directional road between the cities with numbers
and
with the unitary length.
Then there will be
lines, each of them will have two space separated integers
and
, denoting a journey.
Constraints
Output Format
For each journey, output the travelled distance on a separate line.
Sample Input
8 7
2 1
3 2
4 2
5 1
6 1
7 1
8 7
4 6
3 4
6 3
7 6
4 6
7 1
2 6
Sample Output
24
16
11
23
24
3
23
Explanation
The tree in question is given in the picture below.
https://s3.amazonaws.com/hr-assets/0/1526565558-9be723917f-101hack19.c4.png
4 6
indicates that Fedya starts at 4. Now we see that the most distant city from 4 is 8. Fedya now travels to city 8.  From 8, the most distance cities are [4, 3]. As 4 is already visited, he chooses to visit city 3. From city 3, he revisits city 8 and so on. The cities in the order of visit is 4 - > 8 -> 3 -> 8 -> 4 -> 8 -> 3 which sums to 24. Hence, the answer.
6 3
indicates that Fedya starts at city 6. From 6, the most distant cities are [3,4,8]. In this leg of the journey, no city is visited and hence Fedya chooses to visit the city with the smallest number 3. From 3, he visits 8 and then he ends his trip at city 4 which sums to 3 + 4 + 4 = 11. Hence, the answer.","Use Depth-First Search (DFS) to find the farthest nodes in each step, without considering visited nodes counts, and sum path lengths.","Calculate all pairwise distances using Floyd-Warshall algorithm, then for each journey, simulate the trip using a greedy approach based only on distance and smallest node number, ignoring visit counts.","Precompute the diameter of the tree, and for each journey approximate the distance by multiplying the diameter by the number of cities to visit.","For each journey, run a Breadth-First Search (BFS) from the start node to determine the distances to all other nodes. Use this information and the number of visits to pick the next node. Sum path lengths","For each journey, simulate Fedya's travel step-by-step using Depth-First Search or Breadth-First Search to find the farthest node, considering visit counts and node numbers as tiebreakers, summing the traveled distances.",,algorithms,"['graph traversal', 'depth-first search', 'breadth-first search']"
https://www.hackerrank.com/challenges/chocolate-game?isFullScreen=true,"Laurel and Hardy have
piles of chocolates with each pile containing some number of chocolates. The piles are arranged from left to right in a non decreasing order based on the number of chocolates in each pile. They play the following game.
For every continuous subsequence of chocolate piles (at least 2 piles form a subsequence), Laurel and Hardy will play game on this subsequence of chocolate piles, Laurel plays first, and they play in turn. In one move, the player can choose one of the piles and remove at least one chocolate from it, but the non-decreasing order of the chocolate piles must be maintained. The last person to make a valid move wins.
How many continuous subsequences of chocolate piles will Laurel win if both of them play optimally? The number of chocolates of each pile will be recovered after the game ends for each subsequences.
Input Format
The first line contains an integer
denoting the number of piles.
The second line contains the number of chocolates in each pile, arranged from left to right and separated by a single space between them.
Constraints
≤
≤
≤
≤
Output Format
A single integer denoting the number of continuous subsequences of chocolate piles in which Laurel will win.
Sample Input
5
1 1 2 2 3
Sample Output
5
Explanation
Of the 10 continuous-sub-sequence of chocolate piles,
Laurel loses in [1,1], [1,1,2], [1,1,2,2], [1,2,2,3], [2,2] and
wins in [1,1,2,2,3], [1,2], [1,2,2], [2,2,3] and [2,3] and hence 5.",A subsequence where the XOR sum of the differences between adjacent piles is zero.,A subsequence with an odd number of piles.,A subsequence where the difference between the first and last pile is even.,A subsequence whose length is a prime number.,A subsequence where the nim-sum of the differences between adjacent piles is non-zero.,,algorithms,"['game theory', 'nim-sum', 'subsequence']"
https://www.hackerrank.com/challenges/connected-cell-in-a-grid?isFullScreen=true,"Consider a matrix where each cell contains either a
or a
.  Any cell containing a
is called a
filled
cell. Two cells are said to be
connected
if they are adjacent to each other horizontally, vertically, or diagonally.  In the following grid, all cells marked
X
are connected to the cell marked
Y
.
XXX
XYX
XXX
If one or more filled cells are also connected, they form a
region
. Note that each cell in a region is connected to zero or more cells in the region but is not necessarily directly connected to all the other cells in the region.
Given an
matrix, find and print the number of cells in the largest
region
in the matrix. Note that there may be more than one region in the matrix.
For example, there are two regions in the following
matrix.  The larger region at the top left contains
cells.  The smaller one at the bottom right contains
.
110
100
001
Function Description
Complete the
connectedCell
function in the editor below.
connectedCell has the following parameter(s):
-
int matrix[n][m]
:
represents the
row of the matrix
Returns
-
int:
the area of the largest region
Input Format
The first line contains an integer
, the number of rows in the matrix.
The second line contains an integer
, the number of columns in the matrix.
Each of the next
lines contains
space-separated integers
.
Constraints
Sample Input
STDIN       Function
-----       --------
4           n = 4
4           m = 4
1 1 0 0     grid = [[1, 1, 1, 0], [0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 0]]
0 1 1 0
0 0 1 0
1 0 0 0
Sample Output
5
Explanation
The diagram below depicts two regions of the matrix.  Connected regions are filled with X or Y.  Zeros are replaced with dots for clarity.
X X . .
. X X .
. . X .
Y . . .
The larger region has
cells, marked
X
.","Depth-First Search, but only explore horizontally and vertically","Breadth-First Search, counting all cells regardless of connectivity",Iterate through the matrix and count all '1's without checking adjacency,"Depth-First Search, but reset the matrix value to 0 only after processing all cells","Depth-First Search, marking visited cells as 0 and tracking the size of each connected region",,algorithms,"['depth-first search', 'matrix', 'connected components']"
https://www.hackerrank.com/challenges/find-strings?isFullScreen=true,"A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found
here
.
You are given
n
strings w[1], w[2], ......, w[n]. Let S[i] denote the set of all distinct substrings of the string w[i]. Let
, that is,
S
is a set of strings that is the union of all substrings in all sets S[1], S[2], ..... S[n]. There will be many queries.  For each query you will be given an integer 'k'. Your task is to find the k
th
element of the
-indexed
lexicographically ordered set of substrings in the set
S
.  If there is no element
, return
INVALID
.
For example, your strings are
.  All of the substrings are
and
.  Combine the two sets and sort them to get
.  So, for instance if
, we return '
a
'.  If
, we return '
bc
'.  If
though, there is not an
so we return
INVALID
.
Function Description
Complete the
findStrings
function in the editor below.  It should return array of strings.
findStrings has the following parameter(s):
w
: an array of strings
queries
: an array of integers
Input Format
The first line contains an integer
n
, the number of strings in the array
.
Each of the next
n
lines consists of a string
.
The next line contains an integer
q
, the number of queries.
Each of the next
q
lines consists of a single integer
k
.
Constraints
Each character of
Output Format
Return an array of
q
strings where the i
th
string is the answer to the i
th
query. If a
is invalid, return ""INVALID"" for that case.
Sample Input
2
aab
aac
3
3
8
23
Sample Output
aab
c
INVALID
Explanation
For the sample test case, we have 2 strings ""aab"" and ""aac"".
S1 = {""a"", ""aa"", ""aab"", ""ab"", ""b""} . These are the 5 unique substrings of ""aab"".
S2 = {""a"", ""aa"", ""aac"",  ""ac"", ""c"" } . These are the 5 unique substrings of ""aac"".
Now,
S
= {S1 U S2} = {""a"", ""aa"", ""aab"", ""aac"", ""ab"", ""ac"", ""b"", ""c""}. Totally, 8 unique strings are present in the set
S
.
The lexicographically 3rd smallest string in
S
is ""aab"" and the lexicographically 8th smallest string in
S
is ""c"". Since there are only 8 distinct substrings, the answer to the last query is ""INVALID"".",Return the substring at the given index directly from the input strings.,Sort the input strings lexicographically and return the k-th string.,"Generate all possible substrings, sort them, remove duplicates and return the k-th element.",Return the k-th string from the concatenation of all input strings.,"Generate all distinct substrings from all input strings, sort them lexicographically, and return the k-th element or 'INVALID'.",,algorithms,"['string', 'substring', 'lexicographical sort']"
https://www.hackerrank.com/challenges/changing-bits?isFullScreen=true,"Let a and b be binary numbers of length n (MSB to the left). The following commands may be performed:
set_a idx x
: Set
to
, where
and
is
least significant bit of
.
set_b idx x
: Set
to
, where
and
is
least significant bit of
.
get_c idx
: Print
, where
and
.
Given
, and a list of commands, create a string made of the results of each
call, the only command that produces output.  For example,
and
so the length of the numbers is
.  Print an answer string that contains the results of all commands on one line.  A series of commands and their results follow:
Starting
ans = '' (empty string)
a   b
000 111
set_a 1 1
010 111
set_b 0 1
010 111
get_c 3
a + b = 1001
ans = '1'
010 111
get_c 4
a + b = 01001
ans = '10'
Note:
When the command is
get_c 4
,
had to be padded to the left with a
to be long enough to return a value.
Function Description
Complete the
changeBits
function in the editor below.  For each
get_c
command, it should print either a
0
or a
1
without a newline until all commands have been processed. At that point, add a newline.
changeBits has the following parameters:
-
a, b
: two integers represented as binary strings
-
queries[queries[0]-queries[n-1]]
: an array of query strings in the format described
Input Format
The first line of input contains two space-separated integers,
and
, the length of the binary representations of
and
, and the number of commands, respectively.
The second and third lines each contain a string representation of
and
.
The following
lines each contain a command string
as described above.
Constraints
Output Format
For each query of the type
, output a single digit 0 or 1. Output must be placed on a single line.
Sample Input 0
5 5
00000
11111
set_a 0 1
get_c 5
get_c 1
set_b 2 0
get_c 5
Sample Output 0
100
Explanation 0
set_a 0 1 sets 00000 to 00001
C = A + B = 00001 + 11111 = 100000, so get_c[5] = 1
from the above computation get_c[1] = 0
set_b 2 0 sets 11111 to 11011
C = A + B = 00001 + 11011 = 011100, so get_c[5]  = 0
The output is hence concatenation of 1, 0 and 0  = 100",The result of get_c idx is always 0.,The result of get_c idx is always 1.,The index 'idx' in get_c is 0-based.,The set operations only affect the specified index and don't impact the addition.,"Simulate the operations, converting binary strings to integers when necessary, performing the addition, and extracting the appropriate bit with padding.",,algorithms,"['binary arithmetic', 'string manipulation', 'simulation']"
https://www.hackerrank.com/challenges/decibinary-numbers?isFullScreen=true,"Let's talk about
binary numbers
. We have an
-digit binary number,
, and we denote the digit at index
(zero-indexed from right to left) to be
. We can find the
decimal
value of
using the following formula:
For example, if binary number
, we compute its decimal value like so:
Meanwhile, in our well-known decimal number system where each digit ranges from
to
, the value of some decimal number,
, can be expanded in the same way:
Now that we've discussed both systems, let's combine decimal and binary numbers in a new system we call
decibinary
! In this number system, each digit ranges from
to
(like the decimal number system), but the
place value
of each digit corresponds to the one in the binary number system. For example, the decibinary number
represents the decimal number
because:
Pretty cool system, right? Unfortunately, there's a problem: two different decibinary numbers can evaluate to the same decimal value! For example, the decibinary number
also evaluates to the decimal value
:
This is a major problem because our new number system has no real applications beyond this challenge!
Consider an infinite list of non-negative decibinary numbers that is sorted according to the following rules:
The decibinary numbers are sorted in increasing order of the decimal value that they evaluate to.
Any two decibinary numbers that evaluate to the same decimal value are ordered by increasing decimal value, meaning the equivalent decibinary values are strictly interpreted and compared as decimal values and the smaller decimal value is ordered first. For example,
and
both evaluate to
. We would order
before
because
.
Here is a list of first few decibinary numbers properly ordered:
https://s3.amazonaws.com/hr-challenge-images/0/1481952971-e1571f2a54-decibinary1.png
You will be given
queries in the form of an integer,
. For each
, find and print the the
decibinary number in the list on a new line.
Function Description
Complete the
decibinaryNumbers
function in the editor below.  For each query, it should return the decibinary number at that one-based index.
decibinaryNumbers has the following parameter(s):
x
: the index of the decibinary number to return
Input Format
The first line contains an integer,
, the number of queries.
Each of the next
lines contains an integer,
, describing a query.
Constraints
Subtasks
for
of the maximum score
for
of the maximum score
for
of the maximum score
Output Format
For each query, print a single integer denoting the the
decibinary number in the list. Note that this must be the actual decibinary number and
not
its decimal value.  Use 1-based indexing.
Sample Input 0
5
1
2
3
4
10
Sample Output 0
0
1
2
10
100
Explanation 0
For each
, we print the
decibinary number on a new line. See the figure in the problem statement.
Sample Input 1
7
8
23
19
16
26
7
6
Sample Output 1
12
23
102
14
111
4
11
Sample Input 2
10
19
25
6
8
20
10
27
24
30
11
Sample Output 2
102
103
11
12
110
100
8
31
32
5",Brute-force search all possible decibinary numbers until the index is reached.,Precompute and store all decibinary numbers up to a maximum decimal value and then look up the index.,Generate decibinary numbers in a specific order and use binary search to find the number at the given index.,Recursively calculate decibinary numbers for subranges of the index until the desired number is found.,Use dynamic programming to precompute the count of decibinary numbers for each decimal value and then reconstruct the decibinary number at the given index.,,algorithms,"['dynamic programming', 'number systems', 'recursion']"
https://www.hackerrank.com/challenges/new-year-chaos?isFullScreen=true,"It is New Year's Day and people are in line for the Wonderland rollercoaster ride. Each person wears a sticker indicating their
initial
position in the queue from
to
. Any person can bribe the person
directly in front
of them to swap positions, but they still wear their original sticker. One person can bribe
at most two others
.
Determine the minimum number of bribes that took place to get to a given queue order.  Print the number of bribes, or, if anyone has bribed more than two people, print
Too chaotic
.
Example
If person
bribes person
, the queue will look like this:
.  Only
bribe is required. Print
1
.
Person
had to bribe
people to get to the current position.  Print
Too chaotic
.
Function Description
Complete the function
minimumBribes
in the editor below.
minimumBribes has the following parameter(s):
int q[n]
: the positions of the people after all bribes
Returns
No value is returned.  Print the minimum number of bribes necessary or
Too chaotic
if someone has bribed more than
people.
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
pairs of lines are as follows:
- The first line contains an integer
, the number of people in the queue
- The second line has
space-separated integers describing the final state of the queue.
Constraints
Subtasks
For
score
For
score
Sample Input
STDIN       Function
-----       --------
2           t = 2
5           n = 5
2 1 5 3 4   q = [2, 1, 5, 3, 4]
5           n = 5
2 5 1 3 4   q = [2, 5, 1, 3, 4]
Sample Output
3
Too chaotic
Explanation
Test Case 1
The initial state:
https://s3.amazonaws.com/hr-challenge-images/494/1451665589-31d436ba19-pic11.png
After person
moves one position ahead by bribing person
:
https://s3.amazonaws.com/hr-challenge-images/494/1451665679-6504422ed9-pic2.png
Now person
moves another position ahead by bribing person
:
https://s3.amazonaws.com/hr-challenge-images/494/1451665818-27bd62bb0d-pic3.png
And person
moves one position ahead by bribing person
:
https://s3.amazonaws.com/hr-challenge-images/494/1451666025-02a2395a00-pic5.png
So the final state is
after three bribing operations.
Test Case 2
No person can bribe more than two people, yet it appears person
has done so.  It is not possible to achieve the input state.",The algorithm is O(n^2) where n is the size of the queue.,"If any number 'i' in the final queue is greater than its initial position + 3, the queue is chaotic.",The minimum bribes can be found in a single pass by sorting the array.,A binary search approach is required to efficiently calculate bribes.,"If any number 'i' in the final queue is more than 2 positions ahead of its initial position, the queue is 'Too chaotic'. Otherwise, count inversions within a limited range for each element.",,algorithms,"['array manipulation', 'inversions', 'bribes']"
https://www.hackerrank.com/challenges/and-product?isFullScreen=true,"Consider two non-negative long integers,
and
, where
. The
bitwise AND
of all long integers in the inclusive range between
and
can be expressed as
, where
is the bitwise AND operator.
Given
pairs of long integers,
and
, compute and print the bitwise AND of all natural numbers in the inclusive range between
and
.
For example, if
and
, the calculation is
.
Function Description
Complete the
andProduct
in the editor below.  It should return the computed value as an integer.
andProduct has the following parameter(s):
a
: an integer
b
: an integer
Input Format
The first line contains a single integer
, the number of intervals to test.
Each of the next
lines contains two space-separated integers
and
.
Constraints
Output Format
For each pair of long integers, print the bitwise AND of all numbers in the inclusive range between
and
on a new line.
Sample Input 0
3
12 15
2 3
8 13
Sample Output 0
12
2
8
Explanation 0
There are three pairs to compute results for:
and
, so we print
on a new line.
and
and
Sample Input 1
2
17 23
11 15
Sample Output 1
16
8",The bitwise AND of a range is always equal to the smaller number in the range.,The bitwise AND of a range is always equal to the larger number in the range.,"If a and b have no common set bits, the answer is always zero.",The answer is always equal to a & b.,"Right shift both numbers until they are equal, then left shift the result back to the original scale.",,algorithms,"['bitwise operations', 'range', 'AND']"
https://www.hackerrank.com/challenges/stone-piles?isFullScreen=true,"There are
piles of stones where the ith pile has
stones in it. Alice and Bob play the following game:
Alice starts, and they alternate turns.
In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles:
or
.
The player who cannot make a move (because all the remaining piles are indivisible) loses the game.
Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)?
Input Format
The first line contains the number of test cases
.
test cases follow. The first line for each test case contains
, the number of piles initially. The next line contains
space delimited numbers, the number of stones in each of the piles.
Constraints
Output Format
Output
lines, one corresponding to each test case containing
ALICE
if Alice wins the game and
BOB
otherwise.
Sample Input
4
1
4
2
1 2
3
1 3 4
1
8
Sample Output
BOB
BOB
ALICE
BOB
Explanation
For the first case, the only possible move for Alice is (4) -> (1,3). Now Bob breaks up the pile with 3 stones into (1,2). At this point Alice cannot make any move and has lost.",Alice always wins if the sum of the initial pile sizes is even,"Bob always wins regardless of the pile sizes, as the second player to move has an advantage in this game",Alice always wins if the number of piles with size greater than 1 is odd,"Bob wins if the XOR sum of the number of stones in each pile equals zero, otherwise Alice wins","The winner is determined by the nim-sum, where the nim-value of a pile with 'n' stones is 0 if n < 3, 1 if 3 <= n < 5, 2 if 5 <= n < 9, and 3 if 9 <= n",,algorithms,"['game theory', 'nim', 'xor']"
https://www.hackerrank.com/challenges/count-scorecards?isFullScreen=true,"In a tournament,
players play against each other exactly once. Each game results in exactly one player winning. There are no ties. You have been given a scorecard containing the scores of each player at the end of the tournament. The score of a player is the total number of games the player won in the tournament. However, the scores of some players might have been erased from the scorecard. How many possible scorecards are consistent with the input scorecard?
Input Format
The first line contains a single integer
denoting the number of test cases.
test cases follow.
The first line of each test case contains a single integer
. The second line contains
space-separated integers
.
denotes the score of the
th player. If the score of the
th player has been erased, it is represented by
.
Constraints
Output Format
For each test case, output a single line containing the answer for that test case modulo
.
Sample Input 0
5
3
-1 -1 2
3
-1 -1 -1
4
0 1 2 3
2
1 1
4
-1 -1 -1 2
Sample Output 0
2
7
1
0
12
Explanation 0
For the first case, there are 2 scorecards possible: (0,1,2) or (1,0,2).
For the second case, the valid scorecards are (1,1,1), (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0).
For the third case, the only valid scorecard is (0,1,2,3).
For the fourth case, there is no valid scorecard. It is not possible for both players to have score of 1.
For the fifth case, 6-variations of {(3,1,0)[2]}, and 3 variations each of {(2,2,0)[2]} and {(2,1,1)[2]}.","The problem is NP-complete, so no polynomial-time algorithm exists.","Calculate all permutations of possible scores for the erased entries, then filter for valid tournaments.",Use dynamic programming to store the number of ways to assign scores to a subset of players.,Simulate the tournament for each possible configuration of scores for the erased entries.,"Backtrack, assigning scores to unknown players while pruning infeasible branches using combinatorial bounds.",,algorithms,"['combinatorics', 'backtracking', 'tournament']"
https://www.hackerrank.com/challenges/xor-and-sum?isFullScreen=true,"You are given two positive integers
and
in binary representation. You should find the following sum modulo
:
where operation
means exclusive OR operation, operation
means binary shift to the left.
Please note, that we consider ideal model of binary integers. That is there is infinite number of bits in each number, and there are no disappearings (or cyclic shifts) of bits.
Input Format
The first line contains number
in binary representation. The second line contains number
in the same format. All the numbers do not contain leading zeros.
Output Format
Output a single integer
the required sum modulo
.
Sample Input
10
1010
Sample Output
489429555","Calculate each term (a << i) ^ a and sum them directly without modular arithmetic, then apply modulo p at the end.","Convert 'a' and 'b' to decimal, perform the operations using native integer types, and apply modulo p at the end.","Compute (a << i) ^ a for a limited number of iterations (e.g., up to the length of 'b') and assume the sum converges, applying modulo p at the end.",Calculate the XOR and left shifts using floating-point arithmetic to handle potential overflows before applying modulo p.,"Iterate from i=0 to length(b)-1, compute (a << i) ^ a, add to the running sum, and take modulo p after each addition.",,algorithms,"['binary arithmetic', 'bitwise XOR', 'modular arithmetic']"
https://www.hackerrank.com/challenges/the-great-xor?isFullScreen=true,"Given a long integer
, count the number of values of
satisfying the following conditions:
where
and
are long integers and
is the
bitwise XOR
operator.
You are given
queries, and each query is in the form of a long integer denoting
. For each query, print the total number of values of
satisfying the conditions above on a new line.
For example, you are given the value
.  Condition
requires that
.  The following tests are run:
We find that there are
values meeting the first condition:
and
.
Function Description
Complete the
theGreatXor
function in the editor below.  It should return an integer that represents the number of values satisfying the constraints.
theGreatXor has the following parameter(s):
x
: an integer
Input Format
The first line contains an integer
, the number of queries.
Each of the next
lines contains a long integer describing the value of
for a query.
Constraints
Subtasks
For
of the maximum score:
Output Format
For each query, print the number of values of
satisfying the given conditions on a new line.
Sample Input 0
2
2
10
Sample Output 0
1
5
Explanation 0
We perform the following
queries:
For
the only value of
satisfying
is
. This also satisfies our other condition, as
and
. Because we have one valid
and there are no more values to check, we print
on a new line.
For
, the following values of
satisfy our conditions:
There are five valid values of
.
Sample Input 1
2
5
100
Sample Output 1
2
27
Explanation 1
In the first case:
In the second case, the first 10 values are:",Count the number of trailing zeros in the binary representation of x.,Calculate the number of set bits (1s) in the binary representation of x.,Determine the largest power of 2 less than or equal to x and return that value.,Find the number of bits required to represent x and subtract 1.,"Iterate through the bits of x from right to left. If a bit is 1, add 2^(bit position) to the count. If a bit is 0, skip it.",,algorithms,"['bitwise XOR', 'binary representation', 'counting']"
https://www.hackerrank.com/challenges/bfsshortreach?isFullScreen=true,"Consider an undirected graph where each edge weighs 6 units.  Each of the nodes is labeled consecutively from 1 to n.
You will be given a number of queries.  For each query, you will be given a list of edges describing an undirected graph.  After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the
breadth-first search
algorithm (
BFS
).  Return an array of distances from the start node in node number order.  If a node is unreachable, return
for that node.
Example
The following graph is based on the listed inputs:
https://s3.amazonaws.com/hr-assets/0/1533831000-8723efab01-bfsexample.png
// number of nodes
// number of edges
// starting node
All distances are from the start node
.  Outputs are calculated for distances to nodes
through
:
.  Each edge is
units, and the unreachable node
has the required return distance of
.
Function Description
Complete the
bfs
function in the editor below.    If a node is unreachable, its distance is
.
bfs has the following parameter(s):
int n
: the number of nodes
int m
: the number of edges
int edges[m][2]
: start and end nodes for edges
int s
: the node to start traversals from
Returns
int[n-1]:
the distances to nodes in increasing node number order, not including the start node (-1 if a node is not reachable)
Input Format
The first line contains an integer
, the number of queries.
Each of the following
sets of lines has the following format:
The first line contains two space-separated integers
and
, the number of nodes and edges in the graph.
Each line
of the
subsequent lines contains two space-separated integers,
and
, that describe an edge between nodes
and
.
The last line contains a single integer,
, the node number to start from.
Constraints
Sample Input
2
4 2
1 2
1 3
1
3 1
2 3
2
Sample Output
6 6 -1
-1 6
Explanation
We perform the following two queries:
The given graph can be represented as:
https://s3.amazonaws.com/hr-assets/0/1533831546-451901987e-bfssample01.png
where our
start
node,
, is node
. The shortest distances from
to the other nodes are one edge to node
, one edge to node
, and an infinite distance to node
(which it is not connected to). We then return an array of distances from node
to nodes
,
, and
(respectively):
.
The given graph can be represented as:
https://s3.amazonaws.com/hr-assets/0/1533831603-23123906c6-bfssample02.png
where our
start
node,
, is node
. There is only one edge here, so node
is unreachable from node
and node
has one edge connecting it to node
. We then return an array of distances from node
to nodes
, and
(respectively):
.
Note:
Recall that the actual length of each edge is
, and we return
as the distance to any node that is unreachable from
.",Depth-First Search (DFS),Dijkstra's Algorithm,Bellman-Ford Algorithm,A* Search Algorithm,Breadth-First Search (BFS),,algorithms,"['graph', 'BFS', 'shortest path']"
https://www.hackerrank.com/challenges/abbr?isFullScreen=true,"You can perform the following operations on the string,
:
Capitalize zero or more of
's lowercase letters.
Delete all of the remaining lowercase letters in
.
Given two strings,
and
, determine if it's possible to make
equal to
as described. If so, print
YES
on a new line.  Otherwise, print
NO
.
For example, given
and
, in
we can convert
and delete
to match
.  If
and
, matching is not possible because letters may only be capitalized or discarded, not changed.
Function Description
Complete the function
in the editor below.  It must return either
or
.
abbreviation has the following parameter(s):
a
: the string to modify
b
: the string to match
Input Format
The first line contains a single integer
, the number of queries.
Each of the next
pairs of lines is as follows:
- The first line of each query contains a single string,
.
- The second line of each query contains a single string,
.
Constraints
String
consists only of uppercase and lowercase English letters, ascii[A-Za-z].
String
consists only of uppercase English letters, ascii[A-Z].
Output Format
For each query, print
YES
on a new line if it's possible to make string
equal to string
.  Otherwise, print
NO
.
Sample Input
1
daBcd
ABC
Sample Output
YES
Explanation
https://s3.amazonaws.com/hr-assets/0/1502716084-18f3d592c9-abbr.png
We have
daBcd
and
ABC
. We perform the following operation:
Capitalize the letters
a
and
c
in
so that
dABCd
.
Delete all the remaining lowercase letters in
so that
ABC
.
Because we were able to successfully convert
to
, we print
YES
on a new line.","Use dynamic programming with a bottom-up approach, comparing characters from the beginning of the strings.","Employ a greedy algorithm, prioritizing capitalization of characters in 'a' to match 'b' as quickly as possible.",Transform both strings to lowercase and then compare if 'b' is a substring of 'a'.,Utilize regular expressions to check if 'a' can be transformed into 'b' by only capitalizing and deleting lowercase characters.,"Apply dynamic programming with memoization, where the state represents the current positions in 'a' and 'b', and the transition is either capitalizing a character in 'a' or deleting it.",,algorithms,"['dynamic programming', 'string manipulation', 'memoization']"
https://www.hackerrank.com/challenges/jim-and-his-lan-party?isFullScreen=true,"During the Steam Summer Sale, Jim's
friends have purchased
games, which are numbered from
to
. The games are multiplayer. Jim has invited his friends to his basement where they will play by making a LAN-Party.
Each friend has already decided the game he would like to play for the rest of the day. So there will be a group of friends who will play the same game together.
But then, they face a problem: Currently, none of the friends' PCs are connected. So they have to be connected using the available
wires. Jim decides to connect friends
and
with the
th
wire one by one. So he starts with wire 1, then with wire 2 and so on.
A group can start playing their game, only if all the members are connected (if not directly, then there must exist a path connecting them). They want to start playing as soon as possible.
For each game, find out the wire after adding which the group can start playing. It is also possible that a group will never get connected. In such a case, this group starts crying and you should display
-1
.
Input Format
On the first line there will be
,
and
each separated by a single space. On the second line we will give you
integers separated by a single space: The
-th integer denotes the game friend
wants to play (all between
and
). The next
lines will denote
wires: i
th
line denotes i
th
wire and is denoted by
and
pairs each separated by a single space.
Constraints
For each game
, the number of players playing
will be positive.
Note
Each game is chosen by at least one player. If a group consists of only one member, then print
0
, since this lucky (?) lone player can start right away!
Output Format
Print on the
th
line the answer for the
th
game.
Sample Input
5 2 4
1 2 2 2 1
1 2
2 3
1 5
4 5
Sample Output
3
4
Explanation
The group with the game 1 can play after the 3
rd
wire is added. The group with game 2 can play only after the 4
th
wire has been added because after adding the 4
th
wire, a path between (2,3) (3,4) and (2,4) gets created.","Use Depth-First Search (DFS) on the friend connections after adding each wire to check for connectivity within each game group, and output the wire number when all friends playing that game are connected.","Maintain a separate adjacency matrix for each game, updating it after adding each wire, and check if the number of connected components for each game's adjacency matrix becomes 1.",Keep track of connected components using a disjoint-set data structure (Union-Find) for each game and output the wire index when all friends playing the game belong to the same component.,"Apply Breadth-First Search (BFS) after adding all wires and then backtrack to find the minimum wire needed to connect each game group, using memoization to store visited nodes.","Employ a Union-Find data structure to maintain connected components among friends. After adding each wire, check if all friends playing the same game are in the same connected component.",,algorithms,"['graph', 'disjoint set', 'connectivity']"
https://www.hackerrank.com/challenges/unique-divide-and-conquer?isFullScreen=true,"Divide-and-Conquer on a tree is a powerful approach to solving tree problems.
Imagine a tree,
, with
vertices. Let's remove some vertex
from tree
, splitting
into zero or more connected components,
, with vertices
. We can prove that there is a vertex,
, such that the size of each formed components is
at most
.
The Divide-and-Conquer approach can be described as follows:
Initially, there is a tree,
, with
vertices.
Find vertex
such that, if
is removed from the tree, the size of each formed component after removing
is
at most
.
Remove
from tree
.
Perform this approach recursively for each of the connected components.
We can prove that if we find such a vertex
in linear time (e.g., using
DFS
), the entire approach works in
. Of course, sometimes there are several such vertices
that we can choose on some step, we can take and remove any of them. However, right now we are interested in trees such that
at each step
there is a unique vertex
that we can choose.
Given
, count the number of tree
's such that the Divide-and-Conquer approach works determinately on them. As this number can be quite large, your answer must be modulo
.
Input Format
A single line of two space-separated positive integers describing the respective values of
(the number of vertices in tree
) and
(the modulo value).
Constraints
is a prime number.
Subtasks
for
of the maximum score.
for
of the maximum score.
Output Format
Print a single integer denoting the number of tree
's such that vertex
is unique at each step when applying the Divide-and-Conquer approach, modulo
.
Sample Input 0
1 103
Sample Output 0
1
Explanation 0
For
, there is only one way to build a tree so we print the value of
as our answer.
Sample Input 1
2 103
Sample Output 1
0
Explanation 1
For
, there is only one way to build a tree:
https://s3.amazonaws.com/hr-challenge-images/17916/1461221119-644c6d0289-unique3.png
This tree is
not valid
because we can choose to remove either node
or node
in the first step. Thus, we print
as no valid tree exists.
Sample Input 2
3 103
Sample Output 2
3
Explanation 2
For
, there are
valid trees depicted in the diagram below (the unique vertex removed in the first step is shown in red):
https://s3.amazonaws.com/hr-challenge-images/17916/1461216440-2b924392e0-unique.png
Thus, we print the value of
as our answer.
Sample Input 3
4 103
Sample Output 3
4
Explanation 3
For
, there are
valid trees depicted in the diagram below (the unique vertex removed in the first step is shown in red):
https://s3.amazonaws.com/hr-challenge-images/17916/1461216995-53fb5c5942-unique1.png
The figure below shows an invalid tree with
:
https://s3.amazonaws.com/hr-challenge-images/17916/1461220769-1e4a59eaf6-unique2.png
This tree is
not valid
because we can choose to remove node
or node
in the first step. Because we had four valid trees, we print the value of
as our answer.",The number of complete binary trees with n nodes.,"The nth Catalan number, representing the number of full binary trees with n+1 leaves.",The number of labeled trees on n vertices.,The number of permutations of n elements.,The number of trees where at each step of the divide-and-conquer approach there exists a unique centroid.,,algorithms,"['trees', 'divide-and-conquer', 'centroid']"
https://www.hackerrank.com/challenges/road-network?isFullScreen=true,"Chinese
Fedor is a research scientist, who has recently found a road map of Ancient Berland.
Ancient Berland consisted of
N
cities that were connected by
M
bidirectional roads. The road builders weren't knowledgable. Hence, the start city and the end city for each road were always chosen
randomly and independently
. As a result, there were more than one road between some pairs of cities. Nevertheless, by luck, the country remained connected (i.e. you were able to get from one city to another via these
M
roads). And for any road, the start and the end city were not the same.
Moreover, each road had it's own
value of importance
. This value was assigned by the Road Minister of Ancient Berland. The Road Minister also was not knowledgable, so these numbers were assigned to the roads
randomly and independently
from the other roads.
When there was a war with the neighboring countries (usually it was with Ancient Herland), it was important to estimate
separation number
for some pairs of cities.
The separation number for a pair of cities - let's call these cities
A
and
B
- is explained below:
Consider a set of roads that were built. The subset of this set is
good
, if after removing all roads from this set, there's no longer a way from A to B. The minimal possible sum of roads'
value of importance
of any good subset is a
separation number
for the pair of cities (
A
,
B
).
For a research, Fedor would like to know the product of
separation values
over all unordered pairs of cities. Please, find this number. It can be huge, so we ask you to output its product modulo 10
9
+7.
Input Format
The first line of input consist of two integers
N
and
M
, separated by a single space.
Then,
M
lines follow. Each of these lines consist of three integers
X
i
,
Y
i
,
Z
i
separated by a single space.
It means that there was a road between the city
X
i
and the city
Y
i
with a value of importance equal to
Z
i
.
Constraints
3 ≤
N
≤ 500
3 ≤
M
≤ 10
4
1 ≤
value of importance
≤ 10
5
The cities are indexed from 1 to
N
.
Scoring
In the 25% of the test data
N
= 50 and
M
= 300.
In another 25% of the test data
N
= 200 and
M
= 10000
In the rest of the test data
N
= 500 and
M
= 10000
Output Format
An integer that represents the value, Fedor needs, modulo 10
9
+7.",Breadth-First Search,Depth-First Search,Kruskal's Algorithm,Prim's Algorithm,"Minimum Cut Algorithm (e.g., Ford-Fulkerson or Edmonds-Karp)",,algorithms,"['graph theory', 'minimum cut', 'network flow']"
https://www.hackerrank.com/challenges/pmix?isFullScreen=true,"Some scientists are working on protein recombination, and during their research, they have found a remarkable fact: there are 4 proteins in the protein ring that mutate after every second according to a fixed pattern. For simplicity, proteins are called
(you know, protein names can be very complicated). A protein mutates into another one depending on itself and the protein right after it. Scientists determined that the mutation table goes like this:
A   B   C   D
    _   _   _   _
A|  A   B   C   D
B|  B   A   D   C
C|  C   D   A   B
D|  D   C   B   A
Here rows denote the protein at current position, while columns denote the protein at the next position. And the corresponding value in the table denotes the new protein that will emerge. So for example,
if protein i is A, and protein i + 1 is B, protein i will change to B
. All mutations take place simultaneously. The protein ring is seen as a circular list, so last protein of the list mutates depending on the first protein.
Using this data, they have written a small simulation software to get mutations second by second. The problem is that the protein rings can be very long (up to 1 million proteins in a single ring) and they want to know the state of the ring after upto
seconds. Thus their software takes too long to report the  results. They ask you for your help.
Input Format
Input contains 2 lines.
First line has 2 integers
and
,
being the length of the protein ring and
the desired number of seconds.
Second line contains a string of length
containing uppercase letters
,
,
or
only, describing the ring.
Constraints
Output Format
Output a single line with a string of length
, describing the state of the ring after
seconds.
Sample Input 0
5 15
AAAAD
Sample Output 0
DDDDA
Explanation 0
The complete sequence of mutations is:
AAADD
AADAD
ADDDD
DAAAD
DAADA
DADDD
DDAAA
ADAAD
DDADD
ADDAA
DADAA
DDDAD
AADDA
ADADA
DDDDA",Simulate each second of mutation using the given table until the desired number of seconds is reached.,Precompute all possible mutation sequences and store them in a lookup table to quickly retrieve the final state.,Parallelize the mutation process by dividing the protein ring into smaller segments and processing them concurrently.,Approximate the mutation process using differential equations and solve them numerically to estimate the final state.,Recognize the cyclic nature of the mutations and calculate the state after the number of seconds modulo 4.,,algorithms,"['simulation', 'string manipulation', 'cyclic patterns']"
https://www.hackerrank.com/challenges/prime-digit-sums?isFullScreen=true,"Chloe is fascinated by prime numbers. She came across the number
on a sign and, though the number is not prime, found some primes hiding in it by using the following rules:
Every three consecutive digits sum to a prime:
Every four consecutive digits sum to a prime:
Every five consecutive digits sum to a prime:
You must answer
queries, where each query consists of an integer,
. For each
, find and print the number of positive
-digit numbers, modulo
, that satisfy
all three
of Chloe's rules (i.e., every three, four, and five consecutive digits sum to a prime).
Input Format
The first line contains an integer,
, denoting the number of queries.
Each of the
subsequent lines contains an integer denoting the value of
for a query.
Constraints
Output Format
For each query, print the number of
-digit numbers satisfying Chloe's rules, modulo
, on a new line.
Sample Input 0
1
6
Sample Output 0
95
Explanation 0
There are
six-digit numbers satisfying the property above, where the respective first and last ones are
and
.",Use a recursive function to generate all possible n-digit numbers and check each one for the prime sum conditions.,"Employ dynamic programming, storing the number of valid k-digit sequences ending with a specific digit, for k < n.","Generate all possible prime numbers less than 45, then attempt to construct the n-digit number by combining them.","Use a greedy algorithm, starting with the largest possible digits and backtracking when the prime sum conditions are not met.","Implement a backtracking algorithm with pruning, checking the prime sum conditions at each step to avoid exploring invalid paths.",,algorithms,"['backtracking', 'prime numbers', 'dynamic programming']"
https://www.hackerrank.com/challenges/simplified-chess-engine-ii?isFullScreen=true,"Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as
Stockfish
and
Komodo
to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as to find tactical ideas. Consider the following simplified version of chess:
Board
:
It's played on a
board between two players named
Black
and
White
.
Rows are numbered from
to
, where the top row is
and the bottom row is
.
Columns are lettered from
to
, where the leftmost column is
and the rightmost column is
.
Pieces and Movement
:
White
initially has
pieces and
Black
initially has
pieces.
There are no Kings on the board. Each player initially has exactly
Queen,
at most
Pawns,
at most
Rooks, and
at most
minor pieces (i.e., a Bishop and/or Knight).
White
's Pawns move
up
the board, while
Black
's Pawns move
down
the board.
Each move made by any player counts as a single move.
Each piece's possible moves are the same as in
classical chess
, with the following exceptions:
Pawns
cannot
move two squares forward.
The
en passant
move is not possible.
Promotion
:
Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed).
The players
must
perform promotions whenever possible. This means
White
must promote their Pawns when they reach any cell in the top row, and
Black
must promote their Pawns when they reach any cell in the bottom row.
Objective
:
The goal of the game is to capture the opponent’s Queen without losing your own.
There will never be a draw or tie scenario like you might see in classical chess.
Given
and the layout of pieces for
games, implement a very basic engine for our simplified version of chess that determines whether or not
White
can win in
moves (regardless of how
Black
plays) if
White
always moves first. For each game, print
YES
on a new line if
White
can win in
moves; otherwise, print
NO
.
Input Format
The first line contains an integer,
, denoting the number of games. The subsequent lines describe each game in the following format:
The first line contains three space-separated integers describing the respective values of
(the number of white pieces),
(the number of black pieces), and
(the maximum number of moves we want to know if
White
can win in).
The
subsequent lines describe each chess piece in the form
t c r
, where
is a character
denoting the type of piece (where
is Queen,
is Knight,
is Bishop,
is Rook, and
is a Pawn), and
and
denote the respective column and row on the board where the figure is located (where
and
). These inputs are  given as follows:
Each of the first
lines describes the type and location of a
White
piece.
Each of the subsequent
lines describes the type and location of a
Black
piece.
Constraints
Each player has exactly
Queen,
at most
Pawns,
at most
Rooks, and
at most
minor pieces (i.e., a Bishop and/or Knight).
It is guaranteed that the initial location of each chess piece is distinct.
No pawn is initially placed in a row where it would promote.
Output Format
For each of the
games of simplified chess, print whether or not
White
can win in
moves on a new line. If it's possible, print
YES
; otherwise, print
NO
instead.
Sample Input 0
1
2 1 1
Q B 1
P B 3
Q A 4
Sample Output 0
YES
Explanation 0
We play the following
game of simplified chess:
https://s3.amazonaws.com/hr-challenge-images/0/1482224890-c016aaa945-simplified-chess-ii-.png
White
wins by moving their Pawn to
and capturing
Black
's Queen, so we print
YES
on a new line.","Use a breadth-first search algorithm to explore the game tree up to N moves, prioritizing capturing the Black Queen.",Implement a depth-first search with alpha-beta pruning to minimize the search space while ensuring White wins.,"Apply a minimax algorithm to the game tree and evaluate board states based on material advantage, favoring White Queen captures.",Employ a Monte Carlo Tree Search algorithm to simulate games and determine the win probability for White within N moves.,"Check if White can capture the Black Queen in N moves through exhaustive search, considering all possible move sequences and pawn promotions.",,algorithms,"['game theory', 'search algorithm', 'chess']"
https://www.hackerrank.com/challenges/counter-game?isFullScreen=true,"Louise and Richard have developed a numbers game.  They pick a number and check to see if it is a power of
.  If it is, they divide it by
.  If not, they reduce it by the next lower number which is a power of
.  Whoever reduces the number to
wins the game.  Louise always starts.
Given an initial value, determine who wins the game.
Example
It's Louise's turn first.  She determines that
is not a power of
.  The next lower power of
is
, so she subtracts that from
and passes
to Richard.
is a power of
, so Richard divides it by
and passes
to Louise.  Likewise,
is a power so she divides it by
and reaches
.  She wins the game.
Update
If they initially set counter to
, Richard wins.  Louise cannot make a move so she loses.
Function Description
Complete the
counterGame
function in the editor below.
counterGame has the following parameter(s):
int n:
the initial game counter value
Returns
string:
either
Richard
or
Louise
Input Format
The first line contains an integer
, the number of testcases.
Each of the next
lines contains an integer
, the initial value for each game.
Constraints
Sample Input 0
1
6
Sample Output 0
Richard
Explanation 0
is not a power of
so Louise reduces it by the largest power of
less than
:
.
is a power of
so Richard divides by
to get
and wins the game.",The player with the longer name always wins.,"If the initial number is even, Louise wins; otherwise, Richard wins.",The winner is determined by the parity of the number of prime factors of n.,"If the base-2 logarithm of n is an integer, then Richard wins; otherwise, Louise wins.",The winner is determined by the parity of the number of moves (power of 2 checks + subtractions/divisions).,,algorithms,"['game theory', 'bit manipulation', 'number theory']"
https://www.hackerrank.com/challenges/square-subsequences?isFullScreen=true,"Square Subsequences
A string is called a square string if it can be obtained by concatenating two copies of the same string. For example, ""abab"", ""aa"" are square strings, while ""aaa"", ""abba"" are not. Given a string, how many (non-empty) subsequences of the string are square strings? A subsequence of a string can be obtained by deleting zero or more characters from it, and maintaining the relative order of the remaining characters.
Input Format
The first line contains the number of test cases,
.
test cases follow. Each case contains a string,
.
Output Format
Output
lines, one for each test case, containing the required answer modulo 1000000007.
Constraints:
will have at most
lowercase characters ('a' - 'z').
Sample Input
3
aaa
abab
baaba
Sample Output
3
3
6
Explanation
For the first case, there are 3 subsequences of length 2, all of which are square strings.
For the second case, the subsequences ""abab"", ""aa"", ""bb"" are square strings.
Similarly, for the third case, ""bb"", ""baba"" (twice), and ""aa"" (3 of them) are the square subsequences.","Compute all possible subsequences and then check if each is a square string, leading to exponential time complexity.","Use dynamic programming to store the count of subsequences ending at each index, but only for half the string length.","Employ a greedy approach by selecting characters that form the longest possible palindrome, assuming this maximizes square subsequences.",Recursively divide the string into smaller halves and compute square subsequences for each half independently.,"Use dynamic programming to count matching subsequences from the beginning of the string, effectively checking for repeating patterns to build square strings.",,algorithms,"['dynamic programming', 'subsequence', 'string']"
https://www.hackerrank.com/challenges/xor-matrix?isFullScreen=true,"Consider a zero-indexed matrix with
rows and
columns, where each row is filled
gradually
. Given the first row of the matrix, you can generate the elements in the subsequent rows using the following formula:
Each row is generated one by one, from the second row through the last row. Given the first row of the matrix, find and print the elements of the last row as a single line of space-separated integers.
Note:
The
operator denotes
bitwise XOR
.
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of columns in the matrix) and
(the number of rows in the matrix).
The second line contains
space-separated integers denoting the respective values of the elements in the matrix's first row.
Constraints
Output Format
Print
space-separated integers denoting the respective values of the elements in the last row of the matrix.
Sample Input 0
4 2
6 7 1 3
Sample Output 0
1 6 2 5
Explanation 0
We use the formula given above to calculate the
values in the last row of the matrix:
We then print each value (in order) as a single line of space-separated integers.",Each element in the last row is the XOR of all the elements in the first row.,The last row will always be a repetition of the first row.,Each element in the last row is simply the first element of the first row.,Each element in the last row is the sum of the corresponding column in the rows above it.,Calculate each row iteratively using the XOR formula until the last row is determined.,,algorithms,"['matrix', 'bitwise XOR', 'iteration']"
https://www.hackerrank.com/challenges/playing-with-numbers?isFullScreen=true,"Given an array of integers, you must answer a number of queries. Each query consists of a single integer,
, and is performed as follows:
Add
to each element of the array, permanently modifying it for any future queries.
Find the absolute value of each element in the array and print the sum of the absolute values on a new line.
Tip:
The Input/Output for this challenge is
very large
, so you'll have to be creative in your approach to pass all test cases.
Function Description
Complete the
playingWithNumbers
function in the editor below.  It should return an array of integers that represent the responses to each query.
playingWithNumbers has the following parameter(s):
arr
: an array of integers
queries
: an array of integers
Input Format
The first line contains an integer
the number of elements in
.
The second line contains
space-separated integers
.
The third line contains an integer
, the number of queries.
The fourth line contains
space-separated integers
where
.
Constraints
, where
.
, where
Output Format
For each query, print the sum of the absolute values of all the array's elements on a new line.
Sample Input
3
-1 2 -3
3
1 -2 3
Sample Output
5
7
6
Explanation
Query 0:
Array:
The sum of the absolute values of the updated array's elements is
.
Query 1:
Array:
The sum of the absolute values of the updated array's elements is
.
Query 2:
Array:
The sum of the absolute values of the updated array's elements is
.",Calculate the absolute sum by iterating through the array for each query.,Maintain a cumulative sum array and update it for each query.,Use binary search to find the minimum absolute value and derive the sum.,"Store the original array and apply each query to a copy, calculating absolute values on demand.",Track the sum of the array and the number of negative elements. Update these efficiently for each query to calculate the absolute sum.,,algorithms,"['array', 'absolute value', 'cumulative sum']"
https://www.hackerrank.com/challenges/maximizing-the-function?isFullScreen=true,"Consider an array of
binary integers (i.e.,
's and
's) defined as
.
Let
be the
bitwise XOR
of all elements in the inclusive range between index
and index
in array
. In other words,
. Next, we'll define another function,
:
Given array
and
independent queries, perform each query on
and print the result on a new line. A query consists of three integers,
,
, and
, and you must find the maximum possible
you can get by changing
at most
elements in the array from
to
or from
to
.
Note:
Each query is independent and considered separately from all other queries, so changes made in one query have no effect on the other queries.
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of elements in array
) and
(the number of queries).
The second line contains
space-separated integers where element
corresponds to array element
.
Each line
of the
subsequent lines contains
space-separated integers,
,
and
respectively, describing query
.
Constraints
Subtask
and
for
of the maximum score
,
and
for
of the maximum score
Output Format
Print
lines where line
contains the answer to query
(i.e., the maximum value of
if no more than
bits are changed).
Sample Input
3 2
0 0 1
0 2 1
0 1 0
Sample Output
4
0
Explanation
Given
, we perform the following
queries:
If we change
to
, then we get
and
.
In this query,
.","Calculate the XOR sum of the range, then iterate through all possible combinations of 'k' flips within the range and return the maximum XOR sum.","Calculate the initial XOR sum. If 'k' is even, return the initial XOR sum. If 'k' is odd, flip the bit in the range that results in the greatest XOR sum.","Return the range length if k is greater than or equal to the range length, otherwise return the initial XOR sum.","Calculate the initial XOR sum. If the number of 0s in the range is less than or equal to k, return the range length. Otherwise, flip the smallest 'k' bits and return the resulting XOR sum.","Calculate the XOR sum of the range. If k is even, return the XOR sum. If k is odd, and the XOR sum is 0, flip the smallest element in the range to maximize the XOR sum; otherwise, return the existing XOR sum.",,algorithms,"['XOR', 'bit manipulation', 'arrays']"
https://www.hackerrank.com/challenges/distant-pairs?isFullScreen=true,"We take a line segment of length
on a one-dimensional plane and bend it to create a circle with circumference
that's indexed from
to
. For example, if
:
https://s3.amazonaws.com/hr-challenge-images/0/1484170037-5740fad055-101hack45-distant-pairs-ps.png
We denote a
pair
of points,
and
, as
. We then plot
pairs of points (meaning a total of
individual points) at various indices along the circle's circumference. We define the distance
between points
and
in pair
as
.
Next, let's consider two pairs:
and
. We define distance
as the
minimum
of the six distances between any two points among points
,
,
, and
. In other words:
For example, consider the following diagram in which the relationship between points in pairs at non-overlapping indices is shown by a connecting line:
https://s3.amazonaws.com/hr-challenge-images/0/1484174919-076032d241-101hack45-distant-pairs-ps-2.png
Given
pairs of points and the value of
, find and print the
maximum
value of
, where
, among all pairs of points.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of pairs of points) and
(the circumference of the circle).
Each line
of the
subsequent lines contains two space-separated integers describing the values of
and
(i.e., the locations of the points in pair
).
Constraints
Output Format
Print a single integer denoting the maximum
,
, where
.
Sample Input 0
5 8
0 4
2 6
1 5
3 7
4 4
Sample Output 0
2
Explanation 0
In the diagram below, the relationship between points in pairs at non-overlapping indices is shown by a connecting line:
https://s3.amazonaws.com/hr-challenge-images/0/1484173329-07ada37b4c-101hack45-distant-pairs-sc-0.png
As you can see, the maximum distance between any two pairs of points is
, so we print
as our answer.
Sample Input 1
2 1000
0 10
10 20
Sample Output 1
0
Explanation 1
In the diagram below, we have four individual points located at three indices:
https://s3.amazonaws.com/hr-challenge-images/0/1484173951-110496cb8b-101hack45-distant-pairs-sc-1.png
Because two of the points overlap, the minimum distance between the two pairs of points is
. Thus, we print
as our answer.",Calculate the Euclidean distance between the centroids of each pair.,"Compute the average distance between all points, then take the maximum deviation from the average.",Sort all points along the circumference and calculate the distance between adjacent points.,Consider only pairs within a fixed radius and calculate distances for those pairs.,"Iterate through all pairs of pairs, compute the minimum distance between points in each pair, and track the maximum of these minimums.",,algorithms,"['geometry', 'optimization', 'pairwise comparison']"
https://www.hackerrank.com/challenges/gena?isFullScreen=true,"The
Tower of Hanoi
is a famous game consisting of
rods and a number of discs of incrementally different diameters. The puzzle starts with the discs neatly stacked on one rod, ordered by ascending size with the smallest disc at the top. The game's objective is to move the entire stack to another rod, obeying the following rules:
Only one disk can be moved at a time.
In one move, remove the topmost disk from one rod and move it to another rod.
No disk may be placed on top of a
smaller
disk.
Gena has a modified version of the
Tower of Hanoi
. This game of
Hanoi
has
rods and
disks ordered by ascending size. Gena has already made a few moves following the rules above. Given the state of Gena's
Hanoi
, determine the minimum number of moves needed to restore the tower to its original state with all disks on rod
.
Note:
Gena's rods are numbered from
to
. The radius of a disk is its index in the input array, so disk
is the smallest disk with a radius of
, and disk
is the largest with a radius of
.
Example
In this case, the disks are arranged from large to small across the four rods.  The largest disk, disk
, is already on rod
, so move disks
and
to rod
, in that order.  It takes
moves to reset the game.
The largest disk, disk
with radius
, is already on rod
.  Disk
is on rod
and must be below disk
.  Move disk
to rod
, disk
to rod
and disk
to rod
.  Now move disk
to rod
.  It takes
moves to reset the game.
Function Description
Complete the
hanoi
function below.
hanoi
has the following parameters:
int posts[n]:
is the location of the disk with radius
Returns
int:
the minimum moves to reset the game to its initial state
Input Format
The first line contains a single integer,
, the number of disks.
The second line contains
space-separated integers, where the
integer is the index of the rod where the disk with diameter
is located.
Constraints
Sample Input
STDIN   Function
-----   --------
3       size of posts[] n = 3
1 4 1   posts = [1, 4, 1]
Sample Output
3
Explanation
moves are enough to build the tower. Here is one possible solution:
https://s3.amazonaws.com/hr-challenge-images/11782/1440789936-2576093316-gena1.png
https://s3.amazonaws.com/hr-challenge-images/11782/1440789939-3adf8c7ca6-gena2.png",Calculate the moves assuming all disks above the largest misplaced disk need to be moved to a temporary rod and then to rod 1,The number of moves is always equal to the number of misplaced disks,"Use a greedy approach, always moving the smallest misplaced disk to rod 1","Calculate the moves assuming each disk needs to be moved to rod 1 independently, ignoring the tower constraints","Iterate from largest to smallest disk; if a disk is not on rod 1, recursively calculate moves to move all smaller disks to a temporary rod, then move the current disk to rod 1, and then move the smaller disks back to rod 1",,algorithms,"['recursion', 'Tower of Hanoi', 'algorithm']"
https://www.hackerrank.com/challenges/hyper-strings?isFullScreen=true,"String
is called a
Super String
if and only if:
contains only letters
;
For any
and
,
has lower ascii code than
, where
Given a set of Super Strings
, a
Hyper String
is a string that can be constructed by concatenation of some Super Strings of the set
. We can use each Super String as many times as we want.
Given set
, you have to compute the number of Hyper Strings with length no greater than
.
Input Format
The first line of input contains two integers,
(the number of Super Strings in
) and
. The next
lines describe the Super Strings in set
.
Constraints
and
are not greater than
.
Output Format
Output an integer which is the number of possible Hyper Strings that can be derived. Since it may not fit in
bit integer, print the output module
. (i.e. answer = answer %
)
Sample Input
2 3
a
ab
Sample Output
7
Explanation
In the example all the Hyper Strings are : """" (empty string), ""
"", ""
"", ""
"", ""
"", ""
"", and ""
"".","Use a greedy approach, selecting the shortest super string at each step until the target length is reached.",Employ dynamic programming with a 2D array to store the counts of hyper strings for each length and each super string.,Recursively generate all possible combinations of super strings and count those with length no greater than N.,Sort the super strings alphabetically and use backtracking to find all hyper strings within the length limit.,"Apply dynamic programming with a 1D array to store the counts of hyper strings of each length from 0 to N, considering all super strings.",,algorithms,"['dynamic programming', 'string concatenation', 'counting']"
https://www.hackerrank.com/challenges/longest-palindromic-subsequence?isFullScreen=true,"Steve loves playing with palindromes. He has a string,
, consisting of
lowercase English alphabetic characters (i.e.,
a
through
z
). He wants to calculate the number of ways to insert exactly
lowercase character into string
such that the length of the
longest palindromic subsequence
of
increases by
at least
. Two ways are considered to be
different
if either of the following conditions are satisfied:
The positions of insertion are different.
The inserted characters are different.
This means there are
at most
different ways to insert exactly
character into a string of length
.
Given
queries consisting of
,
, and
, print the number of different ways of inserting exactly
new lowercase letter into string
such that the length of the longest palindromic subsequence of
increases by
at least
.
Input Format
The first line contains a single integer,
, denoting the number of queries. The
subsequent lines describe each query over two lines:
The first line of a query contains two space-separated integers denoting the respective values of
and
.
The second line contains a single string denoting
.
Constraints
It is guaranteed that
consists of lowercase English alphabetic letters (i.e.,
a
to
z
) only.
Subtasks
for
of the maximum score.
for
of the maximum score.
Output Format
On a new line for each query, print the number of ways to insert exactly
new lowercase letter into string
such that the length of the longest palindromic subsequence of
increases by
at least
.
Sample Input
3
1 1
a
3 2
aab
3 0
aba
Sample Output
2
1
104
Explanation
We perform the following
queries:
The length of the longest palindromic subsequence of
a
is
. There are two ways to increase this string's length by
at least
:
Insert an
a
at the start of string
, making it
aa
.
Insert an
a
at the end of string
, making it
aa
.
Both methods result in
aa
, which has a longest palindromic subsequence of length
(which is longer than the original longest palindromic subsequence's length by
). Because there are two such ways, we print
on a new line.
The length of the longest palindromic subsequence of
aab
is
. There is one way to increase the length by
at least
:
Insert a
b
at the start of string
, making it
baab
.
We only have one possible string,
baab
, and the length of its longest palindromic subsequence is
(which is longer than the original longest palindromic subsequence's length by
). Because there is one such way, we print
on a new line.",n * 25,26,25 * 26,n,n * 26,,algorithms,"['string', 'palindrome', 'subsequence']"
https://www.hackerrank.com/challenges/bear-and-steady-gene?isFullScreen=true,"A gene is represented as a string of length
(where
is divisible by
), composed of the letters
,
,
, and
.
It is considered to be
steady
if each of the four letters occurs exactly
times.  For example,
and
are both steady genes.
Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string
.  It is not necessarily steady.  Fortunately, Limak can choose one (maybe empty) substring of
and replace it with any string of the same length.
Modifying a large substring of bear genes can be dangerous.
Given a string
, can you help Limak find the length of the smallest possible substring that he can replace to make
a steady gene?
Note
: A substring of a string
is a subsequence made up of zero or more
contiguous
characters of
.
As an example, consider
.  The substring
just before or after
can be replaced with
or
.  One selection would create
.
Function Description
Complete the
function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.
steadyGene has the following parameter:
gene
: a string
Input Format
The first line contains an interger
divisible by
, that denotes the length of a string
.
The second line contains a string
of length
.
Constraints
is divisible by
Subtask
in tests worth
points.
Output Format
Print the length of the minimum length substring that can be replaced to make
stable.
Sample Input
8
GAAATAAA
Sample Output
5
Explanation
One optimal solution is to replace
with
resulting in
.
The replaced substring has length
.",Use dynamic programming to find the longest common substring.,Sort the string and then replace the smallest substring containing the extra characters.,Greedily replace the leftmost occurrences of excessive characters until the gene is steady.,Calculate the frequency of each character and replace characters in the substring with the lowest frequencies.,"Use a sliding window technique to find the smallest substring that, when replaced, makes the gene steady.",,algorithms,"['string manipulation', 'sliding window', 'optimization']"
https://www.hackerrank.com/challenges/equal?isFullScreen=true,"Christy is interning at HackerRank. One day she has to distribute some chocolates to her colleagues. She is biased towards her friends and plans to give them more than the others. One of the program managers hears of this and tells her to make sure everyone gets the same number.
To make things difficult, she must equalize the number of chocolates in a series of operations. For each operation, she can give
pieces to all but one colleague.  Everyone who gets a piece in a round receives the same number of pieces.
Given a starting distribution, calculate the minimum number of operations needed so that every colleague has the same number of pieces.
Example
represents the starting numbers of pieces for each colleague.  She can give
pieces to the first two and the distribution is then
.  On the next round, she gives the same two
pieces each, and everyone has the same number:
.  Return the number of rounds,
.
Function Description
Complete the
equal
function in the editor below.
equal has the following parameter(s):
int arr[n]:
the integers to equalize
Returns
int:
the minimum number of operations required
Input Format
The first line contains an integer
, the number of test cases.
Each test case has
lines.
- The first line contains an integer
, the number of colleagues and the size of
.
- The second line contains
space-separated integers,
, the numbers of pieces of chocolate each colleague has at the start.
Constraints
The number of chocolates each colleague has initially <
.
Sample Input
STDIN       Function
-----       --------
1           t = 1
4           arr[] size n = 4
2 2 3 7     arr =[2, 2, 3, 7]
Sample Output
2
Explanation
Start with
Add
to all but the 3
rd
element
Add
to all but the 4
th
element
Two operations were required.
Sample Input 1
1
3
10 7 12
Sample Output 1
3
Explanation 1
Start with
Add
to the first two elements
Add
to the last two elements
Add
to the last two elements
Three operations were required.",Calculate the difference from the maximum value in the array and sum those differences.,Sort the array and iteratively apply operations to bring all elements to the smallest value.,Find the median value and perform operations to bring all elements to the median.,"For each element, calculate the operations needed to reach the average value and sum them.","Iterate through 5 potential minimum values (min, min-1, min-2, min-3, min-4) and choose the one yielding the fewest operations.",,algorithms,"['greedy algorithm', 'optimization', 'array']"
https://www.hackerrank.com/challenges/chief-hopper?isFullScreen=true,"Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building
and at a height of
.  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.
Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:
If the bot's
is less than the height of the building, his
If the bot's
is greater than the height of the building, his
Example
Starting with
, we get the following table:
botEnergy   height  delta
    4               2       +2
    6               3       +3
    9               4       +5
    14              3       +11
    25              2       +23
    48
That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting
in this case is
.
Function Description
Complete the
chiefHopper
function in the editor below.
chiefHopper has the following parameter(s):
int arr[n]:
building heights
Returns
int:
the minimum starting
Input Format
The first line contains an integer
, the number of buildings.
The next line contains
space-separated integers
, the heights of the buildings.
Constraints
where
Sample Input 0
5
3 4 3 2 4
Sample Output 0
4
Explanation 0
If initial energy is 4, after step 1 energy is 5, after step 2 it's 6, after step 3 it's 9 and after step 4 it's 16, finally at step 5 it's 28.
If initial energy were 3 or less, the bot could not complete the course.
Sample Input 1
3
4 4 4
Sample Output 1
4
Explanation 1
In the second test case if bot has energy 4, it's energy is changed by (4 - 4 = 0) at every step and remains 4.
Sample Input 2
3
1 6 4
Sample Output 2
3
Explanation 2
botEnergy   height  delta
3           1       +2
5           6       -1
4           4       0
4
We can try lower values to assure that they won't work.","Binary search through the possible energy values, checking each value by simulating the bot's jumps and energy levels from left to right.","Calculate the sum of all building heights and divide by the number of buildings. Then, round up to the nearest integer.","Start with an initial energy equal to the average height of the buildings, then iterate through the buildings and adjust the initial energy based on the largest height difference encountered.","Iterate through the building heights, keeping track of the minimum energy required at each step without going below zero, and return the maximum of these minimum values.","Iterate backwards through the building heights, calculating the minimum required energy at each step based on the energy needed for the next building.",,algorithms,"['dynamic programming', 'binary search', 'simulation']"
https://www.hackerrank.com/challenges/maximum-subarray-sum?isFullScreen=true,"We define the following:
A
subarray
of array
of length
is a contiguous segment from
through
where
.
The
sum
of an array is the sum of its elements.
Given an
element array of integers,
, and an integer,
, determine the maximum value of the sum of any of its subarrays modulo
.
Example
The following table lists all subarrays and their moduli:
sum
%
2
[
1
]
1
1
[
2
]
2
0
[
3
]
3
1
[
1
,
2
]
3
1
[
2
,
3
]
5
1
[
1
,
2
,
3
]
6
0
The maximum modulus is
.
Function Description
Complete the
maximumSum
function in the editor below.
maximumSum has the following parameter(s):
long a[n]:
the array to analyze
long m:
the modulo divisor
Returns
-
long:
the maximum (subarray sum modulo
)
Input Format
The first line contains an integer
, the number of queries to perform.
The next
pairs of lines are as follows:
The first line contains two space-separated integers
and (long)
, the length of
and the modulo divisor.
The second line contains
space-separated long integers
.
Constraints
the sum of
over all test cases
Sample Input
STDIN       Function
-----       --------
1           q = 1
5 7         a[] size n = 5, m = 7
3 3 9 9 5
Sample Output
6
Explanation
The subarrays of array
and their respective sums modulo
are ranked in order of length and sum in the following list:
and
and
The maximum value for
for any subarray is
.",Calculate the prefix sum array and find the maximum difference between any two elements.,Sort the array and calculate the sum of the largest element modulo m.,"Calculate all possible subarray sums, store them in a list, take the modulo of each, and then find the maximum.",Iterate through each element and return that element modulo m if it is greater than the current max.,Use a TreeSet to store prefix sums modulo m and find the smallest element greater than the current prefix sum modulo m.,,algorithms,"['prefix sum', 'modulo', 'subarray']"
https://www.hackerrank.com/challenges/synchronous-shopping?isFullScreen=true,"Bitville is a seaside city that has a number of shopping centers connected by bidirectional roads, each of which has a travel time associated with it.  Each of the shopping centers may have a fishmonger who sells one or more kinds of fish.  Two cats,
Big Cat
and
Little Cat
, are at shopping center
(each of the centers is numbered consecutively from
to
).  They have a list of fish they want to purchase, and to save time, they will divide the list between them.  Determine the total travel time for the cats to purchase all of the types of fish, finally meeting at shopping center
.  Their paths may intersect, they may backtrack through shopping center
, and one may arrive at a different time than the other.  The minimum time to determine is when both have arrived at the destination.
For example, there are
shopping centers selling
types of fish.  The following is a graph that shows a possible layout of the shopping centers connected by
paths.  Each of the centers is labeled
.  Here
and
represent
Big Cat
and
Little Cat
, respectively.  In this example, both cats take the same path, i.e.
and arrive at time
having purchased all three types of fish they want.  Neither cat visits shopping centers
or
.
https://s3.amazonaws.com/hr-assets/0/1544041107-a20059b5a2-SynchronousShoppingExample.png
Function Description
Complete the
shop
function in the editor below.  It should return an integer that represents the minimum time required for their shopping.
shop has the following parameters:
-
n
: an integer, the number of shopping centers
-
k
: an integer, the number of types of fish
-
centers
: an array of strings of space-separated integers where the first integer of each element is the number of types of fish sold at a center and the remainder are the types sold
-
roads
: a 2-dimensional array of integers where the first two values are the shopping centers connected by the bi-directional road, and the third is the travel time for that road
Input Format
The first line contains
space-separated integers:
(the number of shopping centers),
(the number of roads), and
(the number of types of fish sold in Bitville), respectively.
Each line
of the
subsequent lines (
) describes a shopping center as a line of space-separated integers. Each line takes the following form:
The first integer,
, denotes the number of types of fish that are sold by the fishmonger at the
shopping center.
Each of the
subsequent integers on the line describes a type of fish sold by that fishmonger, denoted by
, where
going forward.
Each line
of the
subsequent lines (
) contains
space-separated integers that describe a road. The first two integers,
and
, describe the two shopping centers it connects. The third integer,
, denotes the amount of time it takes to travel the road.
Constraints
All
are different for every fixed
.
Each road connectes
distinct shopping centers (i.e., no road connects a shopping center to itself).
Each pair of shopping centers is directly connected by no more than
road.
It is possible to get to any shopping center from any other shopping center.
Each type of fish is always sold by at least one fishmonger.
Output Format
Print the minimum amount of time it will take for the cats to collectively purchase all
fish and meet up at shopping center
.
Sample Input
5 5 5
1 1
1 2
1 3
1 4
1 5
1 2 10
1 3 10
2 4 10
3 5 10
4 5 10
Sample Output
30
Explanation
https://s3.amazonaws.com/hr-assets/0/1544037692-e51dbc72a0-SynchronousShoppingSample0.png
represents a location
Big Cat
visits,
represents a location where
Little Cat
visits.
Big Cat
can travel
and buy fish at all of the shopping centers on his way.
Little Cat
can then travel
, and buy fish from the fishmonger at the
shopping center only.","Use Dijkstra's algorithm on the first cat and then apply Bellman-Ford for the second cat's path, combining results.",Run a single Dijkstra's algorithm from shopping center 1 and then multiply the result by 2.,"Perform a brute-force search, exploring all possible paths for both cats and selecting the minimum combined time.",Use Prim's algorithm to find the minimum spanning tree and then calculate the path through that tree.,"Use Dijkstra's algorithm with a bitmask representing the fish collected, considering both cats simultaneously to minimize total time.",,algorithms,"['graph algorithm', ""Dijkstra's"", 'bitmask']"
https://www.hackerrank.com/challenges/subset-component?isFullScreen=true,"You are given an array with
-bit integers:
.
BIT(x, i) = (x >> i) & 1, where
is the
lower bit of
in binary form.  If we regard every bit as a vertex of a graph G, there is an undirected edge between vertices
and
if there is a value
such that BIT(d[k], i) == 1 && BIT(d[k], j) == 1.
For every subset of the input array, how many
connected-components
are there in that graph?
A connected component in a graph is a set of nodes which are accessible to each other via a path of edges. There may be multiple connected components in a graph.
Example
In the real challenge, there will be
nodes associated with each integer in
represented as a
bit binary value.  For clarity, only
bits will be shown in the example but all
will be considered in the calculations.
Decimal  Binary Edges   Node ends
    d[0] = 1   0001   0
    d[1] = 2   0010   0
    d[2] = 3   0011   1       0 and 1
    d[3] = 5   0101   1       0 and 2
Consider all subsets:
Edges
    Subset   Count  Nodes  Connected components
    {1}         0           64
    {2}         0           64
    {3}         1   0-1     63
    {5}         1   0-2     63
    {1,2}       0           64
    {1,3}       1   0-1     63
    {1,5}       1   0-2     63
    {2,3}       1   0-1     63
    {2,5}       1   0-2     63
    {3,5}       2   0-1-2   62
    {1,2,3}     1   0-1     63
    {1,2,5}     1   0-2     63
    {1,3,5}     2   0-1-2   62
    {2,3,5}     2   0-1-2   62
    {1,2,3,5}   2   0-1-2   62
    Sum                    944
The values
and
have
bits set, so they have
edge each.  If a subset contains only a
or
, there will be one connected component with
nodes, and
components with
node for a total of
.
If both
and
are in a subset,
component with nodes
and
is formed since node
is one end of each edge described.  The other
nodes are solitary, so there are
connected components total.
All other values have only
bit set, so they have no edges.  They have
components with
node each.
Function Description
Complete the
findConnectedComponents
function in the editor below.
findConnectedComponents has the following parameters:
int d[n]:
an array of integers
Returns
int:
the sum of the number of connected components for all subsets of
Input Format
The first row contains the integer
, the size of
.
The next row has
space-separated integers,
.
Constraints",O(n^2) - Compare each subset individually.,O(n log n) - Sort the input array first.,"O(2^n * m) - Iterate through all subsets and perform a depth-first search (DFS) to find connected components, where m is the number of bits.",O(n*m) - Perform bitwise operations on all array elements,"O(n * 2^n) - Iterate through all possible subsets (2^n) and for each subset, compute connected components based on bitwise operations.",,algorithms,"['graph theory', 'bitwise operations', 'subsets']"
https://www.hackerrank.com/challenges/mr-k-marsh?isFullScreen=true,"Mr K has a rectangular plot of land which may have marshes where fenceposts cannot be set. He wants you to find the perimeter of the largest rectangular fence that can be built on this land.
For example, in the following
grid,
marks a marsh and
marks good land.
....
..x.
..x.
x...
If we number the rows and columns starting with
, we see that there are two main areas that can be fenced:
and
.  The longest perimeter is
.
Function Description
Complete the
kMarsh
function in the editor below.  It should print either an integer or
impossible
.
kMarsh has the following parameter(s):
grid
: an array of strings that represent the grid
Input Format
The first line contains two space-separated integers
and
, the grid rows and columns.
Each of the next
lines contains
characters each describing the state of the land. 'x' (ascii value: 120) if it is a marsh and '.' ( ascii value:46) otherwise.
Constraints
Output Format
Output contains a single integer - the largest perimeter. If the rectangular fence cannot be built, print
impossible
.
Sample Input 0
4 5
.....
.x.x.
.....
.....
Sample Output 0
14
Explanation 0
The fence can be put up around the entire field. The perimeter is
.
Sample Input 1
2 2
.x
x.
Sample Output 1
impossible
Explanation 1
We need a minimum of 4 points to place the 4 corners of the fence. Hence, impossible.
Sample Input 2
2 5
.....
xxxx.
Sample Output 2
impossible","Use dynamic programming to find the largest rectangle, considering marshes as obstacles, storing results in a 2D array of maximum perimeters.","Iterate through all possible rectangles, checking each cell within the rectangle to ensure it's not a marsh. Return the largest perimeter found or 'impossible'.","Employ a recursive function to explore possible rectangular fence configurations, pruning branches when a marsh is encountered, and returning the maximum perimeter.","Calculate the area of all possible rectangles and choose the one with the largest area, assuming area maximization leads to perimeter maximization.","Precompute a 2D array indicating reachable land from the top-left corner, then iterate through all possible rectangle corners to find the largest perimeter with no marshes.",,algorithms,"['dynamic programming', 'grid traversal', 'rectangle']"
https://www.hackerrank.com/challenges/sherlocks-array-merging-algorithm?isFullScreen=true,"Watson gave Sherlock a collection of arrays
. Here each
is an array of variable length. It is guaranteed that if you merge the arrays into one single array, you'll get an array,
, of
distinct integers in the range
.
Watson asks Sherlock to merge
into a sorted array. Sherlock is new to coding, but he accepts the challenge and writes the following algorithm:
(an empty array).
number of arrays in the collection
.
While there is at least one non-empty array in
:
(an empty array) and
.
While
:
If
is not empty:
Remove the first element of
and push it to
.
.
While
is not empty:
Remove the minimum element of
and push it to
.
Return
as the
output
.
Let's see an example. Let V be
.
https://s3.amazonaws.com/hr-assets/0/1487236255-0a10b84d71-sherlock4.png
The image below demonstrates how Sherlock will do the merging according to the algorithm:
https://s3.amazonaws.com/hr-assets/0/1487236775-99cec837ef-sherlock7.png
Sherlock isn't sure if his algorithm is correct or not. He ran Watson's
input
,
, through his pseudocode algorithm to produce an
output
,
, that contains an array of
integers. However, Watson forgot the contents of
and only has Sherlock's
with him! Can you help Watson reverse-engineer
to get the original contents of
?
Given
, find the number of different ways to create collection
such that it produces
when given to Sherlock's algorithm as
input
. As this number can be quite large, print it modulo
.
Notes:
Two collections of arrays are
different
if one of the following is
true
:
Their sizes are different.
Their sizes are the same but at least one array is present in one collection but not in the other.
Two arrays,
and
, are different if one of the following is
true
:
Their sizes are different.
Their sizes are the same, but there exists an index
such that
.
Input Format
The first line contains an integer,
, denoting the size of array
.
The second line contains
space-separated integers describing the respective values of
.
Constraints
Output Format
Print the number of different ways to create collection
, modulo
.
Sample Input 0
3
1 2 3
Sample Output 0
4
Explanation 0
There are four distinct possible collections:
.
Thus, we print the result of
as our answer.
Sample Input 1
2
2 1
Sample Output 1
1
Explanation 1
The only distinct possible collection is
, so we print the result of
as our answer.",Compute the number of partitions of the array into contiguous subarrays.,Calculate the power set of the array and count the valid combinations.,Count the number of subsequences of the array that are sorted.,"Apply dynamic programming to determine the number of ways to divide the array such that each division represents a valid input to Sherlock's algorithm, considering only strictly increasing subsequences","Use dynamic programming with memoization to count valid partitions, where each partition point 'i' represents a possible split and the subsequent elements must be greater than or equal to the last element of the previous subarray.",,algorithms,"['dynamic programming', 'partitions', 'memoization']"
https://www.hackerrank.com/challenges/array-splitting?isFullScreen=true,"Nikita just came up with a new array game. The rules are as follows:
Initially, Nikita has an array of integers.
In each move, Nikita must partition the array into
non-empty contiguous parts such that the sum of the elements in the left partition is equal to the sum of the elements in the right partition. If Nikita can make such a move, she gets
point; otherwise, the game ends.
After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array
.
Nikita loves this game and wants your help getting the best score possible. Given
, can you find and print the maximum number of points she can score?
For example, Nikita starts with the array
.  She first splits it into
and
, then discards
.
.  Discard
leaving
.  This cannot be further split, so Nikita scored
.
Function Description
Complete the
arraySplitting
function in the editor below.  It should return an integer that reperesents the number of times Nikita can split the array.
arraySplitting has the following parameter(s):
arr
: an array of integers
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
pairs of lines is as follows:
The first line contains an integer
, the size of array
.
The next line contains
space-separated integers
.
Constraints
Scoring
for
of the test data
for
of the test data
for
of the test data
Output Format
For each test case, print Nikita's maximum possible score on a new line.
Sample Input
3
3
3 3 3
4
2 2 2 2
7
4 1 0 1 1 0 1
Sample Output
0
2
3
Explanation
Test Case 0:
Nikita cannot partition
into
parts having equal sums. Therefore, her maximum possible score is
and we print
on a new line.
Test Case 1:
Initially,
looks like this:
https://s3.amazonaws.com/hr-challenge-images/16423/1458891077-134273d179-split3.png
She splits the array into
partitions having equal sums, and then discards the left partition:
https://s3.amazonaws.com/hr-challenge-images/16423/1458890937-8e9211544a-split1.png
She then splits the new array into
partitions having equal sums, and then discards the left partition:
https://s3.amazonaws.com/hr-challenge-images/16423/1458891080-141706afdb-split2.png
At this point the array only has
element and can no longer be partitioned, so the game ends. Because Nikita successfully split the array twice, she gets
points and we print
on a new line.
Test Case 2:
array
a1
a2
[
4
,
1
,
0
,
1
,
1
,
0
,
1
]
[
4
]
[
1
,
0
,
1
,
1
,
0
,
1
]
[
1
,
0
,
1
,
1
,
0
,
1
]
[
1
,
0
,
1
]
[
1
,
0
,
1
]
[
1
,
0
,
1
]
[
1
,
0
]
[
1
]
The answer is
.","Return 0 if the array has only one element; otherwise, return 1",Return the floor of the array's length divided by 2,"Return the array's length minus 1 if all elements are equal; otherwise, return 0","Return 1 if the sum of all elements is even; otherwise, return 0","Recursively split the array into two equal sum partitions, adding 1 to the score for each successful split and continuing with the remaining partition",,algorithms,"['array', 'recursion', 'summation']"
https://www.hackerrank.com/challenges/ticket?isFullScreen=true,"There are
people at the railway station, and each one wants to buy a ticket to go to one of
different destinations. The
people are in a queue.
There are
ticket windows from which tickets can be purchased. The
people will be distributed in the windows such that
the order is maintained
. In other words, suppose we number the people
to
from front to back. If person
and person
go to the same window and
, then person
should still be ahead of person
in the window.
Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.
For example, suppose there are
people in the queue for a single ticket window, all with the same destination which costs
bucks. Then the first person in the queue pays
bucks, and the 2nd and 3rd persons get a discount of 20% on
bucks, so they end up paying
bucks each instead of
bucks.
Try to distribute the
people across the
windows such that the total cost
paid by all
people is minimized.
Input Format
The first line contains
integers:
is the number of people
is the number of ticket windows
is the number of destinations separated by a single space (in the same order)
Then
lines follow. The
line contains an alphanumeric string
and an integer
:
is the
destination
is the ticket price for
Then
lines follow. The
line contains an alphanumeric string
which is the destination of the
person.
Constraints
The
available destinations have nonempty and distinct names.
Each person's destination appears in the list of
available destinations.
Output Format
Output
lines. The first line contains
, the total cost that is to be minimized. In the
following line, print the ticket window which the
person goes to. The windows are indexed
to
. There may be multiple ways to distribute the people among the windows such that the total cost is minimized; any one will be accepted.
The answer
will be accepted if it is within an error of
of the true answer.
Sample Input
5 2 3
CALIFORNIA 10
HAWAII 8
NEWYORK 12
NEWYORK
NEWYORK
CALIFORNIA
NEWYORK
HAWAII
Sample Output
49.2
1
1
2
1
1
Explanation
At the beginning, all the people are in the same queue, and will go to the ticket windows one by one in the initial order.
will buy ticket in the first window.
will buy ticket in the second window.
In the first ticket window, #1 will pay
bucks to go to
NEWYORK
, and #2 and #4 have the same destination with the person in front of them, so they will get 20% off, and will pay
bucks each. #5 has a different destination, so it will cost him
bucks to go to
HAWAII
.
In the second ticket window, #3 will pay
bucks to go to
CALIFORNIA
.","Use a greedy approach, assigning each person to the window with the lowest current cost.",Sort people by destination and assign them to windows based on destination frequency.,Calculate the cost for each possible window assignment and choose the minimum using recursion without memoization.,"Assign people to windows in a round-robin fashion, regardless of destination.",Use dynamic programming to find the minimum cost by considering all possible assignments of people to windows.,,algorithms,"['dynamic programming', 'optimization', 'queue']"
https://www.hackerrank.com/challenges/coprime-paths?isFullScreen=true,"You are given an undirected, connected graph,
, with
nodes and
edges where
. Each node
is initially assigned a value,
, that has
at most
prime divisors.
You must answer
queries in the form
u v
. For each query, find and print the
number of
pairs
of nodes on the path between
and
such that
and the length of the path between
and
is minimal among all paths from
to
.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
The second line contains
space-separated integers describing the respective values of
.
Each of the
subsequent lines contains two space-separated integers,
and
, describing an edge between nodes
and
.
Each of the
subsequent lines contains two space-separated integers,
and
, describing a query.
Constraints
Output Format
For each query, print an integer on a new line denoting the
number of
pairs
of nodes on the path between
and
such that
and the length of the path between
and
is minimal among all paths from
to
.
Sample Input 0
6 5
3 2 4 1 6 5
1 2
1 3
2 4
2 5
3 6
4 6
5 6
1 1
1 6
6 1
Sample Output 0
9
6
0
3
3
Explanation 0
The diagram below depicts graph
and the
paths specified by each query, as well as the
Pair Values
for each path in the form
:
https://s3.amazonaws.com/hr-challenge-images/0/1482360845-85c6797f26-woc-coprime-pairs.png
Recall that, for each queried path, we want to find and print the number of
pairs of nodes such that
.",Use Depth-First Search (DFS) to enumerate all possible paths and then check for coprimality and minimal path length.,Precompute all pairwise shortest paths using Floyd-Warshall and then iterate over the precomputed paths to count coprime pairs.,"Apply Dijkstra's algorithm to find the shortest path, then iterate through the nodes in the shortest path and use memoization to improve efficiency.","Employ a greedy algorithm by always choosing the edge with the smallest weight, ignoring coprimality and path length minimality.","Perform Breadth-First Search (BFS) to find the shortest path, and simultaneously compute the number of coprime pairs on each shortest path found.",,algorithms,"['graph theory', 'coprime', 'shortest path']"
https://www.hackerrank.com/challenges/the-time-in-words?isFullScreen=true,"Given the time in numerals we may convert it into words, as shown below:
At
, use
o' clock
.  For
, use
past
, and for
use
to
.  Note the space between the apostrophe and
clock
in
o' clock
.  Write a program which prints the time in words for the input given in the format described.
Function Description
Complete the
timeInWords
function in the editor below.
timeInWords has the following parameter(s):
int h:
the hour of the day
int m:
the minutes after the hour
Returns
string:
a time string as described
Input Format
The first line contains
, the hours portion
The second line contains
, the minutes portion
Constraints
Sample Input 0
5
47
Sample Output 0
thirteen minutes to six
Sample Input 1
3
00
Sample Output 1
three o' clock
Sample Input 2
7
15
Sample Output 2
quarter past seven",Use a series of if/else statements to handle each possible minute value individually.,Create a lookup table containing all possible time phrases and use h and m as indices.,Convert the hour and minute integers to strings and concatenate them with appropriate words.,Employ a recursive function that iteratively breaks down the time into smaller units.,"Use lookup arrays/dictionaries for numbers and phrases, combined with conditional logic for 'past', 'to', and 'o' clock'.",,algorithms,"['string manipulation', 'conditionals', 'lookup table']"
https://www.hackerrank.com/challenges/yet-another-minimax-problem?isFullScreen=true,"You are given
non-negative integers,
. We define the
score
for some permutation (
) of length
to be the maximum of
for
.
Find the permutation with the minimum possible score and print its score.
Note:
is the
exclusive-OR
(XOR) operator.
Input Format
The first line contains single integer,
, denoting the number of integers.
The second line contains
space-separated integers,
, describing the respective integers.
Constraints
Output Format
Print a single integer denoting the minimum possible score.
Sample Input 0
4
1 2 3 4
Sample Output 0
5
Sample Input 1
3
1 2 3
Sample Output 1
2
Explanation
Sample Case 0:
The permutation with the
minimum score
is
:
Because the permutation's score is the
maximum
of these values, we print
on a new line.
Sample Case 1:
The permutation with the
minimum score
is
:
Because the permutation's score is the
maximum
of these values, we print
on a new line.",The minimum XOR value among all pairs of numbers in the array.,The XOR of the smallest and largest numbers in the array.,The median value of the sorted array.,The largest number in the array.,"Half the maximum number in the array, rounded up to the nearest integer.",,algorithms,"['XOR', 'permutations', 'optimization']"
https://www.hackerrank.com/challenges/walking-the-approximate-longest-path?isFullScreen=true,"Jenna is playing a computer game involving a large map with
cities numbered sequentially from
to
that are connected by
bidirectional roads. The game's objective is to travel to as many cities as possible without visiting any city more than once. The more cities the player visits, the more points they earn.
As Jenna's fellow student at Hackerland University, she asks you for help choosing an optimal path. Given the map, can you help her find a path that maximizes her score?
Note:
She can start and end her path at any two distinct cities.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of cities) and
(the number of roads).
Each line
of the
subsequent lines contains two space-separated integers,
and
, describing a bidirectional road between cities
and
.
Map Generation Algorithm
The graph representing the map was generated randomly in the following way:
Initially, the graph was empty.
Permutations
were chosen uniformly at random among all
permutations.
For each
, edge
was added to the graph.
An additional
edges were chosen uniformly at random among all possible sets of
edges which don't intersect with edges added during step
.
Constraints
For
of test
and
.
For
of test
and
.
For
of test
and
.
It's guaranteed that a valid path of length
always exists.
Scoring
A valid path of length
earns
of a test case's available points. The total score will be rounded to next
.
Output Format
Print the following two lines of output:
The first line must contain a single integer,
, denoting the length of the path.
The second line must contain
distinct space-separated integers describing Jenna's path in the same order in which she visited each city.
Sample Input 0
4 5
3 1
3 4
2 4
2 3
4 1
Sample Output 0
4
1 4 2 3
Explanation 0
The diagrams below depict the city's initial map, an optimal path that would earn a full score, and an alternative path that would earn a partial score:
https://s3.amazonaws.com/hr-challenge-images/0/1478735142-1f1c6a35d2-walk-the-approximate-longest-path.png
In the optimal path (center image), Jenna walks the path
. This answer earns
of the maximum score because the path length,
, is equal to
(i.e., she was able to visit every city exactly once).
In the alternative path (right image), Jenna walks the path
for
of the maximum score.",Always choose the shortest path between two cities to reduce the overall path length.,Perform a Depth-First Search (DFS) from a random starting city and backtrack when a dead-end is reached.,Apply a greedy algorithm by repeatedly selecting the city with the fewest unvisited neighbors.,Use a Minimum Spanning Tree (MST) algorithm to find the minimum cost path through all cities.,"Find a Hamiltonian path (or a close approximation) in the graph, visiting each city exactly once.",,algorithms,"['graph theory', 'pathfinding', 'Hamiltonian path']"
https://www.hackerrank.com/challenges/almost-sorted?isFullScreen=true,"Given an array of integers, determine whether the array can be sorted in ascending order using only one of the following operations one time.
Swap two elements.
Reverse one sub-segment.
Determine whether one, both or neither of the operations will complete the task. Output is as follows.
If the array is already sorted, output
yes
on the first line. You do not need to output anything else.
If you can sort this array using one single operation (from the two permitted operations) then output
yes
on the first line and then:
If elements can only be swapped,
and
, output
swap l r
in the second line.
and
are the indices of the elements to be swapped, assuming that the array is indexed from
to
.
If elements can only be reversed, for the segment
, output
reverse l r
in the second line.
and
are the indices of the first and last elements of the subarray to be reversed, assuming that the array is indexed from
to
. Here
represents the subarray that begins at index
and ends at index
, both inclusive.
If an array can be sorted both ways, by using either swap or reverse, choose swap.
If the array cannot be sorted either way, output
no
on the first line.
Example
Either swap the
and
at indices 3 and 4, or reverse them to sort the array.  As mentioned above, swap is preferred over reverse.  Choose swap. On the first line, print
yes
.  On the second line, print
swap 3 4
.
Function Description
Complete the
almostSorted
function in the editor below.
almostSorted has the following parameter(s):
int arr[n]
:  an array of integers
Prints
Print the results as described and return nothing.
Input Format
The first line contains a single integer
, the size of
.
The next line contains
space-separated integers
where
.
Constraints
All
are distinct.
Output Format
If the array is already sorted, output
yes
on the first line. You do not need to output anything else.
If you can sort this array using one single operation (from the two permitted operations) then output
yes
on the first line and then:
a.
If elements can be swapped,
and
, output
swap l r
in the second line.
and
are the indices of the elements to be swapped, assuming that the array is indexed from
to
.
b.
Otherwise, when reversing the segment
, output
reverse l r
in the second line.
and
are the indices of the first and last elements of the subsequence to be reversed, assuming that the array is indexed from
to
.
represents the sub-sequence of the array, beginning at index
and ending at index
, both inclusive.
If an array can be sorted by either swapping or reversing, choose swap.
If you cannot sort the array either way, output
no
on the first line.
Sample Input 1
STDIN   Function
-----   --------
2       arr[] size n = 2
4 2     arr = [4, 2]
Sample Output 1
yes
swap 1 2
Explanation 1
You can either
swap(1, 2)
or
reverse(1, 2)
.  You prefer swap.
Sample Input 2
3
3 1 2
Sample Output 2
no
Explanation 2
It is impossible to sort by one single operation.
Sample Input 3
6
1 5 4 3 2 6
Sample Output 3
yes
reverse 2 5
Explanation 3
You can reverse the sub-array
d[2...5] = ""5 4 3 2""
, then the array becomes sorted.",Only a single swap can always correct the array if it is not sorted initially,Reversing a subsegment guarantees the array will be sorted if not initially,"If more than two elements are out of order, neither operation will sort the array",The problem can be solved efficiently using dynamic programming to find the optimal swap or reverse,"Identify the out-of-order segments, then test if a single swap or reverse operation will sort the array",,algorithms,"['array manipulation', 'sorting', 'conditional logic']"
https://www.hackerrank.com/challenges/tower-breakers-again-1?isFullScreen=true,"Two players (numbered
and
) are playing a game of Tower Breakers! The rules of the game are as follows:
Player
always moves first.
Initially there are
towers of various heights.
The players move in alternating turns. In each turn, a player must choose a tower of height
and break it down into
towers, each of height
. The numbers
and
must satisfy
and
.
If the current player is unable to make any move, they lose the game.
Given the value of
and the respective height values for all towers, can you determine who will win, assuming both players always move
optimally
? If the first player wins, print
; otherwise, print
.
Input Format
The first line contains an integer,
, denoting the number of test cases.
The
subsequent lines define the test cases. Each test case is described by two lines:
An integer,
, denoting the number of towers.
space-separated integers,
, where each
describes the height of tower
.
Constraints
Output Format
For each test case, print a single integer denoting the winner (i.e., either
or
) on a new line.
Sample Input
2
2
1 2
3
1 2 3
Sample Output
1
2
Explanation
In the first test case, the first player simply breaks down the second tower of height
into two towers of height
and wins.
In the second test case, there are only two possible moves:
Break the second tower into
towers of height
.
Break the third tower into
towers of height
.
Whichever move player
makes, player
can make the other move and win the game.","If the number of towers is even, player 2 always wins.","If any tower has a height of 1, player 2 always wins.",The winner is determined by whether the sum of the prime factors of all tower heights is even or odd.,"If all tower heights are prime numbers, player 1 always wins.","The winner is determined by the parity of the count of towers with height greater than 1. If the count is even, player 2 wins, otherwise player 1 wins.",,algorithms,"['game theory', 'parity', 'optimal strategy']"
https://www.hackerrank.com/challenges/making-candies?isFullScreen=true,"Karl loves playing games on social networking sites. His current favorite is
CandyMaker
, where the goal is to make candies.
Karl just started a level in which he must accumulate
candies starting with
machines and
workers. In a single
pass
, he can make
candies.  After each pass, he can decide whether to spend some of his candies to buy more machines or hire more workers. Buying a machine or hiring a worker costs
units, and there is no limit to the number of machines he can own or workers he can employ.
Karl wants to minimize the number of passes to obtain the required number of candies at the end of a day. Determine that number of passes.
For example, Karl starts with
machine and
workers.  The cost to purchase or hire,
and he needs to accumulate
candies.  He executes the following strategy:
Make
candies.  Purchase two machines.
Make
candies.  Purchase
machines and hire
workers.
Make
candies. Retain all
candies.
Make
candies. With yesterday's production, Karl has
candies.
It took
passes to make enough candies.
Function Description
Complete the
minimumPasses
function in the editor below.  The function must return a long integer representing the minimum number of passes required.
minimumPasses has the following parameter(s):
m
: long integer, the starting number of machines
w
: long integer, the starting number of workers
p
: long integer, the cost of a new hire or a new machine
n
: long integer, the number of candies to produce
Input Format
A single line consisting of four space-separated integers describing the values of
,
,
, and
, the starting number of machines and workers, the cost of a new machine or a new hire, and the the number of candies Karl must accumulate to complete the level.
Constraints
Output Format
Return a long integer denoting the minimum number of passes required to accumulate at least
candies.
Sample Input
3 1 2 12
Sample Output
3
Explanation
Karl makes three passes:
In the first pass, he makes
candies. He then spends
of them hiring another worker, so
and he has one candy left over.
In the second pass, he makes
candies. He spends
of them on another machine and another worker, so
and
and he has
candies left over.
In the third pass, Karl makes
candies. Because this satisfies his goal of making at least
candies, we print the number of passes (i.e.,
) as our answer.","Use a greedy approach, always buying machines or workers based on which provides the most immediate candy production increase.","Perform a binary search on the number of passes, simulating the candy production and purchasing strategy for each pass count.",Calculate the optimal number of machines and workers beforehand and divide the target candies by the resulting production rate.,"Simulate the process for a fixed number of passes, then extrapolate to find the estimated minimum number of passes.","Simulate the candy production, buying machines or workers to balance production, and track the minimum number of passes required using long integers to avoid overflow.",,algorithms,"['optimization', 'simulation', 'greedy']"
https://www.hackerrank.com/challenges/the-grid-search?isFullScreen=true,"Given an array of strings of digits, try to find the occurrence of a given pattern of digits. In the grid and pattern arrays, each string represents a row in the grid.  For example, consider the following grid:
1234567890
09
876543
21
11
111111
11
11
111111
11
2222222222
The pattern array is:
876543
111111
111111
The pattern begins at the second row and the third column of the grid and continues in the following two rows.  The pattern is said to be
present
in the grid.  The return value should be
YES
or
NO
, depending on whether the pattern is found.  In this case, return
YES
.
Function Description
Complete the
gridSearch
function in the editor below.  It should return
YES
if the pattern exists in the grid, or
NO
otherwise.
gridSearch has the following parameter(s):
string G[R]:
the grid to search
string P[r]:
the pattern to search for
Input Format
The first line contains an integer
, the number of test cases.
Each of the
test cases is represented as follows:
The first line contains two space-separated integers
and
, the number of rows in the search grid
and the length of each row string.
This is followed by
lines, each with a string of
digits that represent the grid
.
The following line contains two space-separated integers,
and
, the number of rows in the pattern grid
and the length of each pattern row string.
This is followed by
lines, each with a string of
digits that represent the pattern grid
.
Returns
string:
either
YES
or
NO
Constraints
Sample Input
2
10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
Sample Output
YES
NO
Explanation
The first test in the input file is:
10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
The pattern is present in the larger grid as marked in bold below.
7283455864
6731158619
8988242643
3830589324
222
9505
813
563
3845
374
647
3530
293
7053106601
0834282956
4607924137
The second test in the input file is:
15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
The search pattern is:
99
99
This pattern is not found in the larger grid.",Iterate through the grid and pattern using nested loops and compare substrings converted to integers.,Convert the grid and pattern to matrices of integers and use matrix multiplication to find the pattern.,"Use regular expressions to search for the pattern in the grid, treating each row as a string.","Apply a hashing algorithm to both the grid and pattern, comparing hash values for potential matches.","Slide the pattern across the grid, row by row and column by column, comparing each digit for a complete match.",,algorithms,"['string searching', 'pattern matching', 'nested loops']"
https://www.hackerrank.com/challenges/robot?isFullScreen=true,"You have two arrays of integers,
and
, where both have
number of elements. Consider the following function:
score = 0

int Go(step, energy) {
    if (step == N) {
        score += V[step];
        return (score);
    }
    else {
        int way = random(1, 2);
        if (way == 1) {
            score += V[step];
        }
        else {
            energy = P[step];
        }
        if (energy > 0) {
            Go(step + 1, energy - 1);
        }
        else {
            KillTheWorld();
        }
    }
}
What is the maximum possible value of score that we can get in the end, if we call
?.
Note that the function should never invoke
KillTheWorld
function. And
generates a random integer from set
[1, 2]
.
It is guaranteed there will be a solution that
wont
kill the world.
Input Format
The first line contains an integer N. Each of the following N lines contains a pair of integers. The i-th line contains a pair of numbers,
, separated by space.
Constraints
Output Format
Derive the maximum score given by
return (score);
.
Sample Input
4
4 2
0 2
4 0
3 4
Sample Output
7
Explanation
In the best case, the first and second function call in Go variable
will take value 2, while in the other calls it will be equal to 1 then the final score will be equal to the value of 7.","The sum of all values in V, regardless of P",The sum of all values in P,The sum of the minimum values between V[i] and P[i] for all i,"A value dependent on the specific random choices made during execution, thus unpredictable","The sum of V[i] for all i, where energy allows reaching the end",,algorithms,"['recursion', 'dynamic programming', 'optimization']"
https://www.hackerrank.com/challenges/fighting-pits?isFullScreen=true,"Meereen is famous for its fighting pits where fighters fight each other to the death.
Initially, there are
fighters and each fighter has a strength value. The
fighters are divided into
teams, and each fighter belongs exactly one team. For each fight, the Great Masters of Meereen choose two teams,
and
, that must fight each other to the death. The teams attack each other in alternating turns, with team
always launching the first attack. The fight ends when all the fighters on one of the teams are dead.
Assume each team always attacks optimally. Each attack is performed as follows:
The attacking team chooses a fighter from their team with strength
.
The chosen fighter chooses
at most
fighters from other team and kills all of them.
The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries:
1 p x
Add a new fighter with strength
to team
. It is guaranteed that this new fighter's strength value will not be less than any current member of team
.
2 x y
Print the name of the team that would win a matchup between teams
and
in their current state (recall that team
always starts first). It is guaranteed that
.
Given the initial configuration of the teams and
queries, perform each query so the Great Masters can plan the next fight.
Note:
You are determining the team that
would
be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups.
Input Format
The first line contains three space-separated integers describing the respective values of
(the number of fighters),
(the number of teams), and
(the number of queries).
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of fighter
's strength,
, and team number,
.
Each of the
subsequent lines contains a space-separated query in one of the two formats defined in the
Problem Statement
above (i.e.,
1 p x
or
2 x y
).
Constraints
It is guaranteed that both teams in a query matchup will always have at least one fighter.
Scoring
This challange has binary scoring. This means you will get a full score if your solution passes all test cases; otherwise, you will get
points.
Output Format
After each type
query, print the name of the winning team on a new line. For example, if
and
are matched up and
wins, you would print
.
Sample Input
7 2 6
1 1
2 1
1 1
1 2
1 2
1 2
2 2
2 1 2
2 2 1
1 2 1
1 2 1
2 1 2
2 2 1
Sample Output
1
2
1
1
Explanation
Team
has three fighters with the following strength levels:
.
Team
has four fighters with the following strength levels:
.
The first query matching up team
and
would play out as follows:
Team
attacks
The fighter with strength
can kill one fighter with strength
and one fighter with strength
. Now,
, and
.
Team
attacks
The fighter with strength
can kill the fighter with strength
. Now,
, and
.
Team
attacks
The fighter with strength
can kill one fighter with strength
. Now,
, and
.
Team
attacks
The fighter with strength
can kill one fighter with strength
. Now,
, and
.
Team
attacks
The fighter with strength
can kill the last fighter with strength
. Now,
, and
.
After this last attack, all of Team
's fighters would be dead. Thus, we print
as team
would win that fight.",The team with the most fighters always wins.,The team with the highest sum of fighter strengths always wins.,Simulate the entire fight by iteratively having each team choose a random fighter to attack with until one team is defeated.,The team whose strongest fighter is stronger always wins.,"Simulate the optimal alternating attacks, where each team's strongest fighter targets the most enemy fighters they can eliminate, until one team is defeated.",,algorithms,"['simulation', 'greedy algorithm', 'optimization']"
https://www.hackerrank.com/challenges/sansa-and-xor?isFullScreen=true,"Sansa has an array. She wants to find the value obtained by
XOR
-ing the contiguous subarrays, followed by
XOR
-ing the values thus obtained. Determine this value.
Example
Subarray
Operation
Result
3
None
3
4
None
4
5
None
5
3
,
4
3
XOR
4
7
4
,
5
4
XOR
5
1
3
,
4
,
5
3
XOR
4
XOR
5
2
Now we take the resultant values and XOR them together:
.  Return
.
Function Description
Complete the
sansaXor
function in the editor below.
sansaXor has the following parameter(s):
int arr[n]:
an array of integers
Returns
int:
the result of calculations
Input Format
The first line contains an integer
, the number of the test cases.
Each of the next
pairs of lines is as follows:
- The first line of each test case contains an integer
, the number of elements in
.
- The second line of each test case contains
space-separated integers
.
Constraints
Sample Input 0
2
3
1 2 3
4
4 5 7 5
Sample Output 0
2
0
Explanation 0
Test case 0:
Test case 1:
Sample Input 1
2
3
98 74 12
3
50 13 2
Sample Output 1
110
48
Explanation 1
Test Case 0:
Test Case 1:","If the array size is odd, XOR all elements; otherwise, return 0",XOR the first and last element of the array,Return the XOR of the array's minimum and maximum elements,Calculate the sum of all elements and take the XOR of the sum with the array size,"If the array size is even, return 0; otherwise, XOR all elements at even indices",,algorithms,"['array', 'XOR', 'subarray']"
https://www.hackerrank.com/challenges/kingdom-division?isFullScreen=true,"King Arthur has a large kingdom that can be represented as a
tree
, where nodes correspond to cities and edges correspond to the roads between cities. The kingdom has a total of
cities numbered from
to
.
The King wants to divide his kingdom between his two children, Reggie and Betty, by giving each of them
or more cities; however, they don't get along so he must divide the kingdom in such a way that they will not invade each other's cities. The first sibling will invade the second sibling's city if the second sibling has no other cities directly connected to it. For example, consider the kingdom configurations below:
https://s3.amazonaws.com/hr-challenge-images/0/1485538883-b78be96095-kingdom13.png
Given a map of the kingdom's
cities, find and print the number of ways King Arthur can divide it between his two children such that they will not invade each other. As this answer can be quite large, it must be modulo
.
Input Format
The first line contains a single integer denoting
(the number of cities in the kingdom).
Each of the
subsequent lines contains two space-separated integers,
and
, describing a road connecting cities
and
.
Constraints
It is guaranteed that all cities are connected.
Subtasks
for
of the maximum score.
Output Format
Print the number of ways to divide the kingdom such that the siblings will not invade each other, modulo
.
Sample Input
5
1 2
1 3
3 4
3 5
Sample Output
4
Explanation
In the diagrams below,
red
cities are ruled by Betty and
blue
cities are ruled by Reggie. The diagram below shows a division of the kingdom that results in war between the siblings:
https://s3.amazonaws.com/hr-challenge-images/0/1484145649-31313a7c49-kingdom5.png
Because cities
and
are not connected to any other
red
cities,
blue
city
will cut off their supplies and declare war on them. That said, there are four valid ways to divide the kingdom peacefully:
https://s3.amazonaws.com/hr-challenge-images/0/1484145522-97fc31fdf3-kingdom4.png
We then print the value of
as our answer.","Calculate the number of subsets of nodes with size at least N/2, without checking for connectivity after removal.",Compute the number of connected components for all possible node subsets and filter those with two components whose size >= N/2.,"Perform a brute-force search over all possible divisions, checking the connectivity of both resulting subgraphs after each division, but without modulo.","Use dynamic programming on subtrees to count valid divisions, but consider disconnected components within each subtree.","Employ dynamic programming on trees, where the state represents the number of ways to divide the subtree rooted at a node into two connected components of at least N/2 nodes each, modulo 10^9+7.",,algorithms,"['tree', 'dynamic programming', 'graph partitioning']"
https://www.hackerrank.com/challenges/task-scheduling?isFullScreen=true,"You have a long list of tasks that you need to do today. To accomplish task
you need
minutes, and the deadline for this task is
. You need not complete a task at a stretch. You can complete a part of it, switch to another task, and then switch back.
You've realized that it might not be possible to complete all the tasks by their deadline. So you decide to do them in such a manner that the maximum amount by which a task's completion time overshoots its deadline is minimized.
Input Format
The first line contains the number of tasks,
. Each of the next
lines contains two integers,
and
.
Constraints
Output Format
Output
lines. The
line contains the value of the maximum amount by which a task's completion time overshoots its deadline, when the first
tasks on your list are scheduled optimally. See the sample input for clarification.
Sample Input
5
2 2
1 1
4 3
10 1
2 1
Sample Output
0
1
2
2
3
Explanation
The first task alone can be completed in 2 minutes, and so you won't overshoot the deadline.
With the first two tasks, the optimal schedule can be:
time 1: task 2
time 2: task 1
time 3: task 1
We've overshot task 1 by 1 minute, hence returning 1.
With the first three tasks, the optimal schedule can be:
time 1 : task 2
time 2 : task 1
time 3 : task 3
time 4 : task 1
time 5 : task 3
time 6 : task 3
Task 1 has a deadline 2, and it finishes at time 4. So it exceeds its deadline by 2.
Task 2 has a deadline 1, and it finishes at time 1. So it exceeds its deadline by 0.
Task 3 has a deadline 4, and it finishes at time 6. So it exceeds its deadline by 2.
Thus, the maximum time by which you overshoot a deadline is 2. No schedule can do better than this.
Similar calculation can be done for the case containing 5 tasks.",Greedy algorithm sorting by shortest time first.,Dynamic programming storing optimal solutions for all subsets of tasks.,Backtracking search exploring all possible task orderings.,"First-Come, First-Served (FCFS) scheduling.","Binary search on the maximum lateness, using a greedy algorithm to check feasibility.",,algorithms,"['scheduling', 'optimization', 'binary search']"
https://www.hackerrank.com/challenges/hard-drive-disks?isFullScreen=true,"There are
pairs
of hard disk drives (HDDs) in a cluster. Each HDD is located at an integer coordinate on an infinite straight line, and each pair consists of one
primary
HDD and one
backup
HDD.
Next, you want to place
computers at integer coordinates on the same infinite straight line. Each
pair
of HDDs must then be connected to a single computer via
wires
, but a computer can have any number (even zero) of HDDs connected to it. The
length
of a wire connecting a single HDD to a computer is the absolute value of the distance between their respective coordinates on the infinite line. We consider the
total length
of wire used to connect all the HDDs to computers to be the sum of the lengths of all the wires used to connect HDDs to computers. Note that both the primary and secondary HDDs in a pair
must
connect to the same computer.
Given the locations of
pairs (i.e., primary and backup) of HDDs and the value of
, place all
computers in such a way that the total length of wire needed to connect each pair of HDDs to computers is
minimal
. Then print the total length on a new line.
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of
pairs
of HDDs) and
(the number of computers).
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
(coordinate of the primary HDD) and
(coordinate of the backup HDD) for a pair of HDDs.
Constraints
Output Format
Print a single integer denoting the minimum total length of wire needed to connect all the pairs of HDDs to computers.
Sample Input
5 2
6 7
-1 1
0 1
5 2
7 3
Sample Output
13
Explanation
For the given
Sample Case
, it's optimal to place computers at positions
and
on our infinite line. We then connect the second (
) and the third (
) pairs of HDDs to the first computer (at position
) and then connect the remaining pairs to the second computer (at position
).
We calculate the wire lengths needed to connect the drives to each computer. The amount of wire needed to connect the second and third drives to the first computer is
, and the amount of wire needed to connect the rest of the drives to the second computer is
. When we sum the lengths of wire needed to connect all pairs of drives to the two computers, we get a total length of
. Thus, we print
as our answer.",Place each computer at the median of all HDD locations.,Place computers at the location of primary HDDs only.,Place all computers at the origin (coordinate 0).,Use the average of all HDD locations as each computer's location.,"For each pair, place a computer at the midpoint between the primary and backup HDD, minimizing the wire length for that pair.",,algorithms,"['optimization', 'coordinate geometry', 'greedy algorithm']"
https://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence?isFullScreen=true,"A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.  Longest common subsequence (
LCS
) of 2 sequences is a subsequence, with maximal length, which is common to both the sequences.
Given two sequences of integers,
and
, find the longest common subsequence and print it as a line of space-separated integers. If there are multiple common subsequences with the same maximum length, print any one of them.
In case multiple solutions exist, print any of them. It is guaranteed that at least one non-empty common subsequence will exist.
Recommended References
This Youtube video tutorial explains the problem and its solution quite well.
Function Description
Complete the
longestCommonSubsequence
function in the editor below.  It should return an integer array of a longest common subsequence.
longestCommonSubsequence has the following parameter(s):
a
: an array of integers
b
: an array of integers
Input Format
The first line contains two space separated integers
and
, the sizes of sequences
and
.
The next line contains
space-separated integers
.
The next line contains
space-separated integers
.
Constraints
Constraints
Output Format
Print the longest common subsequence as a series of space-separated integers on one line. In case of multiple valid answers, print any one of them.
Sample Input
5 6
1 2 3 4 1
3 4 1 2 1 3
Sample Output
1 2 3
Explanation
There is no common subsequence with length larger than 3. And ""1 2 3"",  ""1 2 1"", ""3 4 1"" are all correct answers.
Tested by
Khongor",Always choose the element from sequence 'a' if it's larger.,Select elements from sequence 'b' if they appear earlier than in sequence 'a'.,Choose elements that minimize the difference in indices between the two sequences.,Prioritize elements that appear more frequently in both sequences.,"Use dynamic programming to build a table storing lengths of common subsequences for prefixes of the input sequences, then backtrack to construct one of the longest common subsequences.",,algorithms,"['dynamic programming', 'longest common subsequence', 'sequence alignment']"
https://www.hackerrank.com/challenges/tutzki-and-lcs?isFullScreen=true,"Given two strings,
and
, find and print the total number of ways to insert a character at any position in string
such that the length of the
Longest Common Subsequence
of characters in the two strings increases by one.
Input Format
The first line contains a single string denoting
.
The second line contains a single string denoting
.
Constraints
Scoring
Strings
and
are alphanumeric (i.e., consisting of arabic digits and/or upper and lower case English letters).
The new character being inserted must also be alphanumeric (i.e., a digit or upper/lower case English letter).
Subtask
for
of the maximum score.
Output Format
Print a single integer denoting the total number of ways to insert a character into string
in such a way that the length of the longest common subsequence of
and
increases by one.
Sample Input
aa
baaa
Sample Output
4
Explanation
The longest common subsequence shared by
and
is
aa
, which has a length of
. There are two ways that the length of the longest common subsequence can be increased to
by adding a single character to
:
There are
different positions in string
where we could insert an additional
a
to create longest common subsequence
aaa
(i.e., at the beginning, middle, and end of the string).
We can insert a
b
at the beginning of the string for a new longest common subsequence of
baa
.
As we have
ways to insert an alphanumeric character into
and increase the length of the longest common subsequence by one, we print
on a new line.",Insert characters at the beginning and end of the string only,Insert only characters that already exist in both strings,Consider only inserting characters at positions that maximize the length of the string,Calculate the longest common subsequence length after each possible insertion and count if it increases by exactly one,"Iterate through each possible insertion point and character, calculate the LCS length, and increment a counter if the LCS length increases by one",,algorithms,"['longest common subsequence', 'string manipulation', 'dynamic programming']"
https://www.hackerrank.com/challenges/dag-queries?isFullScreen=true,"You are given a
Directed Acyclic Graph
(DAG) with
vertices and
edges. Each vertex
has an integer,
, associated with it and the initial value of
is
for all vertices. You must perform
queries on the DAG, where each query is one of the following types:
1 u x
: Set
to
for all
such that there is a path in the DAG from
to
.
2 u x
: Set
to
for all
such that there is a path from
to
and
.
3 u
: Print the value of
on a new line.
Input Format
The first line contains three space-separated integers describing the respective values of
(the number of vertices in the DAG),
(the number of edges in the DAG), and
(the number of queries to perform).
Each of the
subsequent lines contains two space-separated integers describing the respective values of
and
(where
,
) denoting a directed edge from vertex
to vertex
in the graph.
Each of the
subsequent lines contains a query in one of the three formats described above.
Constraints
It's guaranteed that the graph is acyclic, but there may be more than one edge connecting two nodes.
Output Format
For each query of type
(i.e.,
3 u
), print the value of
on a new line.
Sample Input 0
6 5 18
1 2
1 3
3 4
2 4
5 6
1 1 3
3 1
3 2
3 3
3 4
1 2 2
3 1
3 2
3 3
3 4
2 6 7
3 5
3 6
2 1 3
3 1
3 2
3 3
3 4
Sample Output 0
3
3
3
3
3
2
3
2
0
0
3
2
3
2
Explanation 0
The diagram below depicts the changes to the graph after all type
and type
queries:
https://s3.amazonaws.com/hr-challenge-images/0/1478222364-85faf11551-dag-queries.png","Use depth-first search (DFS) to propagate updates, but do not track visited nodes, leading to infinite loops in some cases.","Use a topological sort to process vertices in order, but only update values based on immediate neighbors, ignoring transitive paths.","Process queries in reverse order to simulate undoing the changes, improving performance for certain query patterns.","Use a simple adjacency matrix to represent the graph, which becomes inefficient for large, sparse graphs.","Employ a topological sort to efficiently process updates, combined with depth-first search or breadth-first search to propagate changes to affected vertices.",,algorithms,"['directed acyclic graph', 'topological sort', 'graph traversal']"
https://www.hackerrank.com/challenges/reverse-shuffle-merge?isFullScreen=true,"Given a string,
, we define some operations on the string as follows:
a.
denotes the string obtained by reversing string
. Example:
b.
denotes any string that's a permutation of string
. Example:
c.
denotes any string that's obtained by interspersing the two strings
&
, maintaining the order of characters in both. For example,
&
, one possible result of
could be
, another could be
, another could be
and so on.
Given a string
such that
for some string
, find the
lexicographically
smallest
.
For example,
.  We can split it into two strings of
.  The reverse is
and we need to find a string to shuffle in to get
.  The middle two characters match our reverse string, leaving the
and
at the ends.  Our shuffle string needs to be
.  Lexicographically
, so our answer is
.
Function Description
Complete the
reverseShuffleMerge
function in the editor below.  It must return the lexicographically smallest string fitting the criteria.
reverseShuffleMerge has the following parameter(s):
s
: a string
Input Format
A single line containing the string
.
Constraints
contains only lower-case English letters,
ascii[a-z]
Output Format
Find and return the string which is the lexicographically smallest valid
.
Sample Input 0
eggegg
Sample Output 0
egg
Explanation 0
Split ""eggegg"" into strings of like character counts: ""egg"", ""egg""
reverse(""egg"") = ""gge""
shuffle(""egg"") can be ""egg""
""eggegg"" belongs to the merge of (""gge"", ""egg"")
The merge is:
gge
.
'egg' < 'gge'
Sample Input 1
abcdefgabcdefg
Sample Output 1
agfedcb
Explanation 1
Split the string into two strings with like characters:
and
.
Reverse
=
Shuffle
can be
Merge to
bcdefga
Sample Input 2
aeiouuoiea
Sample Output 2
aeiou
Explanation 2
Split the string into groups of like characters:
Reverse
=
These merge to
uoiea","Find the smallest character in the string and greedily build the result string from it, ensuring the required character count is met at each step.","Start with the reverse of the input string and iteratively remove characters to satisfy the merge condition, selecting the smallest character at each iteration.","Generate all possible sub-sequences of the input string, check if they satisfy the reverseShuffleMerge property, and return the lexicographically smallest one.","Recursively divide the string into halves, find the optimal solution for each half, and merge the results based on lexicographical order.","Count character frequencies, greedily build the result string from the beginning, prioritizing smaller characters while ensuring enough characters remain to form the reverse and shuffle parts.",,algorithms,"['string manipulation', 'greedy algorithm', 'lexicographical order']"
https://www.hackerrank.com/challenges/separate-the-chocolate?isFullScreen=true,"Chinese Version
Russian Version
Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that:
Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.
All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component
The absolute difference between the number of chocolates in pieces should be at most K
After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this:
XX
XX
Input Format
The first line of the input contains 3 integers M, N and K separated by a single space.
M lines follow, each of which contains N characters.
Each character is 'T','D' or 'U'.
Constraints
0≤ M, N ≤8
0≤ K ≤ M * N
Output Format
A single line containing the number of ways to divide the chocolate bar.
Sample Input
2 2 4
UU
UU
Sample Output
12
Explanation
Note:
In the explanation T and D are used to represent, which parts belong to Tom and Derpina respectively.
There are 2
4
= 16 possible separations.  The 4 invalid are:
TT
TT

DD
DD

DT
TD

TD
DT
Some of the valid ones are:
TD
TD

TT
DD

DD
TT

DT
DT",Breadth-first search,Greedy algorithm,Dynamic programming,Divide and conquer,Backtracking,,algorithms,"['backtracking', 'connected components', 'constraint satisfaction']"
https://www.hackerrank.com/challenges/move-the-coins?isFullScreen=true,"Alice and Bob are playing a game, defined below:
There is an undirected tree graph with
nodes that has the following properties:
Each node has
golden coins.
Node
is root of the tree.
The parent node of some node
is defined as
.
Moves
Players move in turns.
During a move, a player can select a node
and move one or more coins to
.
If the current player can't make any move, they lose the game.
The game quickly becomes boring because the result is determined by the tree's configuration and the number of coins in each node (assuming that both players play optimally).
Alice decides to instead challenge Bob by asking him
questions. For each question
:
Alice picks a node
and
removes
the edge between
and
.
She picks another node
and draws a new undirected edge between
and
. So now
.
Bob must determine if the first player has a winning strategy for the new tree or not. It's possible that after Alice draws the new edge, the graph will no longer be a tree; if that happens, the question is
invalid
. Each question is independent, so the answer depends on the initial state of the graph (and not on previous questions).
Given the tree and the number of coins in each node, can you help Bob answer all
questions?
Input Format
The first line contains an integer,
(the number of nodes).
The second line contains
space-separated integers,
, describing the number of coins in each node.
Each of the
subsequent lines contains
space-separated integers denoting an undirected edge between nodes
and
, respectively.
The next line contains an integer,
(the number of questions Alice asks).
Each of the
subsequent lines contains
space-separated integers,
and
, respectively.
Constraints
For each question:
Output Format
On a new line for each question, print
if the first player has a winning strategy, print
if they do not, or print
if the question is not valid.
Sample Input
6
0 2 2 1 3 2
1 2
1 3
3 4
3 5
4 6
3
6 2
4 1
3 6
Sample Output
NO
YES
INVALID
Explanation
Initally the tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/19994/1459406547-fb6e897a57-goldenagain.png
After the first question (
), the tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/19994/1459406604-0f1ba4ec28-goldenagain1.png
Alice removes the edge conecting node
to
and makes
the new parent node of
. Because this configuration does not result in a winning strategy, we print
on a new line.
After the second question (
), the tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/19994/1459406662-83a17f629f-goldenagain5.png
Alice removes the edge conecting node
to
and makes
the new parent node of
. Because this configuration results in a winning strategy, we print
on a new line.
After the third question (
), the graph is no longer a tree:
https://s3.amazonaws.com/hr-challenge-images/19994/1459406666-8efce8aba5-goldenagain6.png
Alice removes the edge conecting node
to
and makes
the new parent node of
. The graph is now partitioned into two separate subgraphs (one of which is also not a tree); because the game must be played on a single undirected tree graph, we print
on a new line.",The first player always wins if the total number of coins is non-zero.,The first player wins if the parity of the number of nodes with coins is odd.,"The first player always loses, regardless of the tree structure or coin distribution.",The validity check is flawed; it does not detect all cases where the graph becomes a cycle.,"The first player wins if the XOR sum of the coin counts at each node is non-zero after the edge modification, and the graph remains a tree; otherwise, they lose. If the edge modification creates a cycle, the question is invalid.",,algorithms,"['game theory', 'graph algorithms', 'XOR']"
https://www.hackerrank.com/challenges/newyear-present?isFullScreen=true,"Nina received an odd New Year's present from a student: a set of
unbreakable sticks. Each stick has a length,
, and the length of the
stick is
. Deciding to turn the gift into a lesson, Nina asks her students the following:
How many ways can you build a square using
exactly
of these unbreakable sticks?
Note:
Two ways are distinct if they use at least one different stick. As there are
choices of sticks, we must determine which combinations of sticks can build a square.
Input Format
The first line contains an integer,
, denoting the number of sticks. The second line contains
space-separated integers
describing the length of each stick in the set.
Constraints
Output Format
On a single line, print an integer representing the number of ways that
unbreakable sticks can be used to make a square.
Sample Input 0
8
4 5 1 5 1 9 4 5
Sample Output 0
3
Sample Input 1
6
1 2 3 4 5 6
Sample Output 1
0
Explanation
Sample 0
Given
sticks (
), the only possible side length for our square is
. We can build square
in
different ways:
In order to build a square with side length
using
exactly
sticks,
and
must always build two of the sides. For the remaining two sides, you must choose
of the remaining
sticks of length
(
and
).
Sample 1
We have to use all
sticks, making the largest stick length (
) the minimum side length for our square. No combination of the remaining sticks can build
more sides of length
(total length of all other sticks is
and we need at least length
), so we print
.",Use dynamic programming with memoization to avoid redundant calculations of stick combinations.,Iterate through all possible subsets of sticks and check if any four sticks form a square.,"Sort the sticks and use a greedy approach, trying to find four sticks of equal length sequentially.","Calculate the total length of all sticks, divide by four, and check if any stick length equals this result.","Count stick frequencies, then iterate through unique lengths, checking combinations that sum to form a square's sides.",,algorithms,"['combinatorics', 'array manipulation', 'optimization']"
https://www.hackerrank.com/challenges/tower-breakers-the-final-battle-1?isFullScreen=true,"Our unsung tower-breaking heroes (players
and
) only have one tower left, and they've decided to break it for a special game commemorating the end of
days of Game Theory! The rules are as follows:
always moves first, and both players always move optimally.
Initially there is
tower of height
.
The players move in alternating turns. The moves performed by each player are different:
At each turn,
divides the current tower into some number of smaller towers. If the turn starts with a tower of height
and
breaks it into
smaller towers, the following condition must apply:
, where
denotes the height of the
new tower.
At each turn,
chooses some tower
of the
new towers made by
(where
). Then
must pay
coins to
. After that,
gets another turn with tower
and the game continues.
The game is over when no valid move can be made by
, meaning that
.
's goal is to pay as few coins as possible, and
's goal is to earn as many coins as possible.
Can you predict the number of coins that
will earn?
Input Format
The first line contains a single integer,
, denoting the number of test cases.
Each of the
subsequent lines contains a single integer,
, defining the initial tower height for a test case.
Constraints
Output Format
For each test case, print a single integer denoting the number of coins earned by
on a new line.
Sample Input
3
4
2
7
Sample Output
6
4
8
Explanation
Test Case 0:
Our players make the following moves:
splits the initial tower into
smaller towers of sizes
and
.
chooses the first tower and earns
coin.
splits the tower into
smaller towers of sizes
and
.
chooses the first tower and earns
coin.
splits the tower into
smaller towers of size
.
chooses the second tower and earns
coins.
The total number of coins earned by
is
, so we print
on a new line.",n - 1,n,n + 1,2 * n,n * (n - 1) / 2,,algorithms,"['game theory', 'recursion', 'combinatorics']"
https://www.hackerrank.com/challenges/road-maintenance?isFullScreen=true,"Byteland has
cities (numbered from
to
) and
bidirectional roads. A
path
is comprised of
or more connected roads. It is guaranteed that there is a path from any city to any other city.
Steven is a road maintenance worker in Byteland. He is required to maintain
exactly
paths on any given workday. He
cannot
work on the same road twice in one day (so no
paths can contain the same
roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city.
Given
, help Steven determine how many different possible
path sets will allow him to perform his maintenance duties. Then print the answer modulo
.
Input Format
The first line contains
space-separated integers,
(the number of cities) and
(the number of roads to maintain).
Each line
of the
subsequent lines contains
space-separated integers,
, describing a bidirectional road between cities
and
.
Constraints
Output Format
Find the number of different
path sets that will allow Steven to complete
orders, and print the answer
.
Sample Input
4 2
1 2
2 3
2 4
Sample Output
6
Explanation
For the following Byteland map:
https://s3.amazonaws.com/hr-challenge-images/15611/1451743433-d3b06d3a80-st-rr.png
Steven can maintain
roads using any of the following
routes:
and
and
and
and
and
and
Thus, we print the result of
on a new line, which is
.",Use Dijkstra's algorithm to find the shortest paths and count combinations,"Employ a brute-force approach by generating all possible path sets and checking validity, modulo 10^9 + 7","Apply a greedy algorithm, always selecting the shortest available path until all roads are covered","Solve with dynamic programming, where dp[i][j] represents the number of valid path sets using the first i roads and j paths","Model the problem as finding the number of ways to partition the edges into k paths, considering the graph's properties and calculating combinations modulo 10^9 + 7",,algorithms,"['graph theory', 'combinations', 'path enumeration']"
https://www.hackerrank.com/challenges/kth-ancestor?isFullScreen=true,"A tree of
nodes is an un-directed connected graph having
edges. Let us denote
as the root node. If
is a node such that it is at a distance of
from
, and
is a node such that it is at at distance of
from
and
is connected to
, then we call
as the parent of
.
Similarly, if
is at a distance of
from
and
is at a distance of
from
and there is a path of length
from
to
, then we call
as the
th
parent of
.
Susan likes to play with graphs and Tree data structure is one of her favorites. She has designed a problem and wants to know if anyone can solve it. Sometimes she adds or removes a leaf node. Your task is to figure out the
th
parent of a node at any instant.
Input Format
The first line contain an integer
denoting the number of test cases.
test cases follow. First line of each test case contains an integer
, the number of nodes in the tree.
lines follows each containing two integers
and
separated by a single space denoting
as the parent of
. If
is
, then X is the root node of the tree.  (
is for namesake and is not in the tree).
The next line contains an integer
, the number of queries.
lines follow each containing a query.
:
is added as a new leaf node whose parent is
.
is not in the tree while
is in.
: This tells that leaf node
is removed from the tree.
is a leaf in the tree.
: In this query output the
th
parent of
.
is a node in the tree.
Note
Each node index is any number between 1 and 10
5
i.e., a tree with a single node can have its root indexed as 10
5
Constraints
Output Format
For each query of type
, output the
th
parent of
. If
th
parent doesn't exist, output
and if the node doesn't exist, output
.
Sample Input
2
7
2 0
5 2
3 5
7 5
9 8
8 2
6 8
10
0 5 15
2 15 2
1 3
0 15 20
0 20 13
2 13 4
2 13 3
2 6 10
2 11 1
2 9 1
1
10000 0
3
0 10000 4
1 4
2 4 1
Sample Output
2
2
5
0
0
8
0
Explanation
There are 2 test cases. The first test case has 7 nodes with 2 as its root. There are 10 queries
0 5 15 -> 15 is added as a leaf node to 5.
2 15 2 -> 2nd parent of 15 is 15->5->2 is 2.
1 3 -> leaf node 3 is removed from the tree.
0 15 20 -> 20 is added as a leaf node to 15.
0 20 13 -> 13 is added as a leaf node to 20.
2 13 4 -> 4th parent of 13 is 2.
2 13 3 -> 3rd parent of 13 is 5.
2 6 10 -> there is no 10th parent of 6 and hence 0.
2 11 1 -> 11 is not a node in the tree, hence 0.
2 9 1 -> 9's parent is 8.
the second testcase has a tree with only 1 node (10000).
0 10000 4 -> 4 is added as a leaf node to 10000.
1 4 -> 4 is removed.
2 4 1 -> as 4 is already removed, answer is 0.","Perform a Depth-First Search (DFS) from the node upwards for 'k' levels, returning 0 if not found or node doesn't exist.","Maintain a parent array during tree construction, update it with each add/remove, and access the k-th parent by traversing the array 'k' times. Return 0 if the node or parent doesn't exist.","Store the tree in an adjacency matrix and compute all ancestors for each node after each modification, then directly access the k-th parent.","Use a modified Breadth-First Search (BFS) from the root to find the depth of each node, then iterate upwards from the given node 'k' times, returning 0 if the node or parent does not exist.",Use dynamic programming to precompute the 2^i-th ancestor for each node. Use binary lifting to efficiently find the k-th ancestor. Handle add/remove operations by updating relevant entries and return 0 if node or parent does not exist,,algorithms,"['tree', 'graph', 'ancestor']"
https://www.hackerrank.com/challenges/points-in-a-plane?isFullScreen=true,"There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things:
The minimum number of turns (T) needed to remove all the points.
The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn.
Input Format
The first line contains the number of test cases T. T test cases follow. Each test case contains N on the first line, followed by N lines giving the coordinates of the points.
Constraints
1 <= T <= 50
1 <= N <= 16
0 <= xi,yi <= 100
No two points will have the same coordinates.
Output Format
Output T lines, one for each test case, containing the least number of turns needed to remove all points and the number of ways to do so. As the answers can be large, output them modulo 1000000007.
Sample Input
2
3
0 0
0 1
1 0
4
3 4
3 5
3 6
5 5
Sample Output
2 6
2 8
Explanation
For the 1st input, Let the points be labelled p1,p2,p3. These are the ways to remove them (first turn's points, followed by second turn's points):
a. 1) p1,p2 2) p3
b. 1) p1,p3 2) p2
c. 1) p2,p3 2) p1
d. 1) p3 2) p1,p2
e. 1) p2 2) p1,p3
f. 1) p1 2) p3,p2",Use dynamic programming to find the minimum number of turns and memoize the number of ways for each subset of points.,Implement a greedy algorithm that iteratively removes the largest possible set of collinear points in each turn.,Recursively try all possible combinations of collinear points and backtrack to find the minimum turns and count the ways.,Approximate the solution using a genetic algorithm to minimize the number of turns and estimate the number of ways.,"Use bitmasking to represent subsets of points, iterate through all possible combinations of lines, and calculate the minimum turns using dynamic programming with memoization to count the number of ways.",,algorithms,"['dynamic programming', 'bitmasking', 'collinearity']"
https://www.hackerrank.com/challenges/repair-roads?isFullScreen=true,"The country of Byteland contains
cities and
bidirectional roads. There is a path between any two cities. The roads in Byteland were built long ago, and now they are in need of repair. You have been hired to fix all the roads. You intend to do this by dispatching robots on some of the roads. Each robot will repair the road he is currently on and then moves to one of the adjacent unrepaired roads. After repairing that, it will move to another adjacent unrepaired road, repair that and so on.
Two roads are adjacent if they have the same city at one of their endpoints. For the process to be efficient, no two robots will ever repair the same road, and no road can be visited twice. What is the minimum number of robots needed to accomplish the task?
Input Format
The first line contains the number of test cases
.
test cases follow. The first line of each test case contains
, the number of cities in Byteland. The cities are numbered
. The following
lines contain the description of the roads. The
line contains two integers
and
, meaning that there is a road connecting cities with numbers
and
.
Constraints
Output Format
Print
lines, one corresponding to each test case containing the required answer for that test case.
Sample Input
3
4
0 1
0 2
0 3
6
0 1
1 2
2 3
2 4
4 5
7
0 1
1 2
2 3
2 4
4 5
3 6
Sample Output
1
1
2
Explanation
For the first case, one robot is enough to repair all roads:
For the second case, one robot is again enough:
The the third case, there is no way to repair all the roads with one robot and at least two are needed.",Eulerian Path,Hamiltonian Path,Minimum Spanning Tree,Dijkstra's Algorithm,Eulerian Circuit,,algorithms,"['graph theory', 'eulerian path', 'connectivity']"
https://www.hackerrank.com/challenges/cuttree?isFullScreen=true,"Given a tree
T
with
n
nodes, how many subtrees (
T'
) of
T
have at most
K
edges connected to (T - T')?
Input Format
The first line contains two integers
n
and
K
followed by
n-1
lines each containing two integers a & b denoting that there's an edge between a & b.
Constraints
1 <= K <= n <= 50
Every node is indicated by a distinct number from 1 to n.
Output Format
A single integer which denotes the number of possible subtrees.
Sample Input
3 1
2 1
2 3
Sample Output
6
Explanation
There are 2^3 possible sub-trees:
{} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3}
But:
the sub-trees {2} and {1,3} are not valid.
{2} isn't valid because it has 2 edges connecting to it's complement {1,3} whereas K = 1 in the sample test-case
{1,3} isn't valid because, well, it's not a sub-tree. The nodes aren't connected.",O(n!),O(n^2),O(2^n),O(n log n),O(n^3),,algorithms,"['tree', 'subtree', 'dynamic programming']"
https://www.hackerrank.com/challenges/mining?isFullScreen=true,"There are
gold mines along a river, and each mine
produces
tons of gold. In order to collect the mined gold, we want to redistribute and consolidate it amongst exactly
mines where it can be picked up by trucks. We do this according to the following rules:
You can move gold between any pair of mines (i.e.,
and
, where
).
All the gold at some pickup mine
must either stay at mine
or be completely moved to some other mine,
.
Move
tons of gold between the mine at location
and the mine at location
at a cost of
.
Given
,
, and the amount of gold produced at each mine, find and print the minimum cost of consolidating the gold into
pickup locations according to the above conditions.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of mines) and
(the number of pickup locations).
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
(the mine's distance from the mouth of the river) and
(the amount of gold produced in tons) for mine
.
Note:
It is guaranteed that the mines are will be given in order of ascending location.
Constraints
Output Format
Print a single line with the minimum cost of consolidating the mined gold amongst
different pickup sites according to the rules stated above.
Sample Input 0
3 1
20 1
30 1
40 1
Sample Output 0
20
Explanation 0
We need to consolidate the gold from
mines into a single pickup location (because
). The mines are all equidistant and they all produce the same amount of gold, so we just move the gold from the mines at locations
and
to the mine at
for a minimal cost of
.
Sample Input 1
3 1
11 3
12 2
13 1
Sample Input 1
4
Explanation 1
We need to consolidate the gold from
mines into a single pickup location (because
). We can achieve a minimum cost of
by moving the gold from mines
and
to the mine at
.
Sample Input 2
6 2
10 15
12 17
16 18
18 13
30 10
32 1
Sample Output 2
182
Explanation 2
We need to consolidate the gold from
mines into
pickup locations. We can minimize the cost of doing this by doing the following:
Move the gold from the mines at locations
,
, and
to the mine at
.
Move the gold from the mine at location
to the mine at
.",Use a greedy approach by always merging with the nearest mine,Sort the mines by gold amount and consolidate from the largest to the smallest,Calculate the cost of all possible combinations using recursion and choose the minimal one,"Apply dynamic programming by considering subproblems of merging the first i mines into j locations, minimizing cost",Apply dynamic programming to calculate the minimum cost of consolidating the first i mines into j pickup locations,,algorithms,"['dynamic programming', 'optimization', 'minimum cost']"
https://www.hackerrank.com/challenges/journey-to-the-moon?isFullScreen=true,"The member states of the UN are planning to send
people to the moon. They want them to be from different countries.  You will be given a list of pairs of astronaut ID's.  Each pair is made of astronauts from the same country.  Determine how many pairs of astronauts from different countries they can choose from.
Example
There are
astronauts numbered
through
.  Astronauts grouped by country are
and
.  There are
pairs to choose from:
and
.
Function Description
Complete the
journeyToMoon
function in the editor below.
journeyToMoon has the following parameter(s):
int n:
the number of astronauts
int astronaut[p][2]:
each element
is a
element array that represents the ID's of two astronauts from the same country
Returns
-
int:
the number of valid pairs
Input Format
The first line contains two integers
and
, the number of astronauts and the number of pairs.
Each of the next
lines contains
space-separated integers denoting astronaut ID's of two who share the same nationality.
Constraints
Sample Input 0
5 3
0 1
2 3
0 4
Sample Output 0
6
Explanation 0
Persons numbered
belong to one country, and those numbered
belong to another. The UN has
ways of choosing a pair:
Sample Input 1
4 1
0 2
Sample Output 1
5
Explanation 1
Persons numbered
belong to the same country, but persons
and
don't share countries with anyone else.  The UN has
ways of choosing a pair:",Use a disjoint set data structure to find connected components (countries) and then calculate the number of pairs by multiplying the sizes of all possible pairs of components.,Perform a brute-force iteration through all possible pairs of astronauts and check if they belong to the same country using the given astronaut pairs.,"Sort the input array of astronaut pairs, then iterate through all possible pairs and count the valid ones, optimizing for early exits.",Apply a greedy algorithm by always selecting the largest country first and pairing astronauts from different countries based on a decreasing size order.,Use a disjoint set (Union-Find) data structure to group astronauts by country. Count the astronauts in each country and calculate the number of ways to choose two astronauts from different countries as n*(n-1)/2 - sum(size_i*(size_i-1)/2).,,algorithms,"['disjoint set', 'graph theory', 'combinatorics']"
https://www.hackerrank.com/challenges/manipulative-numbers?isFullScreen=true,"Suppose that
is a list of
numbers
and
is a permutation of these numbers, we say B is
K-Manipulative
if and only if:
is not less than
, where
represents the
XOR
operator.
You are given
. Find the largest
such that there exists a
K-manipulative
permutation
.
Input:
The first line is an integer
. The second line contains
space separated integers -
.
Output:
The largest possible
, or
if there is no solution.
Constraints:
Sample Input 0
3
13 3 10
Sample Output 0
2
Explanation 0
Here the list
is
. One possible permutation
. Here
.
So there exists a permutation
of
such that
is not less than
. However there does not exist any permutation
of
such that
is not less than
. So the maximum possible value of
is
.
Sample Input 1
4
1 2 3 4
Sample Output 1
1
Explanation 1
Here the list
is
. One possible permutation
. Here
.
So there exists a permutation
of
such that
is not less than
. However there does not exist any permutation
of
such that
is not less than
. So the maximum possible value of
is
.",Sort the array and check if the XOR sum of the first K elements is greater than or equal to the XOR sum of the remaining elements.,"Iterate through all possible values of K from N down to 1, generating all permutations for each K and checking the condition.","Calculate the XOR sum of the entire array. The largest K is N if the XOR sum is 0, otherwise 1.","Check if the array is sorted. If sorted, the maximum K is N-1, otherwise it is 1.","Find the smallest element in the array. The largest K is 1 if that element is less than or equal to the XOR sum of the rest of the array; otherwise, it's 0 if N = 1, or iterate through all possible K and its permuations if N > 1 and the smallest element isn't enough.",,algorithms,"['array', 'XOR', 'permutation']"
https://www.hackerrank.com/challenges/unbounded-knapsack?isFullScreen=true,"Given an array of integers and a target sum, determine the sum nearest to but not exceeding the target that can be created.  To create the sum, use any element of your array zero or more times.
For example, if
and your target sum is
, you might select
or
.  In this case, you can arrive at exactly the target.
Function Description
Complete the
unboundedKnapsack
function in the editor below.  It must return an integer that represents the sum nearest to without exceeding the target value.
unboundedKnapsack has the following parameter(s):
k
: an integer
arr
: an array of integers
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
pairs of lines are as follows:
- The first line contains two integers
and
, the length of
and the target sum.
-  The second line contains
space separated integers
.
Constraints
Output Format
Print the maximum sum for each test case which is as near as possible, but not exceeding, to the target sum on a separate line.
Sample Input
2
3 12
1 6 9
5 9
3 4 4 4 8
Sample Output
12
9
Explanation
In the first test case, one can pick {6, 6}. In the second, we can pick {3,3,3}.",Use a greedy approach by repeatedly subtracting the largest element from the target until it becomes zero or negative.,Sort the array in descending order and use a dynamic programming approach with a 2D table.,"Calculate all possible sums using recursion without memoization, then filter for values less than or equal to the target.",Iterate through all possible combinations of array elements using bit manipulation to generate subsets and find the maximum sum less than or equal to the target.,"Use dynamic programming with a 1D table to store achievable sums up to the target, building it iteratively using each array element.",,algorithms,"['dynamic programming', 'knapsack', 'integer array']"
https://www.hackerrank.com/challenges/greedy-florist?isFullScreen=true,"A group of friends want to buy a bouquet of flowers.  The florist wants to maximize his number of
new
customers and the money he makes.  To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus
.  The first flower will be original price,
, the next will be
and so on.
Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers.  The number of flowers they want equals the length of the
array.
Example
The length of
, so they want to buy
flowers total.  Each will buy one of the flowers priced
at the original price.  Having each purchased
flower, the first flower in the list,
, will now cost
.  The total cost is
.
Function Description
Complete the
getMinimumCost
function in the editor below.
getMinimumCost has the following parameter(s):
int c[n]:
the original price of each flower
int k:
the number of friends
Returns
-
int:
the minimum cost to purchase all flowers
Input Format
The first line contains two space-separated integers
and
, the number of flowers and the number of friends.
The second line contains
space-separated positive integers
, the original price of each flower.
Constraints
Sample Input 0
3 3
2 5 6
Sample Output 0
13
Explanation 0
There are
flowers with costs
and
people in the group. If each person buys one flower, the total cost of prices paid is
dollars. Thus, we print
as our answer.
Sample Input 1
3 2
2 5 6
Sample Output 1
15
Explanation 1
There are
flowers with costs
and
people in the group. We can minimize the total purchase cost like so:
The first person purchases
flowers in order of decreasing price; this means they buy the more expensive flower (
) first at price
dollars and the less expensive flower (
) second at price
dollars.
The second person buys the most expensive flower at price
dollars.
We then print the sum of these purchases, which is
, as our answer.
Sample Input 2
5 3
1 3 5 7 9
Sample Output 2
29
Explanation 2
The friends buy flowers for
,
and
,
and
for a cost of
.",Sort the flower prices in ascending order and assign them to friends in a round-robin fashion.,Divide the total cost of the flowers evenly among the friends.,Sort the flower prices in descending order and assign the most expensive flowers to friends with the least amount of flowers already bought.,"Use a greedy approach, always assigning the cheapest flower to the next available friend.","Sort the flower prices in descending order and assign the most expensive flowers to friends in a round-robin fashion, incrementing the purchase count for each friend after each round.",,algorithms,"['greedy algorithm', 'sorting', 'optimization']"
https://www.hackerrank.com/challenges/coin-on-the-table?isFullScreen=true,"You have a rectangular board consisting of
rows, numbered from
to
, and
columns, numbered from
to
. The top left is
and the bottom right is
. Initially - at time
- there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:
*
: Exactly one of your cells has letter '*'.
U
: If at time
the coin is on cell
and cell
has letter 'U', the coin will be on cell
at time
, if
. Otherwise, there is no coin on your board at time
.
L
: If at time
the coin is on cell
and cell
has letter 'L', the coin will be on cell
at time
, if
. Otherwise, there is no coin on your board at time
.
D
: If at time
the coin is on cell
and cell
has letter 'D', the coin will be on cell
at time
, if
. Otherwise, there is no coin on your board at time
.
R
: If at time
the coin is on cell
and cell
has letter 'R', the coin will be on cell
at time
, if
. Otherwise, there is no coin on your board at time
.
When the coin reaches a cell that has letter '
*
', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time
the coin will reach the cell having letter '
*
'. In each operation you can select a cell with some letter other than '
*
' and change the letter to '
U
', '
L
', '
R
' or '
D
'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations.
For example, given a grid of
rows and
columns:
UDL
RR
*
the goal is to get from
to
in as few steps as possible.  As the grid stands, it cannot be done because of the
U
in the cell at
.  If
is changed to
D
, the path
is available.  It could also be changed to
R
which would make the path
available.  Either choice takes
change operation, which is the value sought if
.  A lower value of
would result in a return value of
because the shortest path is
steps, starting from
.
Function Description
Complete the
coinOnTheTable
function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or
if it is not possible.
coinOnTheTable has the following parameters:
m
: an integer, the number of columns on the board
k
: an integer, the maximum time to reach the goal
board
: an array of strings where each string represents a row of the board
Input Format
The first line of input contains three integers,
,
, and
, the number of rows, the number of columns and the maximum time respectively.
The next
lines contain
letters each, describing your board.
Constraints
Output Format
Print an integer which represents the minimum number of operations required to achieve your goal.
If you cannot achieve your goal, print
.
Sample Input
2 2 3
RD
*L
Sample output :
0
Sample input :
2 2 1
RD
*L
Sample output :
1
Explanation :
In the first example, a valid path exists without making any changes.  In the second example, the letter of cell (1,1) must be changed to 'D' to make a valid path.  In each example, a path length
is available.","Use Dijkstra's algorithm to find the shortest path, ignoring the time constraint.",Apply dynamic programming to find the longest path that reaches the target within the time limit.,Perform a breadth-first search (BFS) without considering the time constraint 'k'.,"Employ a greedy algorithm, always choosing the move that seems to bring the coin closest to the target.",Use dynamic programming with memoization to calculate the minimum operations for each cell within 'k' steps.,,algorithms,"['dynamic programming', 'pathfinding', 'grid']"
https://www.hackerrank.com/challenges/black-n-white-tree-1?isFullScreen=true,"Nikita is making a graph as a birthday gift for her boyfriend, a fellow programmer! She drew an undirected connected graph with
nodes numbered from
to
in her notebook.
Each node is shaded in either
white
or
black
. We define
to be the number of white nodes, and
to be the number of black nodes. The graph is drawn in such a way that:
No
adjacent nodes have same coloring.
The value of
, which we'll call
, is minimal.
Nikita's mischievous little brother erased some of the edges and all of the coloring from her graph! As a result, the graph is now decomposed into one or more components. Because you're her best friend, you've decided to help her reconstruct the graph by adding
edges such that the aforementioned graph properties hold true.
Given the decomposed graph, construct and shade a valid connected graph such that the difference
between its shaded nodes is minimal.
Input Format
The first line contains
space-separated integers,
(the number of nodes in the original graph) and
(the number of edges in the decomposed graph), respectively.
The
subsequent lines each contain
space-separated integers,
and
, describing a bidirectional edge between nodes
and
in the decomposed graph.
Constraints
It is guaranteed that every edge will be between
distinct nodes, and there will never be more than
edge between any
nodes.
Your answer
must
meet the following criteria:
The graph is connected and no
adjacent nodes have the same coloring.
The value of
is minimal.
Output Format
You must have
lines of output.
The first line contains
space-separated integers:
(the minimum possible value of
) and
(the number of edges you've added to the graph), respectively.
Each of the
subsequent lines contains
space-separated integers,
and
, describing a newly-added bidirectional edge in your final graph (i.e.: new edge
).
You may print
any
of the possible reconstructions of Nikita's graph such that the value of
in the reconstructed shaded graph is minimal.
Sample Input 0
8 8
 1 2
 2 3
 3 4
 4 1
 1 5
 2 6
 3 7
 4 8
Sample output 0
0 0
Sample Input 1
8 6
 1 2
 3 4
 3 5
 3 6
 3 7
 3 8
Sample Output 1
4 1
1 5
Sample Input 2
5 4
 1 2
 2 3
 3 4
 4 1
Sample Output 2
1 2
  2 5
  4 5
Explanation
In the figure below, the solid lines show the decomposed graph after Nikita's brother erased the edges, and the dotted lines show one possible correct answer:
https://s3.amazonaws.com/hr-challenge-images/16422/1459006776-a6493d5706-bw.jpg
In
Sample
, no additional edges are added and
. Because
and
, we get
. Thus, we print
on a new line (there is only
line of output, as
).
In
Sample
, the only edge added is
, so
. Here,
and
, so
. Thus, we print
on the first line. Next, we must print
lines describing each edge added; because
, we print a single line describing the
space-separated nodes connected by our new edge:
.
In
Sample
, we can either add
edge
or
, or both of them. In both cases we get
and
, so
. Thus
and
or
both are correct.","Use Depth First Search (DFS) to color each component, then add edges between components prioritizing smaller color differences.",Apply a greedy algorithm by always connecting the two smallest components regardless of their coloring.,Employ a brute-force approach: try all possible edge additions and colorings until a valid connected graph with minimal difference is found.,"Color each component randomly, and then add edges until the graph is connected, accepting the first valid coloring found.","Identify connected components using DFS or BFS, color each component using bipartite coloring, and then connect components with minimal color difference, adding edges accordingly.",,algorithms,"['graph theory', 'bipartite coloring', 'connectivity']"
https://www.hackerrank.com/challenges/borrowing-money?isFullScreen=true,"Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in
houses in Happy Harbor that are numbered sequentially from
to
. There are
roads, and each road
connects two different houses,
and
. Each superhero house
(where
) has
dollars stashed away for a rainy day.
As long as a superhero is home at house
, Killgrave knows they will hand over all of their saved money,
. Once he gets money from them, he moves on to the next house. However, the superheroes are cunning; when Killgrave comes to house
, every neighbor immediately connected to house
by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road.
What is the maximum amount of money Killgrave can collect from the superheroes, and how many
different
ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different.
Note:
Killgrave can start at an arbitrary house and doesn't have to only use the roads.
Input Format
The first line contains two space-separated integers,
(the number of houses) and
(the number of roads), respectively.
The second line contains
space-separated integers, where each integer
describes the amount of money,
, at house
.
Each line
of the
subsequent lines contains two space-separated integers defining a road connecting houses
and
. Every road connects a different pair of houses.
Constraints
, where
No unordered pair
will appear more than once.
Output Format
Print two space-separated integers:
The first integer must denote the maximum amount of money Killgrave can get out of the Justice League.
The second integer must denote the number of different ways he can collect that amount of money.
Sample Input
3 2
6 8 2
1 2
3 2
Sample Output
8 2
Explanation
https://s3.amazonaws.com/hr-challenge-images/22036/1467059623-af162b0100-happyharbor.png
Killgrave has two possible courses of action:
Visit house
and get
dollars.
Visit houses
and
and get
dollars.
Both of these options result in
dollars, so we know that this is maximal. Thus, we print the maximum amount of money (
) followed by the number of ways he can get that amount of money (
) as two space-separated values on a single line.","Dynamic programming with a table representing the maximum amount collected up to each house, without considering the number of ways.","Greedily choose the house with the most money at each step, ignoring the road constraints, and then backtrack if a conflict arises.","Calculate all possible subsets of houses, check if they violate the road constraints, and then find the subset with the maximum sum.","Simulate Killgrave's movement by randomly choosing houses and their neighbors, and then keep track of the highest result and count the number of instances.",Model the problem as a Maximum Weight Independent Set on a graph and use dynamic programming on trees or recursion with memoization to efficiently find the maximum amount and the number of ways to achieve it.,,algorithms,"['graph theory', 'dynamic programming', 'maximum independent set']"
https://www.hackerrank.com/challenges/ashton-and-string?isFullScreen=true,"Ashton appeared for a job interview and is asked the following question. Arrange all the distinct
substrings
of a given string in lexicographical order and concatenate them. Print the
character of the concatenated string. It is assured that given value of
will be valid i.e. there will be a
character. Can you help Ashton out with this?
For example, given the string
, its distinct substrings are
.  Sorted and concatenated, they make the string
.  If
then, the answer is
, the
character of the 1-indexed concatenated string.
Note
We have distinct substrings here, i.e. if string is
aa
, it's distinct substrings are
a
and
aa
.
Function Description
Complete the
ashtonString
function in the editor below.  It should return the
character from the concatenated string, 1-based indexing.
ashtonString has the following parameters:
-
s
: a string
-
k
: an integer
Input Format
The first line will contain an integer
, the number of test cases.
Each of the subsequent
pairs of lines is as follows:
- The first line of each test case contains a string,
.
- The second line contains an integer,
.
Constraints
Each character of string
will be an appropriate integer.
Output Format
Print the
character (1-based index) of the concatenation of the ordered distinct substrings of
.
Sample Input
1
dbac
3
Sample Output
c
Explanation
The substrings when arranged in lexicographic order are as follows
a, ac, b, ba, bac, c, d, db, dba, dbac
On concatenating them, we get
aacbbabaccddbdbadbac
The third character in this string is
c
.",Use a trie data structure to store all substrings and then traverse the trie in lexicographical order to find the k-th character.,"Generate all substrings, sort them using a standard sorting algorithm, concatenate them, and then return the k-th character directly.","Employ a suffix array to efficiently generate and sort the substrings, then calculate the cumulative lengths to determine the correct substring and character.","Calculate the total length of all possible substrings, perform binary search on substring lengths to locate the target substring, and then find the k-th character within that substring.","Generate all distinct substrings, sort them lexicographically, concatenate them, and return the character at the k-th index.",,algorithms,"['string manipulation', 'substring', 'sorting']"
https://www.hackerrank.com/challenges/candles-2?isFullScreen=true,"Tim is visiting his grandma for two days and is bored due to the lack of the electricity over there. That's why he starts to play with grandma's colorful candle collection.
He aligned the
candles from left to right. The
th candle from the left has the height
and the color
, an integer ranged from 1 to a given
, the number of colors.
Now he stares at the sequence of candles and wonders, how many strictly increasing ( in height ) colorful subsequences are there? A subsequence is considered as colorful if every of the
colors appears at least one times in the subsequence.
As the number of subsequences fulfilling the requirement can be large, print the result modulo
.
Input Format
On the first line you will be given
and
, then
lines will follow. On the
th line you will be given two integers
and
.
Constraints
Output Format
Print the number of strictly increasing colorful subsequences modulo
.
Sample Input
4 3
1 1
3 2
2 2
4 3
Sample Output
2
Explanation
In the first sample the only two valid subsequences are (1, 2, 4) and (1, 3, 4).",Calculate all possible strictly increasing subsequences and filter out those missing at least one color.,"Sort the candles by height and color, then count the strictly increasing subsequences.",Use dynamic programming to calculate the number of strictly increasing subsequences for each possible subset of colors.,"Recursively explore all possible subsequences and check for the colorful condition, memoizing the results.","Apply dynamic programming to count strictly increasing subsequences, tracking the presence of each color with bit masking.",,algorithms,"['dynamic programming', 'subsequence', 'bit masking']"
https://www.hackerrank.com/challenges/a-super-hero?isFullScreen=true,"Ma5termind is crazy about Action Games. He just bought a new one and got down to play it. Ma5termind usually finishes all the levels of a game very fast. But, This time however he got stuck at the very first level of this new game. Can you help him play this game.
To finish the game, Ma5termind has to cross
levels. At each level of the game, Ma5termind has to face
enemies. Each enemy has its associated power
and some number of bullets
. To knock down an enemy, Ma5termind needs to shoot him with one or multiple bullets whose collective count is equal to the power of the enemy. If Ma5termind manages to knock down any one enemy at a level, the rest of them run away and the level is cleared.
Here comes the challenging part of the game.
Ma5termind acquires all the bullets of an enemy once he has knocked him down. Ma5termind can use the bullets acquired after killing an enemy at
level only till the
level.
However, the bullets Ma5termind carried before the start of the game can be taken forward and can be used to kill more enemies.
Now, Ma5termind has to guess the minimum number of bullets he must have before the start of the game so that he clears all the
levels successfully.
NOTE
Bullets carried before the start of the game can be used to kill an enemy at any level.
One bullet decreases the power of an enemy by 1 Unit.
For better understanding of the problem look at the sample testcases.
Input Format
First line of input contains a single integer
denoting the number of test cases.
First line of each test case contains two space separated integers
and
denoting the number of levels and number of enemies at each level respectively.
Each of next
lines of a test case contain
space separated integers, where
integer in the
line denotes the power
of
enemy on the
level.
Each of the next
lines of a test case contains
space separated integers, where
integer in the
line denotes the number of bullets
enemy of
level has.
Constraints
For each test file, sum of
over all the test cases does not exceed
.
Output Format
For each test case, print the required answer.
Sample Input
2
3 3
3 2 1
1 2 3
3 2 1
1 2 3
3 2 1
1 2 3
3 3
3 2 5
8 9 1
4 7 6
1 1 1
1 1 1
1 1 1
Sample Output
1
5
Explanation
For the First test case , Ma5termind kills the enemy in the following order:
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
So this way Ma5termind can successfully finish this game with only
bullet in hand before the start of the game.
For the second test case , Ma5termind kills the enemy in the following order:
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
Ma5termind kills the
enemy at the
level, takes all his bullets and moves to the next level.
So this way Ma5termind can successfully finish this game with only
bullet in hand before the start of the game.
NOTE:
There can be more than one way of getting the optimal answer but that does not matter in our case, because we need to answer the minimum number of bullets required.","Use a greedy approach, always selecting the enemy with the lowest power at each level.","Sort the enemies at each level by bullet count and then by power, and always select the enemy with the highest bullet count.",Calculate the total power of all enemies and subtract the total bullets available to determine the initial bullets needed.,Use dynamic programming to store the minimum bullets needed to reach each level.,"Iterate through levels, keep track of current bullets, find the enemy with the minimum power less than or equal to the current bullets + bullets acquired, update current bullets, and track the maximum deficit.",,algorithms,"['greedy algorithm', 'optimization', 'minimum bullets']"
https://www.hackerrank.com/challenges/fairy-chess?isFullScreen=true,"Let's play
Fairy Chess
!
You have an
chessboard. An
-leaper is a chess piece which can move from some square
to some square
if
; however, its movements are restricted to
up
(
),
down
(
),
left
(
), and
right
(
) within the confines of the chessboard, meaning that diagonal moves are not allowed. In addition, the leaper cannot leap to any square that is occupied by a
pawn
.
Given the layout of the chessboard, can you determine the number of ways a leaper can move
times within the chessboard?
Note:
refers to the absolute value of some integer,
.
Input Format
The first line contains an integer,
, denoting the number of queries. Each query is described as follows:
The first line contains three space-separated integers denoting
,
, and
, respectively.
Each line
of the
subsequent lines contains
characters. The
character in the
line describes the contents of square
according to the following key:
.
indicates the location is
empty
.
P
indicates the location is occupied by a
pawn
.
L
indicates the location of the
leaper
.
Constraints
There will be exactly one
L
character on the chessboard.
The
-leaper can move
up
(
),
down
(
),
left
(
), and
right
(
) within the confines of the chessboard. It
cannot
move diagonally.
Output Format
For each query, print the number of ways the leaper can make
moves on a new line. Because this value can be quite large, your answer must be modulo
.
Sample Input 0
3
4 1 1
....
.L..
.P..
....
3 2 1
...
...
..L
4 3 2
....
...L
..P.
P...
Sample Output 0
4
11
385
Explanation 0
You must perform two queries, outlined below. The
green
cells denote a cell that was leaped to by the leaper, and coordinates are defined as
.
The leaper can leap to the following locations:
https://s3.amazonaws.com/hr-challenge-images/78/1466557923-3264193c17-ScreenShot2016-06-21at6.07.10PM.png
Observe that the leaper cannot leap to the square directly underneath it because it's occupied by a pawn. Thus, there are
ways to make
move and we print
on a new line.
The leaper can leap to the following locations:
https://s3.amazonaws.com/hr-challenge-images/78/1466558235-e20dfc3525-ScreenShot2016-06-21at6.16.40PM.png
Thus, we print
on a new line.
Note:
Don't forget that your answer must be modulo
.","Use Dijkstra's algorithm to find the shortest path, considering each move as an edge with weight 1.",Employ a greedy algorithm to choose the move that maximizes the distance from the nearest pawn in each step.,Calculate all possible paths using a breadth-first search (BFS) and then filter out the invalid ones due to pawn obstructions.,Apply a Monte Carlo simulation by randomly moving the leaper and averaging the results over many iterations.,"Use dynamic programming to store the number of ways to reach each cell in a given number of moves, considering pawn restrictions.",,algorithms,"['dynamic programming', 'recursion', 'chess']"
https://www.hackerrank.com/challenges/magic-square-forming?isFullScreen=true,"We define a
magic square
to be an
matrix of distinct positive integers from
to
where the sum of any row, column, or diagonal of length
is always equal to the same number:  the
magic constant
.
You will be given a
matrix
of integers in the inclusive range
. We can convert any digit
to any other digit
in the range
at cost of
.  Given
, convert it into a magic square at
minimal
cost. Print this cost on a new line.
Note:
The resulting magic square must contain distinct integers in the inclusive range
.
Example
$s = [[5, 3, 4], [1, 5, 8], [6, 4, 2]]
The matrix looks like this:
5
3
4
1
5
8
6
4
2
We can convert it to the following magic square:
8
3
4
1
5
9
6
7
2
This took three replacements at a cost of
.
Function Description
Complete the
formingMagicSquare
function in the editor below.
formingMagicSquare has the following parameter(s):
int s[3][3]:
a
array of integers
Returns
int:
the minimal total cost of converting the input square to a magic square
Input Format
Each of the
lines contains three space-separated integers of row
.
Constraints
Sample Input 0
4 9 2
3 5 7
8 1 5
Sample Output 0
1
Explanation 0
If we change the bottom right value,
, from
to
at a cost of
,
becomes a magic square at the minimum possible cost.
Sample Input 1
4 8 2
4 5 7
6 1 6
Sample Output 1
4
Explanation 1
Using 0-based indexing, if we make
->
at a cost of
->
at a cost of
->
at a cost of
,
then the total cost will be
.",Calculate the sum of each possible magic square and return the smallest difference.,Generate all permutations of numbers 1-9 and select the one with the minimum cost to convert the input matrix.,"For each cell, calculate the average of its row, column, and diagonals, then sum the absolute differences.",Use a greedy approach by iterating through the matrix and making local adjustments to minimize the immediate cost.,"Precompute all possible 3x3 magic squares, then calculate the cost to transform the input to each, and return the minimum.",,algorithms,"['optimization', 'matrix', 'magic square']"
https://www.hackerrank.com/challenges/shortest-path?isFullScreen=true,"You are given a table,
, with
rows and
columns. The top-left corner of the table has coordinates
, and the bottom-right corner has coordinates
. The
cell contains integer
.
A path in the table is a sequence of cells
such that for each
, cell
and cell
share a side.
The weight of the path
is defined by
where
is the weight of the cell
.
You must answer
queries. In each query, you are given the coordinates of two cells,
and
. You must find and print the minimum possible weight of a path connecting them.
Note:
A cell can share sides with at most
other cells. A cell with coordinates
shares sides with
,
,
and
.
Input Format
The first line contains
space-separated integers,
(the number of rows in
) and
(the number of columns in
), respectively.
Each of
subsequent lines contains
space-separated integers. The
integer in the
line denotes the value of
.
The next line contains a single integer,
, denoting the number of queries.
Each of the
subsequent lines describes a query in the form of
space-separated integers:
,
,
, and
, respectively.
Constraints
For each query:
Output Format
On a new line for each query, print a single integer denoting the minimum possible weight of a path between
and
.
Sample Input
3 5
0 0 0 0 0
1 9 9 9 1
0 0 0 0 0
3
0 0 2 4
0 3 2 3
1 1 1 3
Sample Output
1
1
18
Explanation
The input table looks like this:
https://s3.amazonaws.com/hr-challenge-images/14770/1459784984-9dd393d924-shortest.png
The first two queries are explained below:
In the first query, we have to find the minimum possible weight of a path connecting
and
. Here is one possible path:
https://s3.amazonaws.com/hr-challenge-images/14770/1459785487-d39f82c13c-shortest1.png
The total weight of the path is
.
In the second query, we have to find the minimum possible weight of a path connecting
and
. Here is one possible path:
https://s3.amazonaws.com/hr-challenge-images/14770/1459785602-3013ff917e-shortest2.png
The total weight of the path is
.",Use Depth First Search (DFS) to explore all possible paths and keep track of the minimum weight.,"Apply a greedy approach, always moving to the adjacent cell with the smallest weight.",Calculate the Euclidean distance between the start and end cells and multiply it by the minimum cell weight in the grid.,"Implement a recursive function that explores all paths and returns the shortest one, using memoization to improve performance.","Use Dijkstra's algorithm to find the shortest path between the two cells, treating the table as a weighted graph.",,algorithms,"['graph algorithms', 'shortest path', ""Dijkstra's algorithm""]"
https://www.hackerrank.com/challenges/climbing-the-leaderboard?isFullScreen=true,"An arcade game player wants to climb to the top of the leaderboard and track their ranking. The game uses
Dense Ranking
, so its leaderboard works like this:
The player with the highest score is ranked number
on the leaderboard.
Players who have equal scores receive the same ranking number, and the next player(s) receive the immediately following ranking number.
Example
The ranked players will have ranks
,
,
, and
, respectively.  If the player's scores are
,
and
, their rankings after each game are
,
and
. Return
.
Function Description
Complete the
climbingLeaderboard
function in the editor below.
climbingLeaderboard has the following parameter(s):
int ranked[n]
: the leaderboard scores
int player[m]
: the player's scores
Returns
int[m]:
the player's rank after each new score
Input Format
The first line contains an integer
, the number of players on the leaderboard.
The next line contains
space-separated integers
, the leaderboard scores in decreasing order.
The next line contains an integer,
, the number games the player plays.
The last line contains
space-separated integers
, the game scores.
Constraints
for
for
The existing leaderboard,
, is in
descending
order.
The player's scores,
, are in
ascending
order.
Subtask
For
of the maximum score:",Use a binary search to find the player's score in the ranked array and return its index.,Iterate through the ranked array for each player's score to determine their rank.,Sort both the ranked and player score arrays and then merge them to determine rankings.,Append the player's scores to the ranked array and sort the combined array to determine rankings.,Use a modified binary search taking into account the dense ranking system to efficiently determine the player's rank after each game.,,algorithms,"['binary search', 'dense ranking', 'leaderboard']"
https://www.hackerrank.com/challenges/xor-se?isFullScreen=true,"An array,
, is defined as follows:
for
, where
is the symbol for
XOR
You will be given a left and right index
.  You must determine the XOR sum of the segment of
as
.
For example,
.  The segment from
to
sums to
.
Print the answer to each question.
Function Description
Complete the
xorSequence
function in the editor below.  It should return the integer value calculated.
xorSequence has the following parameter(s):
l
: the lower index of the range to sum
r
: the higher index of the range to sum
Input Format
The first line contains an integer
, the number of questions.
Each of the next
lines contains two space-separated integers,
and
, the inclusive left and right indexes of the segment to query.
Constraints
Output Format
On a new line for each test case, print the
XOR-Sum
of
's elements in the inclusive range between indices
and
.
Sample Input 0
3
2 4
2 8
5 9
Sample Output 0
7
9
15
Explanation 0
The beginning of our array looks like this:
Test Case 0:
Test Case 1:
Test Case 2
:
Sample Input 1
3
3 5
4 6
15 20
Sample Output 1
5
2
22
Explanation 1
.  Perform the xor sum on each interval:",Precompute the XOR sequence up to the maximum value of 'r' and then calculate the XOR sum for each query.,Recursively calculate the XOR sequence and store intermediate results in a memoization table.,Calculate the XOR sequence using a generator function and evaluate the XOR sum on demand.,Compute the sum of 'l' and 'r' and return the XOR of the sum with 'l' XOR 'r'.,"Utilize the pattern of XOR sums for numbers 0 to n: n % 4 == 0: n, n % 4 == 1: 1, n % 4 == 2: n + 1, n % 4 == 3: 0. Calculate XOR(0, r) XOR XOR(0, l-1)",,algorithms,"['array', 'XOR', 'sequence']"
https://www.hackerrank.com/challenges/the-blacklist?isFullScreen=true,"A new gangster is trying to take control of the city. He makes a list of his
adversaries (e.g.
gangster
,
gangster
, ...
gangster
,
gangster
) and plans to get rid of them.
mercenaries are willing to do the job. The gangster can use any number of these mercenaries. But he has to honor one condition set by them: they have to be assigned in such a way that they eliminate a consecutive group of gangsters in the list, e.g.
gangster
,
gangster
, ...,
gangster
,
gangster
, where the following is true:
.
While our new gangster wants to kill all of them, he also wants to pay the least amount of money. All mercenaries charge a different amount to kill different people. So he asks you to help him minimize his expenses.
Input Format
The first line contains two space-separated integers,
and
. Then
lines follow, each containing
integers as follows:
The
th
number on the
th
line is the amount charged by the
th
mercenary for killing the
th
gangster on the list.
Constraints
Output Format
Just one line, the minimum cost for killing the
gangsters on the list.
Sample Input
3 2
1 4 1
2 2 2
Sample Output
5
Explanation
The new gangster can assign
mercenary 1
to kill
gangster 1
, and
mercenary 2
to kill
gangster 2
and
gangster 3
.","Use a greedy approach, always selecting the mercenary with the lowest cost for the next available gangster.",Sort the mercenaries by their average cost per gangster and assign them in that order.,"Use a dynamic programming approach where the state is (mercenary, gangster) and the value is the minimum cost to eliminate up to that gangster using that mercenary.",Calculate all possible assignments of mercenaries to consecutive groups of gangsters and choose the one with the minimum cost.,Employ dynamic programming where dp[i] stores the minimum cost to eliminate the first i gangsters.,,algorithms,"['dynamic programming', 'optimization', 'minimum cost']"
https://www.hackerrank.com/challenges/spies-revised?isFullScreen=true,"Two spies in a grid will have their covers blown if:
They are both in the same row.
They are both in the same column.
They can see each other diagonally (i.e., lie in a line inclined
° or
° to the base of the grid).
The level of danger is now increased! In addition to the conditions above,
no
spies may lie in any straight line
. This line need not be aligned
° or
° to the base of grid.
Write a program in the language of your choice to place
spies (one spy per row) on an
grid without blowing anyone's cover. Your program must then print the following
lines describing a valid configuration:
The value of
.
A space-separated list of
-indexed column numbers, where each value
is the column number of the spy in row
(where
).
Solve this problem for
as large as possible, up to (and including)
.
Note:
Run
and
Custom Input
are not available for this challenge; you must click
Submit Code
for your submission to be scored. Your score for this challenge will always be the maximum value scored by any of your submissions.
Examples
In the examples below,
denotes a spy and * denotes an empty cell.
Sample Configuration 0
A valid configuration for
:
*
S
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
S
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
Sample Output 0
This C++ code:
#include
<stdio>
using
namespace
std
;
int
main
(){
cout
<<
""11
\n
""
;
cout
<<
""2 4 7 1 8 11 5 3 9 6 10""
;
return
0
;
}
Produces this output:
11
2 4 7 1 8 11 5 3 9 6 10
This configuration will earn a score of
.
Sample Configuration 1
A valid configuration for
:
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
Sample Output 1
This Python code:
print
""13""
print
""1 3 12 10 7 2 11 5 8 13 9 4 6""
Produces this output:
13
1 3 12 10 7 2 11 5 8 13 9 4 6
This configuration will earn a score of
.
Sample Configuration 2
An invalid configuration for
:
S
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
S
*
S
*
*
*
*
*
*
*
*
S
*
*
*
*
*
*
*
*
S
*
Sample Output 2
The following output:
7
1 3 5 7 2 4 6
will earn a score of
because the spies in the first
rows are in a straight line as are the spies in the next
rows.
Input Format
There is no input for this challenge.
Constraints
is odd.
(
Do not
submit for any value of
larger than
)
Scoring
A correct configuration will get a score of
.
Output Format
Print the following
lines of output:
The first line should be a single integer denoting the value of
.
The second line should contain a space-separated list of integers. Each integer
(where
) should be the
-indexed column number where the spy in row
is located.","Use a backtracking algorithm, randomly placing spies and reverting if a conflict is found, until a solution is reached.","Employ a greedy algorithm, placing each spy in the safest available column in its row without considering future placements.","Precompute all possible configurations and then filter out the invalid ones, selecting the largest valid N.",Start with a random configuration and use simulated annealing to iteratively improve it until a valid configuration is found.,"Utilize a constraint satisfaction algorithm (e.g., n-queens variant) to systematically explore possible placements and prune search space.",,algorithms,"['constraint satisfaction', 'backtracking', 'n-queens']"
https://www.hackerrank.com/challenges/bike-racers?isFullScreen=true,"There are
bikers present in a city (shaped as a grid) having
bikes. All the bikers want to participate in the HackerRace competition, but unfortunately only
bikers can be accommodated in the race. Jack is organizing the HackerRace and wants to start the race as soon as possible. He can instruct any biker to move towards any bike in the city. In order to minimize the time to start the race, Jack instructs the bikers in such a way that the first
bikes are acquired in the minimum time.
Every biker moves with a unit speed and one bike can be acquired by only one biker.
A biker can proceed in any direction
. Consider distance between bikes and bikers as Euclidean distance.
Jack would like to know the
square of required time
to start the race as soon as possible.
Input Format
The first line contains three integers,
,
, and
, separated by a single space.
The following
lines will contain
pairs of integers denoting the co-ordinates of
bikers. Each pair of integers is separated by a single space. The next
lines will similarly denote the co-ordinates of the
bikes.
Constraints
,
Output Format
A single line containing the square of required time.
Sample Input
3 3 2
0 1
0 2
0 3
100 1
200 2
300 3
Sample Output
40000
Explanation
There's need for two bikers for the race. The first biker (0,1) will be able to reach the first bike (100,1) in 100 time units. The second biker (0,2) will be able to reach the second bike (200,2) in 200 time units. This is the most optimal solution and will take 200 time units. So output will be 200
2
= 40000.","Use a greedy approach, pairing each biker with the closest bike in each iteration, regardless of overall cost.","Calculate all possible biker-bike pairings and choose the pairings that minimize the average time, then square the average.","Sort the bikers and bikes by their x-coordinates, then pair them sequentially and square the resulting time.","Calculate the minimum Euclidean distance between each biker and bike, sum the k smallest distances, and then square the sum.","Solve using the Hungarian algorithm or minimum-cost maximum matching to find the optimal assignment of bikers to bikes, then square the maximum time taken among the first k bikers.",,algorithms,"['Hungarian algorithm', 'minimum-cost maximum matching', 'Euclidean distance']"
https://www.hackerrank.com/challenges/vertical-rooks?isFullScreen=true,"HackerChess is a variant of chess played at HackerRank. It is a game played between two players who make moves in turns until one of them cannot make any move. The player who cannot make a move loses the game and the other player is declared the winner. The game is played on a board with
rows and
columns. The only pieces used in the game are rooks. A rook in HackerChess moves only vertically, which means that in never leaves a column to which it belongs. Moreover, in a single move, a rook moves through any number of unoccupied cells. Notice that there are no captures in HackerChess, two rooks cannot occupy the same cell, and a rook cannot jump over another rook. Each player has exactly one rook in each of the
columns of the board.
Given the initial position of the rooks and knowing that the second player makes the first move, decide who will win the game if both players play optimally.
Input Format
In the first line, there is a single integer
denoting the number of games to be played. After that, descriptions of
games follow:
In the first line, there is a single integer
denoting the size of the board. Next,
lines follow. In the
-th of them there is a single integer
denoting the row of the rook belonging to the first player placed in the
-th column. After that, another
lines follow. In the
-th of them there is a single integer
denoting the row of the rook belonging to the second player placed in the
-th column.
Constraints
Output Format
Print exactly
lines. In the
-th of them, print
player-1
if the first player will win the
-th game. Otherwise, print
player-2
in this line.
Sample Input 0
1
3
1
2
2
3
1
1
Sample Output 0
player-2
Explanation 0
There is only one game player in the sample input. The game is played on the board with
rows and
columns. Let's denote the first player's rooks as red rooks and the second player's rooks as green ones. Then the initial position of the game looks like this:
https://s3.amazonaws.com/hr-assets/0/1497441833-dfbf8fbc16-initial.jpg
The second player moves first and he can move his rook in the first column to the second row. After this move, the position looks as follows:
https://s3.amazonaws.com/hr-assets/0/1497441866-e3a6c5d9f0-1.jpg
Next, it is the first player's turn. He cannot make any move with his rook in the first column, so he has to make a move in the second or the third column. Without the loss of generality, let's assume that he makes a move in the second column. He can only make one such move, i.e. move the rook from the second to the third row. This results in the following position:
https://s3.amazonaws.com/hr-assets/0/1497441899-0ed71c73ec-2.jpg
After that, the best move for the second player is to move his rook in the second column from the first to the second row. After this move, the position looks like this:
https://s3.amazonaws.com/hr-assets/0/1497441914-91e26a4441-3.jpg
Next, it is again the first player's move. The only move he can make is to move his rook in the third column from the second to the third row. It results in the following position:
https://s3.amazonaws.com/hr-assets/0/1497441924-0c9b8aaab7-4.jpg
Then, the best move for the second player is to move his rook in the third column from the first to the second row. After that, the position looks as follows:
https://s3.amazonaws.com/hr-assets/0/1497441935-5530dae1e5-5.jpg
Next, it is the first player's move, but since he is unable to make any valid move, he loses and the second player is declared a winner.
It shows that regardless of the first player's moves, the second player has a strategy leading to his victory.
Sample Input 1
1
4
3
3
3
3
4
4
4
4
Sample Output 1
player-1
Explanation 1
Second player cannot make a move so
is the winner.",The first player always wins if the XOR sum of the differences between rook positions is non-zero.,The game's outcome depends only on the largest difference between the rook positions in each column.,Player 2 wins if and only if the sum of differences in rook positions is even.,Player 1 wins if any column has rooks in the same row.,"Calculate the XOR sum of the differences between the rows of the rooks in each column. If the XOR sum is zero, player 2 wins; otherwise, player 1 wins.",,algorithms,"['game theory', 'xor', 'nim']"
https://www.hackerrank.com/challenges/short-palindrome?isFullScreen=true,"Consider a string,
, of
lowercase English letters where each character,
(
, denotes the letter at index
in
. We define an
palindromic tuple of
to be a sequence of indices in
satisfying the following criteria:
, meaning the characters located at indices
and
are the same.
, meaning the characters located at indices
and
are the same.
, meaning that
,
,
, and
are ascending in value and are valid indices within string
.
Given
, find and print the number of
tuples satisfying the above conditions. As this value can be quite large, print it modulo
.
Function Description
Complete the function
shortPalindrome
in the editor below.
shortPalindrome
has the following paramter(s):
-
string s:
a string
Returns
-
int:
the number of tuples, modulo
Input Format
A single string,
.
Constraints
It is guaranteed that
only contains lowercase English letters.
Sample Input 0
kkkkkkz
Sample Output 0
15
Explanation 0
The letter
z
will not be part of a valid tuple because you need at least two of the same character to satisfy the conditions defined above. Because all tuples consisting of four
k
's are valid, we just need to find the number of ways that we can
choose
four of the six
k
's. This means our answer is
.
Sample Input 1
ghhggh
Sample Output 1
4
Explanation 1
The valid tuples are:
Thus, our answer is
.
Sample Input 0
kkkkkkz
Sample Output 0
15
Sample Input 1
abbaab
Sample Output 1
4
Sample Input 2
akakak
Sample Output 2
2
Explanation 2
Tuples possible are",Use dynamic programming to store counts of substrings of length 2 and 3.,Iterate through all possible quadruples of indices and check if they form a palindromic tuple.,Precompute all possible palindromes and count their occurrences in the string.,Use a sliding window of size 4 and check if it's a palindromic tuple.,"Count occurrences of pairs, then use these counts to determine the number of palindromic tuples, applying modulo at each step.",,algorithms,"['string', 'palindrome', 'counting']"
https://www.hackerrank.com/challenges/lego-blocks?isFullScreen=true,"You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width):
d
h
w
1
1
1
1
1
2
1
1
3
1
1
4
Using these blocks, you want to make a wall of height
and width
. Features of the wall are:
- The wall should not have any holes in it.
- The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks.
- The bricks must be laid horizontally.
How many ways can the wall be built?
Example
The height is
and the width is
.  Here are some configurations:
https://s3.amazonaws.com/hr-assets/0/1526322298-72d127a6f7-bricks.png
These are not all of the valid permutations.  There are
valid permutations in all.
Function Description
Complete the
legoBlocks
function in the editor below.
legoBlocks has the following parameter(s):
int n:
the height of the wall
int m:
the width of the wall
Returns
-
int:
the number of valid wall formations modulo
Input Format
The first line contains the number of test cases
.
Each of the next
lines contains two space-separated integers
and
.
Constraints
Sample Input
STDIN   Function
-----   --------
4       t = 4
2 2     n = 2, m = 2
3 2     n = 3, m = 2
2 3     n = 2, m = 3
4 4     n = 4, m = 4
Sample Output
3
7
9
3375
Explanation
For the first case, we can have:
https://s3.amazonaws.com/hr-assets/0/1526322982-b16b20303f-legosample.png
For the second case, each row of the wall can contain either two blocks of width 1, or one block of width 2. However, the wall where all rows contain two blocks of width 1 is not a solid one as it can be divided vertically. Thus, the number of ways is
and
.","Calculate all possible wall configurations without considering the solid structure constraint, then subtract invalid configurations using a depth-first search.","Use dynamic programming to find the number of ways to form a row and the total number of walls, then apply inclusion-exclusion to account for non-solid walls.","Employ a recursive approach to explore all possible arrangements of bricks, memoizing results to avoid redundant computations.","Calculate the number of ways to fill each row independently and multiply the results across all rows, without adjusting for the 'solid structure' requirement.","Employ dynamic programming to compute total possible row configurations and total wall configurations. Then, compute configurations for non-solid walls and subtract them from the total, using modular arithmetic.",,algorithms,"['dynamic programming', 'combinatorics', 'modular arithmetic']"
https://www.hackerrank.com/challenges/the-prime-game?isFullScreen=true,"Manasa loves the
nim game
, in which there are
buckets, each having
balls. Two players play alternately. Each turn consists of removing some non-zero number of balls from one of the bucket. A player with lack of moves looses. But, Manasa having played it so many times, she gets bored one day. So she wants to change the rules of the game. She loves prime numbers, so she makes a new rule: any player can only remove a prime number of balls from a bucket. But there are infinite number prime numbers. So to keep the game simple, a player can only remove
balls from a bucket if
belongs to the set
The whole game can now be described as follows:
There are
buckets, and the
bucket contains
balls. A player can choose a bucket and remove
balls from that bucket where
belongs to
. A player loses if there are no more available moves.
Manasa plays the first move against Sandy. Who will win if both of them play optimally?
Input Format
The first line contains an integer
, the number of test cases.
Each test case consists of two lines. The first line contains a single integer
. The second line contain
space-separated integers
.
Constraints
Output Format
Print a single line containing the name of the winner:
Manasa
or
Sandy
.
Sample Input 0
2
2
10 10
3
2 2 3
Sample Output 0
Sandy
Manasa
Explanation 0
For the first testcase: Since both the buckets have same number of balls, Manasa can choose any one of them for her first move. If Manasa selects to remove
or
balls to remove from first bucket. Now, Sandy  can always counter her move by removing
balls from first bucket if it's left with
balls respectively. Now, there are no valid moves left for first bucket. The same thing repeats for second bucket and Sandy wins.
For the second testcase: Manasa removes
balls from the third bucket. Now, if Sandy choose the remove
balls from second bucket Manasa will empty the first bucket and if Sandy choose the remove
balls from first bucket, Manasa will empty second one. Hence, Manasa wins.",Determine the Sprague-Grundy value of each pile by taking the maximum prime number in the set S,"Calculate the bitwise AND of all pile sizes. If the result is non-zero, Manasa wins; otherwise, Sandy wins.","If the sum of all pile sizes is even, Sandy wins; otherwise, Manasa wins.","Calculate the number of piles with an odd number of balls. If the count is odd, Manasa wins; otherwise, Sandy wins.","Determine the Sprague-Grundy value of each pile and calculate the XOR sum of these values. If the XOR sum is non-zero, Manasa wins; otherwise, Sandy wins.",,algorithms,"['game theory', 'nim', 'sprague-grundy']"
https://www.hackerrank.com/challenges/red-john-is-back?isFullScreen=true,"Red John has committed another murder. This time, he doesn't leave a red smiley behind. Instead he leaves a puzzle for Patrick Jane to solve. He also texts Teresa Lisbon that if Patrick is successful, he will turn himself in. The puzzle begins as follows.
There is a wall of size
4xn
in the victim's house. The victim has an infinite supply of bricks of size
4x1
and
1x4
in her house. There is a hidden safe which can only be opened by a particular configuration of bricks. First we must calculate the total number of ways in which the bricks can be arranged so that the entire wall is covered.  The following diagram shows how bricks might be arranged to cover walls where
:
https://s3.amazonaws.com/hr-assets/0/1523548158-285d2d86ee-bricks.png
There is one more step to the puzzle.  Call the number of possible arrangements
.   Patrick must calculate the number of prime numbers
in the inclusive range
.
As an example, assume
.  From the diagram above, we determine that there is only one configuration that will cover the wall properly.
is not a prime number, so
.
A more complex example is
.  The bricks can be oriented in
total configurations that cover the wall.  The two primes
and
are less than or equal to
, so
.
https://s3.amazonaws.com/hr-assets/0/1523550290-dc87615c2f-bricks2.png
Function Description
Complete the
redJohn
function in the editor below.  It should return the number of primes determined, as an integer.
redJohn has the following parameter(s):
n
: an integer that denotes the length of the wall
Input Format
The first line contains the integer
, the number of test cases.
Each of the next
lines contains an integer
, the length of the
wall.
Constraints
Output Format
Print the integer
on a separate line for each test case.
Sample Input
2
1
7
Sample Output
0
3
Explanation
For
, the brick can be laid in 1 format only: vertically.
The number of primes
is
.
For
, one of the ways in which we can lay the bricks is
https://s3.amazonaws.com/hr-assets/0/1526565411-23a30392d5-brick2.jpg
There are
ways of arranging the bricks for
and there are
primes
.","The number of arrangements is always a Fibonacci number, and the number of primes is therefore logarithmic in n.","The number of arrangements is a Catalan number, and the number of primes requires primality tests for all numbers up to the Catalan number.","The number of arrangements can be found using dynamic programming, and the number of primes can be estimated using the Prime Number Theorem.","The number of arrangements is equivalent to 4^n, and the number of primes less than it can be approximated using Wilson's Theorem.",The number of arrangements can be found using dynamic programming; the number of primes must be calculated using an algorithm like the Sieve of Eratosthenes.,,algorithms,"['dynamic programming', 'prime numbers', 'sieve of eratosthenes']"
https://www.hackerrank.com/challenges/jumping-rooks?isFullScreen=true,"Nina has an
chessboard and
jumping rooks. Every cell of the chessboard is either
blocked
or
free
, and Nina can only put a
single
rook in any
free
cell.
Two jumping rooks beat each other if they are either in the same row or in the same column
and
all cells between them are free (note that it's possible that there are some other rooks between them). More formally, if the first rook is in cell
and the second rook is in cell
(where
), then these two rooks beat each other if and only if
are free. If the rooks are in cells
and
, then cells
must all be free.
Given the configuration of the chessboard and some
, help Nina place
jumping rooks in the chessboard's free cells such that the number of pairs of rooks that beat each other is minimal. Then print a single integer denoting the number of rooks that beat each other.
Input Format
The first line contains two space-separated integers describing the respective values of
(the size of the chessboard) and
(the number of rooks to place).
Each line
of the
subsequent lines contains a string of
characters describing each row in the chessboard. The
character of the
line is
#
if cell
is blocked or
.
if the cell is free.
Constraints
It is guaranteed that
is less than the number of free cells in the chessboard.
Output Format
Print a single integer denoting the minimum possible number of pairs of rooks that beat each other.
Sample Input 0
3 4
...
...
...
Sample Output 0
2
Explanation 0
For this input, one possible arrangement is:
o.o
.o.
..o
where each
o
is a jumping rook.
Sample Input 1
5 10
..#..
..#..
#####
..#..
..#..
Sample Output 1
4
Explanation 1
For this input, one possible arrangement is:
.o#o.
oo#oo
#####
.o#o.
o.#.o
where each
o
is a jumping rook.","Use a greedy approach, placing rooks in rows/columns with the most free spaces until all rooks are placed, then count attacking pairs.","Place rooks randomly and simulate the game multiple times, keeping track of the minimum attacking pairs found.",Calculate the number of free cells in each row and column. Sort these counts and place rooks in cells corresponding to the highest counts to minimize conflicts.,"Place rooks in a diagonal pattern to ensure they don't attack each other, then place remaining rooks randomly.",Model the problem as a maximum independent set problem in a graph where nodes are free cells and edges connect attacking pairs. Find an approximate solution using heuristics.,,algorithms,"['greedy algorithm', 'graph theory', 'optimization']"
https://www.hackerrank.com/challenges/zig-zag-sequence?isFullScreen=true,"In this challenge, the task is to debug the existing code to successfully execute all provided test files.
Given an array of
distinct integers, transform the array into a zig zag sequence by permuting the array elements. A sequence will be called a zig zag sequence if the first
elements in the sequence are in increasing order and the last
elements are in decreasing order, where
. You need to find the
lexicographically smallest
zig zag sequence of the given array.
Example
.
Now if we permute the array as
, the result is a zig zag sequence.
Debug the given function
findZigZagSequence
to return the appropriate zig zag sequence for the given input array.
Note:
You can modify at most
three
lines in the given code.  You cannot add or remove lines of code.
To restore the original code, click on the icon to the right of the language selector.
Input Format
The first line contains
the number of test cases. The first line of each test case contains an integer
, denoting the number of array elements.
The next line of the test case contains
elements of array
.
Constraints
(
is always odd
)
Output Format
For each test cases, print the elements of the transformed zig zag sequence in a single line.
Sample Input 0
1
7
1 2 3 4 5 6 7
Sample Output 0
1 2 3 7 6 5 4",Sort the entire array in ascending order.,Reverse the first half of the sorted array.,Swap the middle element with the last element of the array.,Sort the array in descending order.,"Sort the array, find the middle element, and reverse the elements after the middle element.",,algorithms,"['sorting', 'array manipulation', 'debugging']"
https://www.hackerrank.com/challenges/gridland-provinces?isFullScreen=true,"The Kingdom of Gridland contains
provinces. Each province is defined as a
grid where each cell in the grid represents a city. Every cell in the grid contains a single lowercase character denoting the first character of the city name corresponding to that cell.
From a city with the coordinates
, it is possible to move to any of the following cells in
unit of time (provided that the destination cell is within the confines of the grid):
A knight wants to visit all the cities in Gridland. He can start his journey in any city and immediately stops his journey after having visited each city at least once. Moreover, he always plans his journey in such a way that the total time required to complete it is minimum.
After completing his tour of each province, the knight forms a string by concatenating the characters of all the cells in his path. How many distinct strings can he form in each province?
Input Format
The first line contains a single integer,
, denoting the number of provinces. The
subsequent lines describe each province over the following three lines:
The first line contains an integer,
, denoting the number of columns in the province.
Each of the next two lines contains a string,
, of length
denoting the characters for the first and second row of the province.
Constraints
Output Format
For each province, print the number of distinct strings the knight can form on a new line.
Sample Input
3
1
a
a
3
dab
abd
5
ababa
babab
Sample Output
1
8
2
Explanation
Province 0:
https://s3.amazonaws.com/hr-challenge-images/20359/1466406002-188ce9a517-hackerland.png
The knight can only form one string (
aa
), so we print
on a new line.
Province 1:
https://s3.amazonaws.com/hr-challenge-images/20359/1466406112-3eea23fe0a-hackerland1.png
The knight can form eight different strings (
abdbad
,
adabdb
,
badabd
,
bdbada
,
dababd
,
dabdba
,
dbabad
, and
dbadab
), so we print
on a new line.
Province 2:
https://s3.amazonaws.com/hr-challenge-images/20359/1466406248-cb1a6f25b4-hackerland2.png
The knight can form two different strings (
ababababab
and
bababababa
), so we print
on a new line.",Breadth-First Search,Depth-First Search,A* Search,Dijkstra's Algorithm,Hamiltonian Path Algorithm,,algorithms,"['graph theory', 'pathfinding', 'Hamiltonian cycle']"
https://www.hackerrank.com/challenges/torque-and-development?isFullScreen=true,"Determine the minimum cost to provide library access to all citizens of HackerLand.  There are
cities numbered from
to
. Currently there are no libraries and the cities are not connected.  Bidirectional roads may be built between any city pair listed in
. A citizen has access to a library if:
Their city contains a library.
They can travel by road from their city to a city containing a library.
Example
The following figure is a sample map of HackerLand where the dotted lines denote possible roads:
https://s3.amazonaws.com/hr-challenge-images/0/1481983010-b779ad2b2b-torque1.png
The cost of building any road is
, and the cost to build a library in any city is
.  Build
roads at a cost of
and
libraries for a cost of
.  One of the available roads in the cycle
is not necessary.
There are
queries, where each query consists of a map of HackerLand and value of
and
. For each query, find the minimum cost to make libraries accessible to all the citizens.
Function Description
Complete the function
roadsAndLibraries
in the editor below.
roadsAndLibraries has the following parameters:
int n
: integer, the number of cities
int c_lib
: integer, the cost to build a library
int c_road
: integer, the cost to repair a road
int cities[m][2]
: each
contains two integers that represent cities that can be connected by a new road
Returns
-
int
:  the minimal cost
Input Format
The first line contains a single integer
, that denotes the number of queries.
The subsequent lines describe each query in the following format:
- The first line contains four space-separated integers that describe the respective values of
,
,
and
, the number of cities, number of roads, cost of a library and cost of a road.
- Each of the next
lines contains two space-separated integers,
and
, that describe a bidirectional road that can be built to connect cities
and
.
Constraints
Each road connects two distinct cities.
Sample Input
STDIN       Function
-----       --------
2           q = 2
3 3 2 1     n = 3, cities[] size m = 3, c_lib = 2, c_road = 1
1 2         cities = [[1, 2], [3, 1], [2, 3]]
3 1
2 3
6 6 2 5     n = 6, cities[] size m = 6, c_lib = 2, c_road = 5
1 3         cities = [[1, 3], [3, 4],...]
3 4
2 4
1 2
2 3
5 6
Sample Output
4
12
Explanation
Perform the following
queries:
HackerLand contains
cities and can be connected by
bidirectional roads. The price of building a library is
and the price for repairing a road is
.
https://s3.amazonaws.com/hr-challenge-images/0/1479708586-328d4ff060-torque.png
The cheapest way to make libraries accessible to all is to:
Build a library in city
at a cost of
.
Build the road between cities
and
at a cost of
.
Build the road between cities
and
at a cost of
.
This gives a total cost of
. Note that the road between cities
and
does not need to be built because each is connected to city
.
In this scenario it is optimal to build a library in each city because the cost to build a library is less than the cost to build a road.
https://s3.amazonaws.com/hr-challenge-images/0/1479709794-c1d435eec9-torque3.png
There are
cities, so the total cost is
.",Use Dijkstra's algorithm to find the shortest path between every pair of cities and build libraries accordingly.,"Build a library in every city, ignoring the road costs completely.",Apply Prim's algorithm to find the minimum spanning tree and build a library in a randomly selected city.,"Use a greedy approach, connecting the closest cities first and building a library only when necessary.","Use Depth First Search (DFS) or Breadth First Search (BFS) to find connected components, building one library per component and connecting the remaining cities within that component using roads.",,algorithms,"['graph theory', 'DFS', 'BFS']"
https://www.hackerrank.com/challenges/2s-complement?isFullScreen=true,"Understanding
's complement
representation is fundamental to learning about Computer Science. It allows us to write negative numbers in binary.  The leftmost digit is used as a sign bit.  If it is
, we have a negative number and it is represented as the two's complement of its absolute value.  Let's say you wrote down the
's complement representation for each
-bit integer in the inclusive range from
to
.  How many
's would you write down in all?
For example, using an
-bit byte rather than
bit integer, the two's complement of a number can be found by reversing all its bits and adding
.  The two's complement representations for a few numbers are shown below:
|Number|                Representation in
Number   Binary     Inverse     Two's Complement
-3      00000011    11111100    11111101
-2      00000010    11111101    11111110
-1      00000001    11111110    11111111
 0      00000000                00000000
 1      00000001                00000001
 2      00000010                00000010
 3      00000011                00000011
To write down that range of numbers' two's complements in
bits, we wrote
's.  Remember to use
bits rather than
in your solution.  The logic is the same, so the
bit representation was chosen to reduce apparent complexity in the example.
Function Description
Complete the
twosCompliment
function in the editor below.  It should return an integer.
twosCompliment has the following parameter(s):
-
a
: an integer, the range minimum
-
b
: an integer, the range maximum
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
lines contains two space-separated integers,
and
.
Constraints
Output Format
For each test case, print the number of
's in the
-bit
's complement representation for integers in the inclusive range from
to
on a new line.
Sample Input 0
3
-2 0
-3 4
-1 4
Sample Output 0
63
99
37
Explanation 0
Test case 0
-2 has 31 ones
-1 has 32 ones
0 has 0 ones
31+32+0 = 63
Test case 1
-3 has 31 ones
-2 has 31 ones
-1 has 32 ones
0 has 0 ones
1 has 1 ones
2 has 1 ones
3 has 2 ones
4 has 1 ones
31+31+32+0+1+1+2+1 = 99
Test case 2
-1 has 32 ones
0 has 0 ones
1 has 1 ones
2 has 1 ones
3 has 2 ones
4 has 1 ones
32+0+1+1+2+1 = 37
Sample Input 1
4
-5 0
1 7
-6 -3
3 6
Sample Output 1
155
12
122
7
Explanation 1
Test case 0
-5 has 31 ones
-4 has 30 ones
-3 has 31 ones
-2 has 31 ones
-1 has 32 ones
0 has 0 ones
31+30+31+31+32+0 = 155
Test case 1
1 has 1 ones
2 has 1 ones
3 has 2 ones
4 has 1 ones
5 has 2 ones
6 has 2 ones
7 has 3 ones
1+1+2+1+2+2+3 = 12
Test case 2
-6 has 30 ones
-5 has 31 ones
-4 has 30 ones
-3 has 31 ones
30+31+30+31 = 122
Test case 3
3 has 2 ones
4 has 1 ones
5 has 2 ones
6 has 2 ones
2+1+2+2 = 7",2147483647,4294967295,0,-1,"An algorithm to count the number of ones in the two's complement representation of each integer in the range [a, b] and sum them.",,algorithms,"[""two's complement"", 'bit manipulation', 'counting']"
https://www.hackerrank.com/challenges/interval-selection?isFullScreen=true,"Given a set of
intervals, find the size of its largest possible subset of intervals such that no three intervals in the subset share a common point.
Input Format
The first line contains an integer,
, denoting the number of interval sets you must find answers for. The
subsequent lines describe each of the
interval sets as follows:
The first line contains an integer,
, denoting the number of intervals in the list.
Each line
of the
subsequent lines contains two space-separated integers describing the respective starting (
) and ending (
) boundaries of an interval.
Constraints
Output Format
For each of the
interval sets, print an integer denoting the size of the largest possible subset of intervals in the given set such that no three points in the subset overlap.
Sample Input
4
3
1 2
2 3
2 4
3
1 5
1 5
1 5
4
1 10
1 3
4 6
7 10
4
1 10
1 3
3 6
7 10
Sample Output
2
2
4
3
Explanation
For set
, all three intervals fall on point
so we can only choose any
of the intervals. Thus, we print
on a new line.
For set
, all three intervals span the range from
to
so we can only choose any
of them. Thus, we print
on a new line.
For set
, we can choose all
intervals without having more than two of them overlap at any given point. Thus, we print
on a new line.
For set
, the intervals
,
, and
all overlap at point
, so we must only choose
of these intervals to combine with the last interval,
, for a total of
qualifying intervals. Thus, we print
on a new line.","Sort the intervals by start time and use a greedy approach to select non-overlapping intervals, allowing up to two overlaps at any point.","Use dynamic programming, where dp[i] represents the maximum size subset considering the first i intervals, but incorrectly handles the overlap constraint.","Sort the intervals by end time and iteratively select intervals, ensuring no three selected intervals overlap, but fails to find the optimal solution in all cases.","Randomly select subsets of intervals until a subset satisfying the condition is found, then return the size of the largest such subset found.","Use dynamic programming where dp[i] stores the size of the largest subset considering intervals up to i. Calculate dp[i] by either including or excluding interval i, checking for violation of the three-overlap constraint with previously selected intervals.",,algorithms,"['intervals', 'dynamic programming', 'overlap']"
https://www.hackerrank.com/challenges/mandragora?isFullScreen=true,"The evil forest is guarded by vicious mandragoras. Garnet and her
pet
must make a journey through.  She starts with
health point (
) and
experience points.
As she encouters each mandragora, her choices are:
Garnet's pet
eats
mandragora
. This increments
by
and defeats mandragora
.
Garnet's pet
battles
mandragora
. This increases
by
experience points and defeats mandragora
.
Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.
For example, as always, she starts out with
health point and
experience points.  Mandragoras have the following health values:
.  For each of the beings, she has two choices,
at or
attle.  We have the following permutations of choices and outcomes:
Action  s   p
_______ _   __
e, e, e 4   0
e, e, b 3   15
e, b, b 2   14
b, b, b 1   10
b, b, e 2   10
b, e, e 3   9
b, e, b 2   16
e, b, e 3   6
Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have
health points, then battles the beast with
heatlth points to gain
experience points.  We see that the best option is to eat the beast with
points and battle the others to achieve
experience points.
Function Description
Complete the
mandragora
function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn.
mandragora has the following parameter(s):
H
: an array of integers that represents the health values of mandragoras
Input Format
The first line contains an integer,
, denoting the number of test cases. Each test case is described over two lines:
The first line contains a single integer
, the number of mandragoras in the forest.
The second line contains
space-separated integers describing the respective health points for the mandragoras
.
Constraints
, where
The sum of all
s in a single test case is
Output Format
For each test case, print a single line with an integer denoting the maximum number of experience points that Garnet can earn.
Sample Input
1
3
3 2 2
Sample Output
10
Explanation
There are
mandragoras having the following health points:
. Initially,
and
. The following is an optimal sequence of actions for achieving the maximum number of experience points possible:
Eat
the second mandragora (
).
is increased from
to
, and
is still
.
Battle
the first mandragora (
).
remains the same, but
increases by
experience points.
Battle
the third mandragora (
).
remains the same, but
increases by
experience points.
Garnet earns
experience points.","Use dynamic programming to store and reuse the results of subproblems, focusing on maximizing experience at each step.",Sort the mandragoras by health in descending order and always battle the strongest ones first.,Employ a greedy algorithm by always eating the mandragora with the highest health to maximize Garnet's health points.,Calculate the total health of all mandragoras and subtract each mandragora's health to find the maximum experience.,"Sort the mandragoras by health, then iterate through them, calculating experience gained by battling remaining mandragoras after eating the preceding ones.",,algorithms,"['dynamic programming', 'greedy algorithm', 'sorting']"
https://www.hackerrank.com/challenges/count-luck?isFullScreen=true,"Ron and Hermione are deep in the Forbidden Forest collecting potion ingredients, and they've managed to lose their way. The path out of the forest is blocked, so they must make their way to a portkey that will transport them back to Hogwarts.
Consider the forest as an
grid. Each cell is either empty (represented by
.
) or blocked by a tree (represented by
). Ron and Hermione can move (together inside a single cell)
LEFT
,
RIGHT
,
UP
, and
DOWN
through empty cells, but they
cannot
travel through a tree cell. Their starting cell is marked with the character
, and the cell with the portkey is marked with a
. The upper-left corner is indexed as
.
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......XXXX.
In example above, Ron and Hermione are located at index
and the portkey is at
. Each cell is indexed according to
Matrix Conventions
.
Hermione decides it's time to find the portkey and leave. They start along the path and each time they have to choose a direction, she waves her wand and it points to the correct direction. Ron is betting that she will have to wave her wand exactly
times. Can you determine if Ron's guesses are correct?
The map from above has been redrawn with the path indicated as a series where
is the starting point (no decision in this case),
indicates a decision point and
is just a step on the path:
.X.X.10000X
.X*0X0XXX0X
.XX0X0XM01.
...100XXXX.
There are three instances marked with
where Hermione must use her wand.
Note:
It is guaranteed that there is only one path from the starting location to the portkey.
Function Description
Complete the
countLuck
function in the editor below.  It should return a string, either
if Ron is correct or
if he is not.
countLuck has the following parameters:
matrix
: a list of strings, each one represents a row of the matrix
k
: an integer that represents Ron's guess
Input Format
The first line contains an integer
, the number of test cases.
Each test case is described as follows:
The first line contains
space-separated integers
and
, the number of forest matrix rows and columns.
Each of the next
lines contains a string of length
describing a row of the forest matrix.
The last line contains an integer
, Ron's guess as to how many times Hermione will wave her wand.
Constraints
There will be exactly one
and one
in the forest.
Exactly one path exists between
and
.
Output Format
On a new line for each test case, print
if Ron impresses Hermione by guessing correctly.  Otherwise, print
.
Sample Input
3
2 3
*.M
.X.
1
4 11
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......XXXX.
3
4 11
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......XXXX.
4
Sample Output
Impressed
Impressed
Oops!
Explanation
For each test case,
denotes the number of times Hermione waves her wand.
Case 0:
Hermione waves her wand at
, giving us
. Because
, we print
on a new line.
Case 1:
Hermione waves her wand at
,
, and
, giving us
. Because
, we print
on a new line.
Case 2:
Hermione waves her wand at
,
, and
, giving us
. Because
and
,
and we print
on a new line.",Depth-First Search (DFS) without backtracking,Breadth-First Search (BFS) with pruning of already visited cells,Randomly traverse the grid until the target is found,"Greedy search, always moving towards the portkey's coordinates",Depth-First Search (DFS) with backtracking and counting decision points,,algorithms,"['DFS', 'graph traversal', 'backtracking']"
https://www.hackerrank.com/challenges/powers-game-1?isFullScreen=true,"After their success in coming up with
Fun Game
, Kyle and Mike invented another game having the following rules:
The game starts with an
-element sequence,
, and is played by two players,
and
.
The players move in alternating turns, with
always moving first. During each move, the current player chooses one of the asterisks (
) in the above sequence and changes it to either a
+
(plus) or a
-
(minus) sign.
The game ends when there are no more asterisks (
) in the expression. If the evaluated value of the sequence is divisible by
, then
wins; otherwise,
wins.
Given the value of
, can you determine the outcome of the game? Print
if
will win, or
if
will win. Assume both players always move optimally.
Input Format
The first line of input contains a single integer
, denoting the number of test cases.
Each line
of the
subsequent lines contains an integer,
, denoting the maximum exponent in the game's initial sequence.
Constraints
Output Format
For each test case, print either of the following predicted outcomes of the game on a new line:
Print
if
will win.
Print
if
will win.
Sample Input
1
2
Sample Output
First
Explanation
In this case, it doesn't matter in which order the asterisks are chosen and altered. There are
different courses of action and, in each one, the final value is not divisible by
(so
always loses and we print
on a new line).
Possible options:",First,Second,The outcome depends on the initial arrangement of asterisks.,The outcome is always a draw.,First,,algorithms,"['game theory', 'mathematical game', 'parity']"
https://www.hackerrank.com/challenges/cut-the-tree?isFullScreen=true,"There is an undirected tree where each vertex is numbered from
to
, and each contains a data value.  The
sum
of a tree is the sum of all its nodes' data values.  If an edge is cut, two smaller trees are formed.  The
difference
between two trees is the absolute value of the difference in their sums.
Given a tree, determine which edge to cut so that the resulting trees have a minimal
difference
between them, then return that difference.
Example
In this case, node numbers match their weights for convenience.  The graph is shown below.
https://s3.amazonaws.com/hr-assets/0/1525451112-5ca073ae7a-cutthetreeexample.png
The values are calculated as follows:
Edge    Tree 1  Tree 2  Absolute
Cut     Sum      Sum     Difference
1        8         13         5
2        9         12         3
3        6         15         9
4        4         17        13
5        5         16        11
The minimum absolute difference is
.
Note:
The given tree is
always
rooted at vertex
.
Function Description
Complete the
cutTheTree
function in the editor below.
cutTheTree has the following parameter(s):
int data[n]:
an array of integers that represent node values
int edges[n-1][2]:
an 2 dimensional array of integer pairs where each pair represents nodes connected by the edge
Returns
int:
the minimum achievable absolute difference of tree sums
Input Format
The first line contains an integer
, the number of vertices in the tree.
The second line contains
space-separated integers, where each integer
denotes the
data value,
.
Each of the
subsequent lines contains two space-separated integers
and
that describe edge
in tree
.
Constraints
, where
.
Sample Input
STDIN                       Function
-----                       --------
6                           data[] size n = 6
100 200 100 500 100 600     data = [100, 200, 100, 500, 100, 600]
1 2                         edges = [[1, 2], [2, 3], [2, 5], [4, 5], [5, 6]]
2 3
2 5
4 5
5 6
Sample Output
400
Explanation
We can visualize the initial, uncut tree as:
https://s3.amazonaws.com/hr-challenge-images/1629/1475619162-70ee42a9ce-cut-the-tree.png
There are
edges we can cut:
Edge
results in
Edge
results in
Edge
results in
Edge
results in
Edge
results in
The minimum
difference
is
.",Use dynamic programming to store subtree sums and then iterate through all possible edges.,Perform a depth-first search (DFS) and maintain a global minimum difference during traversal.,"Calculate the total sum and then, for each edge, subtract one node's value to estimate the difference.","Employ a greedy approach, always cutting the edge connected to the heaviest node.","Calculate the total sum, then use depth-first search (DFS) to find the subtree sums and minimize the absolute difference between subtree sum and (total sum - subtree sum).",,algorithms,"['tree', 'graph', 'depth-first search']"
https://www.hackerrank.com/challenges/cards-permutation?isFullScreen=true,"Alice was given the
integers from
to
. She wrote all possible permutations in increasing lexicographical order, and wrote each permutation in a new line. For example, for
, there are
possible permutations:
She then chose one permutation among them as her
favorite permutation
.
After some time, she forgot some elements of her favorite permutation. Nevertheless, she still tried to write down its elements. She wrote a
in every position where she forgot the true value.
She wants to know the sum of the line numbers of the permutations which could possibly be her favorite permutation, i.e., permutations which can be obtained by replacing the
s. Can you help her out?
Since the sum can be large, find it modulo
.
Input Format
The first line contains a single integer
.
The next line contains
space-separated integers
denoting Alice's favorite permutation with some positions replaced by
.
Constraints
The positive values appearing in
are distinct.
Subtask
For ~33% of the total points,
Output Format
Print a single line containing a single integer denoting the sum of the line numbers of the permutations which could possibly be Alice's favorite permutation.
Sample Input 0
4
0 2 3 0
Sample Output 0
23
Explanation 0
The possible permutations are
and
. The permutation
occurs on line
and the permutation
occurs on line
. Therefore the sum is
.
Sample Input 1
4
4 3 2 1
Sample Output 1
24
Explanation 1
There is no missing number in the permutation. Therefore, the only possible permutation is
, and it occurs on line
. Therefore the sum is
.","Recursively generate all permutations and filter those that match the given partial permutation, then sum their indices.",Use dynamic programming to store the rank of each possible partial permutation to avoid recomputation and compute the sum.,Apply inclusion-exclusion principle to count valid permutations directly without generating them explicitly.,Transform the problem into a constraint satisfaction problem (CSP) and use backtracking search to find valid permutations.,"Calculate the rank range by fixing known values and summing factorials for the unknown positions, then summing the ranks within that range.",,algorithms,"['permutation', 'ranking', 'combinatorics']"
https://www.hackerrank.com/challenges/summing-pieces?isFullScreen=true,"Consider an array,
, of length
. We can split
into contiguous segments called
pieces
and store them as another array,
. For example, if
, we have the following arrays of pieces:
contains three
-element pieces.
contains two pieces, one having
elements and the other having
element.
contains two pieces, one having
element and the other having
elements.
contains one
-element piece.
We consider the
value
of a piece in some array
to be
, and we consider the
total value
of some array
to be the sum of the values for all pieces in that
. For example, the total value of
is
.
Given
, find the total values for all possible
's, sum them together, and print this sum modulo
on a new line.
Input Format
The first line contains a single integer,
, denoting the size of array
.
The second line contains
space-separated integers describing the respective values in
(i.e.,
).
Constraints
Output Format
Print a single integer denoting the sum of the total values for all piece arrays (
's) of
, modulo
.
Sample Input 0
3
1 3 6
Sample Output 0
73
Explanation 0
Given
, our piece arrays are:
, and
.
, and
.
, and
.
, and
.
When we sum all the total values, we get
. Thus, we print the result of
on a new line.
Sample Input 1
5
4 2 9 10 1
Sample Output 1
971",Compute prefix sums and use combinatorics to count piece occurrences.,Enumerate all sub-arrays and directly calculate the sum of values for each.,Use dynamic programming to store intermediate piece values for efficiency.,Only consider contiguous segments of lengths that are powers of 2 to simplify calculations.,Calculate the contribution of each element by counting the number of times it appears in all possible piece arrays.,,algorithms,"['arrays', 'combinatorics', 'modular arithmetic']"
https://www.hackerrank.com/challenges/knightl-on-chessboard?isFullScreen=true,"is a chess piece that moves in an
L
shape. We define the possible moves of
as any movement from some position
to some
satisfying either of the following:
and
, or
and
Note that
and
allow for the same exact set of movements. For example, the diagram below depicts the possible locations that
or
can move to from its current location at the center of a
chessboard:
https://s3.amazonaws.com/hr-assets/0/1486410238-98ef4547f1-knightl-example-ps.png
Observe that for each possible movement, the Knight moves
units in one direction (i.e., horizontal or vertical) and
unit in the perpendicular direction.
Given the value of
for an
chessboard, answer the following question for each
pair where
:
What is the minimum number of moves it takes for
to get from position
to position
? If it's not possible for the Knight to reach that destination, the answer is
-1
instead.
Then print the answer for each
according to the
Output Format
specified below.
Input Format
A single integer denoting
.
Constraints
Output Format
Print exactly
lines of output in which each line
(where
) contains
space-separated integers describing the minimum number of moves
must make for each respective
(where
). If some
cannot reach position
, print
-1
instead.
For example, if
, we organize the answers for all the
pairs in our output like this:
(1,1) (1,2)
(2,1) (2,2)
Sample Input 0
5
Sample Output 0
4 4 2 8
4 2 4 4
2 4 -1 -1
8 4 -1 1
Explanation 0
The diagram below depicts possible minimal paths for
,
, and
:
https://s3.amazonaws.com/hr-assets/0/1486417363-fa5b2d9c1d-knightl-sample0.png
One minimal path for
is:
We then print
4 4 2 8
as our first line of output because
took
moves,
took
moves,
took
moves, and
took
moves.
In some of the later rows of output, it's impossible for
to reach position
. For example,
can only move back and forth between
and
so it will never reach
.",Dijkstra's algorithm,Binary search,Merge sort,Depth-First Search (DFS),Breadth-First Search (BFS),,algorithms,"['graph traversal', 'shortest path', 'BFS']"
https://www.hackerrank.com/challenges/letter-islands?isFullScreen=true,"You are given string
and number
.
Consider a substring
of string
. For each position of string
mark it if there is an occurence of the substring that covers the position. More formally, position
will be marked if there exists such index
that:
and
. We will tell
produce
islands if all the marked positions form
groups of contiguous positions.
For example, if we have a string
ababaewabaq
the substring
aba
marks the positions 1, 2, 3, 4, 5, 8, 9, 10; that is
XXXXXewXXXq
(
X
denotes marked position). We can see 2 groups of contiguous positions, that is 2 islands. Finally, substring
aba
produces 2 islands in the string
ababaewabaq
.
Calculate and print the number of different substrings of string
that produce exactly
islands.
Input Format
The first line contains string
. The string consists of lowercase letters only. The second line contains an integer
.
Output Format
Output a single integer
the answer to the problem.
Sample Input
abaab
2
Sample Output
3
Explanation
All the suitable substrings are:
a
,
ab
,
b
.","Enumerate all substrings, count islands using brute force, and store counts in a hash map","Build a suffix tree, traverse it to find all substrings, and use dynamic programming to count islands",Utilize the Aho-Corasick algorithm to identify substrings and maintain a running count of island formations,Employ a sliding window approach with binary search to efficiently identify substrings and calculate island counts,"Iterate through all possible substrings, mark occurrences in the main string, and count contiguous groups of marked positions",,algorithms,"['string matching', 'substring', 'counting']"
https://www.hackerrank.com/challenges/tripartite-matching?isFullScreen=true,"You are given
unweighted, undirected graphs,
,
, and
, with
vertices each, where the
graph has
edges and the vertices in each graph are numbered from
through
. Find the number of ordered triples
, where
,
, such that there is an edge
in
, an edge
in
, and an edge
in
.
Input Format
The first line contains single integer,
, denoting the number of vertices in the graphs. The subsequent lines define
,
, and
. Each graph is defined as follows:
The first line contains an integer,
, describing the number of edges in the graph being defined.
Each line
of the
subsequent lines (where
) contains
space-separated integers describing the respective nodes,
and
connected by edge
.
Constraints
, and
Each graph contains no cycles and any pair of directly connected nodes is connected by a maximum of
edge.
Output Format
Print a single integer denoting the number of distinct
triples as described in the
Problem Statement
above.
Sample Input
3
2
1 2
2 3
3
1 2
1 3
2 3
2
1 3
2 3
Sample Output
3
Explanation
There are three possible triples in our
Sample Input
:
Thus, we print
as our output.","O(N^3), where N is the number of vertices, by iterating through all possible triples and checking for the existence of edges.","O(M1 + M2 + M3), where Mi is the number of edges in graph i, by sorting the edge lists and performing a three-way merge to find common edges.","O(N^2), where N is the number of vertices, by using adjacency matrices to represent the graphs and then iterating through the matrix entries to count triples.","O(N * (M1 + M2 + M3)), where N is the number of vertices and Mi is the number of edges in graph i, by iterating through each vertex and checking its neighbors in all three graphs.","O(M1 + M2 + M3), where Mi is the number of edges in graph i, by iterating through the edges of G1 and, for each edge (u, v), checking the neighbors of u and v in G2 and G3 respectively.",,algorithms,"['graph theory', 'triple counting', 'edge traversal']"
https://www.hackerrank.com/challenges/minimum-loss?isFullScreen=true,"Lauren has a chart of distinct projected prices for a house over the next several years.  She must buy the house in one year and sell it in another, and she must do so at a loss.  She wants to minimize her financial loss.
Example
Her minimum loss is incurred by purchasing in year
at
and reselling in year
at
.  Return
.
Function Description
Complete the
minimumLoss
function in the editor below.
minimumLoss has the following parameter(s):
int price[n]:
home prices at each year
Returns
int:
the minimum loss possible
Input Format
The first line contains an integer
, the number of years of house data.
The second line contains
space-separated long integers that describe each
.
Constraints
All the prices are distinct.
A valid answer exists.
Subtasks
for
of the maximum score.
Sample Input 0
3
5 10 3
Sample Output 0
2
Explanation 0
Lauren buys the house in year
at
and sells it in year
at
for a minimal loss of
.
Sample Input 1
5
20 7 8 2 5
Sample Output 1
2
Explanation 1
Lauren buys the house in year
at
and sells it in year
at
for a minimal loss of
.","Use a brute-force approach, comparing every buy/sell combination with loss.",Sort the prices array and only consider adjacent elements for loss calculation.,Use dynamic programming to store minimum losses for sub-arrays of prices.,Calculate the average price and find the closest buy/sell combination to the average.,Sort the prices array and use a set to efficiently find the smallest difference between a price and its predecessor.,,algorithms,"['sorting', 'optimization', 'difference']"
https://www.hackerrank.com/challenges/real-estate-broker?isFullScreen=true,"You are a real estate broker in ancient Knossos. You have
unsold houses, and each house
has an area,
, and a minimum price,
. You also have
clients, and each client
wants a house with an area greater than
and a price less than or equal to
.
Each client can buy
at most
one house, and each house can have
at most
one owner. What is the maximum number of houses you can sell?
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of clients) and
(the number of houses).
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
and
for client
.
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
and
for house
.
Constraints
, where
.
, where
.
Output Format
Print a single integer denoting the maximum number of houses you can sell.
Sample Input 0
3 3
5 110
9 500
20 400
10 100
2 200
30 300
Sample Output 0
2
Explanation 0
Recall that each client
is only interested in some house
where
and
. The diagram below depicts which clients will be interested in which houses:
https://s3.amazonaws.com/hr-challenge-images/0/1479507519-5061168dcd-wcs-real-estate-broker.png
Client
will be interested in house
because it has more than
units of space and costs less than
. Both of the other houses are outside of this client's price range.
Client
will be interested in houses
and
, as both these houses have more than
units of space and cost less than
. They will not be interested in the remaining house because it's too small.
Client
will be interested in house
because it has more than
units of space and costs less than
. They will not be interested in the other two houses because they are too small.
All three clients are interested in the same two houses, so you can sell
at most
two houses in the following scenarios:
Client
buys house
and client
buys house
.
Client
buys house
and client
buys house
.
Client
buys house
and client
buys house
.
Thus, we print the maximum number of houses you can sell,
, on a new line.","Use a greedy approach, matching clients and houses based on the best price difference.","Sort clients and houses by area, then iterate through them, matching if prices align.",Brute force: try all possible client-house combinations and choose the one selling most houses.,Solve it as a linear programming problem with constraints for each client and house.,Model as a maximum bipartite matching problem and solve using the Ford-Fulkerson algorithm or similar.,,algorithms,"['bipartite matching', 'max flow', 'greedy']"
https://www.hackerrank.com/challenges/circular-palindromes?isFullScreen=true,"A
palindrome
is a string that reads the same from left to right as it does from right to left.
Given a string,
, of
lowercase English letters, we define a
-length rotation
as cutting the first
characters from the beginning of
and appending them to the end of
. For each
, there are
possible
-length rotations (where
). See the
Explanation
section for examples.
Given
and
, find all
-length rotations of
; for each rotated string,
, print the maximum possible length of any palindromic substring of
on a new line.
Input Format
The first line contains an integer,
(the length of
).
The second line contains a single string,
.
Constraints
Output Format
There should be
lines of output, where each line
contains an integer denoting the maximum length of any palindromic substring of rotation
.
Sample Input 0
13
aaaaabbbbaaaa
Sample Output 0
12
12
10
8
8
9
11
13
11
9
8
8
10
Sample Input 1
7
cacbbba
Sample Output 1
3
3
3
3
3
3
3
Sample Input 2
12
eededdeedede
Sample Output 2
5
7
7
7
7
9
9
9
9
7
5
4
Explanation
Consider
Sample Case 1
, where
.
The possible rotations,
, for string
are:
.
The longest palindromic substrings for each
are:
and
, so we print their length (
) on a new line.
, so we print its length (
) on a new line.
and
, so we print their length (
) on a new line.
and
, so we print their length (
) on a new line.
and
, so we print their length (
) on a new line.
and
, so we print their length (
) on a new line.
and
, so we print their length (
) on a new line.",Use dynamic programming to compute palindromic substrings for each rotation independently.,Implement Manacher's algorithm on the original string and infer the palindrome lengths for rotations.,Compute all possible substrings for each rotation and check for palindromes using brute force.,Apply a simplified longest common subsequence (LCS) algorithm between the rotated string and its reverse.,"For each rotation, use an efficient algorithm like expanding from the center to find the longest palindromic substring.",,algorithms,"['palindrome', 'string manipulation', 'substring']"
https://www.hackerrank.com/challenges/clique?isFullScreen=true,"A clique in a graph is set of nodes such that there is an edge between any two distinct nodes in the set. Finding the largest clique in a graph is a computationally difficult problem. Currently no polynomial time algorithm  is known for solving this. However, you wonder what is the minimum size of the largest clique in any graph with
nodes and
edges.
For example, consider a graph with
nodes and
edges.  The graph below shows
nodes with
edges and no cliques.  It is evident that the addition of any
edge must create two cliques with
members each.
https://s3.amazonaws.com/hr-assets/0/1526329612-3c9c0f082d-cliqueExample.png
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
lines contains two space-separated integers
and
.
Constraints
Output Format
For each test case, print the minimum size of the largest clique that must be formed given
and
.
Sample Input
3
3 2
4 6
5 7
Sample Output
2
4
3
Explanation
For the first case, we have two cliques with two nodes each:
https://s3.amazonaws.com/hr-assets/0/1526329959-be28e8a84d-cliqueSample0.png
For the second test case, the only valid graph having
nodes and
edges is one where each pair of nodes is connected. So the size of the largest clique cannot be smaller than
.
https://s3.amazonaws.com/hr-assets/0/1526330004-55c560013b-cliqueSample1.png
For the third test case, it is easy to verify that any graph with
nodes and
.  The
solid lines in the graph below indicate the maximum edges that can be added without forming a clique larger than
.  The dashed lines could connect any two nodes not connected by solid lines producing a clique of size
.
https://s3.amazonaws.com/hr-assets/0/1526392344-d484fb3e77-cliqueSample2.png
Hints
Turan's theorem gives us an upper bound on the number of edges a graph can have if we wish that it should not have a clique of size
. Though the bound is not exact, it is easy to extend the statement of the theorem to get an exact bound in terms of
and
. Once this is done, we can binary search for the largest
such that
. See:
Turan's Theorem",Find the largest complete subgraph using a brute-force approach by checking all possible subsets of nodes.,Approximate the clique size by dividing the number of edges by the number of nodes: floor(m/n).,Use a greedy algorithm that iteratively adds nodes with the highest degree until no more nodes can be added without violating the clique property.,"Employ a Bron-Kerbosch algorithm, a backtracking method, and return its time complexity.","Use Turán's theorem to determine the minimum clique size. Binary search to find the largest k such that m > ex(n, k-1) where ex(n, k-1) is the maximum number of edges in an n-vertex graph without a k-clique.",,algorithms,"['graph theory', 'clique problem', ""Turán's theorem""]"
https://www.hackerrank.com/challenges/grid-walking?isFullScreen=true,"You are situated in an
dimensional grid at position
. The dimensions of the grid are
. In one step, you can walk one step ahead or behind in any one of the
dimensions. This implies that there are always
possible moves if movements are unconstrained by grid boundaries. How many ways can you take
steps without leaving the grid at any point? You leave the grid if at any point
, either
or
.
For example, you start off in a 3 dimensional grid at position
.  The dimensions of the grid are
, so each of your axes will be numbered from
to
.  If you want to move
step, you can move to the following coordinates:
.
https://s3.amazonaws.com/hr-assets/0/1526327938-afa87cb1a0-multidimension.png
If we started at
in the same grid, our new paths would lead to
.  Other moves are constrained by
.
Function Description
Complete the
gridWalking
function in the editor below.  It should return an integer that represents the number of possible moves, modulo
.
gridWalking has the following parameter(s):
m
: an integer that represents the number of steps
x
: an integer array where each
represents a coordinate in the
dimension where
D
: an integer array where each
represents the upper limit of the axis in the
dimension
Input Format
The first line contains an integer
, the number of test cases.
Each of the next
sets of lines is as follows:
The first line contains two space-separated integers,
and
.
The next line contains
space-separated integers
.
The third line of each test contains
space-separated integers
.
Constraints
Output Format
Output one line for each test case. Since the answer can be really huge, output it modulo
.
Sample Input
1
2 3
1 1
2 3
Sample Output
12
Explanation
We are starting from (1, 1) in a
2-D grid, and need to count the number of possible paths with length equal to
.
Here are the
paths:","Recursively explore each dimension's possible moves, pruning branches that lead out of bounds, and summing the valid paths.","Use dynamic programming to build a table of possible paths for each position and step count, then return the final count modulo 1000000007.","Calculate all possible paths without considering the grid boundaries, then subtract the paths that leave the grid at any point.","Simulate a random walk, counting the number of valid paths encountered within the step limit.","Employ dynamic programming to store the number of ways to reach a given position with a certain number of steps, ensuring all intermediate positions are within bounds, and taking the modulo at each step.",,algorithms,"['dynamic programming', 'grid traversal', 'combinatorics']"
https://www.hackerrank.com/challenges/challenging-palindromes?isFullScreen=true,"You have two strings,
and
. Find a string,
, such that:
can be expressed as
where
is a non-empty
substring
of
and
is a non-empty substring of
.
is a
palindromic
string.
The length of
is as long as possible.
For each of the
pairs of strings (
and
) received as input, find and print string
on a new line. If you're able to form more than one valid string
, print whichever one comes first alphabetically. If there is no valid answer, print
instead.
Input Format
The first line contains a single integer,
, denoting the number of queries. The subsequent lines describe each query over two lines:
The first line contains a single string denoting
.
The second line contains a single string denoting
.
Constraints
and
contain only lowercase English letters.
Sum of |a| over all queries does not exceed
Sum of |b| over all queries does not exceed
Output Format
For each pair of strings (
and
), find some
satisfying the conditions above and print it on a new line. If there is no such string, print
instead.
Sample Input
3
bac
bac
abc
def
jdfh
fds
Sample Output
aba
-1
dfhfd
Explanation
We perform the following three queries:
Concatenate
with
to create
.
We're given
and
; because both strings are composed of unique characters, we cannot use them to form a palindromic string. Thus, we print
.
Concatenate
with
to create
. Note that we chose these particular substrings because the length of string
must be maximal.",Output the longest common substring between the reversed strings a and b.,"Concatenate a and reversed b, then output the longest palindromic substring.","Find the longest common substring between a and reversed b; if it's a palindrome, output it. Otherwise, output '-1'.",Output the longest substring from a concatenated with the reversed of the longest substring from b.,"Iterate through all substrings of a and b, checking if their concatenation is a palindrome. Return the longest palindromic concatenation found, or '-1' if none exists.",,algorithms,"['string manipulation', 'palindrome', 'substring']"
https://www.hackerrank.com/challenges/two-strings-game?isFullScreen=true,"Consider the following game for two players:
There are two strings A and B. Initially, some strings A' and B' are written on the sheet of paper. A' is always a substring of A and B' is always a substring of B. A move consists of appending a letter to
exactly one
of these strings: either to A' or to B'. After the move the constraint of A' being a substring of A and B' is a substring of B should still be satisfied. Players take their moves alternately. We call a pair (A', B') a position.
Two players are playing this game optimally. That means that if a player has a move that leads to his/her victory, he/she will definitely use this move. If a player is unable to make a move, he loses.
Alice and Bob are playing this game. Alice makes the first move. As always, she wants to win and this time she does a clever trick. She wants the starting position to be the
K
th
lexicographically winning position for the first player (i.e. her). Consider two positions (A'
1
, B'
1
) and (A'
2
, B'
2
). We consider the first position lexicographically smaller than the second if A1 is lexicographically smaller than A2, or if A1 is equal to A2 and B1 is lexicographically smaller than B2.
Please help her to find such a position, knowing the strings A, B and the integer
K
.
Note
: An empty string has higher precedence than character
""a""
Input Format
The first line of input consists of three integers, separated by a single space: N, M and K denoting the length of
A
, the length of
B
and K respectively.
The second line consists of N small latin letters, corresponding to the string A.
The third line consists of M small latin letters, corresponding to the string B.
Constraints
1 <= N, M <= 3 * 10
5
1 <= K <= 10
18
Output Format
Output A' on the first line of input and B' on the second line of input. Please, pay attention that some of these strings can be empty.
If there's no such pair, output ""no solution"" without quotes.
Sample Input 0
2 1 3
ab
c
Sample Output 0
a
c
Explanation 0
The given strings are
and
. So there are
=
ways to fill a starting position (each character has two options, either to be present or not present).
["""", """"] : If this is the start position, Alice will append
to
. So, the next two moves will consist of appending
and
to
and
respectively. So, Bob will suffer lack of moves and hence Alice wins.
["""", ""c""] : If this is the start position, Alice will append
to
. Now, Bob will suffer lack of moves and hence Alice wins.
[""a"", """"] : If Alice appends
to
then Bob will append
to
and if Alice appends
to
then Bob will append
to
. So Alices looses.
[""a"", ""c""] : If this is the start position, Alice will append
to
. Now, Bob will suffer lack of moves and hence Alice wins.
[""ab"", """"] : If this is the start position, Alice will append
to
. Now, Bob will suffer lack of moves and hence Alice wins.
[""ab"", ""c""] : If this is the start position, Alice will suffer lack of moves and hence he looses.
[""b"", """"] : If this is the start position, Alice will append
to
. Now, Bob will suffer lack of moves and hence Alice wins.
[""b"", ""c""] : If this is the start position, Alice will suffer lack of moves and hence he looses.
So, the list of start positions in lexicographical order where Alice wins are: ["""", """"], ["""", ""c""], [""a"", ""c""], [""ab"", """"], [""b"", """"]. The
one in this list is [""a"", ""c""].",Calculate the Sprague-Grundy value for all possible positions and find the K-th winning position.,"Enumerate all possible substring pairs (A', B'), determine if they are winning positions, and select the K-th one.",Use dynamic programming to determine winning positions and backtracking to find the K-th lexicographical one.,Greedily construct A' and B' such that the difference in their lengths is K modulo some value related to A and B.,"Determine the winning positions using game theory principles (e.g., minimax or Sprague-Grundy theorem). Then, iterate through potential starting positions in lexicographical order until the K-th winning position is found.",,algorithms,"['game theory', 'substring', 'lexicographical order']"
https://www.hackerrank.com/challenges/simplified-chess-engine?isFullScreen=true,"Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as
Stockfish
and
Komodo
to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as find tactical ideas. Consider the following
simplified version of chess
:
Board:
It's played on a
board between two players named
Black
and
White
.
Pieces and Movement:
White initially has
pieces and Black initially has
pieces.
There are no Kings and no Pawns on the board. Each player has exactly
one
Queen, at most
two
Rooks, and at most
two
minor pieces (i.e., a Bishop and/or Knight).
Each piece's possible moves are the same as in classical chess, and each move made by any player counts as a single move.
There is no draw when positions are repeated as there is in classical chess.
Objective:
The goal of the game is to capture the opponent’s Queen without losing your own.
Given
and the layout of pieces for
games of simplified chess, implement a very basic (in comparison to the real ones) engine for our simplified version of chess with the ability to determine whether or not White can win in
moves (regardless of how Black plays) if White always moves first. For each game, print
YES
on a new line if White can win under the specified conditions; otherwise, print
NO
.
Input Format
The first line contains a single integer,
, denoting the number of simplified chess games. The subsequent lines define each game in the following format:
The first line contains three space-separated integers denoting the respective values of
(the number of White pieces),
(the number of Black pieces), and
(the maximum number of moves we want to know if White can win in).
The
subsequent lines describe each chesspiece in the format
t c r
, where
is a character
denoting the type of piece (where
is Queen,
is Knight,
is Bishop, and
is Rook), and
and
denote the respective column and row on the board where the figure is placed (where
and
). These inputs are given as follows:
Each of the
subsequent lines denotes the type and location of a White piece on the board.
Each of the
subsequent lines denotes the type and location of a Black piece on the board.
Constraints
It is guaranteed that the locations of all pieces given as input are distinct.
Each player initially has exactly one Queen, at most two Rooks and at most two minor pieces.
Output Format
For each of the
games of simplified chess, print whether or not White can win in
moves on a new line. If it's possible, print
YES
; otherwise, print
NO
.
Sample Input 0
1
2 1 1
N B 2
Q B 1
Q A 4
Sample Output 0
YES
Explanation 0
We play
games of simplified chess, where the initial piece layout is as follows:
https://s3.amazonaws.com/hr-challenge-images/16694/1476120299-2d6819743e-simplified-chess.png
White is the next to move, and they can win the game in
move by taking their Knight to
and capturing Black's Queen. Because it took
move to win and
, we print
YES
on a new line.",Use a Breadth-First Search (BFS) algorithm to explore all possible move sequences within the given move limit.,Implement a Minimax algorithm with alpha-beta pruning to determine the optimal move for White in each turn.,Employ a Monte Carlo Tree Search (MCTS) to simulate multiple games and estimate the winning probability for White.,Check only direct attacks on the black queen and see if any exist within the move limit.,Use a Depth-First Search (DFS) algorithm to explore possible move sequences and check for a win within the move limit.,,algorithms,"['chess engine', 'game theory', 'search algorithm']"
https://www.hackerrank.com/challenges/an-interesting-game-1?isFullScreen=true,"Andy wants to play a game with his little brother, Bob.  The game starts with an array of distinct integers and the rules are as follows:
Bob always plays first.
In a single move, a player chooses the maximum element in the array.  He removes it and all elements to its right. For example, if the starting array
, then it becomes
after removing
.
The two players alternate turns.
The last player who can make a move wins.
Andy and Bob play
games. Given the initial array for each game, find and print the name of the winner on a new line. If Andy wins, print
ANDY
; if Bob wins, print
BOB
.
To continue the example above, in the next move Andy will remove
.  Bob will then remove
and win because there are no more integers to remove.
Function Description
Complete the
gamingArray
function in the editor below.
gamingArray has the following parameter(s):
int arr[n]:
an array of integers
Returns
-
string:
either
ANDY
or
BOB
Input Format
The first line contains a single integer
, the number of games.
Each of the next
pairs of lines is as follows:
The first line contains a single integer,
, the number of elements in
.
The second line contains
distinct space-separated integers
where
.
Constraints
Array
contains
distinct integers.
For
of the maximum score:
The sum of
over all games does not exceed
.
For
of the maximum score:
The sum of
over all games does not exceed
.
Sample Input 0
2
5
5 2 6 3 4
2
3 1
Sample Output 0
ANDY
BOB
Explanation 0
Andy and Bob play the following two games:
Initially, the array looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1480410987-b0e277b032-gaming5.png
In the first move, Bob removes
and all the elements to its right, resulting in
:
https://s3.amazonaws.com/hr-challenge-images/0/1480410946-e48583da01-gaming4.png
In the second move, Andy removes
and all the elements to its right, resulting in
:
https://s3.amazonaws.com/hr-challenge-images/0/1480410901-262033f50c-gaming3.png
At this point, the array is empty and Bob cannot make any more moves. This means Andy wins, so we print
ANDY
on a new line.
In the first move, Bob removes
and all the elements to its right, resulting in
. As there are no elements left in the array for Andy to make a move, Bob wins and we print
BOB
on a new line.
Sample Input 1
2
5
1 3 5 7 9
5
7 4 6 5 9
Sample Output 1
BOB
ANDY
Explanation 1
In the first test, they alternate choosing the rightmost element until the end.  Bob, Andy, Bob, Andy, Bob.
In the second case, Bob takes
, Andy takes
.","If the number of moves is even, Andy wins; otherwise, Bob wins.",The player who removes the smallest element first wins.,"Sort the array in descending order; Andy wins if the first element is odd, Bob otherwise.",The winner is determined by the parity of the sum of the array elements.,"Count the number of times the maximum element changes; if it's even, Andy wins, otherwise Bob wins.",,algorithms,"['arrays', 'game theory', 'greedy algorithm']"
https://www.hackerrank.com/challenges/hamming-distance?isFullScreen=true,"You are given a string
, consisting of
small latin letters '
a
' and '
b
'. You are also given
queries to process. The queries are as follows:
C
: all the symbols in the string, starting at the
, ending at the
become equal to
;
S
: swap two consecutive fragments of the string, where the first is denoted by a substring starting from
ending at
and the second is denoted by a substring starting at
ending at
;
R
: reverse the fragment of the string that starts at the
symbol and ends at the
one;
W
: output the substring of the string that starts at the
symbol and ends at the
one;
H
: output the
Hamming distance
between the consecutive substrings that starts at
and
respectively and have the length of
.
Everything is 1-indexed here.
Input Format
The first line of input contains a single integer
the length of the string.
The second line contains the initial string
itself.
The third line of input contains a single integer
the number of queries.
Then, there are
lines, each denotes a query of one of the types above.
Constraints
Total number of characters printed in W-type queries will not exceed
For C-type, R-type, W-type queries:
;
equals either
a
, or
b
For S-type queries:
For H-type queries:
;
;
.
Output Format
For each query of the type
W
or the type
H
output an answer on the separate line of output.
Sample Input 0
10
aabbbabbab
6
R 1 5
W 3 8
C 4 4 a
H 2 1 9
S 5 9 10 10
H 1 2 9
Sample Output 0
baaabb
4
5
Explanation 0
Initial String - aabbbabbab
Queries
Updated String
Output
R 1 5
bbbaaabbab
W 3 8
baaabb
C 4 4 a
bbbaaabbab
H 2 1 9
4
S 5 9 10 10
bbbabaabba
H 1 2 9
5",Use a linked list to store the string and directly implement each operation on the linked list.,Convert the string to an array and utilize array operations for all queries.,Create a mutable string object and use built-in string manipulation functions to perform operations.,Represent the string as a binary tree and perform queries using tree traversals.,Use a character array (or mutable string) along with helper functions to implement each query type efficiently.,,algorithms,"['string manipulation', 'character array', 'mutable string']"
https://www.hackerrank.com/challenges/hr-city?isFullScreen=true,"HackerRank-city is an acyclic connected graph (or
tree
). Its not an ordinary place, the construction of the whole tree takes place in
steps. The process is described below:
It initially has
node.
At each step, you must create
duplicates of the current tree, and create
new nodes to connect all
copies in the following
H
shape:
https://s3.amazonaws.com/hr-challenge-images/15974/1453287425-a21e2a7db5-nik2.png
At each
step, the tree becomes
times bigger plus
new nodes, as well as
new edges connecting everything together. The length of the new edges being added at step
is denoted by input
.
Calculate the sum of distances between each pair of nodes; as these answers may run large, print your answer modulo
.
Input Format
The first line contains an integer,
(the number of steps). The second line contains
space-separated integers describing
,
.
Constraints
Subtask
For
score
Output Format
Print the sum of distances between each pair of nodes
modulo
.
Sample Input 0
1
1
Sample Output 0
29
Sample Input 1
2
2 1
Sample Output 1
2641
Explanation
Sample 0
In this example, our tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/15974/1453287063-28fa199918-nik4.png
Let
denote the distance between nodes
and
.
.
We print the result of
as our answer.
Sample 1
In this example, our tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/15974/1453286854-9a3b71b33d-nikcity2.png
We calculate and sum the distances between nodes in the same manner as
Sample 0
above, and print the result of our
, which is
.","The total distance calculation will overflow the integer limit, causing incorrect results without explicit handling.",A recursive depth-first search approach can efficiently compute all pairwise distances without exceeding time limits.,"Dynamic programming can be used to store and reuse intermediate distance calculations between subtrees, leading to an optimal solution.","The modular arithmetic operation should only be applied at the end, after summing all distances, to avoid inaccuracies.","The distance sum can be computed iteratively, tracking subtree sizes and distances to centroids to handle large tree sizes and edge lengths efficiently while applying the modulo operation correctly at each step.",,algorithms,"['graph theory', 'tree', 'dynamic programming']"
https://www.hackerrank.com/challenges/p-sequences?isFullScreen=true,"We call a sequence of
N
natural numbers (
a
1
,
a
2
, ...,
a
N
) a
P-sequence
, if the product of any two adjacent numbers in it is not greater than
P
. In other words, if a sequence (
a
1
,
a
2
, ...,
a
N
) is a
P-sequence
, then
a
i
*
a
i+1
≤
P
∀ 1 ≤ i < N
You are given
N
and
P
. Your task is to find the number of such
P-sequences
of
N
integers modulo 10
9
+7.
Input Format
The first line of input consists of
N
The second line of the input consists of
P
.
Constraints
2 ≤ N ≤ 10
3
1 ≤ P ≤ 10
9
1 ≤ a
i
Output Format
Output the number of
P-sequences
of
N
integers modulo 10
9
+7.
Sample Input 0
2
2
Sample Output 0
3
Explanation 0
3 such sequences are {1,1},{1,2} and {2,1}","Use dynamic programming with a 2D array, storing the count of sequences ending with a specific number","Recursively generate all possible sequences and count the valid ones, memoizing to avoid recomputation","Greedily construct sequences by always choosing the smallest possible next number, ensuring the product constraint","Employ a backtracking algorithm to explore all possible sequences, pruning branches that violate the product constraint","Use dynamic programming with a 2D array, storing counts of sequences of length i ending with value j, modulo 10^9 + 7",,algorithms,"['dynamic programming', 'sequences', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/queens-attack-2?isFullScreen=true,"You will be given a square chess board with one queen and a number of obstacles placed on it.  Determine how many squares the queen can attack.
A
queen
is standing on an
chessboard
. The chess board's rows are numbered from
to
, going from bottom to top.  Its columns are numbered from
to
, going from left to right. Each square is referenced by a tuple,
, describing the row,
, and column,
, where the square is located.
The queen is standing at position
.  In a single move, she can attack any square in any of the eight directions (left, right, up, down, and the four diagonals). In the diagram below, the green circles denote all the cells the queen can attack from
:
https://s3.amazonaws.com/hr-challenge-images/0/1485426500-a4039ebb00-chess1.png
There are obstacles on the chessboard, each preventing the queen from attacking any square beyond it on that path. For example, an obstacle at location
in the diagram above prevents the queen from attacking cells
,
, and
:
https://s3.amazonaws.com/hr-challenge-images/0/1485459132-3fdc1f1ca3-chess_4_.png
Given the queen's position and the locations of all the obstacles, find and print the number of squares the queen can attack from her position at
.  In the board above, there are
such squares.
Function Description
Complete the
queensAttack
function in the editor below.
queensAttack has the following parameters:
-
int n:
the number of rows and columns in the board
-
nt k:
the number of obstacles on the board
-
int r_q:
the row number of the queen's position
-
int c_q:
the column number of the queen's position
-
int obstacles[k][2]:
each element is an array of
integers, the row and column of an obstacle
Returns
-
int:
the number of squares the queen can attack
Input Format
The first line contains two space-separated integers
and
, the length of the board's sides and the number of obstacles.
The next line contains two space-separated integers
and
, the queen's row and column position.
Each of the next
lines contains two space-separated integers
and
, the row and column position of
.
Constraints
A single cell may contain more than one obstacle.
There will never be an obstacle at the position where the queen is located.
Subtasks
For
of the maximum score:
For
of the maximum score:
Sample Input 0
4 0
4 4
Sample Output 0
9
Explanation 0
The queen is standing at position
on a
chessboard with no obstacles:
https://s3.amazonaws.com/hr-challenge-images/0/1485426553-3064e08638-chess2.png
Sample Input 1
5 3
4 3
5 5
4 2
2 3
Sample Output 1
10
Explanation 1
The queen is standing at position
on a
chessboard with
obstacles:
https://s3.amazonaws.com/hr-challenge-images/0/1485426870-84a6a0ce97-chess3.png
The number of squares she can attack from that position is
.
Sample Input 2
1 0
1 1
Sample Output 2
0
Explanation 2
Since there is only one square, and the queen is on it, the queen can move 0 squares.",Assume the queen can attack to the edge of the board in all directions and then subtract blocked squares based on obstacle distances,"Iterate through each square on the board and, for each, check if the queen can attack it without being blocked by an obstacle","Recursively check each of the eight possible directions, stopping when an obstacle or board edge is encountered",Precompute all possible attack paths and store them in a lookup table for quick access,"For each direction, find the closest obstacle (or board edge) and calculate the number of attackable squares in that direction",,algorithms,"['grid', 'attack range', 'obstacles']"
https://www.hackerrank.com/challenges/pseudo-isomorphic-substrings?isFullScreen=true,"Two strings A and B, consisting of small English alphabet letters are called pseudo-isomorphic if
Their lengths are equal
For every pair (i,j), where 1 <= i < j <= |A|, B[i] = B[j], iff A[i] = A[j]
For every pair (i,j), where 1 <= i < j <= |A|, B[i] != B[j] iff A[i] != A[j]
Naturally, we use 1-indexation in these definitions and |
A
| denotes the length of the string
A
.
You are given a string
S
, consisting of no more than
10
5
lowercase alphabetical characters. For every prefix of
S
denoted by S', you are expected to find the size of the largest possible set of strings , such that all elements of the set are substrings of S' and no two strings inside the set are pseudo-isomorphic to each other.
if S = abcde
then, 1
st
prefix of S is 'a'
then, 2
nd
prefix of S is 'ab'
then, 3
rd
prefix of S is 'abc'
then, 4
th
prefix of S is 'abcd' and so on..
Input Format
The first and only line of input will consist of a single string
S
. The length of
S
will not exceed 10^5.
Constraints
S contains only lower-case english alphabets ('a' - 'z').
Output Format
Output
N
lines. On the i
th
line, output the size of the largest possible set for the first
i
alphabetical characters of
S
such that no two strings in the set are pseudo-isomorphic to each other.
Sample Input
abbabab
Sample Output
1
2
4
6
9
12
15
Explanation
The first character is 'a', the set is {a} hence 1.
The first 2 characters are 'ab', the set is {a, b, ab} but 'a' is pseudo-isomorphic to 'b'. So, we can remove either 'a' or 'b' from the set. We get {a,ab} or {b,ab}, hence 2.
Similarly, the first 3 characters are 'abb', the set is {a, ab, abb, b, bb} and as 'a' is pseudo-isomorphic to 'b', we have to remove either 'a' or 'b' from the set. We get {a,ab, abb, bb}, hence 4. and so on...",Calculate the number of distinct substrings directly using a suffix tree.,Count all possible substrings and subtract the number of pseudo-isomorphic pairs.,"Use dynamic programming to store the maximum size for each prefix, checking all substring pairs.",Maintain a hash set of all substrings and recursively remove pseudo-isomorphic strings until a maximal set remains.,"Iterate through each prefix, generating all substrings, grouping them by pseudo-isomorphism, and counting the groups.",,algorithms,"['string algorithms', 'substring', 'pseudo-isomorphism']"
https://www.hackerrank.com/challenges/super-functional-strings?isFullScreen=true,"We define a function,
, on a string,
, as follows:
where:
denotes the number of characters in string
.
denotes the number of distinct characters in string
.
Consuela loves creating string challenges and she needs your help testing her newest one! Given a string,
, consisting of
lowercase letters, compute the summation of function
(provided above) over all possible
distinct substrings
of
. As the result is quite large, print it modulo
.
Input Format
The first line contains a single integer,
, denoting the number of test cases.
Each of the
subsequent lines contains a string,
.
Constraints
The sum of
over all test cases does not exceed
.
Scoring
for
of test data.
for
of test data.
for
of test data.
Output Format
For each test case, print the answer modulo
.
Sample Input
3
aa
aba
abc
Sample Output
3
19
38
Explanation
Test 0:
and
are the only distinct substrings.
Test 1:
,
,
,
, and
are the only distinct substrings.",Calculate the length of the entire string and multiply it by the number of distinct characters in the entire string.,"For each substring, count the total characters and the distinct characters and multiply these totals. Sum all results.","Find all substrings, count distinct characters in the original string, and multiply the total number of substrings by that count, taking the modulus.","Calculate the number of substrings using n*(n+1)/2, where n is string length. Multiply this result by the number of distinct characters in the whole string. Return modulo 1000000007.","Iterate through all distinct substrings of the input string. For each substring, calculate its length multiplied by the number of its distinct characters. Accumulate the sum modulo 1000000007.",,algorithms,"['string manipulation', 'substrings', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/maximum-palindromes?isFullScreen=true,"Madam Hannah Otto, the CEO of
Reviver
Corp., is fond of palindromes, or words that read the same forwards or backwards. She thinks palindromic brand names are appealing to millennials.
As part of the marketing campaign for the company's new juicer called the
Rotator
™, Hannah decided to push the marketing team's palindrome-searching skills to a new
level
with a new challenge.
In this challenge, Hannah provides a string
consisting of lowercase English letters. Every day, for
days, she would select two integers
and
, take the substring
(the substring of
from index
to index
), and ask the following question:
Consider all the palindromes that can be constructed from some of the letters from
. You can reorder the letters as you need. Some of these palindromes have the maximum length among all these palindromes. How many maximum-length palindromes are there?
For example, if
,
and
, then we have,
https://s3.amazonaws.com/hr-assets/0/1514365300-ce2afe4687-palindrome1.png
Your job as the head of the marketing team is to answer all the queries. Since the answers can be very large, you are only required to find the answer
modulo
.
Complete the functions
initialize
and
answerQuery
and return the number of maximum-length palindromes modulo
.
Input Format
The first line contains the string
.
The second line contains a single integer
.
The
of the next
lines contains two space-separated integers
,
denoting the
and
values Anna selected on the
day.
Constraints
Here,
denotes the length of
.
Subtasks
For 30% of the total score:
For 60% of the total score:
Output Format
For each query, print a single line containing a single integer denoting the answer.
Sample Input 0
week
2
1 4
2 3
Sample Output 0
2
1
Explanation 0
On the first day,
and
. The maximum-length palindromes are ""ewe"" and ""eke"".
On the second day,
and
. The maximum-length palindrome is ""ee"".
https://s3.amazonaws.com/hr-assets/0/1514366321-8b7b4c0a9c-palindrome3.png
Sample Input 1
abab
1
1 4
Sample Output 1
2
Explanation 1
Here, the maximum-length palindromes are ""abba"" and ""baab"".",The number of characters in the substring.,"The product of frequencies of all characters that appear an odd number of times in the substring, modulo MOD.","The frequency of the most frequent character in the substring, modulo MOD.","The number of distinct characters in the substring, modulo MOD.","The number of distinct maximum-length palindromes that can be constructed from the substring, modulo MOD.",,algorithms,"['string manipulation', 'palindrome', 'modulo']"
https://www.hackerrank.com/challenges/the-quickest-way-up?isFullScreen=true,"Markov takes out his
Snakes and Ladders
game, stares at the board and wonders:   ""If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?""
Rules
The game is played with a cubic die of
faces numbered
to
.
Starting from square
, land on square
with the exact roll of the die.  If moving the number rolled would place the player beyond square
, no move is made.
If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only.
If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only.
Function Description
Complete the
quickestWayUp
function in the editor below.  It should return an integer that represents the minimum number of moves required.
quickestWayUp has the following parameter(s):
ladders
: a 2D integer array where each
contains the start and end cell numbers of a ladder
snakes
: a 2D integer array where each
contains the start and end cell numbers of a snake
Input Format
The first line contains the number of tests,
.
For each testcase:
- The first line contains
, the number of ladders.
- Each of the next
lines contains two space-separated integers, the start and end of a ladder.
- The next line contains the integer
, the number of snakes.
- Each of the next
lines contains two space-separated integers, the start and end of a snake.
Constraints
The board is always
with squares numbered
to
.
Neither square
nor square
will be the starting point of a ladder or snake.
A square will have at most one endpoint from either a snake or a ladder.
Output Format
For each of the t test cases, print the least number of rolls to move from start to finish on a separate line.  If there is no solution, print
-1
.
Sample Input
2
3
32 62
42 68
12 98
7
95 13
97 25
93 37
79 27
75 19
49 47
67 17
4
8 52
6 80
26 42
2 72
9
51 19
39 11
37 29
81 3
59 5
79 23
53 7
43 33
77 21
Sample Output
3
5
Explanation
For the first test:
The player can roll a
and a
to land at square
.  There is a ladder to square
.  A roll of
ends the traverse in
rolls.
For the second test:
The player first rolls
and climbs the ladder to square
.  Three rolls of
get to square
.  A final roll of
lands on the target square in
total rolls.",Depth-First Search (DFS),Greedy Algorithm,Dynamic Programming,Divide and Conquer,Breadth-First Search (BFS),,algorithms,"['graph theory', 'shortest path', 'game']"
https://www.hackerrank.com/challenges/tsp-grid?isFullScreen=true,"The travelling salesman has a map containing m*n squares. He starts from the top left corner and visits every cell exactly once and returns to his initial position (top left). The time taken for the salesman to move from a square to its neighbor might not be the same. Two squares are considered adjacent if they share a common edge and the time taken to reach square
b
from square
a
and vice-versa are the same. Can you figure out the shortest time in which the salesman can visit every cell and get back to his initial position?
Input Format
The first line of the input is 2 integers m and n separated by a single space. m and n are the number of rows and columns of the map.
Then m lines follow, each of which contains (n – 1) space separated integers. The j
th
integer of the i
th
line is the travel time from position (i,j) to (i,j+1) (index starts from 1.)
Then (m-1) lines follow, each of  which contains n space integers. The j
th
integer of the i
th
line is the travel time from position (i,j) to (i + 1, j).
Constraints
1 ≤ m, n ≤ 10
Times are non-negative integers no larger than 10000.
Output Format
Just an integer contains the minimal time to complete his task. Print 0 if its not possible to visit each cell exactly once.
Sample Input
2 2
5
8
6 7
Sample Output
26
Explanation
As its a 2*2 square, all cells are visited. 5 + 7 + 8 + 6 = 26","Use a greedy algorithm, always choosing the shortest path available at each step.",Calculate the minimum spanning tree of the graph and double its weight.,"Apply Dijkstra's algorithm to find the shortest path from the starting cell back to itself, visiting all other cells.","Use branch and bound, pruning paths that exceed a known lower bound.","Since each cell must be visited exactly once and return to the start, calculate the sum of all horizontal and vertical edge weights, and if m*n > 1, this forms a Hamiltonian cycle.",,algorithms,"['graph theory', 'Hamiltonian cycle', 'dynamic programming']"
https://www.hackerrank.com/challenges/aorb?isFullScreen=true,"Consider four numbers:
,
,
, and
. You must change
at most
bits in
and
to form the numbers
and
satisfying the equation
. Here, the | symbol denotes the
bitwise OR
operation.
Given
sets of the numbers defined above, find and print the respective values of
and
on new lines; if no such value exists, print
instead. If there are multiple solutions, make
as small as possible; if there are still multiple solutions, make
as small as possible.
Notes:
,
, and
are given in
Hexadecimal (base 16)
, and
is given in decimal (base 10).
If the number of bits changed in
is
and the number of bits changed in B is
, then
must be
.
Input Format
The first line contains an integer,
, denoting the number of queries. The subsequent lines describe each respective query as follows:
The first line contains a single integer denoting the value of
.
Each of the next
lines contains a
Hexadecimal (base 16)
number describing the respective values of
,
, and
.
Constraints
Output Format
Print two lines of output for each query:
The first line should contain a
Hexadecimal (base 16)
number denoting the value of
.
The second line must contain a
Hexadecimal (base 16)
number denoting the value of
.
If no valid answer exists, you must instead print one line of output with the integer
.
Note
: The letters in Hexadecimal numbers must be in uppercase.
Sample Input
3
8
2B
9F
58
5
B9
40
5A
2
91
BE
A8
Sample Output
8
58
18
42
-1
Explanation
Query 0:
In this query,
.
Change
to
.
bits are changed.
https://s3.amazonaws.com/hr-challenge-images/16865/1465308665-7542b72e8f-aorb1.png
Change B =
to
.
bits are changed.
https://s3.amazonaws.com/hr-challenge-images/16865/1465308961-18187ef75a-aorb2.png
Query 1:
In this query,
.
Change
to
.
bits are changed.
Change
to
. Only
bit is changed.
Query 2:
There is no valid answer, so we print
.",A = hex(C & (~B))[2:].upper() and B = hex(C | (~A))[2:].upper(),A = hex(C ^ B)[2:].upper() and B = hex(C & A)[2:].upper(),A = hex(C + B)[2:].upper() and B = hex(C - A)[2:].upper(),A = hex(C >> 1)[2:].upper() and B = hex(C << 1)[2:].upper(),A = hex(C & A)[2:].upper() and B = hex(C & B)[2:].upper(),,algorithms,"['bitwise operations', 'hexadecimal', 'constraints']"
https://www.hackerrank.com/challenges/super-kth-lis?isFullScreen=true,"Given an array of
integers (
), find all possible increasing subsequences of maximum length,
. Then print the lexicographically
longest increasing subsequence as a single line of space-separated integers; if there are less than
subsequences of length
, print
.
Two subsequences
and
are considered to be
different
if there exists at least one
such that
.
Input Format
The first line contains
space-separated integers,
and
, respectively.
The second line consists of
space-separated integers denoting
respectively.
Constraints
Scoring
for
of the test data.
for
of the test data.
Output Format
Print a single line of
space-separated integers denoting the lexicographically
longest increasing subsequence; if there are less than
subsequences of length
, print
.
Note:
is the length of longest increasing subsequence in the array.
Sample Input 0
5 3
1 3 1 2 5
Sample Output 0
1 3 5
Sample Input 1
5 2
1 3 2 4 5
Sample Output 1
1 3 4 5
Explanation
Sample Case 0:
The longest possible increasing subsequences in lexicographical order are:
Notice that the first and second subsequences appear the same; they are actually both
different
because the
in the first subsequence comes from array element
, and the
in the second subsequence comes from array element
. Because
, we print the
one (
) as a single line of space-separated integers.
Sample Case 1:
The longest possible increasing subsequences in lexicographical order are:
Because
, we print the
one (
) as a single line of space-separated integers.","Use dynamic programming to compute all increasing subsequences, then filter for maximum length and sort lexicographically to find the k-th.","Recursively generate all possible subsequences, prune those that are not increasing, and then select the k-th lexicographically largest if it exists.","Sort the array, then iterate through it to build increasing subsequences of maximal length and return the k-th lexicographically","Maintain a set of increasing subsequences, adding elements to extend them greedily while ensuring uniqueness, and return the lexicographically largest if k subsequences exist.","Apply a modified dynamic programming approach to find all longest increasing subsequences (LIS), then sort them lexicographically and return the k-th LIS if it exists, otherwise return -1.",,algorithms,"['dynamic programming', 'lexicographical order', 'longest increasing subsequence']"
https://www.hackerrank.com/challenges/frog-in-maze?isFullScreen=true,"Alef the Frog is in an
two-dimensional maze represented as a table.  The maze has the following characteristics:
Each cell can be
free
or can contain an
obstacle
, an
exit
, or a
mine
.
Any two cells in the table considered
adjacent
if they share a side.
The maze is surrounded by a solid wall made of obstacles.
Some pairs of free cells are connected by a bidirectional
tunnel
.
https://s3.amazonaws.com/hr-assets/0/1497821543-2cb94cfc8e-32.png
When Alef is in any cell, he can randomly and with equal probability choose to move into one of the adjacent cells that don't contain an obstacle in it. If this cell contains a mine, the mine explodes and Alef dies. If this cell contains an exit, then Alef escapes the maze.
When Alef lands on a cell with an entrance to a
tunnel
, he is immediately transported through the tunnel and is thrown into the cell at the other end of the tunnel. Thereafter, he won't fall again, and will now randomly move to one of the adjacent cells again. (He could possibly fall in the same tunnel later.)
It's possible for Alef to get stuck in the maze in the case when the cell in which he was thrown into from a tunnel is surrounded by obstacles on all sides.
Your task is to write a program which calculates and prints a probability that Alef escapes the maze.
Input Format
The first line contains three space-separated integers
,
and
denoting the dimensions of the maze and the number of bidirectional tunnels.
The next
lines describe the maze. The
'th line contains a string of length
denoting the
'th row of the maze. The meaning of each character is as follows:
#
denotes an obstacle.
A
denotes a free cell where Alef is initially in.
*
denotes a cell with a mine.
%
denotes a cell with an exit.
O
denotes a free cell (which may contain an entrance to a tunnel).
The next
lines describe the tunnels. The
'th line contains four space-separated integers
,
,
,
. Here,
and
denote the coordinates of both entrances of the tunnel.
denotes the row and column number, respectively.
Constraints
and
are distinct.
A
appears exactly once.
Each free cell contains at most one entrance to a tunnel.
If a cell contains an entrance to a tunnel, then it doesn't contain an obstacle, mine or exit, and Alef doesn't initially stand in it.
Tunnels don't connect adjacent cells.
Output Format
Print one real number denoting the probability that Alef escapes the maze. Your answer will be considered to be correct if its (absolute) difference from the true answer is not greater than
.
Sample Input 0
3 6 1
###*OO
O#OA%O
###*OO
2 3 2 1
Sample Output 0
0.25
Explanation 0
The following depicts this sample case:
https://s3.amazonaws.com/hr-assets/0/1497821532-fd893aeb0c-31.png
In this case, Alef will randomly choose one of four adjacent cells. If he goes up or down, he will explode and die. If he goes right, he will escape. If he goes left, he will go through a tunnel and get stuck in cell
. So the probability of Alef escaping is
.",Model the maze as a minimum spanning tree and calculate probabilities based on tree traversals.,Use Dijkstra's algorithm to find the shortest path to the exit and use that path's length to estimate the probability.,Employ a Monte Carlo simulation by running multiple random walks and averaging the escape rates.,"Apply A* search to find the optimal escape route, then calculate the probability based on the number of possible moves along the path.",Formulate a system of linear equations representing the probability of escape from each cell and solve using Gaussian elimination.,,algorithms,"['maze', 'probability', 'linear equations']"
https://www.hackerrank.com/challenges/crossword-puzzle?isFullScreen=true,"A
Crossword grid is provided to you, along with a set of words (or names of places) which need to be filled into the grid.  Cells are marked either
+
or
-
.  Cells marked with a
-
are to be filled with the word list.
The following shows an example crossword from the input
grid and the list of words to fit,
:
Input
Output
++++++++++
++++++++++
+------+++
+
POLAND
+++
+++-++++++
+++
H
++++++
+++-++++++
+++
A
++++++
+++-----++
+++
SPAIN
++
+++-++-+++
+++
A
++
N
+++
++++++-+++
++++++
D
+++
++++++-+++
++++++
I
+++
++++++-+++
++++++
A
+++
++++++++++
++++++++++
POLAND
;
LHASA
;
SPAIN
;
INDIA
Function Description
Complete the
crosswordPuzzle
function in the editor below.  It should return an array of strings, each representing a row of the finished puzzle.
crosswordPuzzle has the following parameter(s):
crossword
: an array of
strings of length
representing the empty grid
words:
a string consisting of semicolon delimited strings to fit into
Input Format
Each of the first
lines represents
, each of which has
characters,
.
The last line contains a string consisting of semicolon delimited
to fit.
Constraints
Output Format
Position the words appropriately in the
grid, then return your array of strings for printing.
Sample Input 0
+-++++++++
+-++++++++
+-++++++++
+-----++++
+-+++-++++
+-+++-++++
+++++-++++
++------++
+++++-++++
+++++-++++
LONDON;DELHI;ICELAND;ANKARA
Sample Output 0
+L++++++++
+O++++++++
+N++++++++
+DELHI++++
+O+++C++++
+N+++E++++
+++++L++++
++ANKARA++
+++++N++++
+++++D++++
Sample Input 1
+-++++++++
+-++++++++
+-------++
+-++++++++
+-++++++++
+------+++
+-+++-++++
+++++-++++
+++++-++++
++++++++++
AGRA;NORWAY;ENGLAND;GWALIOR
Sample Output 1
+E++++++++
+N++++++++
+GWALIOR++
+L++++++++
+A++++++++
+NORWAY+++
+D+++G++++
+++++R++++
+++++A++++
++++++++++
Sample Input 2
++++++-+++
++------++
++++++-+++
++++++-+++
+++------+
++++++-+-+
++++++-+-+
++++++++-+
++++++++-+
++++++++-+
ICELAND;MEXICO;PANAMA;ALMATY
Sample Output 2
++++++I+++
++MEXICO++
++++++E+++
++++++L+++
+++PANAMA+
++++++N+L+
++++++D+M+
++++++++A+
++++++++T+
++++++++Y+","Use a greedy algorithm, prioritizing the shortest words first to minimize backtracking","Recursively try placing each word at every possible location and orientation, backtracking on conflicts","Employ dynamic programming to build a table of possible word placements, optimizing for space utilization",Transform the grid into a graph and use graph coloring to assign words to cells based on adjacency,"Use backtracking to iteratively try placing each word; if a conflict occurs, undo the placement and try another word or position",,algorithms,"['backtracking', 'crossword', 'constraint satisfaction']"
https://www.hackerrank.com/challenges/flipping-the-matrix?isFullScreen=true,"Sean invented a game involving a
matrix where each cell of the matrix contains an integer. He can reverse any of its rows or columns any number of times.  The goal of the game is to maximize the sum of the elements in the
submatrix located in the upper-left quadrant of the matrix.
Given the initial configurations for
matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.
Example
1
2
3
4
It is
and we want to maximize the top left quadrant, a
matrix.  Reverse row
:
1
2
4
3
And now reverse column
:
4
2
1
3
The maximal sum is
.
Function Description
Complete the
flippingMatrix
function in the editor below.
flippingMatrix has the following parameters:
-
int matrix[2n][2n]:
a 2-dimensional array of integers
Returns
-
int:
the maximum sum possible.
Input Format
The first line contains an integer
, the number of queries.
The next
sets of lines are in the following format:
The first line of each query contains an integer,
.
Each of the next
lines contains
space-separated integers
in row
of the matrix.
Constraints
, where
.
Sample Input
STDIN           Function
-----           --------
1               q = 1
2               n = 2
112 42 83 119   matrix = [[112, 42, 83, 119], [56, 125, 56, 49], \
56 125 56 49              [15, 78, 101, 43], [62, 98, 114, 108]]
15 78 101 43
62 98 114 108
Sample Output
414
Explanation
Start out with the following
matrix:
Perform the following operations to maximize the sum of the
submatrix in the upper-left quadrant:
Reverse column
(
), resulting in the matrix:
Reverse row
(
), resulting in the matrix:
The sum of values in the
submatrix in the upper-left quadrant is
.",Calculate the sum of all elements in the matrix and divide by 4.,Sum the elements in the upper-left quadrant without any row or column reversals.,Find the maximum element in the entire matrix and multiply it by n*n.,Calculate the average of all elements and multiply by n*n.,"For each element in the upper-left quadrant, choose the maximum from its corresponding 4 positions in the matrix, and sum these maximums.",,algorithms,"['matrix manipulation', 'greedy algorithm', 'optimization']"
https://www.hackerrank.com/challenges/board-cutting?isFullScreen=true,"Alice gives Bob a board composed of
wooden squares and asks him to find the minimum cost of breaking the board back down into its individual squares. To break the board down, Bob must make cuts along its horizontal and vertical lines.
To reduce the board to squares, Bob makes horizontal and vertical cuts across the entire board.  Each cut has a given cost,
or
for each cut along a row or column across one board, so the cost of a cut must be multiplied by the number of segments it crosses.  The cost of cutting the whole board down into
squares is the sum of the costs of each successive cut.
Can you help Bob find the minimum cost?  The number may be large, so print the value modulo
.
For example, you start with a
board.  There are two cuts to be made at a cost of
for the horizontal and
for the vertical.  Your first cut is across
piece, the whole board.  You choose to make the horizontal cut between rows
and
for a cost of
.  The second cuts are vertical through the two smaller boards created in step
between columns
and
.  Their cost is
.  The total cost is
and
.
Function Description
Complete the
boardCutting
function in the editor below.  It should return an integer.
boardCutting has the following parameter(s):
cost_x
: an array of integers, the costs of vertical cuts
cost_y
: an array of integers, the costs of horizontal cuts
Input Format
The first line contains an integer
, the number of queries.
The following
sets of lines are as follows:
The first line has two positive space-separated integers
and
, the number of rows and columns in the board.
The second line contains
space-separated integers cost_y[i], the cost of a  horizontal cut between rows
and
of one board.
The third line contains
space-separated integers cost_x[j], the cost of a vertical cut between columns
and
of one board.
Constraints
Output Format
For each of the
queries, find the minimum cost (
) of cutting the board into
squares and print the value of
.
Sample Input 0
1
2 2
2
1
Sample Output 0
4
Explanation 0
We have a
board, with cut costs
and
. Our first cut is horizontal between
and
, because that is the line with the highest cost (
). Our second cut is vertical, at
. Our first cut has a
of
because we are making a cut with cost
across
segment, the uncut board. The second cut also has a
of
but we are making a cut of cost
across
segments. Our answer is
.
Sample Input 1
1
6 4
2 1 3 1 4
4 1 2
Sample Output 1
42
Explanation 1
Our sequence of cuts is:
,
,
,
,
,
,
and
.
Cut 1:
Horizontal with cost
across
segment.
.
Cut 2:
Vertical with cost
across
segments.
.
Cut 3:
Horizontal with cost
across
segments.
.
Cut 4:
Horizontal with cost
across
segments.
.
Cut 5:
Vertical with cost
across
segments.
.
Cut 6:
Horizontal with cost
across
segments.
.
Cut 7:
Horizontal with cost
across
segments.
.
Cut 8:
Vertical with cost
across
segments.
.
. We then print the value of
.",Sort both cost arrays in ascending order and greedily choose the smallest cuts first.,"Calculate the total cost of all horizontal cuts plus the total cost of all vertical cuts, then take the minimum of that and 0.",Recursively divide the board into smaller sub-boards and calculate the minimum cost for each sub-board.,"Prioritize horizontal cuts if the board has more rows than columns, and vertical cuts otherwise.","Sort both cost arrays in descending order and greedily choose the largest cost cut, multiplying by the number of segments it crosses.",,algorithms,"['greedy algorithm', 'sorting', 'optimization']"
https://www.hackerrank.com/challenges/ones-and-twos?isFullScreen=true,"You are using at most
A
number of 1s and at most
B
number of 2s. How many different evaluation results are possible when they are formed in an expression containing only addition
+
sign and multiplication
*
sign are allowed?
Note that, multiplication takes precedence over addition.
For example, if
A=2
and
B=2
, then we have the following expressions:
1
,
1*1
= 1
2
,
1*2
,
1*1*2
,
1+1
= 2
1+2
,
1+1*2
= 3
2+2
,
2*2
,
1+1+2
,
1*2*2
,
1*1*2*2
,
1*2+1*2
,
1*1*2+2
,
1*2+2
= 4
1+2+2
,
1+1*2+2
= 5
1+1+2+2
,
1+1+2*2
= 6
So there are 6 unique results that can be formed if A = 2 and B = 2.
Input Format
The first line contains the number of test cases T, T testcases follow each in a newline.
Each testcase contains 2 integers A and B separated by a single space.
Constraints
1 <= T <= 10
5
0<=A<=1000000000
0<=B<=1000
Output Format
Print the number of different evaluations modulo (%) (10
9
+7.)
Sample Input
4
0 0
2 2
0 2
2 0
Sample Output
0
6
2
2
Explanation
When A = 0, B = 0, there are no expressions, hence 0.
When A = 2, B = 2, as explained in the problem statement above, expressions leads to 6 possible solutions.
When A = 0, B = 2, we have
2
,
2+2
or
2*2
, hence 2.
When A = 2, B = 0, we have
1
or
1*1
,
1+1
hence 2.",(A + 1) * (B + 1) % (1000000000 + 7),(A + B + 1) % (1000000000 + 7),(A * B + 1) % (1000000000 + 7),(A + 2 * B + 1) % (1000000000 + 7),(A + 1) * (B * (A + 1) + 1) % (1000000000 + 7),,algorithms,"['dynamic programming', 'combinatorics', 'math']"
https://www.hackerrank.com/challenges/simple-game?isFullScreen=true,"Big Cat and Little Cat love playing games. Today, they decide to play a Game of Stones, the
Kitties are Coming
edition. The game's rules are as follows:
The game starts with
stones that are randomly divided into
piles.
The cats move in alternating turns, and Little Cat always moves first.
During a move, a cat picks a pile having a number of stones
and splits it into any number of non-empty piles in the inclusive range from
to
.
The first cat to be unable to make a move (e.g., because all piles contain exactly
stone) loses the game.
Little Cat is curious about the number of ways in which the stones can be initially arranged so that she is guaranteed to win. Two arrangements of stone piles are considered to be different if they contain different sequences of values. For example, arrangements
and
are different.
Given the values for
,
, and
, find the number of winning configurations for Little Cat and print it modulo
.
Note:
Each cat always moves
optimally
, meaning that they're both playing to win and neither cat will make a move that causes them to lose the game if some other (winning) sequence of moves can be made.
Input Format
The first line of input contains three space-separated integers,
(the number of stones),
(the number of piles), and
(the maximum number of piles into which a pile can be split during a single move), respectively.
Constraints
Output Format
Print the number of initial arrangements of piles that will result in Little Cat winning, modulo
.
Sample Input
4 3 3
Sample Output
3
Explanation
There are three possible arrangements:
For any arrangement, Little Cat can pick a pile containing
stones and split it into
piles with
stone each. At this point, the pile configuration will be
, so Big Cat won't be able to make any moves and the game ends. We then print the result of
on a new line.",The number of arrangements where the XOR sum of all pile sizes is zero.,The number of arrangements where the sum of all pile sizes is a multiple of k.,The number of arrangements where the number of piles is even.,The total number of possible arrangements minus the number of arrangements where Big Cat wins.,The number of arrangements that result in a non-zero Sprague-Grundy value.,,algorithms,"['game theory', 'sprague-grundy', 'dynamic programming']"
https://www.hackerrank.com/challenges/xor-subsequence?isFullScreen=true,"Consider an array,
, of
integers (
).
We take all consecutive subsequences of integers from the array that satisfy the following:
For example, if
our subsequences will be:
For each subsequence, we apply the bitwise
XOR
(
) operation on all the integers and record the resultant value. Since there are
subsequences, this will result in
numbers.
Given array
, find the XOR sum of every subsequence of
and determine the frequency at which each number occurs. Then print the number and its respective frequency as two space-separated values on a single line.
Input Format
The first line contains an integer,
, denoting the size of the array.
Each line
of the
subsequent lines contains a single integer describing element
.
Constraints
Output Format
Print
space-separated integers on a single line. The first integer should be the number having the highest frequency, and the second integer should be the number's frequency (i.e., the number of times it appeared). If there are multiple numbers having maximal frequency, choose the smallest one.
Sample Input 0
4
2
1
1
3
Sample Output 0
1 3
Explanation 0
Let's find the XOR sum for all consecutive subsequences. We'll refer to the frequency of some number
as
, and keep a running sum for each frequency:
, frequencies:
, frequencies:
and
, frequencies:
and
, frequencies:
,
, and
, frequencies:
,
, and
, frequencies:
,
,
, and
, frequencies:
,
,
, and
, frequencies:
,
,
, and
, frequencies:
,
,
, and
, frequencies:
,
,
, and
Our maximal frequency is
, and the integers
,
, and
all have this frequency. Because more than one integer has this frequency, we choose the smallest one, which is
. We then print the respective smallest number having the maximal frequency and the maximal frequency as a single line of space-separated values.",The XOR sum is always 0 regardless of the array elements.,The XOR sum is always equal to the XOR of all elements in the original array.,The XOR sum is equal to the sum of all the array elements.,The XOR sum is equal to the product of all the array elements.,"The XOR sum is equal to the bitwise AND of all elements in the array multiplied by 2 raised to the power of (n-1), where n is the size of the array.",,algorithms,"['bitwise operations', 'XOR', 'subsequences']"
https://www.hackerrank.com/challenges/longest-increasing-subsequent?isFullScreen=true,"An Introduction to the Longest Increasing Subsequence Problem
The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in strictly ascending order. This is called the Longest Increasing Subsequence (LIS) problem.
For example, the length of the LIS for
is
since the longest increasing subsequence is
.
Here's a great YouTube video of a lecture from MIT's Open-CourseWare covering the topic.
This is one approach which solves this in quadratic time using dynamic programming. A more efficient algorithm which solves the problem in
time is
available here
.
Given a sequence of integers, find the length of its longest strictly increasing subsequence.
Function Description
Complete the
longestIncreasingSubsequence
function in the editor below.  It should return an integer that denotes the array's LIS.
longestIncreasingSubsequence has the following parameter(s):
arr
: an unordered array of integers
Input Format
The first line contains a single integer
, the number of elements in
.
Each of the next
lines contains an integer,
Constraints
Output Format
Print a single line containing a single integer denoting the length of the longest increasing subsequence.
Sample Input 0
5
2
7
4
3
8
Sample Output 0
3
Explanation 0
In the array
, the longest increasing subsequence is
.  It has a length of
.
Sample Input 1
6
2
4
3
7
4
5
Sample Output 1
4
Explanation 1
The LIS of
is
.","Recursively check all possible subsequences, which leads to redundant calculations.",Sort the input array first and then find the longest subsequence.,Iterate through the array and only keep track of elements greater than the previous element.,Use a greedy approach by always selecting the smallest element that is greater than the last element in the subsequence.,Use dynamic programming or binary search to efficiently track the smallest end element of increasing subsequences of different lengths.,,algorithms,"['dynamic programming', 'longest increasing subsequence', 'binary search']"
https://www.hackerrank.com/challenges/xor-key?isFullScreen=true,"Xorq
has invented an encryption algorithm which uses bitwise XOR operations extensively. This encryption algorithm uses a sequence of non-negative integers
as its key. To implement this algorithm efficiently,
Xorq
needs to find maximum value of
for given integers
,
and
, such that,
. Help
Xorq
implement this function.
For example,
,
,
and
.  We test each
for all values of
between
and
inclusive:
j   x[j]    x[j]^4
1   3       7
2   5       1
3   9       13
Our maximum value is
.
Function Description
Complete the
xorKey
function in the editor below.  It should return an integer array where each value is the response to a query.
xorKey has the following parameters:
x
: a list of integers
queries
: a two dimensional array where each element is an integer array that consists of
for the
query at indices
and
respectively.
Input Format
The first line contains an integer
, the number of test cases.
The first line of each test case contains two space-separated integers
and
, the size of the integer array
and the number of queries against the test case.
The next line contains
space-separated integers
.
Each of next
lines describes a query which consists of three integers
and
.
Constraints
Output Format
For each query, print the maximum value for
, such that,
on a new line.
Sample Input 0
1
15 8
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
10 6 10
1023 7 7
33 5 8
182 5 10
181 1 13
5 10 15
99 8 9
33 10 14
Sample Output 0
13
1016
41
191
191
15
107
47
Explanation 0
First Query (10 6 10):
.  The maximum is
.
Second Query (1023 7 7):
Third Query (33 5 8):
Fourth Query (182 5 10):","The maximum XOR value is always 2^31 - 1, the maximum value of a signed 32-bit integer.",Use dynamic programming to store and reuse XOR values for subranges within the given range.,"Iterate through the range [L, R] and calculate XOR of A[j] with K, keeping track of the maximum result. Precompute XOR values to reduce time complexity.",Sort the subarray from index L to R in ascending order and XOR each element with K. Return the maximum value found after sorting.,"Iterate through the range [L, R] and calculate XOR of A[j] with K, keeping track of the maximum result.",,algorithms,"['bitwise XOR', 'iteration', 'maximum value']"
https://www.hackerrank.com/challenges/maximizing-mission-points?isFullScreen=true,"Xander Cage has a list of cities he can visit on his new top-secret mission. He represents each city as a tuple of
. The values of
,
, and
are distinct across all cities.
We define a mission as a sequence of cities,
, that he visits. We define the total
of such a mission to be the sum of the
of all the cities in his mission list.
Being eccentric, he abides by the following rules on any mission:
He can choose the number of cities he will visit (if any).
He can start the mission from any city.
He visits cities in order of strictly increasing
.
The absolute difference in
between adjacent visited cities in his mission must be
at most
.
The absolute difference in
between adjacent visited cities in his mission must be
at most
.
Given
,
, and the definitions for
cities, find and print the maximum possible total
that Xander can earn on a mission.
Input Format
The first line contains three space-separated integers describing the respective values of
,
, and
.
Each line
of the
subsequent lines contains four space-separated integers denoting the respective
,
,
, and
for a city.
Constraints
Output Format
Print a single integer denoting the maximum possible
that Xander can earn on a mission.
Sample Input 0
3 1 1
1 1 1 3
2 2 2 -1
3 3 3 3
Sample Output 0
5
Explanation 0
Xander can start at city
, then go to city
, and then go to city
for a maximum value of total
https://s3.amazonaws.com/hr-assets/0/1487060424-d58975de09-drawing.jpg
Note that he cannot go directly from city
to city
as that would violate his rules that the absolute difference in
between adjacent visited cities be
and the absolute difference in
between adjacent visited cities be
. Because
and
, he cannot directly travel between those cities.","Use a greedy approach, always selecting the city with the highest score within the constraints.","Sort cities by x-coordinate and calculate the score by iterating through the sorted list, considering only adjacent cities.","Employ a brute-force approach, generating all possible city sequences and selecting the one with the maximum score.",Calculate the convex hull of the cities and then find the longest path along the hull.,"Utilize dynamic programming, storing the maximum score achievable at each city, considering all valid previous cities based on the constraints.",,algorithms,"['dynamic programming', 'graph traversal', 'optimization']"
https://www.hackerrank.com/challenges/animal-transport?isFullScreen=true,"Capeta is working part-time for an animal shipping company. He needs to pick up animals from various zoos and drop them to other zoos. The company ships four kinds of animals: elephants, dogs, cats, and mice.
There are
zoos, numbered
to
. Also, there are
animals. For each animal
, Capeta knows its type
(
E
for elephant,
D
for dog,
C
for cat and
M
for mouse), source zoo
where Capeta has to pick it up from, and destination zoo
where Capeta needs to deliver it to.
https://s3.amazonaws.com/hr-assets/0/1512382341-9d32c6b251-zoo.png
Capeta is given a truck with a huge capacity where
animals can easily fit. He is also given additional instructions:
He must visit the zoos in
increasing
order. He also cannot skip zoos.
Dogs
are scared of
elephants
, so he is not allowed to bring them together at the same time.
Cats
are scared of
dogs
, so he is not allowed to bring them together at the same time.
Mice
are scared of
cats
, so he is not allowed to bring them together at the same time.
Elephants
are scared of
mice
, so he is not allowed to bring them together at the same time.
Also, loading and unloading animals are complicated, so once an animal is loaded onto the truck, that animal will only be unloaded at its destination.
Because of these reasons, Capeta might not be able to transport all animals. He will need to ignore some animals. Which ones? The company decided to leave that decision for Capeta. He is asked to prepare a report and present it at a board meeting of the company.
Capeta needs to report the minimum number of zoos that must be reached so that she is able to transport
animals, for each
from
to
.
Complete the function
minimumZooNumbers
and return an integer array where the
integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport
animals, or
if it is impossible to transport
animals.
He is good at driving, but not so much at planning. Hence, he needs your help.
Input Format
The first line contains a single integer
, the number of test cases.
Each test case consists of four lines. The first line contains two space-separated integers
and
. The second line contains
space-separated characters
. The third line contains
space-separated integers
. The fourth line contains
space-separated integers
.
,
and
are the details for the
th animal, as described in the problem statement.
Constraints
is either
E
,
D
,
C
or
M
Subtasks
For
of the total score,
Output Format
For each case, print a single line containing
space-separated integers, where the
integer is the minimum number of zoos that Capeta needs to reach so that she is able to transport
animals. If it is not possible to transport
animals at all, then put
instead.
Sample Input 0
2
10 3
E D C
4 1 4
7 5 8
10 6
E D C M E D
1 1 1 2 9 7
2 2 2 4 10 10
Sample Output 0
5 8 -1
2 2 4 10 -1 -1
Explanation 0
First Test Case
Capeta can transport one animal by traveling up to zoo number
. Just drop the dog there. Next, in order to transport
animals (elephant and cat), Capeta has to go up to zoo number
.
Second Test Case
Animal: Drop the elephant to zoo
.
Animal: Drop the elephant and cat to zoo
.
Animal: Drop the elephant and cat to zoo
. Then drop the mouse to zoo
.
Animal: Drop the elephant and cat to zoo
. Then drop the mouse to zoo
. Finally, drop either the elephant or the dog to
.
It is impossible to transport
or
animals.",A greedy algorithm that prioritizes maximizing the number of animals picked up at each zoo without considering future constraints.,"A breadth-first search (BFS) algorithm exploring possible zoo sequences, pruning branches that violate animal compatibility rules, and tracking the minimum zoos for each animal count.","A dynamic programming approach where the state represents the number of animals transported and the last zoo visited, optimizing for the minimum number of zoos needed to transport a certain number of animals.","A backtracking algorithm that explores all possible combinations of animals and zoos, pruning branches that violate constraints or exceed the desired animal count, and returns the minimum number of zoos.",A modified binary search on the zoos combined with a feasible check using bitmasking to represent animal combinations to determine if a certain number of animals can be delivered up to that zoo.,,algorithms,"['dynamic programming', 'greedy algorithm', 'binary search']"
https://www.hackerrank.com/challenges/recursive-digit-sum?isFullScreen=true,"We define super digit of an integer
using the following rules:
Given an integer, we need to find the
super digit
of the integer.
If
has only
digit, then its super digit is
.
Otherwise, the super digit of
is equal to the super digit of the sum of the digits of
.
For example, the super digit of
will be calculated as:
super_digit
(
9875
)
9
+
8
+
7
+
5
=
29
super_digit
(
29
)
2
+
9
=
11
super_digit
(
11
)
1
+
1
=
2
super_digit
(
2
)
=
2
Example
The number
is created by concatenating the string
times so the initial
.
superDigit
(
p
)
=
superDigit
(
9875987598759875
)
9
+
8
+
7
+
5
+
9
+
8
+
7
+
5
+
9
+
8
+
7
+
5
+
9
+
8
+
7
+
5
=
116
superDigit
(
p
)
=
superDigit
(
116
)
1
+
1
+
6
=
8
superDigit
(
p
)
=
superDigit
(
8
)
All of the digits of
sum to
.  The digits of
sum to
.
is only one digit, so it is the super digit.
Function Description
Complete the function
superDigit
in the editor below.  It must return the calculated super digit as an integer.
superDigit has the following parameter(s):
string n:
a string representation of an integer
int k:
the times to concatenate
to make
Returns
int:
the super digit of
repeated
times
Input Format
The first line contains two space separated integers,
and
.
Constraints
Sample Input 0
148 3
Sample Output 0
3
Explanation 0
Here
and
, so
.
super_digit(P) = super_digit(148148148)
               = super_digit(1+4+8+1+4+8+1+4+8)
               = super_digit(39)
               = super_digit(3+9)
               = super_digit(12)
               = super_digit(1+2)
               = super_digit(3)
               = 3
Sample Input 1
9875 4
Sample Output 1
8
Sample Input 2
123 3
Sample Output 2
9
Explanation 2
Here
and
, so
.
super_digit(P) = super_digit(123123123)
               = super_digit(1+2+3+1+2+3+1+2+3)
               = super_digit(18)
               = super_digit(1+8)
               = super_digit(9)
               = 9","Return the input number 'n' if k is greater than 1, otherwise calculate and return the super digit of 'n'",Return the length of the input string 'n' multiplied by k,Return the sum of the digits of 'n' without considering the repetition factor 'k',"Calculate the sum of digits of 'n', take modulo 9 of it, then multiply by k and take modulo 9 again","Calculate the sum of digits of n, multiply by k, then find super digit recursively until result has single digit",,algorithms,"['recursion', 'string manipulation', 'digit sum']"
https://www.hackerrank.com/challenges/string-function-calculation?isFullScreen=true,"Jane loves strings more than anything. She has a string
with her, and value of string
over function
can be calculated as given below:
Jane wants to know the maximum value of
among all the substrings
of string
. Can you help her?
Input Format
A single line containing string
.
Output Format
Print the maximum value of
among all the substrings
of string
.
Constraints
The string consists of lowercase English alphabets.
Sample Input 0
aaaaaa
Sample Output 0
12
Explanation 0
f('a') = 6
f('aa') = 10
f('aaa') = 12
f('aaaa') = 12
f('aaaaa') = 10
f('aaaaaa') = 6
Sample Input 1
abcabcddd
Sample Output 1
9
Explanation 1
f
values of few of the substrings are shown below:
f(""a"") = 2
f(""b"") = 2
f(""c"") = 2
f(""ab"") = 4
f(""bc"") = 4
f(""ddd"") = 3
f(""abc"") = 6
f(""abcabcddd"") = 9
Among the function values
9
is the maximum one.",The problem cannot be solved in linear time due to the need to evaluate all substrings.,"Calculate the frequency of each character, sort by frequency, and calculate the weighted sum from highest to lowest frequency.",Use dynamic programming to store the maximum value for all prefixes of the string.,"Employ a divide-and-conquer approach, splitting the string into halves and recursively calculating the maximum value.","Iterate through all substrings, calculating the value for each, and keep track of the maximum value found.",,algorithms,"['string', 'substring', 'optimization']"
https://www.hackerrank.com/challenges/stockmax?isFullScreen=true,"Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days.
Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy?
Example
Buy one share day one, and sell it day two for a profit of
. Return
.
No profit can be made so you do not buy or sell stock those days. Return
.
Function Description
Complete the
stockmax
function in the editor below.
stockmax has the following parameter(s):
prices
: an array of integers that represent predicted daily stock prices
Returns
int:
the maximum profit achievable
Input Format
The first line contains the number of test cases
.
Each of the next
pairs of lines contain:
- The first line contains an integer
, the number of predicted prices for WOT.
- The next line contains n space-separated integers
, each a predicted stock price for day
.
Constraints
Output Format
Output
lines, each containing the maximum profit which can be obtained for the corresponding test case.
Sample Input
STDIN       Function
-----       --------
3           q = 3
3           prices[] size n = 3
5 3 2       prices = [5, 3, 2]
3           prices[] size n = 3
1 2 100     prices = [1, 2, 100]
4           prices[] size n = 4
1 3 1 2     prices =[1, 3, 1, 2]
Sample Output
0
197
3
Explanation
For the first case, there is no profit because the share price never rises, return
.
For the second case, buy one share on the first two days and sell both of them on the third day for a profit of
.
For the third case, buy one share on day 1, sell one on day 2, buy one share on day 3, and sell one share on day 4.  The overall profit is
.",Always buy on the first day and sell on the last day.,Buy only on days when the price is lower than the average price of all days.,Buy on every day with increasing prices and sell the stock on the next high point.,Buy all the stocks on the first day and sell them on the last day.,Iterate backward and buy only when the current price is less than the maximum price seen so far. Calculate profit when selling at the maximum price.,,algorithms,"['dynamic programming', 'greedy algorithm', 'array']"
https://www.hackerrank.com/challenges/bigger-is-greater?isFullScreen=true,"Lexicographical order
is often known as alphabetical order when dealing with strings.  A string is
greater
than another string if it comes later in a lexicographically sorted list.
Given a word, create a new word by swapping some or all of its characters.  This new word must meet two criteria:
It must be greater than the original word
It must be the smallest word that meets the first condition
Example
The next largest word is
.
Complete the function
biggerIsGreater
below to create and return the new string meeting the criteria.  If it is not possible, return
no answer
.
Function Description
Complete the
biggerIsGreater
function in the editor below.
biggerIsGreater has the following parameter(s):
string w
: a word
Returns
-
string:
the smallest lexicographically higher string possible or
no answer
Input Format
The first line of input contains
, the number of test cases.
Each of the next
lines contains
.
Constraints
will contain only letters in the range ascii[a..z].
Sample Input 0
5
ab
bb
hefg
dhck
dkhc
Sample Output 0
ba
no answer
hegf
dhkc
hcdk
Explanation 0
Test case 1:
ba
is the only string which can be made by rearranging
ab
. It is greater.
Test case 2:
It is not possible to rearrange
bb
and get a greater string.
Test case 3:
hegf
is the next string greater than
hefg
.
Test case 4:
dhkc
is the next string greater than
dhck
.
Test case 5:
hcdk
is the next string greater than
dkhc
.
Sample Input 1
6
lmno
dcba
dcbb
abdc
abcd
fedcbabcd
Sample Output 1
lmon
no answer
no answer
acbd
abdc
fedcbabdc",Start from the beginning of the string and find the first character that is smaller than the next character. Swap it with the smallest character to its right that is larger than it.,"Sort the entire string alphabetically. If the sorted string is the same as the original, return 'no answer'.","Generate all possible permutations of the string, sort them lexicographically, and return the next string after the input, or 'no answer' if it's the last.","Reverse the string. If the reversed string is lexicographically greater than the original, return it; otherwise, return 'no answer'.","Find the rightmost character `w[i]` that is smaller than `w[i+1]`. Then find the smallest character to the right of `w[i]` that is greater than `w[i]`. Swap these two characters, and sort the substring starting from `w[i+1]` in ascending order. If no such `w[i]` exists, return 'no answer'.",,algorithms,"['string manipulation', 'lexicographical order', 'algorithm']"
https://www.hackerrank.com/challenges/bob-and-ben?isFullScreen=true,"Bob and Ben are playing a game with forests! The game's rules are as follows:
The game starts with a
forest
of
trees.
Bob always moves first and they take alternating turns. The first player with no available move loses the game.
During each move, the player removes one node. If the node is
not a leaf
, then the whole tree vanishes; otherwise, the rest of the tree remains in the forest. We define a leaf to be a node with exactly
connected edge.
Both players play optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.
We define each tree
in the
-tree forest as follows:
Tree
is defined by two integers,
(the number of nodes in the tree) and
(a constant).
Its nodes are numbered sequentially from
to
.
Its edges are numbered sequentially from
to
, and each edge
connects node
to node
.
Given the values of
and
for each tree in the forest, can you determine who will win the game?
Input Format
The first line contains an integer,
, denoting the number of games. The subsequent lines describe each game in the following format:
The first line contains an integer,
, denoting the number of trees in the forest.
Each of the
subsequent lines contains two space-separated integers describing the respective values of
and
for tree
.
Constraints
The sum of
over all games is at most
.
Subtasks
For
of the maximum score:
The sum of
over all games is at most
.
For
of the maximum score:
Output Format
For each game, print the name of the winner on a new line (i.e.,
BOB
or
BEN
).
Sample Input
2
2
1 2
1 3
1
3 2
Sample Output
BEN
BOB
Explanation
Bob and Ben play the following two games:
The forest consists of
trees containing one node each, and each tree has no edges as
and
are both
(so both trees have
edges). The sequence of moves is as follows:
https://s3.amazonaws.com/hr-challenge-images/0/1478729153-337d0b1f7f-bob-and-ben-1.png
We then print the name of the winner,
BEN
, on a new line.
The forest consists of
tree containing three nodes. We find the
edges like so:
Edge
connects node
to node
.
Edge
connects node
to node
.
The game then plays out as follows:
https://s3.amazonaws.com/hr-challenge-images/0/1478729255-6dbfc92d23-bob-and-ben-2.png
We then print the name of the winner,
BOB
, on a new line.",The first player always wins regardless of tree configuration.,The winner is determined by the parity of the total number of nodes across all trees.,The winner depends only on the largest value of 'n' among all trees.,The second player always wins because they can mirror the first player's moves.,The winner is determined by the XOR sum of (n-leaf_count) across all trees where leaf_count is the number of leaves in each tree.,,algorithms,"['game theory', 'trees', 'XOR']"
https://www.hackerrank.com/challenges/minimum-operations?isFullScreen=true,"In this challenge, the task is to debug the existing code to successfully execute all provided test files.
There are
boxes in front of you. For each
, box
contains
red balls,
green balls, and
blue balls.
You want to separate the balls by their color. In each operation, you can pick a single ball from some box and put it into another box. The balls are separated if no box contains balls of more than one color.
Debug the given function
min_operations
and compute the minimal number of operations required to separate the balls.
Note: In this problem you can modify at most
six
lines of code and you cannot add any new lines.
To restore the original code, click on the icon to the right of the language selector.
Input Format
The first line contains a single integer
.
The next
lines
contain three space-separated integers,
,
, and
, respectively.
Constraints
Output Format
Print the minimal number of operations required to separate the balls. If this is impossible, return
.
Sample Input
3
1 1 1
1 1 1
1 1 1
Sample Output
6
Explanation
Each box contains 1 ball of each color.  In this explanation, the goal will be to let the first box contain only red balls, the second box only blue balls, and the third box only green balls.
Move 1 blue ball and 1 green ball from the first box to the second and third boxes.
Move 1 red ball and 1 green ball from the second box to the first and third boxes.
Move 1 red ball and 1 blue ball from the third box to the first and second boxes.
The number of operations is 6.",Calculate the total number of balls of each color and return the sum of the two smallest counts.,"For each box, find the minimum number of operations to isolate one color, then sum those minimums.","Calculate the number of balls to move for each box assuming only red, green and blue are in each, then find the box needing the least moves and return that value.",Use dynamic programming to track the minimum number of moves required to separate the balls up to a certain box index.,Compute all 6 permutations of assigning colors to boxes and pick the arrangement with the minimal moves,,algorithms,"['optimization', 'debugging', 'combinatorics']"
https://www.hackerrank.com/challenges/dijkstrashortreach?isFullScreen=true,"Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from
to
, and edges will have varying distances or lengths.
For example, consider the following graph of 5 nodes:
Begin
End
Weight
1
2
5
2
3
6
3
4
2
1
3
15
https://s3.amazonaws.com/hr-assets/0/1535120384-c96f8f586f-djikstraexample.png
Starting at node
, the shortest path to
is direct and distance
.  Going from
to
, there are two paths:
at a distance of
or
at a distance of
.  Choose the shortest path,
.  From
to
, choose the shortest path through
and extend it:
for a distance of
There is no route to node
, so the distance is
.
The distances to all nodes in increasing node order, omitting the starting node, are
5 11 13 -1
.
Function Description
Complete the
shortestReach
function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.
shortestReach has the following parameter(s):
n
: the number of nodes in the graph
edges
: a 2D array of integers where each
consists of three integers that represent the start and end nodes of an edge, followed by its length
s
: the start node number
Input Format
The first line contains
, the number of test cases.
Each test case is as follows:
- The first line contains two space-separated integers
and
, the number of nodes and edges in the graph.
- Each of the next
lines contains three space-separated integers
,
, and
, the beginning and ending nodes of an edge, and the length of the edge.
- The last line of each test case has an integer
, denoting the starting position.
Constraints
If there are edges between the same pair of nodes with different weights, they are to be considered as is, like multiple edges.
Output Format
For each of the
test cases, print a single line consisting
space separated integers denoting the shortest distance to the
nodes from starting position
in  increasing order of their labels, excluding
.
For unreachable nodes, print
.
Sample Input
1
4 4
1 2 24
1 4 20
3 1 3
4 3 12
1
Sample Output
24 3 15
Explanation
The graph given in the test case is shown as :
https://s3.amazonaws.com/hr-assets/0/1535119988-c9f7f491e0-djikstrasample0.png
* The lines are weighted edges where weight denotes the length of the edge.
The shortest paths followed for the three nodes 2, 3 and 4 are as follows :
1/S->2
- Shortest Path Value :
1/S->3
- Shortest Path Value :
1/S->3->4
- Shortest Path Value :","Breadth-First Search (BFS) with a queue, updating distances only if a shorter path is found and never re-visiting nodes.","Depth-First Search (DFS) with backtracking, exploring all possible paths and selecting the shortest ones at the end.","A* search algorithm using a heuristic function to estimate the distance to the destination, which can guarantee shortest paths even with negative edge weights.",Floyd-Warshall algorithm to compute all-pairs shortest paths and then extract the distances from the starting node.,Dijkstra's algorithm using a priority queue to efficiently select the next node to visit based on its current shortest distance from the source.,,algorithms,"['graph algorithms', 'shortest path', ""Dijkstra's algorithm""]"
https://www.hackerrank.com/challenges/stone-division?isFullScreen=true,"Consider the following game:
There are two players,
First
and
Second
, sitting in front of a pile of
stones.
First
always plays first.
There is a set,
, of
distinct integers defined as
.
The players move in alternating turns. During each turn, a player chooses some
and splits one of the piles into exactly
smaller piles of equal size. If no
exists that will split one of the available piles into exactly
equal smaller piles, the player loses.
Both players always play optimally.
Given
,
, and the contents of
, find and print the winner of the game. If
First
wins, print
First
; otherwise, print
Second
.
Input Format
The first line contains two space-separated integers describing the respective values of
(the size of the initial pile) and
(the size of the set).
The second line contains
distinct space-separated integers describing the respective values of
.
Constraints
Output Format
Print
First
if the
First
player wins the game; otherwise, print
Second
.
Sample Input 0
15 3
5 2 3
Sample Output 0
Second
Explanation 0
The initial pile has
stones, and
. During
First
's initial turn, they have two options:
Split the initial pile into
equal piles, which forces them to lose after the following sequence of turns:
https://s3.amazonaws.com/hr-challenge-images/26005/1477606092-451edc074c-stone-division.png
Split the initial pile into
equal piles, which forces them to lose after the following sequence of turns:
https://s3.amazonaws.com/hr-challenge-images/26005/1477607342-902e1f8eab-stone-division-2.png
Because
First
never has any possible move that puts them on the path to winning, we print
Second
as our answer.",The first player always wins regardless of the set and initial pile size.,The second player always wins regardless of the set and initial pile size.,The winner is determined by whether the initial pile size is a prime number.,The winner can be determined by checking if the size of the set S is even or odd.,"The winner is determined recursively using a game theory approach, considering all possible moves and their outcomes.",,algorithms,"['game theory', 'recursion', 'dynamic programming']"
https://www.hackerrank.com/challenges/beautiful-string?isFullScreen=true,"You are given a string,
, consisting of lowercase English letters.
A string is
beautiful
with respect to
if it can be derived from
by removing
exactly
characters.
Find and print the number of different strings that are
beautiful
with respect to
.
Input Format
A single string of lowercase English letters denoting
.
Constraints
holds for test cases worth at least
of the problem's score.
holds for test cases worth at least
of the problem's score.
Output Format
Print the number of different strings that are
beautiful
with respect to
.
Sample Input
abba
Sample Output
4
Explanation
The following strings can be derived by removing
characters from
:
.
This gives us our set of
unique
beautiful strings,
. As
, we print
.",Count the occurrences of each character and sum the counts greater than 1.,Generate all possible substrings of length N-1 and count the distinct ones.,"Calculate the power set of the string and filter for strings of length N-1, then count distinct strings.",Find the longest common subsequence of the string with itself.,Iterate through all combinations of N-1 characters from the string and count the number of unique resulting strings.,,algorithms,"['string manipulation', 'combinations', 'substrings']"
https://www.hackerrank.com/challenges/drive?isFullScreen=true,"HackerRank is starting a bus service in
MountainView, California
. The bus starts at time T = 0 at
station
1
and goes through
station
2
,
station
3
,
station
4
in that order and reaches the headquarters located at
station
n
. At every station, the bus waits for various commuters to arrive before it departs to the next station. Ignoring the acceleration, the bus moves at 1 meter / second. i.e., if
station
i
and
station
j
are 1000 meters apart, the bus takes 1000 seconds to travel from
station
i
to
station
j
.
The bus is equipped with
K
units of Nitro (N
2
O). If going from
station
i
to
station
j
takes
x
seconds, then using
t
units of nitro can decrease the time taken to max(x-t, 0) seconds where max(a,b) denotes the greater of the two values between a & b. The Nitro can be used all at once or in multiples of 1 unit.
If the bus driver travels optimally, what is the minimum sum of travelling time for all commuters? The travelling time equals to the time he/she arrived at the destination minus the time he/she arrived the start station.
Please remember that the driver must take all passengers to their destination.
Input Format
The first line contains 3 space separated integers n, m and K which indicate the number of stations, total number of people who board the bus at various stations and the total units of Nitro (N
2
O) present in the bus.
The second line contains n-1 space separated integers where the i
th
integer indicates the distance between
station
(i-1)
to
station
i
.
m lines follow each containing 3 space separated integers. The i
th
line contains t
i
, s
i
and e
i
in that order indicating the arrival time of the commuter at s
i
at time t
i
with his destination being e
i
.
n m K
d1 d2 ... dn-1   // di: the distance between station_i to station_(i+1).
t1 s1 e1         // commuter 1 arrives at his boarding point at s1 and his destination is e1
t2 s2 e2
...
tm sm em
Constraints
0 < n <= 100000
0 < m <= 100000
0 <= K <= 10000000
0 < d
i
<= 100
0 <= t
i
<= 10000000
1 <= s
i
< e
i
<= n
Output Format
The minimal total travel time.
Sample Input
3 3 2
1 4
1 1 3
2 1 2
5 2 3
Sample Output
9
Explanation
The bus waits for the 1
st
and the 2
nd
commuter to arrive at station
1
and travels to station
2
carrying 2 passengers. The travel time from station
1
to station
2
is 1 second. It then waits for the 3
rd
commuter to board the bus at time = 5, 2
nd
commuter deboards the bus. The 3
rd
commuter boards the bus at t = 5. The bus now uses 2 units of nitro, this reduces the commute time to travel to station
3
from 4 to 2.
Hence, the total time spent by each of the passengers on the bus is
1 (time spent waiting for commuter 2) + 1 (travel time from station
1
to station
2
) + 2 (time spent waiting for commuter 3) + 2 (travel time from station
2
to station
3
) = 6
1 (travel time from station
1
to station
2
)
2 (travel time from station
2
to station
3
)
6+1+2 = 9
hence the answer.
Timelimits
Timelimits for this challenge can be seen
here","Use a greedy approach, prioritizing nitro usage on the longest segments without considering passenger wait times",Calculate the shortest path using Dijkstra's algorithm on a graph where edges represent station distances and nitro usage reduces edge weights,Apply dynamic programming to compute the minimum travel time for each passenger individually and sum the results,Simulate all possible nitro usage scenarios and choose the configuration with the lowest total passenger travel time using brute force,"Model the problem as a dynamic programming problem, optimizing nitro usage at each segment to minimize total passenger wait and travel time",,algorithms,"['dynamic programming', 'optimization', 'simulation']"
https://www.hackerrank.com/challenges/kmp-problem?isFullScreen=true,"This challenge uses the famous
KMP algorithm
. It isn't really important to understand how KMP works, but you should understand what it calculates.
A KMP algorithm takes a string,
, of length
as input. Let's assume that the characters in
are indexed from
to
; for every prefix of
, the algorithm calculates the length of its longest valid
border
in linear complexity. In other words, for every
(where
) it calculates the largest
(where
) such that for every
(where
) there is
.
Here is an implementation example of KMP:
kmp
[
1
]
=
0
;
for
(
i
=
2
;
i
<=
N
;
i
=
i
+
1
){
l
=
kmp
[
i
-
1
];
while
(
l
>
0
&&
S
[
i
]
!=
S
[
l
+
1
]){
l
=
kmp
[
l
];
}
if
(
S
[
i
]
==
S
[
l
+
1
]){
kmp
[
i
]
=
l
+
1
;
}
else
{
kmp
[
i
]
=
0
;
}
}
Given a sequence
, construct a string,
, that meets the following conditions:
The frequency of letter '
' in
is exactly
, the frequency of letter '
' in
is exactly
, and so on.
Let's assume characters of
are numbered from
to
, where
. We apply the KMP algorithm to
and get a table,
, of size
. You must ensure that the sum of
for all
is minimal.
If there are multiple strings which fulfill the above conditions, print the
lexicographically
smallest one.
Input Format
A single line containing
space-separated integers describing sequence
.
Constraints
The sum of all
will be a positive integer
.
Output Format
Print a single string denoting
.
Sample Input
2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Sample Output
aabb
Explanation
The output string must have two '
' and two '
'. There are several such strings but we must ensure that sum of
for all
is minimal. See the figure below:
https://s3.amazonaws.com/hr-challenge-images/9000/1461902702-42eba44de8-kmp1.png
The minimum sum is
. Among all the strings that satisfy both the condition, ""aabb"" is the lexicographically smallest.","Construct the string with the most frequent characters first, minimizing prefix overlap.",Sort the input array and greedily build the string from the least frequent characters to maximize prefix matches.,Randomly generate strings and calculate the KMP array sum; select the lexicographically smallest with the minimum sum.,"Build the string iteratively, at each step adding the character that results in the smallest immediate increase in the KMP array sum.",Sort the character counts and construct the string by prioritizing characters earlier in the alphabet that minimize KMP array sum growth.,,algorithms,"['KMP algorithm', 'string construction', 'lexicographical order']"
https://www.hackerrank.com/challenges/counting-road-networks?isFullScreen=true,"Lukas is a Civil Engineer who loves designing road networks to connect
cities numbered from
to
. He can build any number of bidirectional roads as long as the resultant network satisfies these constraints:
It must be possible to reach any city from any other city by traveling along the network of roads.
No two roads can directly connect the same two cities.
A road cannot directly connect a city to itself.
In other words, the roads and cities must form a simple connected labeled graph.
You must answer
queries, where each query consists of some
denoting the number of cities Lukas wants to design a bidirectional network of roads for. For each query, find and print the number of ways he can build roads connecting
cities on a new line; as the number of ways can be quite large, print it modulo
.
Input Format
The first line contains an integer,
, denoting the number of queries.
Each of the
subsequent lines contains an integer denoting the value of
for a query.
Constraints
Output Format
For each of the
queries, print the number of ways Lukas can build a network of bidirectional roads connecting
cities, modulo
, on a new line.
Sample Input 0
3
1
3
10
Sample Output 0
1
4
201986643
Explanation 0
We answer the first two queries like this:
When
, the only option satisfying Lukas' three constraints is to not build any roads at all. Thus, we print the result of
on a new line.
When
, there are four ways for Lukas to build roads that satisfy his three constraints:
https://s3.amazonaws.com/hr-assets/0/1487056543-a4e4d2b64d-ScreenShot2017-02-13at11.14.21PM.png
Thus, we print the result of
on a new line.",n(n-1)/2,n!,2^(n-1),2^(n(n-1)/2),2^(n(n-1)/2 - number of disconnected graphs),,algorithms,"['graph theory', 'connectivity', 'modular arithmetic']"
https://www.hackerrank.com/challenges/determining-dna-health?isFullScreen=true,"DNA
is a nucleic acid present in the bodies of living things. Each piece of DNA contains a number of
genes
, some of which are beneficial and increase the DNA's
total health
. Each gene has a
health value
, and the
total health
of a DNA is the sum of the health values of all the beneficial genes that occur as a substring in the DNA. We represent genes and DNA as non-empty strings of lowercase English alphabetic letters, and the same gene may appear multiple times as a susbtring of a DNA.
Given the following:
An array of beneficial gene strings,
. Note that these gene sequences are
not
guaranteed to be distinct.
An array of gene health values,
, where each
is the health value for gene
.
A set of
DNA strands where the definition of each strand has three components,
,
, and
, where string
is a DNA for which genes
are healthy.
Find and print the respective total healths of the
unhealthiest
(minimum total health) and
healthiest
(maximum total health) strands of DNA as two space-separated values on a single line.
Input Format
The first line contains an integer,
, denoting the total number of genes.
The second line contains
space-separated strings describing the respective values of
(i.e., the elements of
).
The third line contains
space-separated integers describing the respective values of
(i.e., the elements of
).
The fourth line contains an integer,
, denoting the number of strands of DNA to process.
Each of the
subsequent lines describes a DNA strand in the form
start end d
, denoting that the healthy genes for DNA strand
are
and their respective correlated health values are
.
Constraints
the sum of the lengths of all genes and DNA strands
It is guaranteed that each
consists of lowercase English alphabetic letters only (i.e.,
a
to
z
).
Output Format
Print two space-separated integers describing the respective total health of the
unhealthiest
and the
healthiest
strands of DNA.
Sample Input 0
6
a b c aa d b
1 2 3 4 5 6
3
1 5 caaab
0 4 xyz
2 4 bcdybc
Sample Output 0
0 19
Explanation 0
In the diagrams below, the ranges of beneficial genes for a specific DNA on the left are highlighed in
green
and individual instances of beneficial genes on the right are bolded. The total healths of the
strands are:
https://s3.amazonaws.com/hr-assets/0/1487047309-6910fb320f-DNA-health-d1.png
The total health of
caaab
is
.
https://s3.amazonaws.com/hr-assets/0/1487042608-5c723619ca-DNA-health-d2.png
The total health of
xyz
is
, because it contains no beneficial genes.
https://s3.amazonaws.com/hr-assets/0/1487042624-5e3d56e532-DNA-health-d3.png
The total health of
bcdybc
is
.
The unhealthiest DNA strand is
xyz
with a total health of
, and the healthiest DNA strand is
caaab
with a total health of
. Thus, we print
0 19
as our answer.","Use a naive string search for each gene in each DNA strand, resulting in O(n*m*k) time complexity where n is the number of genes, m is the average length of a DNA strand, and k is the average length of a gene.","Precompute all possible substrings of each DNA strand and check if they are in the list of genes, then sum their health values. This requires O(l^2) substring generation for each DNA strand of length l.",Build a suffix tree for all DNA strands and search for the genes within the suffix tree. This approach offers linear time complexity for searching but has a higher initial construction cost.,"Use dynamic programming to store the health values of prefixes of DNA strands, reducing redundant calculations when overlapping genes are present.","Construct an Aho-Corasick automaton from the genes to efficiently find all occurrences in each DNA strand, achieving a time complexity close to O(length of DNA + total length of genes).",,algorithms,"['string matching', 'Aho-Corasick', 'DNA']"
https://www.hackerrank.com/challenges/larrys-array?isFullScreen=true,"Larry has been given a permutation of a sequence of natural numbers incrementing from
as an array.  He must determine whether the array can be sorted using the following operation any number of times:
Choose any
consecutive indices and rotate their elements in such a way that
.
For example, if
:
A
rotate
[
1
,
6
,
5
,
2
,
4
,
3
]
[
6
,
5
,
2
]
[
1
,
5
,
2
,
6
,
4
,
3
]
[
5
,
2
,
6
]
[
1
,
2
,
6
,
5
,
4
,
3
]
[
5
,
4
,
3
]
[
1
,
2
,
6
,
3
,
5
,
4
]
[
6
,
3
,
5
]
[
1
,
2
,
3
,
5
,
6
,
4
]
[
5
,
6
,
4
]
[
1
,
2
,
3
,
4
,
5
,
6
]
YES
On a new line for each test case, print
YES
if
can be fully sorted.  Otherwise, print
NO
.
Function Description
Complete the
larrysArray
function in the editor below.  It must return a string, either
YES
or
NO
.
larrysArray has the following parameter(s):
A
: an array of integers
Input Format
The first line contains an integer
, the number of test cases.
The next
pairs of lines are as follows:
The first line contains an integer
, the length of
.
The next line contains
space-separated integers
.
Constraints
integers that increment by
from
to
Output Format
For each test case, print
YES
if
can be fully sorted.  Otherwise, print
NO
.
Sample Input
3
3
3 1 2
4
1 3 4 2
5
1 2 3 5 4
Sample Output
YES
YES
NO
Explanation
In the explanation below, the subscript of
denotes the number of operations performed.
Test Case 0:
is now sorted, so we print
on a new line.
Test Case 1:
.
.
is now sorted, so we print
on a new line.
Test Case 2:
No sequence of rotations will result in a sorted
. Thus, we print
on a new line.","Check if the array is already sorted in ascending order. If so, return 'YES'. Otherwise, return 'NO'.","Count the number of inversions in the array. If the count is even, return 'YES'; otherwise, return 'NO'.","Sort the array using a standard sorting algorithm like quicksort and compare it with the original array. Return 'YES' if they are identical; otherwise, return 'NO'.","Simulate all possible rotations of subarrays of size 3. If the array can be sorted after a finite number of rotations, return 'YES'. Otherwise, return 'NO'.","Calculate the number of inversions in the array. If the number of inversions is even, the array can be sorted; return 'YES'. Otherwise, return 'NO'.",,algorithms,"['array', 'sorting', 'inversions']"
https://www.hackerrank.com/challenges/deforestation-1?isFullScreen=true,"Alice and Bob are playing a game with a rooted tree. The tree has
vertices and the first node,
, is always the root. Here are the basic rules:
They move in alternating turns, and both players always move optimally.
During each move, a player removes an edge from the tree, disconnecting one of its leaves or branches. The leaf or branch that was disconnected from the rooted tree is removed from the game.
The first player to be unable to make a move loses the game.
Alice always makes the first move.
For example, the diagram below shows a tree of size
, where the root is node
:
https://s3.amazonaws.com/hr-challenge-images/19585/1463178479-7f173f4eeb-tree-initial.png
Now, if a player removes the edge between
and
, then nodes
and
become disconnected from the root and are removed from the game:
https://s3.amazonaws.com/hr-challenge-images/19585/1463178803-d8fdcb21e9-tree-removed.png
Given the structure of the tree, determine and print the winner of the game. If Alice wins, print
; otherwise print
.
Input Format
The first line contains a single integer,
, denoting the number of test cases.
For each test case, the first line contains an integer,
, denoting the number of nodes in the tree.
Each of the
subsequent lines contains
space-separated integers,
and
, defining an edge connecting nodes
and
.
Constraints
Output Format
For each test case, print the name of the winner (i.e.,
or
) on a new line.
Sample Input
1
5
1 2
3 1
3 4
4 5
Sample Output
Alice
Explanation
Test Case 0:
Alice removes the edge connecting node
to node
, effectively
trimming
nodes
and
from the tree. Now the only remaining edges are
and
. Because Bob can't remove both of them, Alice will make the last possible move. Because the last player to move wins, we print
on a new line.",Bob,The winner depends on the tree's diameter; Alice wins if the diameter is even.,The winner is determined by the parity of the number of edges; Alice wins if odd.,The winner depends on whether the tree is a complete binary tree; Alice wins if it is.,Alice,,algorithms,"['game theory', 'tree', 'graph']"
https://www.hackerrank.com/challenges/the-story-of-a-tree?isFullScreen=true,"One day Bob drew a
tree
,
, with
nodes and
edges on a piece of paper. He soon discovered that parent of a node depends on the root of the tree. The following images shows an example of that:
https://s3.amazonaws.com/hr-assets/0/1487245443-a6966b94d1-treestory.png
Learning the fact, Bob invented an exciting new game and decided to play it with Alice. The rules of the game is described below:
Bob picks a random node to be the tree's
root
and keeps the identity of the chosen node a secret from Alice. Each node has an equal probability of being picked as the root.
Alice then makes a list of
guesses, where each guess is in the form
u v
and means Alice guesses that
is
true
. It's guaranteed that an undirected edge connecting
and
exists in the tree.
For each correct guess, Alice earns one point. Alice wins the game if she earns at least
points (i.e., at least
of her guesses were
true
).
Alice and Bob play
games. Given the tree, Alice's guesses, and the value of
for each game, find the probability that Alice will win the game and print it on a new line as a reduced fraction in the format
p/q
.
Input Format
The first line contains an integer,
, denoting the number of different games. The subsequent lines describe each game in the following format:
The first line contains an integer,
, denoting the number of nodes in the tree.
The
subsequent lines contain two space-separated integers,
and
, defining an undirected edge between nodes
and
.
The next line contains two space-separated integers describing the respective values of
(the number of guesses) and
(the minimum score needed to win).
Each of the
subsequent lines contains two space-separated integers,
and
, indicating Alice guesses
.
Constraints
The sum of
over all test cases won't exceed
.
No two guesses will be identical.
Scoring
For
of the maximum score,
.
For
of the maximum score,
.
Output Format
Print the probability as a reduced fraction in the format
p/q
.
Note:
Print
0/1
if the probability is
and print
1/1
if the probability is
.
Sample Input 0
2
4
1 2
1 3
3 4
2 2
1 2
3 4
3
1 2
1 3
2 2
1 2
1 3
Sample Output 0
1/2
1/3
Explanation 0
Alice and Bob play the following
games:
Alice makes two guesses,
and
, meaning she guessed that
and
. To win the game, at least
of her guesses must be
true
.
In the diagrams below, you can see that at least
guesses are
true
if the root of the tree is either node
or
:
https://s3.amazonaws.com/hr-assets/0/1486614711-58d384d3f6-treestory.png
There are
nodes in total and the probability of picking node
or
as the root is
, which reduces to
.
In this game, Alice only wins if node
is the root of the tree. There are
nodes in total, and the probability of picking node
as the root is
.",Depth-First Search (DFS) to enumerate all possible root nodes and count wins,Breadth-First Search (BFS) to traverse the tree and determine parent-child relationships for each root,Using a disjoint set data structure to determine connected components and check if guesses are valid,Pre-calculate all possible parent-child relationships for every node pair before processing guesses,"For each possible root, perform a DFS/BFS to determine parent-child relationships and evaluate Alice's guesses",,algorithms,"['graph', 'tree', 'probability']"
https://www.hackerrank.com/challenges/hexagonal-grid?isFullScreen=true,"You are given a hexagonal grid consisting of two rows, each row consisting of
cells. The cells of the first row are labelled
and the cells of the second row are labelled
.
For example, for
:
https://s3.amazonaws.com/hr-assets/0/1495564532-9e16e289ea-3.png
(Note that the
is connected with
.)
Your task is to tile this grid with
tiles
that look like the following:
https://s3.amazonaws.com/hr-assets/0/1495564517-f725e11e0b-1.png
As you can see above, there are three possible orientations in which a tile can be placed.
Your goal is to tile the whole grid such that every cell is covered by a tile, and no two tiles occupy the same cell. To add to the woes, certain cells of the hexagonal grid are
blackened
. No tile must occupy a blackened cell.
Is it possible to tile the grid?
Here's an example. Suppose we want to tile this grid:
https://s3.amazonaws.com/hr-assets/0/1495564538-9a59a63208-4.png
Then we can do the tiling as follows:
https://s3.amazonaws.com/hr-assets/0/1495564526-f0c430b796-2.png
Input Format
The first line contains a single integer
, the number of test cases.
The first line of each test case contains a single integer
denoting the length of the grid.
The second line contains a binary string of length
. The
character describes whether cell
is blackened.
The third line contains a binary string of length
. The
character describes whether cell
is blackened.
A
0
corresponds to an empty cell and a
1
corresponds to blackened cell.
Constraints
Output Format
For each test case, print
YES
if there exists at least one way to tile the grid, and
NO
otherwise.
Sample Input 0
6
6
010000
000010
2
00
00
2
00
10
2
00
01
2
00
11
2
10
00
Sample Output 0
YES
YES
NO
NO
YES
NO
Explanation 0
The first test case in the sample input describes the example given in the problem statement above.
For the second test case, there are two ways to fill it: either place two diagonal tiles side-by-side or place two horizontal tiles.","A dynamic programming approach will always yield the optimal tiling, but might not be feasible within time constraints for large N.","A greedy algorithm that attempts to place tiles from left to right, backtracking when a dead end is reached, is guaranteed to find a solution if one exists.",Checking if the total number of free cells is divisible by 3 is a sufficient condition to guarantee a valid tiling.,"If the blackened cells form a contiguous block larger than 2 cells, it's always impossible to tile the grid.","If there exists a configuration where at least one of the rows has two consecutive blackened cells, and the cells directly above or below are also blackened (forming a 2x2 block), it is impossible to tile",,algorithms,"['tiling', 'grid', 'combinatorics']"
https://www.hackerrank.com/challenges/toll-cost-digits?isFullScreen=true,"The mayor of Farzville is studying the city's road system to find ways of improving its traffic conditions. Farzville's road system consists of
junctions connected by
bidirectional toll roads, where the
toll road connects junctions
and
. In addition, some junctions may not be reachable from others and there may be multiple roads connecting the same pair of junctions.
Each toll road has a toll rate that's paid each time it's used. This rate varies depending on the direction of travel:
If traveling from
to
, then the toll rate is
.
If traveling from
to
, then the toll rate is
. It is guaranteed that
.
https://s3.amazonaws.com/hr-challenge-images/0/1484787161-bee88db398-tollroads.png
For each digit
, the mayor wants to find the number of ordered pairs of
junctions such that
and a path exists from
to
where the total cost of the tolls (i.e., the sum of all toll rates on the path) ends in digit
. Given a map of Farzville, can you help the mayor answer this question? For each digit
from
to
, print the the number of valid ordered pairs on a new line.
Note
: Each toll road can be traversed an unlimited number of times in either direction.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of junctions) and
(the number of roads).
Each line
of the
subsequent lines describes a toll road in the form of three space-separated integers,
,
, and
.
Constraints
Output Format
Print ten lines of output. Each line
(where
) must contain a single integer denoting the answer for
. For example, the first line must contain the answer for
, the second line must contain the answer for
, and so on.
Sample Input 0
3 3
1 3 602
1 2 256
2 3 411
Sample Output 0
0
2
1
1
2
0
2
1
1
2
Explanation 0
The table below depicts the distinct pairs of junctions for each
:
Note the following:
There may be multiple paths between each pair of junctions.
Junctions and roads may be traversed multiple times. For example, the path
is also valid, and it has total cost of
.
An ordered pair can be counted for more than one
. For example, the pair
is counted for
and
.
Each ordered pair must only be counted once for each
. For example, the paths
and
both have total costs that end in
, but the pair
is only counted once.",Prim's Algorithm,Dijkstra's Algorithm,Topological Sort,Bellman-Ford Algorithm,Floyd-Warshall Algorithm,,algorithms,"['graph theory', 'all pairs shortest path', 'dynamic programming']"
https://www.hackerrank.com/challenges/richie-rich?isFullScreen=true,"Palindromes are strings that read the same from the left or right, for example
madam
or
0110
.
You will be given a string representation of a number and a maximum number of changes you can make.  Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes.  The length of the string may not be altered, so you must consider
's left of all higher digits in your tests.  For example
is valid,
is not.
Given a string representing the starting number, and a maximum number of changes allowed, create the largest palindromic string of digits possible or the string '-1' if it is not possible to create a palindrome under the contstraints.
Example
Make
replacements to get
.
Make
replacement to get
.
Function Description
Complete the
highestValuePalindrome
function in the editor below.
highestValuePalindrome has the following parameter(s):
string s:
a string representation of an integer
int n:
the length of the integer string
int k:
the maximum number of changes allowed
Returns
string:
a string representation of the highest value achievable or
-1
Input Format
The first line contains two space-separated integers,
and
, the number of digits in the number and the maximum number of changes allowed.
The second line contains an
-digit string of numbers.
Constraints
Each character
in the number is an integer where
.
Output Format
Sample Input 0
STDIN   Function
-----   --------
4 1     n = 4, k = 1
3943    s = '3943'
Sample Output 0
3993
Sample Input 1
6 3
092282
Sample Output 1
992299
Sample Input 2
4 1
0011
Sample Output 2
-1
Explanation
Sample 0
There are two ways to make
a palindrome by changing no more than
digits:","Prioritize changing differing digits to 9 if 'k' allows, then make remaining differing digits equal using remaining 'k'. If 'k' becomes negative, return '-1'.","Iterate from the ends, always setting mismatched digits to the larger of the two, decrementing 'k'. After making it a palindrome, greedily set all digits to '9' until 'k' is exhausted.","Compare characters from the start and end. If they are different, and k > 0, change both to the larger digit and decrement k. If characters are same, do nothing.","If n is even, divide n by 2. For the first half of string s, check how many digits are required to make palindrome. If required digit is greater than k, return -1. Else, construct the palindrome.","Iterate inward from the ends. If digits differ, change both to the larger value and decrement 'k'. After forming a palindrome, greedily change digits to '9' if 'k' permits, prioritizing the center digit if 'n' is odd.",,algorithms,"['palindrome', 'greedy algorithm', 'string manipulation']"
https://www.hackerrank.com/challenges/two-two?isFullScreen=true,"Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2.
One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index
i
to index
j
(i<=j) and asked them to find their strength.
The strength of the group of students from i to j is defined as:
strength(i , j)
{
    if a[i] = 0
        return 0; //If first child has value 0 in the group, strength of group is zero
    value = 0;
    for k from i to j
        value = value*10 + a[k]
    return value;
}
Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof.
Input Format
First line contains number of test cases T
Next T line contains the numbers of number plates the students were having when standing in the row in the form of a string A.
Constraints
1 ≤
T
≤ 100
1 ≤
len(A)
≤ 10
5
0 ≤
A[i]
≤ 9
Output Format
Output the total number of strengths of the form 2
x
such that 0 ≤ x ≤ 800.
Sample Input 0
5
2222222
24256
65536
023223
33579
Sample Output 0
7
4
1
4
0
Explanation 0
In following explanations group i-j is group of student from index i to index j (1-based indexing)
In first case only 2 is of form power of two. It is present seven times for groups 1-1,2-2,3-3,4-4,5-5,6-6,7-7
In second case 2,4 and 256 are of required form. 2 is strength of group 1-1 and 3-3, 4 is strength of group 2-2 and 256 is strength of group 3-5.
In third case 65536 is only number in required form. It is strength of group 1-5
In fourth case 2 and 32 are of forms power of 2. Group 1-2 has values 0,2 but its strength is 0, as first value is 0.
In fifth case, None of the group has strength of required form.","Use dynamic programming to store results of subproblems involving powers of 2, optimizing search.",Precompute all powers of 2 up to a limit and use a sliding window to efficiently calculate substrings.,"Brute force all substrings and convert them to integers, checking each against a precomputed list of powers of 2.",Use a trie data structure to store powers of 2 as strings for efficient prefix matching against substrings.,"Iterate through all substrings, converting them to integers and checking if they exist in a pre-calculated set of powers of 2.",,algorithms,"['string manipulation', 'powers of 2', 'substring']"
https://www.hackerrank.com/challenges/play-game?isFullScreen=true,"You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.
As an example, bricks are numbered
.  You can remove either
,
or
.  For your friend, your moves would leave the options of
to
elements from
leaving
for you (total score =
),
or
.  In this case, it will never be optimal for your friend to take fewer than the maximum available number of elements.  Your maximum possible score is
, achievable two ways:
first move and
the second, or
in your first move.
Function Description
Complete the
bricksGame
function in the editor below.  It should return an integer that represents your maximum possible score.
bricksGame has the following parameter(s):
arr
:  an array of integers
Input Format
The first line will contain an integer
, the number of test cases.
Each of the next
pairs of lines are in the following format:
The first line contains an integer
, the number of bricks in
.
The next line contains
space-separated integers $arr[i].
Constraints
Output Format
For each test case, print a single line containing your maximum score.
Sample Input
2
5
999 1 1 1 0
5
0 1 1 1 999
Sample Output
1001
999
Explanation
In first test case, you will pick 999,1,1. If you play in any other way, you will not get a score of 1001.
In second case, best option will be to pick up the first brick (with 0 score) at first. Then your friend  will choose the next three blocks, and you will get the last brick.","Use a greedy approach, always choosing the maximum of the next 1, 2, or 3 bricks","Calculate the sum of all bricks and divide by 2, assuming optimal play leads to an even split",Calculate all possible game outcomes using recursion and return the highest score,"Apply dynamic programming, storing the maximum scores achievable for subproblems of smaller brick stacks, starting from the bottom","Apply dynamic programming, storing the maximum scores achievable for subproblems of smaller brick stacks, starting from the top",,algorithms,"['dynamic programming', 'game theory', 'optimization']"
https://www.hackerrank.com/challenges/cipher?isFullScreen=true,"Jack and Daniel are friends.  They want to encrypt their conversations so that they can save themselves from interception by a detective agency so they invent a new cipher.
Every message is encoded to its binary representation. Then it is written down
times, shifted by
bits. Each of the columns is
XOR
ed together to get the final encoded string.
If
and
it looks like so:
1001011     shift 0
01001011    shift 1
001001011   shift 2
0001001011  shift 3
----------
1110101001  <- XORed/encoded string s
Now we have to decode the message.  We know that
.  The first digit in
so our output string is going to start with
.  The next two digits are also
, so they must have been XORed with
.  We know the first digit of our
shifted string is a
as well.  Since the
digit of
is
, we XOR that with our
and now know there is a
in the
position of the original string.  Continue with that logic until the end.
Then the encoded message
and the key
are sent to Daniel.
Jack is using this encoding algorithm and asks Daniel to implement a decoding algorithm.
Can you help Daniel implement this?
Function Description
Complete the
cipher
function in the editor below.  It should return the decoded string.
cipher has the following parameter(s):
k
: an integer that represents the number of times the string is shifted
s
: an encoded string of binary digits
Input Format
The first line contains two integers
and
, the length of the original decoded string and the number of shifts.
The second line contains the encoded string
consisting of
ones and zeros.
Constraints
It is guaranteed that
is valid.
Output Format
Return the decoded message of length
, consisting of ones and zeros.
Sample Input 0
7 4
1110100110
Sample Output 0
1001010
Explanation 0
1001010
 1001010
  1001010
   1001010
----------
1110100110
Sample Input 1
6 2
1110001
Sample Output 1
101111
Explanation 1
101111
 101111
-------
1110001
Sample Input 2
10 3
1110011011
Sample Output 2
10000101
Explanation 2
10000101
010000101
0010000101
1110011011",Perform XOR operation on the encoded string 's' directly without any shifting based on 'k'.,Concatenate 'k' copies of the encoded string 's' and then XOR each digit.,"Generate all possible binary strings of length 'n' and check which one, when encoded, matches 's'.","Return the encoded string 's' as is, as it is assumed to be the decoded message.","Iterate through the encoded string, XORing the current bit with the previous 'k-1' decoded bits to find the next decoded bit.",,algorithms,"['string manipulation', 'XOR', 'decoding']"
https://www.hackerrank.com/challenges/prime-xor?isFullScreen=true,"Penny has an array of
integers,
. She wants to find the number of unique
multisets
she can form using elements from the array such that the
bitwise XOR
of all the elements of the multiset is a
prime number
. Recall that a
multiset
is a set which can contain duplicate elements.
Given
queries where each query consists of an array of integers, can you help Penny find and print the number of valid multisets for each array? As these values can be quite large, modulo each answer by
before printing it on a new line.
Input Format
The first line contains a single integer,
, denoting the number of queries. The
subsequent lines describe each query in the following format:
The first line contains a single integer,
, denoting the number of integers in the array.
The second line contains
space-separated integers describing the respective values of
.
Constraints
Output Format
On a new line for each query, print a single integer denoting the number of unique multisets Penny can construct using numbers from the array such that the bitwise XOR of all the multiset's elements is prime. As this value is quite large, your answer must be modulo
.
Sample Input
1
3
3511 3671 4153
Sample Output
4
Explanation
The valid multisets are:
is prime.
is prime.
is prime.
, which is prime.
Because there are four valid multisets, we print the value of
on a new line.","Calculate the XOR sum of all possible subsets and count the primes, without accounting for duplicates.","Generate all possible subsets, calculate the XOR sum, and use a primality test that incorrectly handles edge cases.",Calculate the XOR sum for each element in the array independently and count the number of those that are prime.,"Compute the XOR sum of all elements, determine if it's prime, and return 1 if it is, 0 otherwise.","Use dynamic programming to count the number of multisets with a given XOR sum, then sum the counts for prime XOR sums, all modulo 1000000007.",,algorithms,"['dynamic programming', 'bitwise XOR', 'prime numbers']"
https://www.hackerrank.com/challenges/dfs-edges?isFullScreen=true,"Let
be a connected, directed graph with vertices numbered from
to
such that any vertex is reachable from vertex
. In addition, any two distinct vertices,
and
, are connected by
at most
one edge
.
Consider the standard
DFS
(Depth-First Search) algorithm starting from vertex
. As every vertex is reachable, each edge
of
is classified by the algorithm into one of four groups:
tree edge
: If
was discovered for the first time when we traversed
.
back edge
: If
was already on the stack when we tried to traverse
.
forward edge
: If
was already discovered
while
was on the stack.
cross edge
: Any edge that is not a
tree
,
back
, or
forward
edge.
To better understand this, consider the following C++ pseudocode:
// initially false
bool
discovered
[
n
];
// initially false
bool
finished
[
n
];
vector
<
int
>
g
[
n
];
void
dfs
(
int
u
)
{
// u is on the stack now
discovered
[
u
]
=
true
;
for
(
int
v
:
g
[
u
])
{
if
(
finished
[
v
])
{
// forward edge if u was on the stack when v was discovered
// cross edge otherwise
continue
;
}
if
(
discovered
[
v
])
{
// back edge
continue
;
}
// tree edge
dfs
(
v
);
}
finished
[
u
]
=
true
;
// u is no longer on the stack
}
Given four integers,
,
,
, and
, construct any graph
having exactly
tree edges
, exactly
back edges
, exactly
forward edges
, and exactly
cross edges
. Then print
according to the
Output Format
specified below.
Input Format
A single line of four space-separated integers describing the respective values of
,
,
, and
.
Constraints
Output Format
If there is no such graph
, print
-1
; otherwise print the following:
The first line must contain an integer,
, denoting the number of vertices in
.
Each line
of the
subsequent lines must contain the following space-separated integers:
The first integer is the
outdegree
,
, of vertex
.
This is followed by
distinct numbers,
, denoting edges from
to
for
. The order of each
should be the order in which a
DFS
considers edges.
Sample Input 0
3 1 1 1
Sample Output 0
4
3 2 4 3
1 3
1 1
1 2
Explanation 0
The
DFS
traversal order is:
. Thus,
,
and
are
tree edges
;
is a
back edge
;
is a
forward edge
; and
is a
cross edge
. This is demonstrated by the diagram below, in which
tree edges
are black,
forward edges
are blue,
back edges
are red, and
cross edges
are green.
https://s3.amazonaws.com/hr-challenge-images/15582/1465398069-e9edb708d5-pic.png
Sample Input 1
1 10 20 30
Sample Output 1
-1
Explanation 1
No such graph exists satisfying the given values.",The number of vertices must be at least the number of tree edges.,The sum of edges must be less than or equal to the square of the number of vertices.,A valid graph can always be constructed if the sum of all edge types is less than or equal to a predetermined constant.,The number of back edges cannot exceed the number of vertices minus 1.,"No graph can be constructed if T + B + F + C > V * (V - 1), where T = tree edges, B = back edges, F = forward edges, C = cross edges and V = vertices which satisfies V = T + 1.",,algorithms,"['graph theory', 'depth-first search', 'edge classification']"
https://www.hackerrank.com/challenges/minimum-mst-graph?isFullScreen=true,"Allison loves graph theory and just started learning about
Minimum Spanning Trees(MST)
. She has three integers,
,
, and
, and uses them to construct a graph with the following properties:
The graph has
nodes and
undirected edges where
each edge has a positive integer length
.
No edge may directly connect a node to itself, and each pair of nodes can only be directly connected by
at most
one edge.
The graph is
connected
, meaning each node is reachable from any other node.
The
value
of the minimum spanning tree is
. Value of the MST is the sum of all the lengths of all edges of which are part of the tree.
The sum of the lengths of all edges is as small as possible.
For example, let's say
,
and
. We need to construct a graph with
nodes and
edges. The value of minimum spanning tree must be
. The diagram belows shows a way to construct such a graph while keeping the lengths of all edges is as small as possible:
https://s3.amazonaws.com/hr-assets/0/1487251853-4d9507b76b-minmst6.png
Here the sum of lengths of all edges is
.
Given
,
, and
for
graphs satisfying the conditions above, find and print the minimum sum of the lengths of all the edges in each graph on a new line.
Note:
It is guaranteed that, for all given combinations of
,
, and
, we can construct a valid graph.
Input Format
The first line contains an integer,
, denoting the number of graphs.
Each of the
subsequent lines contains three space-separated integers describing the respective values of
(the number of nodes in the graph),
(the number of edges in the graph), and
(the value of the MST graph).
Constraints
For
of the maximum score:
For
of the maximum score:
For
of the maximum score:
For
of the maximum score:
Output Format
For each graph, print an integer on a new line denoting the minimum sum of the lengths of all edges in a graph satisfying the given conditions.
Sample Input
2
4 5 4
4 3 6
Sample Output
7
6
Explanation
Graph
:
The answer for this sample is already explained the problem statement.
Graph
:
We must construct a graph with
nodes,
edges, and an MST value of
. Recall that a connected graph with
nodes and
edges is already a tree, so the MST will contain all
edges and the total length of all the edges of the graph will be equal to the value of the minimum spanning tree. So the answer is
.","The minimum sum is always the product of N, E, and W.",The minimum sum is always equal to W because the MST is a subgraph of the original graph.,Calculate (N-1) edges with weight 1 and distribute the remaining MST weight (W - (N-1)) evenly across the remaining edges.,The minimum sum is always N + E + W.,"Since the MST has weight W, the remaining (E - (N-1)) edges must have the smallest possible weights to minimize the sum. Assign weight 1 to the edges in MST and distribute the remaining weight such that the other edges have a minimal weight.",,algorithms,"['graph theory', 'minimum spanning tree', 'optimization']"
https://www.hackerrank.com/challenges/taras-beautiful-permutations?isFullScreen=true,"Tara has an array,
, consisting of
integers where each integer occurs
at most
times in the array.
Let's define
to be a permutation of
where
is the
element of permutation
. Tara thinks a permutation is
beautiful
if there is no index
such that
where
.
You are given
queries where each query consists of some array
. For each
, help Tara count the number of possible beautiful permutations of the
integers in
and print the count, modulo
, on a new line.
Note:
Two permutations,
and
, are considered to be
different
if and only if there exists an index
such that
and
.
Input Format
The first line contains a single integer,
, denoting the number of queries. The
subsequent lines describe each query in the following form:
The first line contains an integer,
, denoting the number of elements in array
.
The second line contains
space-separated integers describing the respective values of
in array
.
Constraints
Each integer in
can occur at most
times.
For
of the maximum score:
The sum of
over all queries does not exceed
.
For
of the maximum score:
Output Format
For each query, print the the number of possible beautiful permutations, modulo
, on a new line.
Sample Input 0
3
3
1 1 2
2
1 2
4
1 2 2 1
Sample Output 0
1
2
2
Explanation 0
We perform the following
queries:
Array
and there is only one good permutation:
https://s3.amazonaws.com/hr-challenge-images/0/1480502972-20eb64775c-permutation.png
Thus, we print the result of
on a new line.
Array
and there are two good permutations:
https://s3.amazonaws.com/hr-challenge-images/0/1480503066-b255a1ccba-permutation1.png
Thus, we print the result of
on a new line.
Array
and there are two good permutations:
https://s3.amazonaws.com/hr-challenge-images/0/1480503152-66c4e83c09-permutation2.png
For demonstration purposes, the following two permutations are invalid (i.e., not good):
https://s3.amazonaws.com/hr-challenge-images/0/1480503201-05b69d00e0-permutation3.png
Because we only want the number of good permutations, we print the result of
on a new line.","Solve using dynamic programming, memoizing intermediate results of subproblems.",Approximate the solution using a Monte Carlo method with random permutation generation.,Generate all permutations and filter the beautiful ones; count these modulo 1000000007.,Apply inclusion-exclusion principle considering fixed points in permutations.,Use derangements formula with adjustments for repeated elements.,,algorithms,"['derangement', 'permutation', 'inclusion-exclusion']"
https://www.hackerrank.com/challenges/lilys-homework?isFullScreen=true,"Whenever George asks Lily to hang out, she's busy doing homework. George wants to help her finish it faster, but he's in over his head! Can you help George understand Lily's homework so she can hang out with him?
Consider an array of
distinct integers,
. George can swap any two elements of the array any number of times. An array is
beautiful
if the sum of
among
is minimal.
Given the array
, determine and return the minimum number of swaps that should be performed in order to make the array
beautiful
.
Example
One minimal array is
.  To get there, George performed the following swaps:
Swap      Result
          [7, 15, 12, 3]
    3 7   [3, 15, 12, 7]
    7 15  [3, 7, 12, 15]
It took
swaps to make the array beautiful. This is minimal among the choices of beautiful arrays possible.
Function Description
Complete the
lilysHomework
function in the editor below.
lilysHomework has the following parameter(s):
int arr[n]:
an integer array
Returns
int:
the minimum number of swaps required
Input Format
The first line contains a single integer,
, the number of elements in
.
The second line contains
space-separated integers,
.
Constraints
Sample Input
STDIN       Function
-----       --------
4           arr[]size n = 4
2 5 3 1     arr = [2, 5, 3, 1]
Sample Output
2
Explanation
Define
to be the beautiful reordering of
.  The sum of the absolute values of differences between its adjacent elements is minimal among all permutations and only two swaps (
with
and then
with
) were performed.",Perform a bubble sort and count the swaps made during the sorting process,"Sort the array and its reverse, calculate swaps for each, and return the maximum value","Sort the array, then iterate and count mismatches with the original array's indices",Use a selection sort algorithm and count the number of swaps done,"Sort the array and its reversed counterpart, calculate swaps for each to their ideal sorted positions, and return the minimum value",,algorithms,"['sorting', 'array manipulation', 'swaps']"
https://www.hackerrank.com/challenges/extra-long-factorials?isFullScreen=true,"The
factorial
of the integer
, written
, is defined as:
Calculate and print the factorial of a given integer.
For example, if
, we calculate
and get
.
Function Description
Complete the
extraLongFactorials
function in the editor below.  It should print the result and return.
extraLongFactorials has the following parameter(s):
n
: an integer
Note:
Factorials of
can't be stored even in a
long long variable. Big integers must be used for such calculations. Languages like Java, Python, Ruby etc. can handle big integers, but we need to write additional code in C/C++ to handle huge values.
We recommend solving this challenge using BigIntegers.
Input Format
Input consists of a single integer
Constraints
Output Format
Print the factorial of
.
Sample Input
Sample Output
Explanation",Use recursion and a standard integer data type,Use a fixed-size array to store intermediate results and handle overflows,Employ floating-point arithmetic to approximate the factorial,"Return 0, as the factorial is too large to compute",Use a BigInteger data type or implement arbitrary-precision arithmetic,,algorithms,"['factorial', 'big integer', 'arbitrary-precision arithmetic']"
https://www.hackerrank.com/challenges/tbsp?isFullScreen=true,"Quality Blimps Inc. is looking to expand their sales to other cities (
), so they hired you as a salesman to fly to other cities to sell blimps. Blimps can be expensive to travel with, so you will need to determine how many blimps to take along with you on each trip and when to return to headquarters to get more. Quality Blimps has an unlimited supply of blimps.
You will be able to sell only one blimp in each city you visit, but you do not need to visit every city, since some have expensive travel costs. Each city has an initial price that blimps sell for, but this goes down by a certain percentage as more blimps are sold (and the novelty wears off). Find a good route that will maximize profits.
Details
Blimp Decline
- The blimps will decline (
) in price every time you visit
of the cities (the number of cities will always be a multiple of
). For example, if
is
and there are
cities, then for every city you visit (except headquarters), the price of blimps will be multiplied by
. So after
visits, every city's blimp price will be about
of the initial value (
).
Note that if the price declines after you visit some city, then it will only happen
after
you made the sale on that city, so your sale on that city will not be affected. In particular, each blimp you sell in the first
of the cities will always be sold at their corresponding city's initial price.
Input Format
The first line of input for each test case will contain three parameters:
number of cities (
)
blimp cost per mile (
)
blimp factor of decline (
)
This will be followed by
lines, which will each contain three integers
, the city location (x and y coordinates the grid, in miles) and the initial blimp sales price, respectively.
Constraints
The city locations will be distinct
Output Format
On each line, output the x and y coordinates of the next city you are visiting. When leaving the headquarters, also output the number of blimps you are taking with you for that part of the trip. You do not need to return to headquarters when you finish your sales.
You can only visit each city at most once.
Sample Input
10 3 0.95
1 1 30
2 2 35
0 8 50
7 2 20
7 3 25
10 7 90
9 8 35
5 15 10
8 18 15
1 9 60
Sample Output
1 1 2
2 2
0 0
10 7 2
9 8
0 0
0 8 2
1 9
Explanation
The salesman first travels a distance of √2 dollars to (1,1) carrying 2 blimps. This will cost him √2 dollars for his own travel and 6√2 dollars for the 2 blimps. He will then earn 30 dollars selling 1 blimp. He then continues to (2,2) with only 1 blimp, which will cost him 1√2 dollars for his travel and 3√2 dollars for his blimp. He will then earn 33.25 dollars selling the blimp, since the prices have declined by 5%. After his return to HQ (a distance of 2√2) he will have earned an approximate profit of 44.87 dollars.
Scoring
The goal of this challenge is to achieve the maximum profit on each test case. Your profits for each test case will be:
Total Blimp Sales - Total Travel Costs
You will receive a score for each test case based on the ratio of your profit to the estimated maximum profit. Your total score for this challenge will be a weighted sum of your scores for each test case.
If your profit is negative, you'll receive a zero score.","Always visit the city with the highest initial price, regardless of distance or decline factor.",Sort cities by distance from headquarters and visit them in that order to minimize travel costs.,Calculate the shortest path visiting all cities once (Traveling Salesman Problem) and use that route.,Prioritize cities with lower coordinates to reduce potential mileage.,"Dynamically program the optimal route and number of blimps to maximize profit, considering price decline and travel costs.",,algorithms,"['dynamic programming', 'optimization', 'greedy algorithm']"
https://www.hackerrank.com/challenges/construct-the-array?isFullScreen=true,"Your goal is to find the number of ways to construct an array such that consecutive positions contain different values.
Specifically, we want to construct an array with
elements such that each element between
and
, inclusive. We also want the first and last elements of the array to be
and
.
Given
,
and
, find the number of ways to construct such an array. Since the answer may be large, only find it modulo
.
For example, for
,
,
, there are
ways, as shown here:
https://s3.amazonaws.com/hr-assets/0/1511427084-cd3fbbf0e1-FILLARRAY.png
Complete the function
countArray
which takes input
,
and
. Return the number of ways to construct the array such that consecutive elements are distinct.
Constraints
Subtasks
For
of the maximum score,
and
Sample Input
,
,
Sample Output
Explanation
Refer to the diagram in the challenge statement.",O(1),O(n log n),O(n^2),O(log n),O(n),,algorithms,"['dynamic programming', 'array', 'modulo']"
https://www.hackerrank.com/challenges/bomber-man?isFullScreen=true,"Bomberman
lives in a rectangular grid. Each cell in the grid either contains a bomb or nothing at all.
Each bomb can be planted in any cell of the grid but once planted, it will detonate after
exactly 3 seconds
. Once a bomb detonates, it's destroyed — along with anything in its four neighboring cells. This means that if a bomb detonates in cell
, any valid cells
and
are cleared. If there is a bomb in a neighboring cell, the neighboring bomb is destroyed
without
detonating, so there's no chain reaction.
Bomberman is immune to bombs, so he can move freely throughout the grid. Here's what he does:
Initially, Bomberman arbitrarily plants bombs in some of the cells, the initial state.
After one second, Bomberman does nothing.
After one more second, Bomberman plants bombs in all cells without bombs, thus filling the whole grid with bombs.  No bombs detonate at this point.
After one more second, any bombs planted exactly three seconds ago will detonate. Here, Bomberman stands back and observes.
Bomberman then repeats steps 3 and 4 indefinitely.
Note that during every second Bomberman plants bombs, the bombs are planted simultaneously (i.e.,
at the exact same moment
), and any bombs planted at the same time will detonate at the same time.
Given the initial configuration of the grid with the locations of Bomberman's first batch of planted bombs, determine the state of the grid after
seconds.
For example, if the initial grid looks like:
...
.
O
.
...
it looks the same after the first second.  After the second second, Bomberman has placed all his charges:
OOO
OOO
OOO
At the third second, the bomb in the middle blows up, emptying all surrounding cells:
O
.
O
...
O
.
O
Function Description
Complete the
bomberMan
function in the editory below.
bomberMan has the following parameter(s):
int n:
the number of seconds to simulate
string grid[r]:
an array of strings that represents the grid
Returns
string[r]:
n array of strings that represent the grid in its final state
Input Format
The first line contains three space-separated integers
,
, and
, The number of rows, columns and seconds to simulate.
Each of the next
lines contains a row of the matrix as a single string of
characters.  The
.
character denotes an empty cell, and the
O
character (ascii 79) denotes a bomb.
Constraints
Subtask
for
of the maximum score.
Sample Input
STDIN           Function
-----           --------
6 7 3           r = 6, c = 7, n = 3
.......         grid =['.......', '...O...', '....O..',\
...O...                '.......', 'OO.....', 'OO.....']
....O..
.......
OO.....
OO.....
Sample Output
OOO.OOO
OO...OO
OOO...O
..OO.OO
...OOOO
...OOOO
Explanation
The initial state of the grid is:
.......
...O...
....O..
.......
OO.....
OO.....
Bomberman spends the first second doing nothing, so this is the state after 1 second:
.......
...O...
....O..
.......
OO.....
OO.....
Bomberman plants bombs in all the empty cells during his second second, so this is the state after 2 seconds:
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
In his third second, Bomberman sits back and watches all the bombs he planted 3
seconds ago detonate. This is the final state after
seconds:
OOO.OOO
OO...OO
OOO...O
..OO.OO
...OOOO
...OOOO",The grid will return to its initial state.,The entire grid will be filled with bombs ('O').,The grid will be empty (all '.').,The grid will alternate between two distinct states after the initial 2 seconds.,"The grid will stabilize into a repeating pattern after the initial 2 seconds, either returning to a previous state or oscillating between two states.",,algorithms,"['grid', 'simulation', 'pattern recognition']"
https://www.hackerrank.com/challenges/liars?isFullScreen=true,"You have
N
soldiers numbered from 1 to N. Each of your soldiers is either a liar or a truthful person. You have
M
sets of information about them. Each set of information tells you the number of liars among a certain range of your soldiers. Let
L
be the total number of your liar soldiers. Since you can't find the exact value of L, you want to find the minimum and maximum value of L.
Input Format
The first line of the input contains two integers
N
and
M
.
Each of next
M
lines contains three integers:
A B C
where the set of soldiers numbered as {A, A+1, A+2, ..., B}, exactly C of them are liars. (1 <= Ai <= Bi <= n) and (0 <= Ci <= Bi-Ai).
Note:
N
and
M
are not more than 101, and it is guaranteed the given informations is satisfiable.
Output Format
Print two integers Lmin and Lmax to the output.
Sample Input #1
3 2
1 2 1
2 3 1
Sample Output #1
1 2
Sample Input #2
20 11
3 8 4
1 9 6
1 13 9
5 11 5
4 19 12
8 13 5
4 8 4
7 9 2
10 13 3
7 16 7
14 19 4
Sample Output #2
13 14
Explanation
In the first input, the initial line is ""3 2"", i.e. that there are 3 soldiers and we have 2 sets of information. The next line says there is one liar in the set of soldiers {1, 2}. The final line says there is one liar in the set {2,3}. There are two possibilities for this scenario: Soldiers number 1 and 3 are liars or soldier number 2 is liar.
So the minimum number of liars is 1 and maximum number of liars is 2. Hence the answer, 1 2.","Use a greedy approach, always selecting the option that maximizes the number of liars locally","Solve using dynamic programming, storing the minimum and maximum number of liars for each sub-range","Employ backtracking to explore all possible assignments of liars and truthful persons, pruning branches that violate constraints",Use a linear programming solver to formulate the problem as a set of linear equations and inequalities,Model the problem as a constraint satisfaction problem and use binary search to find the minimum and maximum number of liars,,algorithms,"['constraint satisfaction', 'binary search', 'graph theory']"
https://www.hackerrank.com/challenges/arithmetic-expressions?isFullScreen=true,"5-year-old Shinchan had just started learning mathematics. Meanwhile, one of his studious classmates, Kazama, had already written a basic calculator which supports only three operations on integers:
multiplication
, addition
, and subtraction
.  Since he had just learned about these operations, he didn't know about operator precedence, and so, in his calculator, all operators had the same precedence and were left-associative.
As always, Shinchan started to irritate him with his silly questions. He gave Kazama a list of
integers and asked him to insert one of the above operators between each pair of consecutive integers such that the result obtained after feeding the resulting expression in Kazama's calculator is divisible by
. At his core, Shinchan is actually a good guy, so he only gave lists of integers for which an answer exists.
Can you help Kazama create the required expression? If multiple solutions exist, print any one of them.
Input Format
The first line contains a single integer
denoting the number of elements in the list. The second line contains
space-separated integers
denoting the elements of the list.
Constraints
The length of the output expression should not exceed
.
Output Format
Print a single line containing the required expressoin. You may insert spaces between operators and operands.
Note
You are not allowed to permute the list.
All operators have the same precedence and are left-associative, e.g.,
is interpreted as
Unary plus and minus are not supported, e.g., statements like
,
, or
are invalid.
Sample Input 0
3
22 79 21
Sample Output 0
22*79-21
Explanation 0
Solution 1:
, where
, so it is perfectly divisible by
.
Solution 2:
, which is also divisible by
.
Sample Input 1
5
55 3 45 33 25
Sample Output 1
55+3-45*33-25
Explanation 1
which is divisible by
.",Use dynamic programming to explore all possible operator combinations.,Employ a greedy approach by prioritizing multiplication to maximize divisibility.,Apply a brute-force method by trying every possible combination of operators and checking the result.,Utilize a depth-first search algorithm to explore potential expressions.,Apply dynamic programming with memoization to store intermediate results modulo 'm'.,,algorithms,"['dynamic programming', 'modulo', 'arithmetic']"
https://www.hackerrank.com/challenges/benders-play?isFullScreen=true,"General Iroh and Commandant Bumi are heading to the Republic City to stop a rebellion. But it's quite a long travel, so in the meantime they have started discussing about possible attacking plans. Right now, they're arguing about best ways for moving soldiers during the battle. Tired of not getting a final and concise strategy, Iroh proposed a particularly original idea.
Iroh:
Bumi, look at this map: here we have all possible locations in the battle field soldiers can occupy. I know a game which can give us some ideas.
Bumi:
A game? How will a game help us here?
Iroh:
It's pretty simple, we know which location is connected to each one, and also, that all those paths between locations are one-way (it's too dangerous to have two ways paths), so we place some soldiers at random initial locations, take turns, and in each turn, we try to make a valid move with one soldier from one location to another. Eventually, we won't be able to move any man so, the first one which is not able to perform any valid move, loses. One important thing is, at some moment, we may have some men at the same field location.
Bumi:
Are you sure we are gonna end this? We have so many locations and paths... don't know, soldiers could be moving in circles for ever.
Iroh:
Take it easy man, those paths were built by the best architects I've ever known, so there is no way that could happen.
Bumi:
Well, I still don't get how does this help us.
Iroh:
Me neither, but greatest generals from the Earth Kingdom created their strategies from this game, so, who knows?
Bumi:
Ok, I'm in. Who plays first?
Iroh:
You go first my friend. Just make sure you always do your best, because I will show no mercy to you :).
Input Format
First line in the input contains two integers
N
and
M
, describing the number of locations and paths between them, respectively. M lines follow, each one with two integers
u
and
v
,
denoting a one-way path from u to v
.
Then comes a line with a single integer
Q
, denoting how many times Bumi and Iroh played the game over the given field. Q queries follow each one with two lines, first one with a single integer
K
, the number of soldiers in the field; and second one with K integers b_i separated by space, each one denoting the initial location of some soldier.
Constraints
1 < N <= 10
5
1 <= M <= 10
6
1 <= u, v, b_i <= N
1 <= K <= 10
2
1 <= Q <= 10
5
Output Format
Output Q lines, each one saying
Bumi
if Bumi should be the winner of the corresponding game or
Iroh
otherwise.
Remember that, being both top strategy masters, they will always perform the best possible move each turn.
Sample Input
10 10
1 10
3 10
7 8
6 8
7 4
9 4
7 6
5 8
1 8
2 8
5
4
10 7 6 4
3
1 9 4
3
8 3 5
3
4 9 7
3
7 9 10
Sample Output
Bumi
Iroh
Iroh
Bumi
Bumi",Bumi,The outcome depends on the specific implementation details not provided in the question,The outcome is random due to the random placement of soldiers,It's impossible to determine the winner without executing the game,Iroh,,algorithms,"['graph theory', 'game theory', 'directed acyclic graph']"
https://www.hackerrank.com/challenges/array-construction?isFullScreen=true,"Professor GukiZ has hobby — constructing different arrays. His best student, Nenad, gave him the following task that he just can't manage to solve:
Construct an
-element array,
, where the sum of all elements is equal to
and the sum of absolute differences between each pair of elements is equal to
. All elements in
must be non-negative integers.
If there is more then one such array, you need to find the lexicographically smallest one. In the case no such array
exists, print
.
Note:
An array,
, is considered to be lexicographically smaller than another array,
, if there is an index
such that
and, for any index
,
.
Input Format
The first line contains an integer,
, denoting the number of queries.
Each of the
subsequent lines contains three space-separated integers describing the respective values of
(the number of elements in array
),
(the sum of elements in
), and
(the sum of absolute differences between each pair of elements).
Constraints
Subtasks
For
of the maximum score:
For
of the maximum score:
Output Format
For each query, print
space-separated integers describing the respective elements of the lexicographically smallest array
satisfying the conditions given above. If no such array exists, print
instead.
Sample Input
1
 3 3 4
Sample Output
0 1 2
Explanation
We have
query in which
,
, and
. The lexicographically smallest array is
.
The sum of array
's elements is
The absolute differences between each pair of elements are:
The sum of these absolute differences is
As array
is both lexicographically smallest and satisfies the given conditions, we print its contents on a new line as
0 1 2
.",Backtracking with pruning based on exceeding the sum or absolute difference target.,"Greedy approach, filling the array from left to right with the largest possible values.",Dynamic programming to store intermediate results and avoid redundant calculations.,"Sort the input array non-decreasingly and check if the required conditions are met, if not, print -1.",Iterate through possible lexicographical arrays and check if they satisfy the sum and absolute difference conditions.,,algorithms,"['array construction', 'lexicographical order', 'constraints']"
https://www.hackerrank.com/challenges/brick-tiling?isFullScreen=true,"You are given a grid having N rows and M columns. A grid square can either be blocked or empty. Blocked squares are represented by a '#' and empty squares are represented by '.'. Find the number of ways to tile the grid using L shaped bricks. A L brick has one side of length three units while other of length 2 units. All empty squares in the grid should be covered by exactly one of the L shaped tiles, and blocked squares should not be covered by any tile. The bricks can be used in any orientation (they can be rotated or flipped).
Input Format
The first line contains the number of test cases
T
.
T
test cases follow. Each test case contains
N
and
M
on the first line, followed by
N
lines describing each row of the grid.
Constraints
1 <=
T
<= 50
1 <=
N
<= 20
1 <=
M
<= 8
Each grid square will be either '.' or '#'.
Output Format
Output the number of ways to tile the grid. Output each answer modulo 1000000007.
Sample Input
3
2 4
....
....
3 3
...
.#.
...
2 2
##
##
Sample Output
2
4
1
Explanation
NOTE:
If all points in the grid are blocked the number of ways is 1, as in the last sample testcase.","Use backtracking to explore possible tile placements, pruning branches that lead to overlaps or uncovered squares.",Apply dynamic programming with a state representing the current row and a bitmask indicating the filled columns.,"Employ a greedy algorithm, placing tiles in the first available empty square and continuing until the grid is tiled.",Calculate the number of empty squares and divide by 6 (the number of squares in an L-tile) if it results in an integer then ways to tile is 1 otherwise 0.,Use bitmasking and dynamic programming to represent the state of the grid and calculate the number of tiling arrangements.,,algorithms,"['dynamic programming', 'bitmasking', 'tiling']"
https://www.hackerrank.com/challenges/winning-lottery-ticket?isFullScreen=true,"The SuperBowl Lottery is about to commence, and there are several lottery tickets being sold, and each ticket is identified with a ticket ID. In one of the many winning scenarios in the Superbowl lottery, a winning pair of tickets is:
Concatenation of the two ticket IDs in the pair, in any order, contains each digit from
to
at least once.
For example, if there are
distinct tickets with ticket ID
and
,
is a winning pair.
NOTE: The ticket IDs can be concantenated in any order. Digits in the ticket ID can occur in any order.
Your task is to find the number of winning pairs of distinct tickets, such that concatenation of their ticket IDs (in any order) makes for a winning scenario. Complete the function
winningLotteryTicket
which takes a string array of ticket IDs as input, and return the number of winning pairs.
Input Format
The first line contains
denoting the total number of lottery tickets in the super bowl.
Each of the next
lines contains a string, where string on a
line denotes the ticket id of the
ticket.
Constraints
length of
sum of lengths of all
Each ticket id consists of digits from
Output Format
Print the number of pairs in a new line.
Sample Input 0
5
129300455
5559948277
012334556
56789
123456879
Sample Output 0
5
Explanation 0
Pairs of distinct tickets that make for a winning scenario are :
Ticket ID 1
Ticket ID 2
Winning Pair
Notice that each winning pair has digits from
to
atleast once, and the digits in the ticket ID can be of any order. Thus, the number of winning pairs is
.",Use a nested loop to iterate through all pairs and check each digit's presence by converting concatenated strings to sets.,Create a bitmask for each ticket ID representing the digits present. Iterate through all pairs and bitwise AND the masks.,Precompute all possible winning combinations of digits and then check if each ticket's digits are a subset of these combinations.,Sort the ticket IDs lexicographically and then only check adjacent pairs for winning combinations to reduce complexity.,Create a bitmask for each ticket ID representing the digits present. Iterate through all pairs and bitwise OR the masks.,,algorithms,"['string manipulation', 'bit manipulation', 'combinations']"
https://www.hackerrank.com/challenges/billboards?isFullScreen=true,"ADZEN is a popular advertising firm in your city that owns all
billboard locations on Main street. The city council passed a new zoning ordinance mandating that no more than
consecutive billboards may be up at any given time. For example, if there are
billboards on Main street and
, ADZEN must remove either the middle billboard, the first two billboards, the last two billboards or the first and last billboard.
Being a for-profit company, ADZEN wants to lose as little advertising revenue as possible when removing the billboards. They want to comply with the new ordinance in such a way that the remaining billboards maximize their total revenues (i.e., the sum of  revenues generated by the billboards left standing on Main street).
Given
,
, and the revenue of each of the
billboards, find and print the maximum profit that ADZEN can earn while complying with the zoning ordinance. Assume that Main street is a straight, contiguous block of
billboards that can be removed but
cannot
be reordered in any way.
For example, if there are
billboards, and
is the maximum number of consecutive billboards that can be active, with
, then the maximum revenue that can be generated is
:
.
Function Description
Complete the
billboards
function in the editor below.  It should return an integer that represents the maximum revenue that can be generated under the rules.
billboards has the following parameter(s):
k
: an integer that represents the longest contiguous group of billboards allowed
revenue
: an integer array where each element represents the revenue potential for a billboard at that index
Input Format
The first line contains two space-separated integers,
(the number of billboards) and
(the maximum number of billboards that can stand together on any part of the road).
Each line
of the
subsequent lines contains an integer denoting the revenue value of billboard
(where
).
Constraints
Output Format
Print a single integer denoting the maximum profit ADZEN can earn from Main street after complying with the city's ordinance.
Sample Input 0
6 2 
1
2
3
1
6
10
Sample Output 0
21
Explanation 0
There are
billboards, and we must remove some of them so that no more than
billboards are immediately next to one another.
We remove the first and fourth billboards, which gives us the configuration
_ 2 3 _ 6 10
and a profit of
. As no other configuration has a profit greater than
, we print
as our answer.
Sample Input 1
5 4
1
2
3
4
5
Sample Output 1
14
Explanation 1
There are
billboards, and we must remove some of them so that no more than
billboards are immediately next to one another.
We remove the first billboard, which gives us the configuration
_ 2 3 4 5
and a profit of
. As no other configuration has a profit greater than
, we print
as our answer.","Greedily select billboards with the highest revenue until the constraint is violated, then remove the lowest revenue billboard in the violating range.","Use a sliding window approach, always keeping the window size equal to k, and maximizing revenue within that window.",Calculate the total revenue and subtract the minimum revenue obtained by removing any sequence of billboards that violates the constraint.,"Iterate through all possible subsets of billboards and check if they satisfy the constraint, keeping track of the maximum revenue.","Use dynamic programming to calculate the maximum revenue achievable up to each billboard, considering whether to include or exclude it based on the constraint.",,algorithms,"['dynamic programming', 'optimization', 'constraints']"
https://www.hackerrank.com/challenges/bonetrousle?isFullScreen=true,"Here's a
humerus
joke:
Why did Papyrus the skeleton go to the store by himself? Because he had
no body
to go with him!
Did you like it? Don't worry, I've got a ton more. A skele-
ton
.
Once upon a time, Papyrus the skeleton went to buy some pasta from the store. The store's inventory is
bare-bones
and they only sell one thing — boxes of uncooked spaghetti! The store always stocks exactly
boxes of pasta, and each box is numbered sequentially from
to
. This box number also corresponds to the number of sticks of spaghetti in the box, meaning the first box contains
stick, the second box contains
sticks, the third box contains
sticks, …, and the
box contains
sticks. Because they only stock one box of each kind, the store has a
tendon
-cy to sell out of spaghetti.
During each trip to the store, Papyrus likes to buy exactly
sticks of spaghetti by purchasing exactly
boxes (no more, no less). Not sure
which
boxes to purchase, Papyrus calls
Sherlock Bones
for help but he's also stumped! Do you have the
guts
to solve this puzzle?
Given the values of
,
, and
for
trips to the store, determine which boxes Papyrus must purchase during each trip. For each trip, print a single line of
distinct space-separated integers denoting the box number for each box of spaghetti Papyrus purchases (recall that the store only has
one
box of each kind). If it's not possible to buy
sticks of spaghetti by purchasing
boxes, print
-1
instead.
For example, Papyrus wants to purchase
sticks of spaghetti in
boxes and the store has
different box sizes.  He can buy boxes of sizes
,
,
and other combinations.  Any of the combinations will work.
Function Description
Complete the
bonetrousle
function in the editor below.  It should return an array of integers.
bonetrousle has the following parameter(s):
n
: the integer number of sticks to buy
k
: the integer number of box sizes the store carries
b
: the integer number of boxes to buy
Input Format
The first line contains a single integer
, the number of trips to the store.
Each of the next
lines contains three space-separated integers
,
and
, the number of sticks to buy, the number of boxes for sale and the number of boxes to buy on this trip to the store.
Constraints
Output Format
For each trip to the store:
If there is no solution, print
-1
on a new line.
If there is a solution, print a single line of
distinct space-separated integers where each integer denotes the numbers of noodles in each box that Papyrus must purchase.
If there are multiple possible solutions,
you can print any one of them.
Do not print any leading or trailing spaces or extra newlines.
Sample Input
4
12 8 3
10 3 3
9 10 2
9 10 2
Sample Output
2 3 7
-1
5 4
1 8
Explanation
Papyrus makes the following trips to the store:
He wants to buy exactly
boxes of spaghetti and have a total number of
sticks. During this trip, the store has
boxes of spaghetti sticks where the first box has
stick, the second box has
sticks, the third box has
sticks, and so on. One possible solution would be the following:
https://s3.amazonaws.com/hr-challenge-images/19354/1458231663-6f8f337362-save_me.png
Papyrus can buy the
-stick,
-stick, and
-stick boxes for the total of
sticks.
Note that this is not the only valid solution; other valid solutions are acceptable.
He wants to buy exactly
boxes of spaghetti and have a total number of
sticks. Because the store only has three boxes in stock containing
,
, and
sticks of spaghetti, it's not possible for Papyrus to buy
sticks of spaghetti as buying all three boxes would only yield
sticks (which is less than the
that he wanted to purchase). Thus, we print
-1
on a new line.
The third and fourth trips to the store both contain the same values (
,
,
).  This illustrates that there may be multiple solutions for any given trip to the store and any valid solution is acceptable.",Greedily select the smallest boxes first until the target is reached or exceeded.,Brute-force iterate through all combinations of 'b' boxes to find a combination that sums to 'n'.,Use dynamic programming to build a table of possible sums for each number of boxes.,Return the first 'b' boxes available in the store.,"Check for feasibility based on minimum and maximum possible sums, then construct a valid sequence by adjusting values.",,algorithms,"['combinations', 'sum', 'constraints']"
https://www.hackerrank.com/challenges/newyear-game?isFullScreen=true,"It's New Year's Day, and Balsa and Koca are stuck inside watching the rain. They decide to invent a game, the rules for which are described below.
Given array
containing
integers, they take turns making a single move.
Balsa always moves first, and both players are moving optimally (playing to win and making no mistakes)
.
During each move, the current player chooses one element from
, adds it to their own score, and deletes the element from
; because the size of
decreases by
after each move,
's size will be
after
moves and the game ends (as all elements were deleted from
). We refer to Balsa's score as
and Koca's score as
. Koca wins the game if |
-
| is divisible by
; otherwise Balsa wins.
Given
, determine the winner.
Note:
.
Input Format
The first line contains an integer,
, denoting the number of test cases.
Each test case is comprised of two lines; the first line has an integer
, and the second line has
space-separated integers
describing array
.
Constraints
Subtasks
For
score:
For
score:
Output Format
For each test case, print the winner's name on a single line; if Balsa wins print
Balsa
, otherwise print
Koca
.
Sample Input
2
3
7 6 18
1
3
Sample Output
Balsa
Koca
Explanation
Test Case 1
Array
. The possible play scenarios are:
,
,
, and
.
,
,
, and
.
,
,
-
, and
.
In this case, it doesn't matter what Balsa chooses because the difference between their scores isn't divisible by
. Thus, Balsa wins.
Test Case 2
Array
. Balsa must choose that element, the first move ends the game.
,
,
, and
. Thus, Koca wins.",Balsa,It depends on the initial order of elements; sorting is required.,The problem is unsolvable in polynomial time.,Koca,Balsa,,algorithms,"['game theory', 'arrays', 'optimal strategy']"
https://www.hackerrank.com/challenges/strplay?isFullScreen=true,"Shaka and his brother have created a boring game which is played like this:
They take a word composed of lowercase English letters and try to get the maximum possible score by building exactly 2
palindromic subsequences
. The score obtained is the product of the length of these 2
subsequences
.
Let's say
and
are two subsequences from the initial string. If
&
are the smallest and the largest positions (from the initial word) respectively in
; and
&
are the smallest and the largest positions (from the initial word) respectively in
, then the following statements hold true:
,
, &
.
i.e., the positions of the subsequences should not cross over each other.
Hence the score obtained is the product of lengths of subsequences
&
. Such subsequences can be numerous for a larger initial word, and hence it becomes harder to find out the maximum possible score. Can you help Shaka and his brother find this out?
Input Format
Input contains a word
composed of lowercase English letters in a single line.
Constraints
each character will be a lower case english alphabet.
Output Format
Output the maximum score the boys can get from
.
Sample Input
eeegeeksforskeeggeeks
Sample Output
50
Explanation
A possible optimal solution is
eee
-g-
ee
-ksfor-
skeeggeeks
being
eeeee
the one subsequence and
skeeggeeks
the other one. We can also select
eegee
in place of
eeeee
, as both have the same length.",The square of the number of distinct characters in the string.,The cube of the number of distinct characters in the string.,The product of the length of the string and the number of distinct characters.,The length of the longest palindromic subsequence multiplied by 2.,The square of the number of distinct characters in the string.,,algorithms,"['dynamic programming', 'palindromes', 'string']"
https://www.hackerrank.com/challenges/find-the-seed?isFullScreen=true,"A company needs random numbers for its operation.
random numbers have been generated using
numbers as seeds and the following recurrence formula:
The numbers used as seeds are
.
is the
term of the recurrence.
Due to a failure on the servers, the company lost its seed numbers. Now they just have the recurrence formula and the previously generated
random numbers.
The company wants to recover the numbers used as seeds, so they have hired you for doing this task.
Input Format
The first line contains two space-separated integers,
and
, respectively.
The second line contains the space-separated integers describing
(all these numbers are non-negative integers
).
The third line contains the space-separated coefficients of the recurrence formula,
. All of these coefficients are positive integers
.
Constraints
Output Format
The output must be one line containing the space-separated seeds of the random numbers -
.
Sample Input
2 6
13 8
1 1
Sample Output
1 1
Explanation
This is the classic Fibonacci recurrence. We have the
and
terms, and, of course, the seeds are the numbers
and
.",Solve a system of linear equations using Gaussian elimination.,Apply dynamic programming to reconstruct the seed values from the end.,Use a brute-force approach by trying all possible seed combinations.,Implement a Monte Carlo simulation to approximate the seed values.,Solve the recurrence relation backwards iteratively to find the seed values.,,algorithms,"['recurrence relation', 'linear algebra', 'iteration']"
https://www.hackerrank.com/challenges/build-a-string?isFullScreen=true,"Greg wants to build a string,
of length
. Starting with an empty string, he can perform
operations:
Add a character to the end of
for
dollars.
Copy any substring of
, and then add it to the end of
for
dollars.
Calculate minimum amount of money Greg needs to build
.
Input Format
The first line contains number of testcases
.
The
subsequent lines each describe a test case over
lines:
The first contains
space-separated integers,
,
, and
, respectively.
The second contains
(the string Greg wishes to build).
Constraints
is composed of lowercase letters only.
Output Format
On a single line for each test case, print the minimum cost (as an integer) to build
.
Sample Input
2
9 4 5
aabaacaba
9 8 9
bacbacacb
Sample Output
26
42
Explanation
Test Case 0:
"""";
""
""
Append ""
"";
""
""; cost is
Append ""
"";
""
""; cost is
Append ""
"";
""
""; cost is
Copy and append ""
"";
""
""; cost is
Append ""
"";
""
""; cost is
Copy and append ""
"";
""
""; cost is
Summing each cost, we get
, so our output for
Test Case 1
is
.
Test Case 1:
"""";
""
""
Append ""
"";
""
""; cost is
Append ""
"";
""
""; cost is
Append ""
"";
""
""; cost is
Copy and append ""
"";
""
""; cost is
Copy and append ""
"";
""
""; cost is
Summing each cost, we get
, so our output for
Test Case 2
is
.","Dynamic programming, iterating backwards from the target string, calculating cost based on adding a character vs. copying substrings.","Greedy approach, always choosing the cheapest option between adding a character and copying the longest possible substring at each step.","Using recursion with memoization to explore all possible combinations of adding and copying, storing intermediate results.","Brute-force approach, trying all possible combinations of character additions and substring copies and selecting the minimum cost.","Dynamic programming, iterating forward, keeping track of minimum cost to build each prefix of the string.",,algorithms,"['dynamic programming', 'string manipulation', 'optimization']"
https://www.hackerrank.com/challenges/how-many-substrings?isFullScreen=true,"Consider a string of
characters,
, of where each character is indexed from
to
.
You are given
queries in the form of two integer indices:
and
. For each query, count and print the number of different substrings of
in the inclusive range between
and
.
Note:
Two substrings are
different
if their sequence of characters differs by at least one. For example, given the string
aab
, substrings
a
and
a
are the same but substrings
aa
and
ab
are different.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
The second line contains a single string denoting
.
Each of the
subsequent lines contains two space-separated integers describing the respective values of
and
for a query.
Constraints
String
consists of lowercase English alphabetic letters (i.e.,
a
to
z
) only.
Subtasks
For
of the test cases,
For
of the test cases,
For
of the test cases,
Output Format
For each query, print the number of different substrings in the inclusive range between index
and index
on a new line.
Sample Input 0
5 5
aabaa
1 1
1 4
1 1
1 4
0 2
Sample Output 0
1
8
1
8
5
Explanation 0
Given
aabaa
, we perform the following
queries:
1 1
: The only substring of
a
is itself, so we print
on a new line.
1 4
: The substrings of
abaa
are
a
,
b
,
ab
,
ba
,
aa
,
aba
,
baa
, and
abaa
, so we print
on a new line.
1 1
: The only substring of
a
is itself, so we print
on a new line.
1 4
: The substrings of
abaa
are
a
,
b
,
ab
,
ba
,
aa
,
aba
,
baa
, and
abaa
, so we print
on a new line.
0 2
: The substrings of
aab
are
a
,
b
,
aa
,
ab
, and
aab
, so we print
on a new line.","Using a hash set to store substrings, the time complexity is always O(n^2) regardless of the input string",Sorting all possible substrings and then comparing them to find distinct entries offers the best time complexity,A trie data structure is unsuitable for identifying distinct substrings due to its focus on common prefixes,"Using dynamic programming to store previously calculated substring counts significantly improves performance, resulting in near O(n) time","Employ a set data structure to store substrings to ensure uniqueness, leading to an average time complexity of O(n^2) where n is the substring length",,algorithms,"['string', 'substring', 'set']"
https://www.hackerrank.com/challenges/stonegame?isFullScreen=true,"Alice and Bob are playing the game of
Nim
with
piles of stones with sizes
. If Alice plays first, she loses if and only if the '
xor
sum' (or 'Nim sum') of the piles is zero, i.e.,
.
Since Bob already knows who will win (assuming optimal play), he decides to cheat by removing some stones in some piles before the game starts. However, to reduce the risk of suspicion, he must keep at least one pile unchanged. Your task is to count the number of ways Bob can remove the stones to force Alice into losing the game. Since the number can be very large, output the number of ways
modulo
. Assume that both players will try to optimize their strategy and try to win the game.
Input Format
The first line of the input contains an integer
denoting the number of piles. The next line contains
space-separated integers
indicating the sizes of the stone piles.
Constraints
Output Format
Print a single integer denoting the number of ways Bob can force Alice to lose the game, modulo
.
Sample Input 0
3
1 2 3
Sample Output 0
4
Explanation 0
The answer is
. The four possible resulting lists of piles is:
Note that
is not allowed since he must keep one pile unchanged.
Sample Input 1
10
10 10 1 1 1 1 1 10 10 10
Sample Output 1
321616","Calculate the initial Nim-sum and iterate through all possible subsets, ensuring at least one pile remains unchanged, and increment the count if the new Nim-sum is zero.","Use dynamic programming to store the number of ways to achieve a certain Nim-sum with a subset of the piles, considering only subsets of sizes less than or equal to half the total number of piles.",Sort the piles by size and calculate the number of subsets that result in a zero Nim-sum by considering only consecutive piles in the sorted order.,"Compute the total number of subsets and subtract the number of subsets where the Nim-sum is non-zero, using inclusion-exclusion principle to account for overlapping subsets.","Iterate through each pile. For each pile, calculate the Nim-sum of the remaining piles. Calculate the number of ways to remove stones from the chosen pile to make the overall Nim-sum zero. Sum these counts modulo 1000000007.",,algorithms,"['Nim game', 'XOR sum', 'combinatorics']"
https://www.hackerrank.com/challenges/even-tree?isFullScreen=true,"You are given a tree (a simple connected graph with no cycles).
Find the maximum number of edges you can remove from the tree to get a
forest
such that each connected component of the forest contains an even number of nodes.
As an example, the following tree with
nodes can be cut at most
time to create an even forest.
https://s3.amazonaws.com/hr-assets/0/1533926256-3a1cc069a7-evenforestexb.png
Function Description
Complete the
evenForest
function in the editor below.  It should return an integer as described.
evenForest has the following parameter(s):
t_nodes
: the number of nodes in the tree
t_edges
: the number of undirected edges in the tree
t_from
: start nodes for each edge
t_to
: end nodes for each edge, (Match by index to
t_from
.)
Input Format
The first line of input contains two integers
and
, the number of nodes and edges.
The next
lines contain two integers
and
which specify nodes connected by an edge of the tree. The root of the tree is node
.
Constraints
Note:
The tree in the input will be such that it can always be decomposed into components containing an even number of nodes.
is the set of positive even integers.
Output Format
Print the number of removed edges.","Use a greedy approach, always removing edges connected to leaves until only even-sized components remain.",Perform a Depth-First Search (DFS) and count the number of edges that connect subtrees of even size to the rest of the tree.,"Apply dynamic programming, storing the maximum number of removable edges for each subtree, considering both even and odd sizes.",Utilize a Breadth-First Search (BFS) to iteratively partition the tree into even-sized components.,Perform a Depth-First Search (DFS) to calculate the size of each subtree. Remove an edge if a subtree has an even number of nodes.,,algorithms,"['tree', 'DFS', 'graph']"
https://www.hackerrank.com/challenges/box-operations?isFullScreen=true,"Alice purchased an array of
wooden boxes that she indexed from
to
. On each box
, she writes an integer that we'll refer to as
.
Alice wants you to perform
operations
on the array of boxes. Each operation is in one of the following forms:
(Note: For each type of operations,
)
1 l r c
: Add
to each
. Note that
can be negative.
2 l r d
: Replace each
with
.
3 l r
: Print the minimum value of any
.
4 l r
: Print the sum of all
.
Recall that
is the maximum integer
such that
(e.g.,
and
).
Given
, the value of each
, and
operations, can you perform all the operations efficiently?
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of boxes) and
(the number of operations).
The second line contains
space-separated integers describing the respective values of
(i.e., the integers written on each box).
Each of the
subsequent lines describes an
operation
in one of the four formats defined above.
Constraints
Output Format
For each operation of type
or type
, print the answer on a new line.
Sample Input 0
10 10
-5 -4 -3 -2 -1 0 1 2 3 4
1 0 4 1
1 5 9 1
2 0 9 3
3 0 9
4 0 9
3 0 1
4 2 3
3 4 5
4 6 7
3 8 9
Sample Output 0
-2
-2
-2
-2
0
1
1
Explanation 0
Initially, the array of boxes looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1484766100-6ec346abf0-boxes.png
We perform the following sequence of operations on the array of boxes:
The first operation is
1 0 4 1
, so we add
to each
where
:
https://s3.amazonaws.com/hr-challenge-images/0/1484766285-5aeb591de3-boxes1.png
The second operation is
1 5 9 1
, so we add
to each
where
:
https://s3.amazonaws.com/hr-challenge-images/0/1484766335-f6d8bdd4dc-boxes2.png
The third operation is
2 0 9 3
, so we divide each
where
by
and take the floor:
https://s3.amazonaws.com/hr-challenge-images/0/1484766466-10eaf46b45-boxes3.png
The fourth operation is
3 0 9
, so we print the minimum value of
for
, which is the result of
.
The fifth operation is
4 0 9
, so we print the sum of
for
, which is the result of
.
... and so on.",Process all queries in the given order without any optimization.,Use a binary indexed tree (BIT) to efficiently handle updates and range queries.,"Use a segment tree to efficiently handle updates and range queries, but only for addition operations.","Divide the array into blocks and maintain aggregate information for each block, using this for faster updates and queries.","Employ a segment tree with lazy propagation to efficiently handle both range updates (addition, division) and range queries (minimum, sum).",,data structures,"['segment tree', 'lazy propagation', 'range queries']"
https://www.hackerrank.com/challenges/is-binary-search-tree?isFullScreen=true,"For the purposes of this challenge, we define a
binary tree
to be a
binary search tree
with the following ordering requirements:
The
value of every node in a node's left subtree is
less than
the data value of that node.
The
value of every node in a node's right subtree is
greater than
the data value of that node.
Given the root node of a binary tree, can you determine if it's also a binary search tree?
Complete the function in your editor below, which has
parameter: a pointer to the root of a binary tree. It must return a
boolean
denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.
Input Format
You are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument.
Constraints
Output Format
You are not responsible for printing any output to stdout. Your function must return
true
if the tree is a binary search tree; otherwise, it must return
false
. Hidden code stubs will print this result as a
Yes
or
No
answer on a new line.
Sample Input
https://s3.amazonaws.com/hr-challenge-images/8131/1461698192-c9e0fcb28d-BTinput.png
Sample Output
No",Check only if the root node satisfies the BST property.,Perform an inorder traversal and check if the sequence is strictly decreasing.,Compare the value of each node with the minimum and maximum values of the entire tree.,Use a breadth-first search and verify that all nodes at each level satisfy the BST property.,Perform an inorder traversal and check if the sequence is strictly increasing.,,algorithms,"['binary search tree', 'inorder traversal', 'recursion']"
https://www.hackerrank.com/challenges/array-and-simple-queries?isFullScreen=true,"Given two numbers
and
.
indicates the number of elements in the array
and
indicates number of queries. You need to perform two types of queries on the array
.
You are given
queries. Queries can be of two types, type
1
and type
2
.
Type 1 queries are represented as
1 i j
: Modify the given array by removing elements from
to
and adding them to the front.
Type 2 queries are represented as
2 i j
: Modify the given array by removing elements from
to
and adding them to the back.
Your task is to simply print
of the resulting array after the execution of
queries followed by the resulting array.
Note
While adding at back or front the order of elements is preserved.
Input Format
First line consists of two space-separated integers,
and
.
Second line contains
integers, which represent the elements of the array.
queries follow. Each line contains a query of either
type 1
or
type 2
in the form
Constraints
Output Format
Print the absolute value i.e.
in the first line.
Print elements of the resulting array in the second line. Each element should be seperated by a single space.
Sample Input
8 4
1 2 3 4 5 6 7 8
1 2 4
2 3 5
1 4 7
2 1 4
Sample Output
1
2 3 6 5 7 8 4 1
Explanation
Given array is
.
After execution of query
, the array becomes
.
After execution of query
, the array becomes
.
After execution of query
, the array becomes
.
After execution of query
, the array becomes
.
Now
is
i.e.
and the array is",The time complexity will be O(n*m) where n is the array size and m is the number of queries.,The algorithm will result in stack overflow due to excessive recursion.,The algorithm has an average-case time complexity of O(n log n) due to sorting.,The space complexity will always be O(1) because the operations are performed in-place.,The algorithm has a time complexity of O(n*q) where n is the array size and q is the number of queries and a space complexity of O(n).,,algorithms,"['array manipulation', 'time complexity', 'space complexity']"
https://www.hackerrank.com/challenges/subsequence-weighting?isFullScreen=true,"A subsequence of a sequence is a sequence which is obtained by deleting zero or more elements from the sequence.
You are given a sequence
A
in which every element is a pair of integers  i.e
A
=
[(a
1
, w
1
), (a
2
, w
2
),..., (a
N
, w
N
)]
.
For a subseqence
B
=
[(b
1
, v
1
), (b
2
, v
2
), ...., (b
M
, v
M
)]
of the given sequence :
We call it increasing if for every
i
(1 <=
i
<
M
) ,
b
i
< b
i+1
.
Weight(B) = v
1
+ v
2
+ ... + v
M
.
Task:
Given a sequence, output the maximum weight formed by an increasing subsequence.
Input:
The first line of input contains a single integer
T
.
T
test-cases follow. The first line of each test-case contains an integer
N
. The next line contains
a
1
, a
2
,... , a
N
separated by a single space. The next line contains
w
1
, w
2
, ..., w
N
separated by a single space.
Output:
For each test-case output a single integer: The maximum weight of increasing subsequences of the given sequence.
Constraints:
1 <=
T
<= 5
1 <=
N
<= 150000
1 <=
a
i
<= 10
9
, where
i ∈ [1..N]
1 <=
w
i
<= 10
9
, where
i ∈ [1..N]
Sample Input:
2
4
1 2 3 4
10 20 30 40
8
1 2 3 4 1 2 3 4
10 20 30 40 15 15 15 50
Sample Output:
100
110
Explanation:
In the first sequence, the maximum size increasing subsequence is 4, and there's only one of them. We choose
B = [(1, 10), (2, 20), (3, 30), (4, 40)]
, and we have
Weight(B) = 100
.
In the second sequence, the maximum size increasing subsequence is still 4, but there are now 5 possible subsequences:
1 2 3 4
10 20 30 40

1 2 3 4
10 20 30 50

1 2 3 4
10 20 15 50

1 2 3 4
10 15 15 50

1 2 3 4
15 15 15 50
Of those, the one with the greatest weight is
B = [(1, 10), (2, 20), (3, 30), (4, 50)]
, with
Weight(B) = 110
.
Please note that this is not the maximum weight generated from picking the highest value element of each index. That value, 115, comes from [(1, 15), (2, 20), (3, 30), (4, 50)], which is not a valid subsequence because it cannot be created by only deleting elements in the original sequence.","Use a greedy approach, always selecting the element with the highest weight regardless of increasing order.",Sort the sequence 'A' based on the 'a' values and then sum all the 'w' values.,Calculate the sum of all 'w' values in 'A' and return the result.,Apply binary search to find the optimal subsequence.,Use dynamic programming to store the maximum weight of increasing subsequences ending at each index.,,algorithms,"['dynamic programming', 'subsequence', 'optimization']"
https://www.hackerrank.com/challenges/company-retreat?isFullScreen=true,"The
LRT Company
has
employees. Each employee has a unique ID number from
to
, where the director's ID is number
. Every employee in the company has
exactly one
immediate supervisor — except the director, who has no supervisor. The company's employee hierarchy forms a tree of employee IDs that's rooted at employee number
(the director).
The director decides to have a retreat lasting
days. Each day, the employees will be assigned to different groups for team building exercises. Groups are constructed in the following way:
An employee can invite their immediate supervisor (the director has no supervisor and, thus, doesn't invite anyone). If employee
is invited by employee
, then
and
are considered to be in the same group.
Once an employee is invited to be in a group, they are in that group. This means that if two employees have the same immediate supervisor, only one of them can invite that supervisor to be in their group.
Every employee must be in a group, even if they are the only employee in it.
The venue where
LRT
is hosting the retreat has different pricing for each of the
days of the retreat. For each day
, there is a cost of
dollars per group and a per-group size limit of
(i.e., the maximum number of people that can be in any group on that day).
Help the director find optimal groupings for each day so the cost of the
-day retreat is minimal, then print the total cost of the retreat. As this answer can be quite large, your answer must be modulo
.
Input Format
The first line contains two space-separated integers denoting the respective values of
(the number of employees) and
(the retreat's duration in days).
The next line contains
space-separated integers where each integer
denotes
(
), which is the ID number of employee
's direct supervisor.
Each line
of the
subsequent lines contain two space-separated integers describing the respective values of
(the cost per group in dollars) and
(the maximum number of people per group) for the
day of the retreat.
Constraints
Subtask
for
of the maximum possible score.
Output Format
Print a single integer denoting the minimum total cost for the
-day retreat. As this number can be quite large, print your answer modulo
.
Sample Input
7 3
1 1 3 4 2 4
5 3
6 2
1 1
Sample Output
46
Explanation
In the
Sample Case
above, the company has
employees and the retreat goes on for
days. The hierarchy looks like this:
https://s3.amazonaws.com/hr-challenge-images/21545/1468266953-21eebf40fc-company-retreat-hierarchy.png
On the first day, the cost per group is
dollars and each group has a maximum size of
. The employees split into the following three groups:
Employee
invites their manager, employee
. Employee
then invites their manager, employee
(the director).
Employee
invites their manager, employee
. Employee
then invites their manager, employee
.
Employee
's manager is already in another group, so they are in a group by themself.
These groupings are demonstrated in the following image where each group has a different pattern:
https://s3.amazonaws.com/hr-challenge-images/21545/1468268176-7d89f164d0-company-retreat-groupings.png
In other words, the final groups are
,
, and
. This means the total cost for the first day is
dollars.
On the second day, they split into
groups with a maximum size of
at a total cost of
dollars. On the third day, they split into
groups of size
at a total cost of
dollars. When we sum the costs for all three days, we get
as our answer.",Use a greedy approach focusing on minimizing groups by always merging employees with their supervisors regardless of cost and size limits.,"For each day, sort employees by supervisor ID and then greedily form groups until the size limit is reached, ignoring cost.","Calculate the minimum possible groups each day (employees / size limit) and multiply that by the cost, ignoring employee hierarchy.","Randomly assign employees to groups each day, checking if the total cost is lower than the previous minimum, and repeat many times.","Use dynamic programming to minimize cost for each day by considering whether each employee invites their supervisor or forms a new group, accounting for group size limits and costs.",,algorithms,"['dynamic programming', 'tree', 'optimization']"
https://www.hackerrank.com/challenges/tree-coordinates?isFullScreen=true,"We consider
metric space
to be a pair,
, where
is a set and
such that the following conditions hold:
where
is the
distance
between points
and
.
Let's define the
product
of two metric spaces,
, to be
such that:
, where
,
.
So, it follows logically that
is also a metric space. We then define
squared metric space
,
, to be the product of a metric space multiplied with itself:
.
For example,
, where
is a metric space.
, where
.
In this challenge, we need a tree-space. You're given a tree,
, where
is the set of vertices and
is the set of edges. Let the function
be the distance between two vertices in tree
(i.e.,
is the number of edges on the path between vertices
and
). Note that
is a metric space.
You are given a tree,
, with
vertices, as well as
points in
. Find and print the distance between the two furthest points in this metric space!
Input Format
The first line contains two space-separated positive integers describing the respective values of
(the number of vertices in
) and
(the number of given points).
Each line
of the
subsequent lines contains two space-separated integers,
and
, describing edge
in
.
Each line
of the
subsequent lines contains two space-separated integers describing the respective values of
and
for point
.
Constraints
Scoring
This challenge uses
binary
scoring, so you
must
pass all test cases to earn a positive score.
Output Format
Print a single non-negative integer denoting the maximum distance between two of the given points in metric space
.
Sample Input 0
2 2
1 2
1 2
2 1
Sample Output 0
2
Explanation 0
The distance between points
and
is
.
Sample Input 1
7 3
1 2
2 3
3 4
4 5
5 6
6 7
3 6
4 5
5 5
Sample Output 1
3
Explanation 1
The best points are
and
, which gives us a distance of
.","Perform a depth-first search (DFS) starting from an arbitrary point, then perform another DFS from the furthest point found in the first search.",Calculate the distance between every pair of points using Dijkstra's algorithm and select the largest distance.,"Calculate the distance between every point and the root node (node 1), then subtract the smallest from the largest.",Run a breadth-first search (BFS) from an arbitrary starting point and keep track of the longest path.,"Perform a breadth-first search (BFS) starting from an arbitrary point, and then perform another BFS starting from the furthest point found in the first search.",,algorithms,"['graph theory', 'breadth-first search', 'tree diameter']"
https://www.hackerrank.com/challenges/tree-huffman-decoding?isFullScreen=true,"Huffman coding
assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit.  If they are on the left side of the tree, they will be a
0
(zero).  If on the right, they'll be a
1
(one).  Only the leaves will contain a letter and its frequency count.  All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.
For instance, consider the string
ABRACADABRA
.  There are a total of
characters in the string.  This number should match the count in the ultimately determined root of the tree.  Our frequencies are
and
.  The two smallest frequencies are for
and
, both equal to
, so we'll create a tree with them.  The root node will contain the sum of the counts of its descendants, in this case
.  The left node will be the first character encountered,
, and the right will contain
.  Next we have
items with a character count of
:  the tree we just created, the character
and the character
.  The tree came first, so it will go on the left of our new root node.
will go on the right.  Repeat until the tree is complete, then fill in the
's and
's for the edges.  The finished graph looks like:
https://s3.amazonaws.com/hr-assets/0/1528128577-d4e3a24f3e-huffmanExample.png
Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL).  We can determine that our values for characters are:
A - 0
B - 111
C - 1100
D - 1101
R - 10
Our Huffman encoded string is:
A B    R  A C     A D     A B    R  A
0 111 10 0 1100 0 1101 0 111 10 0
or
01111001100011010111100
To avoid ambiguity, Huffman encoding is a prefix free encoding technique.  No codeword appears as a prefix of any other codeword.
To decode the encoded string, follow the zeros and ones to a leaf and return the character there.
You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.
Function Description
Complete the function decode_huff in the editor below.  It must return the decoded string.
decode_huff has the following parameters:
root
: a reference to the root node of the Huffman tree
s
: a Huffman encoded string
Input Format
There is one line of input containing the plain string,
.  Background code creates the Huffman tree then passes the head node and the encoded string to the function.
Constraints
Output Format
Output the decoded string on a single line.
Sample Input
https://s3.amazonaws.com/hr-assets/0/1528126193-578de92bdb-huffmanSample.png
s=""1001011""
Sample Output
ABACA
Explanation
S=""1001011""
Processing the string from left to right.
S[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.
We move back to the root.

S[1]='0' : we move to the left child.
S[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.
We move back to the root.

S[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.
We move back to the root.

S[4]='0' : we move to the left child.
S[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.
We move back to the root.

 S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.
We move back to the root.

Decoded String = ""ABACA""",The Huffman tree must always be a complete binary tree.,Huffman coding is optimal for all types of data compression.,The character with the highest frequency will always have a codeword of length 1.,The encoded string is guaranteed to be shorter than the original string.,"Huffman coding is a variable-length, prefix-free encoding algorithm.",,algorithms,"['huffman coding', 'data compression', 'prefix code']"
https://www.hackerrank.com/challenges/jenny-subtrees?isFullScreen=true,"Jenny loves experimenting with
trees
. Her favorite tree has
nodes connected by
edges, and each edge is
unit in length. She wants to cut a
subtree
(i.e., a connected part of the original tree) of radius
from this tree by performing the following two steps:
Choose a node,
, from the tree.
Cut a subtree consisting of
all
nodes which are
not further
than
units from node
.
For example, the blue nodes in the diagram below depict a subtree centered at
that has radius
:
https://s3.amazonaws.com/hr-challenge-images/0/1483075128-6989fccb33-jenny3.png
Given
,
, and the definition of Jenny's tree, find and print the number of
different
subtrees she can cut out. Two subtrees are considered to be different if they are not
isomorphic
.
Input Format
The first line contains two space-separated integers denoting the respective values of
and
.
Each of the next
subsequent lines contains two space-separated integers,
and
, describing a bidirectional edge in Jenny's tree having length
.
Constraints
Subtasks
For
of the max score:
Output Format
Print the total number of different possible subtrees.
Sample Input 0
7 1
1 2
1 3
1 4
1 5
2 6
2 7
Sample Output 0
3
Explanation 0
In the diagram below, blue nodes denote the possible subtrees:
https://s3.amazonaws.com/hr-challenge-images/0/1483203734-79b5233ce8-jenny8.png
The last
subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print
as our answer.
Sample Input 1
7 3
1 2
2 3
3 4
4 5
5 6
6 7
Sample Output 1
4
Explanation 1
In the diagram below, blue nodes denote the possible subtrees:
https://s3.amazonaws.com/hr-challenge-images/0/1483203649-c8f47679bb-jenny7.png
Here, we have four possible different subtrees.",Depth-First Search (DFS) with memoization to count isomorphic subtrees,Breadth-First Search (BFS) to identify subtrees within radius r and a hashing function to check for isomorphism,Dynamic programming to store and reuse subtree isomorphism results,Greedy algorithm that iteratively grows subtrees and compares them for isomorphism,"Iterate through each node as the center, use BFS to extract the subtree within radius r, serialize the subtree structure, and use a set to store unique subtree representations to count them",,algorithms,"['graph traversal', 'subtree isomorphism', 'BFS']"
https://www.hackerrank.com/challenges/largest-rectangle?isFullScreen=true,"Skyline Real Estate Developers
is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed.
There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by
. If you join
adjacent buildings, they will form a solid rectangle of area
.
Example
A rectangle of height
and length
can be constructed within the boundaries.  The area formed is
.
Function Description
Complete the function
largestRectangle
int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.
largestRectangle has the following parameter(s):
int h[n]:
the building heights
Returns
-
long:
the area of the largest rectangle that can be formed within the bounds of consecutive buildings
Input Format
The first line contains
, the number of buildings.
The second line contains
space-separated integers, each the height of a building.
Constraints
Sample Input
STDIN       Function
-----       --------
5           h[] size n = 5
1 2 3 4 5   h = [1, 2, 3, 4, 5]
Sample Output
9
Explanation
An illustration of the test case follows.
https://s3.amazonaws.com/hr-challenge-images/8136/1436794554-75e178e325-drawing47.svg",Calculate the area of each possible rectangle and return the minimum area.,Divide the total area of all buildings by the number of buildings.,"Use a greedy approach, always selecting the tallest building and extending the rectangle.",Return the area of the tallest building multiplied by the number of buildings.,Use a stack to track potential rectangle heights and calculate areas efficiently.,,algorithms,"['stack', 'area', 'histogram']"
https://www.hackerrank.com/challenges/swaps-and-sum?isFullScreen=true,"You are given a sequence
. The task is to perform the following queries on it:
Type 1.
Given two integers
and
. Reorder the elements of the sequence in such a way (changed part of the sequence is in brackets):
That is swap the first two elements of segment
, the second two elements, and so on.
Type 2.
Given two integers
and
, print the value of sum
.
Input Format
The first line contains two integers
and
. The second line contains
integers
, denoting initial sequence.
Each of the next
lines contains three integers
, where
denotes the type of the query, and
are parameters of the query. It's guaranteed that for a first-type query
will be even.
Constraints
Output Format
For each query of the second type print the required sum.
Sample Input
6 4
1 2 3 4 5 6
1 2 5
2 2 3
2 3 4
2 4 5
Example Output
5
7
9
Explanation
After the first query the sequence becomes [1, 3, 2, 5, 4, 6].","The number of swaps will always be (r - l + 1) / 2, regardless of even/odd parity.","A segment of type 1 can be efficiently reordered using reverse operations within the range [l, r].",Query 2 requires iterating the whole array from l to r to calculate the sum; optimizing this part is not feasible.,"For type 1 queries, perform (r - l) / 2 swaps of adjacent elements within the specified range.","Type 1 queries involve swapping pairs within [l, r]; type 2 queries require summing elements from index l to r.",,algorithms,"['array manipulation', 'queries', 'in-place']"
https://www.hackerrank.com/challenges/find-the-permutation?isFullScreen=true,"Consider a
permutation
,
, of integers from
to
. Let's determine the
of
to be the
minimum absolute difference
between any
consecutive integers in
:
Generate a
lexicographically
sorted list of all permutations of length
having a
maximal distance
between all permutations of the same length. Print the lexicographically
permutation.
Input Format
The first line contains an integer,
(the number of test cases).
The
subsequent lines each contain two space-separated integers,
(the permutation length) and
(the 1-based index in the list of permutations having a maximal distance), respectively. The
line corresponds to the
test case.
Note:
It is guaranteed that the sum of all
does not exceed
.
Constraints
Output Format
For each test case: if the list of permutations having maximal distance has
at least
elements, print the
permutation as sequential (i.e.: from
to
) space-separated integers on a new line; otherwise, print
.
Sample Input
3
3 5
4 2
4 3
Sample Output
3 1 2
3 1 4 2
-1
Explanation
For
and
:
Each of the
permutations has distance
. We choose the fifth one (because
), and print
3 1 2
on a new line.
For
and
:
The maximal distance in the list of permutations of integers from
to
is
, and the only permutations having that distance are
and
. We choose the second one (because
), and print
3 1 4 2
on a new line.",A greedy algorithm that always picks the smallest available number for the next position.,"A backtracking algorithm that explores all permutations and selects the ones with maximal distance, then sorts and returns the k-th element.",A divide-and-conquer algorithm that splits the range 1..n into subranges and recursively generates permutations.,"Generate all permutations, calculate the minimum absolute difference for each, filter to find the maximal distance permutations, sort them lexicographically, and return the k-th permutation.","Generate a specific permutation with alternating large and small values to maximize distance, and if k is valid, generate the k-th such permutation using a constructive approach.",,algorithms,"['permutations', 'lexicographical order', 'maximal distance']"
https://www.hackerrank.com/challenges/recalling-early-days-gp-with-trees?isFullScreen=true,"Chinese Version
Russian Version
You are given a
tree
with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.
The
update query
is of the format
i j X
This means you'd have to add a
GP
series to the nodes which lie in the path from node
i
to node
j
(both inclusive) with first term of the GP as
X
on node
i
and the common ratio as
R
(given in the input)
The
retrieval
query is of the format
i j
You need to return the sum of the node values (S) lying in the path from node i to node j modulo 100711433.
Input Format
The first line contains two integers (N and R respectively) separated by a space.
In the next N-1 lines, the i
th
line describes the i
th
edge: a line with two integers a b separated by a single space denotes an edge between a, b.
The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.
U lines follow. Each of the next U lines contains 3 space separated integers (i,j, and X respectively).
Each of the next Q lines contains 2 space separated integers, i and j respectively.
Output Format
It contains exactly Q lines and each line containing the answer of the i
th
query.
Constraints
2 <= N <= 100000
2 <= R <= 10
9
1 <= U <= 100000
1 <= Q <= 100000
1 <= X <= 10
1 <= a, b, i, j <= N
Sample Input
6 2
1 2
1 4
2 6
4 5
4 3
2 2
1 6 3
5 3 5
6 4
5 1
Sample Output
31
18
Explanation
The node values after the first updation becomes :
3 6 0 0 0 12
The node values after second updation becomes :
3 6 20 10 5 12
Answer to Query #1: 12 + 6 + 3 + 10 = 31
Answer to Query #2: 5 + 10 +3 = 18",Use Dijkstra's algorithm to find the shortest path and sum the node values along that path.,Precompute all pairwise path sums using dynamic programming for faster query responses.,Treat the tree as a graph and apply a breadth-first search (BFS) for each query.,"For each update, recompute the values of all nodes based on the geometric progression.",Use lowest common ancestor (LCA) decomposition and lazy propagation to efficiently update and query path sums.,,algorithms,"['tree', 'geometric progression', 'LCA']"
https://www.hackerrank.com/challenges/number-game-on-a-tree?isFullScreen=true,"Andy and Lily love playing games with numbers and trees. Today they have a
tree
consisting of
nodes and
edges. Each edge
has an integer weight,
.
Before the game starts, Andy chooses an unordered pair of distinct nodes,
, and uses all the edge weights present on the unique path from node
to node
to construct a list of numbers. For example, in the diagram below, Andy constructs a list from the edge weights along the path
:
https://s3.amazonaws.com/hr-challenge-images/0/1485795937-a90f0c2865-treegame_3_.png
Andy then uses this list to play the following game with Lily:
Two players move in alternating turns, and both players play optimally (meaning they will not make a move that causes them to lose the game if some better, winning move exists).
Andy always starts the game by removing a single integer from the list.
During each subsequent move, the current player removes an integer
less than or equal to
the integer removed in the last move.
The first player to be unable to move loses the game.
For example, if the list of integers is
and Andy starts the game by removing
, the list becomes
. Then, in Lily's move, she must remove a remaining integer less than or equal to
(i.e.,
,
,
, or
).
The two friends decide to play
games, where each game is in the form of a tree. For each game, calculate the number of
unordered pairs
of nodes that Andy can choose to ensure he
always
wins the game.
Input Format
The first line contains a single integer,
, denoting the number of games. The subsequent lines describe each game in the following format:
The first line contains an integer,
, denoting the number of nodes in the tree.
Each line
of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
for the
edge connecting nodes
and
with weight
.
Constraints
Sum of
over all games does not exceed
Scoring
For
of score, the sum of
over all games does not exceed
.
For
of score, the sum of
over all games does not exceed
.
Output Format
For each game, print an integer on a new line describing the number of unordered pairs Andy can choose to construct a list that allows him to win the game.
Sample Input 0
3
5
1 2 2
1 3 1
3 4 1
3 5 2
5
1 2 0
2 3 2
3 4 2
4 5 0
5
1 2 0
1 3 1
3 4 0
3 5 2
Sample Output 0
9
8
10
Explanation 0
Andy and Lily play the following
games:
The first game's tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1485704304-f7046664c1-treegame2.png
There are
ways to choose
, and only one such pair causes Andy to lose the game. If he chooses the pair
, the list is
. Andy removes
in his first move, and Lily removes the remaining
in the next move; at this point, Andy has no remaining moves and Lily wins. Because Andy will win if he selects any of the other
pairs, we print
on a new line.
The second game's tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1485703652-d3cd2c9de6-treegame.png
There are
ways to choose
, and two pairs that cause Andy to lose the game:
If Andy chooses
, the list is
. Andy removes
in his first move, and Lily removes the remaining
in the next move; at this point, Andy has no remaining moves and Lily wins.
If Andy chooses
, the list is
. Andy can remove either a
or a
in the first move, but either way Lily will make an optimal choice in her next move that causes Andy to lose. Andy will win if he selects any of the other
pairs, so we print
on a new line.
The third game's tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1485704410-173c04fa5d-treegame1.png
There are
ways to choose
, and Andy will win the game regardless of which pair he chooses. Thus, we print
on a new line.",The number of pairs where the XOR sum of edge weights on the path between the nodes has an odd number of set bits.,The number of pairs where the maximum edge weight on the path between the nodes is a prime number.,The number of pairs where the path between the nodes contains an even number of edges with weights greater than 1.,The number of pairs where the product of all edge weights on the path between the nodes is a power of 2.,The number of pairs of nodes such that the path between them has an edge weight list of odd length after removing duplicates.,,algorithms,"['graph theory', 'game theory', 'pathfinding']"
https://www.hackerrank.com/challenges/ab0?isFullScreen=true,"Two positive integers
and
are given.
is decimal representation of integer
.
Lets define
.
For example, if
:
For each query you will be given two integers
and
that define a substring equal to
.
Your task is to calculate
divisibility
of given substring.
Divisibility
of given substring is equal to number of
pairs such that:
and
is divisible by
, assuming that
is divisible by any other integer.
Timelimits
Timelimits for this challenge is given
here
Input Format
First line contains two integers
and
separated by a single space.
is the number of queries.
Second line contains a big integer
.
Next
lines contains two integers
and
separated by a single space each - begin and end points of substring.
Constraints
Output Format
Output
lines, the
-th line of the output should contain single integer 
divisibility
of the
-th query substring.
Sample Input
3 5
4831318
3 5
5 7
1 7
1 2
2 3
Sample Output
2
3
9
1
1
Explanation
In the first query, b = 3 and e = 5. Two such pairs that are divisible by P = 3 are
 f(3, 3) = 3 and f(5, 5). Hence the answer 2.
In the second query, b = 5 and e = 7. Three such pairs that are divisible by P are
 F(5, 5) = 3, f(6, 7) = 18 and f(5, 7) = 318",The number of substrings is (e - b + 1).,The number of substrings is always 1.,The number of substrings is equal to the sum of the digits in the substring.,"Return (e-b+1)*(e-b)/2, which is total number of sub-strings","Iterate through all pairs (i, j) within the substring bounds and count pairs where the corresponding substring is divisible by P",,algorithms,"['substring', 'divisibility', 'nested loops']"
https://www.hackerrank.com/challenges/unique-colors?isFullScreen=true,"You are given an unrooted tree of
nodes numbered from
to
. Each node
has a color,
.
Let
be the number of different colors in the path between node
and node
. For each node
, calculate the value of
, defined as follows:
Your task is to print the value of
for each node
.
Input Format
The first line contains a single integer,
, denoting the number of nodes.
The second line contains
space-separated integers,
, where each
describes the color of node
.
Each of the
subsequent lines contains
space-separated integers,
and
, defining an undirected edge between nodes
and
.
Constraints
Output Format
Print
lines, where the
line contains a single integer denoting
.
Sample Input
5
1 2 3 2 3
1 2
2 3
2 4
1 5
Sample Output
10
9
11
9
12
Explanation
The
Sample Input
defines the following tree:
https://s3.amazonaws.com/hr-challenge-images/17417/1462441250-3e70e16b09-may1.png
Each
is calculated as follows:","Use a breadth-first search (BFS) starting from each node to calculate the distinct colors for all paths, resulting in O(N^3) time complexity.","Precompute all possible paths using dynamic programming and then count the distinct colors for each pair, which requires O(N^2) memory.","Ignore the tree structure and calculate the number of distinct colors for all possible pairs of nodes, leading to an incorrect result.","Perform a simple depth-first search (DFS) from each node without considering previously visited nodes, potentially leading to infinite loops.","Use a depth-first search (DFS) from each node, maintaining a set of visited colors along the path to efficiently calculate the distinct colors for each path.",,algorithms,"['tree traversal', 'depth-first search', 'distinct colors']"
https://www.hackerrank.com/challenges/coloring-tree?isFullScreen=true,"You are given a tree with
N
nodes with every node being colored. A color is represented by an integer ranging from 1 to 10
9
. Can you find the number of distinct colors available in a subtree rooted at the node
s
?
Input Format
The first line contains three space separated integers representing the number of nodes in the tree (
N
), number of queries to answer (
M
) and the root of the tree.
In each of the next N-1 lines, there are two space separated integers(a b) representing an edge from node a to Node b and vice-versa.
N lines follow: N+i
th
line contains the color of the i
th
node.
M lines follow: Each line containg a single integer s.
Output Format
Output exactly M lines, each line containing the output of the i
th
query.
Constraints
0 <= M <= 10
5
1 <= N <= 10
5
1 <= root <= N
1 <= color of the Node <= 10
9
Example
Sample Input
4 2 1
1 2
2 4
2 3
10
20
20
30
1
2
Sample Output
3
2
Explanation
Query 1-Subtree rooted at 1 is the entire tree and colors used are 10 20 20 30 , so the answer is 3(10,20 and 30)
Query 2-Subtree rooted at 2 contains color 20 20 30, so the answer is 2(20 and 30)",Perform a depth-first search (DFS) and store all colors in a global set.,Use a breadth-first search (BFS) and keep track of distinct colors in a queue.,Utilize dynamic programming to store color counts for each subtree.,"Employ a greedy approach, selecting the most frequent color at each node.","Conduct a depth-first search (DFS) rooted at 's', using a set to track distinct colors within the subtree.",,algorithms,"['tree traversal', 'depth-first search', 'subtree']"
https://www.hackerrank.com/challenges/waiter?isFullScreen=true,"You are a waiter at a party.  There is a pile of numbered plates.  Create an empty
array.  At each iteration,
, remove each plate from the top of the stack in order.  Determine if the number on the plate is evenly divisible by the
prime number.  If it is, stack it in pile
.  Otherwise, stack it in stack
.  Store the values in
from top to bottom in
.  In the next iteration, do the same with the values in stack
.  Once the required number of iterations is complete, store the remaining values in
in
, again from top to bottom.  Return the
array.
Example
An abbreviated list of primes is
.  Stack the plates in reverse order.
Begin iterations.  On the first iteration, check if items are divisible by
.
Move
elements to
.
On the second iteration, test if
elements are divisible by
.
Move
elmements to
.
And on the third iteration, test if
elements are divisible by
.
Move
elmements to
.
All iterations are complete, so move the remaining elements in
, from top to bottom, to
.
.  Return this list.
Function Description
Complete the
waiter
function in the editor below.
waiter
has the following parameters:
int number[n]:
the numbers on the plates
int q:
the number of iterations
Returns
int[n]:
the numbers on the plates after processing
Input Format
The first line contains two space separated integers,
and
.
The next line contains
space separated integers representing the initial pile of plates, i.e.,
.
Constraints
Sample Input 0
5 1
3 4 7 6 5
Sample Output 0
4
6
3
7
5
Explanation 0
Initially:
= [3, 4, 7, 6, 5]<-TOP
After 1 iteration (divide by 2, the 1st prime number):
= [5, 7, 3]<-TOP
= [6, 4]<-TOP
Move
elements to
.
All iterations are complete, so move
elements to
.
.
Sample Input 1
5 2
3 3 4 4 9
Sample Output 1
4
4
9
3
3
Explanation 1
Initially:
= [3, 3, 4, 4, 9]<-TOP
After
iteration (divide by 2):
= [9, 3, 3]<-TOP
= [4, 4]<-TOP
Move
to
.
After
iteration (divide by 3):
= []<- TOP
= [3, 3, 9]<-TOP
Move
elements to
.
There are no values remaining in
.",The function will modify the original input array directly and return void.,"The function will return a list of tuples, where each tuple contains the plate number and the prime number it was divided by.",The function will return a set of the remaining plate numbers in A0 after all iterations.,The function will only process plates divisible by the first prime number (2) regardless of the number of iterations.,"The function will return an array representing the plates after processing them through all iterations, where plates divisible by the current prime are moved to Bi, and remaining plates are moved to Ai+1.",,algorithms,"['prime numbers', 'arrays', 'stack']"
https://www.hackerrank.com/challenges/cube-summation?isFullScreen=true,"Chinese Version
Russian Version
Define a 3-D Matrix in which each block contains 0 initially. The first block is defined by the coordinates (1,1,1) and the last block is defined by the coordinates (n,n,n). There are two types of queries.
UPDATE x y z W
Update the value of block (x,y,z) to W.
QUERY x1 y1 z1 x2 y2 z2
Calculate the sum of the values of blocks whose x coordinate is between x1 and x2 (inclusive), y coordinate between y1 and y2 (inclusive) and z coordinate between z1 and z2 (inclusive).
Function Description
Complete the
cubeSum
function in the editor below.
cubeSum
has the following parameters:
- *int n: the dimensions of the 3-d matrix
-
string operations[m]:
the operations to perform
Returns
-
int[]:
the results of each
QUERY
operation
Input Format
The first line contains an integer
, the number of test-cases.
testcases follow.
For each test case, the first line contains two space-separated integers,
and
.
defines the
matrix.
defines the number of operations.
The next
lines will contain an operation either of these forms:
1. UPDATE x y z W
 2. QUERY  x1 y1 z1 x2 y2 z2
Constraints
-10
9
\le W \le 10
9
Sample Input
2
4 5
UPDATE 2 2 2 4
QUERY 1 1 1 3 3 3
UPDATE 1 1 1 23
QUERY 2 2 2 4 4 4
QUERY 1 1 1 3 3 3
2 4
UPDATE 2 2 2 1
QUERY 1 1 1 1 1 1
QUERY 1 1 1 2 2 2
QUERY 2 2 2 2 2 2
Sample Output
4
4
27
0
1
1
Explanation
In the first test case, there is a cube of 4 * 4 * 4 and there are 5 queries.  Initially all the cells (1,1,1) to (4,4,4) are 0.
UPDATE 2 2 2 4
makes the cell (2,2,2) = 4
QUERY 1 1 1 3 3 3
. As (2,2,2) is updated to 4 and the rest are all 0. The answer to this query is 4.
UPDATE 1 1 1 23
. updates the cell (1,1,1) to 23.
QUERY 2 2 2 4 4 4
. Only the cell (1,1,1) and (2,2,2) are non-zero and (1,1,1) is not between (2,2,2) and (4,4,4). So, the answer is 4.
QUERY 1 1 1 3 3 3
. 2 cells are non-zero and their sum is 23+4 = 27.",Using a quadtree data structure for efficient range updates and queries.,"Iterating through the entire 3D matrix for each query, resulting in O(n^3) time complexity per query.",Using a sparse matrix representation to store only non-zero values.,Using dynamic programming to precompute all possible subcube sums.,Using a 3D Binary Indexed Tree (BIT) to efficiently handle updates and range sum queries in O(log n)^3 time.,,algorithms,"['data structures', '3D matrix', 'Binary Indexed Tree']"
https://www.hackerrank.com/challenges/array-pairs?isFullScreen=true,"Consider an array of
integers,
. Find and print the total number of
pairs such that
where
.
Input Format
The first line contains an integer,
, denoting the number of elements in the array.
The second line consists of
space-separated integers describing the respective values of
.
Constraints
Scoring
for
of the test cases.
for
of the test cases.
for
of the test cases.
Output Format
Print a long integer denoting the total number
pairs satisfying
where
.
Sample Input
5
1 1 2 4 2
Sample Output
8
Explanation
There are eight pairs of indices satisfying the given criteria:
,
,
,
,
,
,
, and
. Thus, we print
as our answer.",O(1),O(n log n),O(log n),O(n^2),O(n),,algorithms,"['array', 'pairs', 'time complexity']"
https://www.hackerrank.com/challenges/x-and-his-shots?isFullScreen=true,"A cricket match is going to be held. The field is represented by a 1D plane. A cricketer, Mr. X has
favorite shots. Each shot has a particular range.
The range of the
shot is from
i
to
i
. That means his favorite shot can be anywhere in this range. Each player on the opposite team
can field only in a particular range. Player
can field from
i
to
i
. You are given the
favorite shots of Mr. X and the range of
players.
represents the strength of each player i.e. the number of shots player
can stop.
Your task is to find:
.
Game Rules
: A player can stop the
shot if the range overlaps with the player's fielding range.
For more clarity about overlapping, study the following figure:
https://s3.amazonaws.com/hr-challenge-images/8943/1441719277-9d9c50f731-L.png
Input Format
The first line consists of two space separated integers,
and
.
Each of the next
lines contains two space separated integers. The
line contains
and
.
Each of the next
lines contains two integers. The
line contains integers
and
.
Output Format
You need to print the sum of the strengths of all the players:
.
Constraints
:
Sample Input
4 4
1 2
2 3
4 5
6 7
1 5
2 3
4 7
5 7
Sample Output
9
Explanation
Player 1
can stop the 1st, 2nd and 3rd shot so the strength is
.
Player 2
can stop the 1st and 2nd shot so the strength is
.
Player 3
can stop the 3rd and 4th shot so the strength is
.
Player 4
can stop the 3rd and 4th shot so the strength is
.
The sum of the strengths of all the players is
.",Only consider players whose fielding range perfectly matches a shot range.,Calculate the strength of each player by counting shots fully contained within their range.,Assume that a player can stop a shot if their range begins before the shot range and stops afterward.,Calculate the strength of each player by counting the number of distinct integers within overlapping ranges.,"Iterate through each player and shot, incrementing the player's strength if their ranges overlap, then sum the strengths.",,algorithms,"['range overlap', 'interval', 'strength calculation']"
https://www.hackerrank.com/challenges/the-strange-function?isFullScreen=true,"One of the most important skills a programmer needs to learn early on is the ability to pose a problem in an abstract way. This skill is important not just for researchers but also in applied fields like software engineering and web development.
You are able to solve most of a problem, except for one last subproblem, which you have posed in an abstract way as follows: Given an array consisting of
integers
, define
For example, for an input array [ 10, -5, 5, 20 ], a subsegment
would be computed as follows:
https://s3.amazonaws.com/hr-assets/0/1514443882-d4fd00ae66-strange_function5.png
What is
, i.e., the maximum value of
among all subsegments
?
Complete the function
maximumValue
which takes an integer array as input and returns the maximum value of
among all subsegments
.
Note that:
Input Format
The first line contains a single integer
The second line contains
space-separated integers
Constraints
Output Format
Print a single integer denoting the answer
Sample Input 0
4
10 -5 5 20
Sample Output 0
50
Explanation 0
The maximum value occurs at
as shown below.
https://s3.amazonaws.com/hr-assets/0/1514443735-fef0ce5b41-strange_function4.png
Sample Input 1
5
7 12 24 6 5
Sample Output 1
144
Explanation 1
The maximum value occurs at
.","Calculate the product of all positive numbers and the sum of all negative numbers, then add the two results.","Sort the array in descending order and multiply the first two elements, then add all remaining elements.",Find the maximum element and multiply it by the sum of all other elements.,"Iterate through all possible subsegments, calculate the product of elements in each subsegment, and return the minimum product.","Iterate through all possible subsegments, calculate the product of elements in each subsegment, and return the maximum product.",,algorithms,"['arrays', 'subsegments', 'maximum product']"
https://www.hackerrank.com/challenges/simple-text-editor?isFullScreen=true,"Implement a simple text editor. The editor initially contains an empty string,
. Perform
operations of the following
types:
append
- Append string
to the end of
.
delete
- Delete the last
characters of
.
print
- Print the
character of
.
undo
- Undo the last (not previously undone) operation of type
or
, reverting
to the state it was in prior to that operation.
Example
operation
index   S       ops[index]  explanation
-----   ------  ----------  -----------
0       abcde   1 fg        append fg
1       abcdefg 3 6         print the 6th letter - f
2       abcdefg 2 5         delete the last 5 letters
3       ab      4           undo the last operation, index 2
4       abcdefg 3 7         print the 7th characgter - g
5       abcdefg 4           undo the last operation, index 0
6       abcde   3 4         print the 4th character - d
The results should be printed as:
f
g
d
Input Format
The first line contains an integer,
, denoting the number of operations.
Each line
of the
subsequent lines (where
) defines an operation to be performed. Each operation starts with a single integer,
(where
), denoting a type of operation as defined in the
Problem Statement
above. If the operation requires an argument,
is followed by its space-separated argument. For example, if
and
, line
will be
1 abcd
.
Constraints
The sum of the lengths of all
in the input
.
The sum of
over all delete operations
.
All input characters are lowercase English letters.
It is guaranteed that the sequence of operations given as input is possible to perform.
Output Format
Each operation of type
must print the
character on a new line.
Sample Input
STDIN   Function
-----   --------
8       Q = 8
1 abc   ops[0] = '1 abc'
3 3     ops[1] = '3 3'
2 3     ...
1 xy
3 2
4
4
3 1
Sample Output
c
y
a
Explanation
Initially,
is empty. The following sequence of
operations are described below:
. We append
to
, so
.
Print the
character on a new line. Currently, the
character is
c
.
Delete the last
characters in
(
), so
.
Append
to
, so
.
Print the
character on a new line. Currently, the
character is
y
.
Undo the last update to
, making
empty again (i.e.,
).
Undo the next to last update to
(the deletion of the last
characters), making
.
Print the
character on a new line. Currently, the
character is
a
.","Use a single string and repeatedly modify it in place, keeping a stack of previous states as strings.","Use a linked list to represent the text, modifying the list directly for each operation and storing states as linked lists.","Maintain a copy of the string for each operation, storing these copies in a stack for undo operations.",Use a rope data structure for efficient string manipulation and store diffs between states for undo.,"Employ a string builder and a stack to store operations, using the stack to revert to previous string builder states.",,data structures,"['string manipulation', 'stack', 'text editor']"
https://www.hackerrank.com/challenges/queries-with-fixed-length?isFullScreen=true,"Consider an
-integer sequence,
. We perform a query on
by using an integer,
, to calculate the result of the following expression:
In other words, if we let
, then you need to calculate
.
Given
and
queries, return a list of answers to each query.
Example
The first query uses all of the subarrays of length
:
.  The maxima of the subarrays are
.  The minimum of these is
.
The second query uses all of the subarrays of length
:
.  The maxima of the subarrays are
.  The minimum of these is
.
Return
.
Function Description
Complete the
solve
function below.
solve
has the following parameter(s):
int arr[n]:
an array of integers
int queries[q]:
the lengths of subarrays to query
Returns
int[q]:
the answers to each query
Input Format
The first line consists of two space-separated integers,
and
.
The second line consists of
space-separated integers, the elements of
.
Each of the
subsequent lines contains a single integer denoting the value of
for that query.
Constraints
Sample Input 0
5 5
33 11 44 11 55
1
2
3
4
5
Sample Output 0
11
33
44
44
55
Explanation 0
For
, the answer is
.
For
, the answer is
.
For
, the answer is
.
For
, the answer is
.
For
, the answer is
.
Sample Input 1
5 5
1 2 3 4 5
1
2
3
4
5
Sample Output 1
1
2
3
4
5
Explanation 1
For each query, the ""prefix"" has the least maximum value among the consecutive subsequences of the same size.",Calculate the minimum of the entire array for each query length,Return the maximum of the entire array for each query length,"Return the average value of the entire array, regardless of the query",Return the value at the index corresponding to the query length,"For each query length, find the minimum of the maximums of all subarrays of that length",,algorithms,"['array', 'sliding window', 'min/max']"
https://www.hackerrank.com/challenges/balanced-forest?isFullScreen=true,"Greg has a tree of nodes containing integer data.  He wants to insert a node with some non-zero integer value somewhere into the tree.  His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount.  This is called a
balanced forest
.  Being frugal, the data value he inserts should be minimal.  Determine the minimal amount that a new node can have to allow creation of a balanced forest.  If it's not possible to create a balanced forest, return -1.
For example, you are given node values
and
.  It is the following tree:
https://s3.amazonaws.com/hr-assets/0/1528138409-097321b50e-forestExample.png
The blue node is root, the first number in a node is node number and the second is its value.  Cuts can be made between nodes
and
and nodes
and
to have three trees with sums
,
and
.  Adding a new node
of
to the third tree completes the solution.
Function Description
Complete the
balancedForest
function in the editor below.  It must return an integer representing the minimum value of
that can be added to allow creation of a balanced forest, or
if it is not possible.
balancedForest has the following parameter(s):
c
: an array of integers, the data values for each node
edges
: an array of 2 element arrays, the node pairs per edge
Input Format
The first line contains a single integer,
, the number of queries.
Each of the following
sets of lines is as follows:
The first line contains an integer,
, the number of nodes in the tree.
The second line contains
space-separated integers describing the respective values of
, where each
denotes the value at node
.
Each of the following
lines contains two space-separated integers,
and
, describing edge
connecting nodes
and
.
Constraints
Each query forms a valid undirected tree.
Subtasks
For
of the maximum score:
For
of the maximum score:
Output Format
For each query, return the minimum value of the integer
.  If no such value exists, return
instead.
Sample Input
2
5
1 2 2 1 1
1 2
1 3
3 5
1 4
3
1 3 5
1 3
1 2
Sample Output
2
-1
Explanation
We perform the following two queries:
The tree initially looks like this:
https://s3.amazonaws.com/hr-assets/0/1528140939-72f0001183-forestSample0-1.png
Greg can add a new node
with
and create a new edge connecting nodes
and
. Then he cuts the edge connecting nodes
and
and the edge connecting nodes
and
. We now have a three-tree balanced forest where each tree has a sum of
.
https://s3.amazonaws.com/hr-assets/0/1528141184-a92a2f7cff-forestSample0-2.png
In the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return
.","Return -1 if the total sum is odd, otherwise return 0",Find the minimum value in the tree and return half of it,Calculate the sum of all nodes and return the sum divided by 3,"Use dynamic programming to find the optimal cut points, ignoring the node insertion","Perform a depth-first search to calculate subtree sums, store these sums, and then search for valid cut combinations that allow for a balanced forest after adding a minimal node",,algorithms,"['tree', 'dfs', 'dynamic programming']"
https://www.hackerrank.com/challenges/kittys-calculations-on-a-tree?isFullScreen=true,"Kitty has a tree,
, consisting of
nodes where each node is uniquely labeled from
to
. Her friend Alex gave her
sets, where each set contains
distinct nodes. Kitty needs to calculate the following expression on each set:
where:
denotes an unordered pair of nodes belonging to the set.
denotes the number of edges on the unique (shortest) path between nodes
and
.
Given
and
sets of
distinct nodes, calculate the expression for each set. For each set of nodes, print the value of the expression modulo
on a new line.
Example
The graph looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1480257483-7359ae9180-aleso.png
There are three pairs that can be created from the query set:
.  The distance from
to
is
, from
to
is
, and from
to
is
.
Now do the summation:
Input Format
The first line contains two space-separated integers, the respective values of
(the number of nodes in tree
) and
(the number of nodes in the query set).
Each of the
subsequent lines contains two space-separated integers,
and
, that describe an
undirected
edge between nodes
and
.
The
subsequent lines define each set over two lines in the following format:
The first line contains an integer,
, the size of the set.
The second line contains
space-separated integers, the set's elements.
Constraints
The sum of
over all
does not exceed
.
All elements in each set are
distinct
.
Subtasks
for
of the maximum score.
for
of the maximum score.
for
of the maximum score.
Output Format
Print
lines of output where each line
contains the expression for the
query, modulo
.
Sample Input 0
7 3
1 2
1 3
1 4
3 5
3 6
3 7
2
2 4
1
5
3
2 4 5
Sample Output 0
16
0
106
Explanation 0
Tree
looks like this:
https://s3.amazonaws.com/hr-challenge-images/0/1480257483-7359ae9180-aleso.png
We perform the following calculations for
sets:
Set
: Given set
, the only pair we can form is
, where
. We then calculate the following answer and print it on a new line:
Set
: Given set
, we cannot form any pairs because we don't have at least two elements. Thus, we print
on a new line.
Set
: Given set
, we can form the pairs
,
, and
. We then calculate the following answer and print it on a new line:",Use Depth First Search (DFS) to traverse all possible paths between node pairs and sum the path lengths modulo 10^9 + 7.,Calculate the shortest path between all node pairs using the Floyd-Warshall algorithm and sum the lengths for nodes within each set modulo 10^9 + 7.,"Employ a Breadth First Search (BFS) for each node pair in each set to determine the shortest path and sum the path lengths, taking the modulo 10^9 + 7.",Represent the tree as an adjacency matrix and compute path lengths by matrix exponentiation modulo 10^9 + 7.,"For each set, use Breadth-First Search (BFS) or Depth-First Search (DFS) to calculate the distance between each pair of nodes in the set and sum the distances modulo 10^9 + 7.",,algorithms,"['graph theory', 'shortest path', 'tree traversal']"
https://www.hackerrank.com/challenges/rooted-tree?isFullScreen=true,"You are given a rooted
tree
with
N
nodes and the root of the tree,
R
, is also given. Each node of the tree contains a value, that is initially empty. You have to mantain the tree under two operations:
Update Operation
Report Operation
Update Operation
Each Update Operation begins with the character
U
. Character
U
is followed by 3 integers
T, V and K
. For every node which is the descendent of the node
T
, update it's value by adding
V + d*K
, where
V
and
K
are the parameters of the query and
d
is the distance of the node from
T
. Note that
V
is added to node
T
.
Report Operation
Each Report Operation begins with the character
Q
. Character
Q
is followed by 2 integers,
A
and
B
. Output the sum of values of nodes in the path from
A
to
B
modulo
(10
9
+ 7)
Input Format
The first Line consists of 3 space separated integers,
N E R
, where
N
is the number of nodes present,
E
is the total number of queries (update + report), and
R
is root of the tree.
Each of the next
N-1
lines contains 2 space separated integers,
X
and
Y
(
X
and
Y
are connected by an edge).
Thereafter,
E
lines follows: each line can represent either the Update Operation or the Report Operation.
Update Operation
is of the form :
U T V K
.
Report Operation
is of the form :
Q A B
.
Output Format
Output the answer for every given report operation.
Constraints
1 ≤ N, E ≤ 10
5
1 ≤ E ≤ 10
5
1 ≤ R, X, Y, T, A, B ≤ N
1 ≤ V, K ≤ 10
9
X ≠ Y
Sample Input
7 7 1
1 2
2 3
2 4
2 5
5 6
6 7
U 5 10 2
U 4 5 3
Q 1 7
U 6 7 4
Q 2 7
Q 1 4
Q 2 4
Sample Output
36
54
5
5
Explanation
Values of Nodes after
U 5 10 2
:
[0 0 0 0 10 12 14]
.
Values of Nodes after
U 4 5 3
:
[0 0 0 5 10 12 14]
.
Sum of the Nodes from 1 to 7: 0 + 0 + 10 + 12 + 14 = 36.
Values of Nodes after
U 6 7 4
: [0 0 0 5 10 19 25].
Sum of the Nodes from 2 to 7: 0 + 10 + 19 + 25 = 54.
Sum of the Nodes from 1 to 4: 0 + 0 + 5 = 5.
Sum of the Nodes from 2 to 4: 0 + 5 = 5.","Use a depth-first search (DFS) to traverse the tree for updates and a separate DFS for each report operation, recalculating values each time.","Maintain a separate array to store the cumulative sum of values from the root to each node and use that for report operations, updating the array after each update.",Use binary lifting to efficiently compute the path between nodes for report operations and update values directly on the tree nodes during update operations.,Apply lazy propagation by storing update operations at the subtree's root and propagating them down only when necessary during report operations.,"Utilize Euler tour and segment tree. For updates, update the segment tree within the subtree range of a node in the Euler tour. For queries, find the LCA, and query the segment tree for the path from A to LCA and B to LCA.",,algorithms,"['tree', 'segment tree', 'euler tour']"
https://www.hackerrank.com/challenges/crush?isFullScreen=true,"Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each array element between two given indices, inclusive.  Once all operations have been performed, return the maximum value in the array.
Example
Queries are interpreted as follows:
a
b
k
1
5
3
4
8
7
6
9
1
Add the values of
between the indices
and
inclusive:
https://s3.amazonaws.com/hr-assets/0/1738699658-ff37fa31d8-array_manipulation_example.png
The largest value is
after all operations are performed.
Function Description
Complete the function
with the following parameters:
: the number of elements in the array
: a two dimensional array of queries where each
contains three integers,
,
, and
.
Returns
: the maximum value in the resultant array
Input Format
The first line contains two space-separated integers
and
, the size of the array and the number of queries.
Each of the next
lines contains three space-separated integers
,
and
, the left index, right index and number to add.
Constraints
Sample Input
STDIN       Function
-----       --------
5 3         arr[] size n = 5, queries[] size q = 3
1 2 100     queries = [[1, 2, 100], [2, 5, 100], [3, 4, 100]]
2 5 100
3 4 100
Sample Output
200
Explanation
After the first update the list is
100 100 0 0 0
.
After the second update list is
100 200 100 100 100
.
After the third update list is
100 200 200 200 100
.
The maximum value is
.","Use nested loops to iterate through the array and apply each query, resulting in O(n*m) time complexity.",Create a copy of the array for each query to avoid modifying the original data.,Use a hash map to store the intermediate values and retrieve them efficiently.,Ignore queries where the start index is greater than the end index.,Use a difference array to record the changes and efficiently compute the final array in O(n+m) time.,,algorithms,"['array manipulation', 'difference array', 'prefix sum']"
https://www.hackerrank.com/challenges/triplets?isFullScreen=true,"There is an integer array
which does not contain more than two elements of the same value. How many distinct ascending triples (
) are present?
Input format
The first line contains an integer,
, denoting the number of elements in the array. This is followed by a single line, containing
space-separated integers. Please note that there are no leading spaces before the first number, and there are no trailing spaces after the last number.
Output format:
A single integer that denotes the number of distinct ascending triplets present in the array.
Constraints:
Every element of the array is present at most twice.
Every element of the array is a 32-bit non-negative integer.
Sample input:
6
1 1 2 2 3 4
Sample output:
4
Explanation
The distinct triplets are
(1,2,3)
(1,2,4)
(1,3,4)
(2,3,4)
The elements of the array might not be sorted. Make no assumptions of the same.",O(n^3) where n is the number of elements in the array,O(n log n) where n is the number of elements in the array,O(n^2) where n is the number of elements in the array,O(1),O(n) where n is the number of elements in the array,,algorithms,"['array', 'triplet', 'counting']"
https://www.hackerrank.com/challenges/jim-and-the-skyscrapers?isFullScreen=true,"Jim has invented a new flying object called HZ42. HZ42 is like a broom and can only fly horizontally, independent of the environment. One day, Jim started his flight from Dubai's highest skyscraper, traveled some distance and landed on another skyscraper of same height! So much fun! But unfortunately, new skyscrapers have been built recently.
Let us describe the problem in one dimensional space. We have in total
skyscrapers aligned from left to right. The
th
skyscraper has a height of
. A flying route can be described as
with
, which means, Jim starts his HZ42 at the top of the skyscraper
and lands on the skyscraper
. Since HZ42 can only fly horizontally, Jim will remain at the height
only. Thus the path
can be valid, only if each of the skyscrapers
is not strictly greater than
and if the height of the skyscraper he starts from and arrives on have the same height. Formally,
is valid iff
and
.
Help Jim in counting the number of valid paths represented by ordered pairs
.
Input Format
The first line contains
, the number of skyscrapers. The next line contains
space separated integers representing the heights of the skyscrapers.
Output Format
Print an integer that denotes the number of valid routes.
Constraints
and no skyscraper will have height greater than
and less than
.
Sample Input #00
6
3 2 1 2 3 3
Sample Output #00
8
Sample Input #01
3
1 1000 1
Sample Output #01
0
Explanation
First testcase: (1, 5), (1, 6) (5, 6) and (2, 4) and the routes in the opposite directions are the only valid routes.
Second testcase: (1, 3) and (3, 1) could have been valid, if there wasn't a big skyscraper with height 1000 between them.","Count pairs where the starting and ending skyscrapers have equal height, ignoring intermediate skyscrapers.",Iterate through all possible pairs of skyscrapers and check if the height of each intermediate skyscraper is strictly less than both the starting and ending heights.,Check only adjacent pairs of skyscrapers to see if they are valid.,Calculate the number of possible routes by summing the number of skyscrapers with the same height as each other.,"For each skyscraper, iterate through all subsequent skyscrapers and check if a valid path exists based on intermediate heights and equal start/end heights.",,algorithms,"['dynamic programming', 'nested loops', 'arrays']"
https://www.hackerrank.com/challenges/merging-communities?isFullScreen=true,"People connect with each other in a social network. A connection between Person
and Person
is represented as
. When two persons belonging to different communities connect, the net effect is the merge the communities which
and
belong to.
At the beginning, there are
people representing
communities. Suppose person
and
connected and later
and
connected, then
,
, and
will belong to the same community.
There are two types of queries:
communities containing persons
and
are merged if they belong to different communities.
print the size of the community to which person
belongs.
Input Format
The first line of input contains 2 space-separated integers
and
, the number of people and the number of queries.
The next
lines will contain the queries.
Constraints
Output Format
The output of the queries.
Sample Input
STDIN   Function
-----   --------
3 6     n = 3, q = 6
Q 1     print the size of the community containing person 1
M 1 2   merge the communities containing persons 1 and 2 ...
Q 2
M 2 3
Q 3
Q 2
Sample Output
1
2
3
3
Explanation
Initial size of each of the community is
.",Use Depth-First Search (DFS) to traverse the graph and count the number of connected components.,Employ a disjoint-set data structure with path compression and union by rank for efficient merging and finding.,Maintain an adjacency matrix representing connections and update it with each merge operation.,"Apply a clustering algorithm like k-means, using person IDs as data points and merging based on cluster assignments.",Utilize a disjoint-set (Union-Find) data structure to track communities and their sizes.,,data structures,"['disjoint-set', 'graph theory', 'union-find']"
https://www.hackerrank.com/challenges/swap-nodes-algo?isFullScreen=true,"A binary tree is a tree which is characterized by one of the following properties:
It can be empty (null).
It contains a root node only.
It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.
In-order
traversal is performed as
Traverse the left subtree.
Visit root.
Traverse the right subtree.
For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true:
it is the first node visited, the first time visited
it is a leaf, should only be visited once
all of its subtrees have been explored, should only be visited once while this is true
it is the root of the tree, the first time visited
Swapping:
Swapping subtrees of a node means that if initially node has left subtree
L
and right subtree
R
, then after swapping, the left subtree will be
R
and the right subtree,
L
.
For example, in the following tree, we swap children of node
1
.
Depth
    1               1            [1]
   / \             / \
  2   3     ->    3   2          [2]
   \   \           \   \
    4   5           5   4        [3]
In-order traversal of left tree is
2 4 1 3 5
and of right tree is
3 5 1 2 4
.
Swap operation
:
We define depth of a node as follows:
The root node is at depth
1
.
If the depth of the parent node is
d
, then the depth of current node will be
d+1
.
Given a tree and an integer,
k
, in one operation, we need to swap the subtrees of all the nodes at each depth
h
, where
h ∈ [k, 2k, 3k,...]
.  In other words, if
h
is a multiple of
k
, swap the left and right subtrees of that level.
You are given a tree of
n
nodes where nodes are indexed from
[1..n]
and it is rooted at
1
. You have to perform
t
swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.
Function Description
Complete the
swapNodes
function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.
swapNodes has the following parameter(s):
-
indexes
: an array of integers representing index values of each
, beginning with
, the first element, as the root.
-
queries
: an array of integers, each representing a
value.
Input Format
The first line contains
n
, number of nodes in the tree.
Each of the next
n
lines contains two integers,
a b
, where
a
is the index of left child, and
b
is the index of right child of
i
th
node.
Note:
-1
is used to represent a null node.
The next line contains an integer,
t
, the size of
.
Each of the next
t
lines contains an integer
, each being a value
.
Output Format
For each
k
, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.
Constraints
Either
or
Either
or
The index of a non-null child will always be greater than that of its parent.
Sample Input 0
3
2 3
-1 -1
-1 -1
2
1
1
Sample Output 0
3 1 2
2 1 3
Explanation 0
As nodes
2
and
3
have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.
1   [s]       1    [s]       1
   / \      ->   / \        ->  / \
  2   3 [s]     3   2  [s]     2   3
Note:
[s]
indicates that a swap operation is done at this depth.
Sample Input 1
5
2 3
-1 4
-1 5
-1 -1
-1 -1
1
2
Sample Output 1
4 2 1 5 3
Explanation 1
Swapping child nodes of node
2
and
3
we get
1                  1
   / \                / \
  2   3   [s]  ->    2   3
   \   \            /   /
    4   5          4   5
Sample Input 2
11
2 3
4 -1
5 -1
6 -1
7 8
-1 9
-1 -1
10 11
-1 -1
-1 -1
-1 -1
2
2
4
Sample Output 2
2 9 6 4 1 3 7 5 11 8 10
2 6 9 4 1 3 7 5 10 8 11
Explanation 2
Here we perform swap operations at the nodes whose depth is either
2
or
4
for
and then at nodes whose depth is
4
for
.
1                     1                          1
        / \                   / \                        / \
       /   \                 /   \                      /   \
      2     3    [s]        2     3                    2     3
     /      /                \     \                    \     \
    /      /                  \     \                    \     \
   4      5          ->        4     5          ->        4     5
  /      / \                  /     / \                  /     / \
 /      /   \                /     /   \                /     /   \
6      7     8   [s]        6     7     8   [s]        6     7     8
 \          / \            /           / \              \         / \
  \        /   \          /           /   \              \       /   \
   9      10   11        9           11   10              9     10   11",A swap operation would result in a binary tree that violates the properties of a complete binary tree.,A post-order traversal will be the same as an in-order traversal after the swaps.,Only the root node needs to be considered during the swap operation; all other nodes are irrelevant.,A depth-first search can be modified to efficiently perform the node swaps at each level.,A level-order traversal is used to determine the depth of each node and in-order traversal is applied after swapping.,,algorithms,"['binary tree', 'tree traversal', 'swap']"
https://www.hackerrank.com/challenges/balanced-brackets?isFullScreen=true,"A bracket is considered to be any one of the following characters:
(
,
)
,
{
,
}
,
[
, or
]
.
Two brackets are considered to be a
matched pair
if the an opening bracket (i.e.,
(
,
[
, or
{
) occurs to the left of a closing bracket (i.e.,
)
,
]
, or
}
)
of the exact same type
. There are three types of matched pairs of brackets:
[]
,
{}
, and
()
.
A matching pair of brackets is
not balanced
if the set of brackets it encloses are not matched. For example,
{[(])}
is not balanced because the contents in between
{
and
}
are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket,
(
, and the pair of parentheses encloses a single, unbalanced closing square bracket,
]
.
By this logic, we say a sequence of brackets is
balanced
if the following conditions are met:
It contains no unmatched brackets.
The subset of brackets enclosed within the confines of a matched pair of brackets  is also a matched pair of brackets.
Given
strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return
YES
.  Otherwise, return
NO
.
Function Description
Complete the function
isBalanced
in the editor below.
isBalanced has the following parameter(s):
string s
: a string of brackets
Returns
string:
either
YES
or
NO
Input Format
The first line contains a single integer
, the number of strings.
Each of the next
lines contains a single string
, a sequence of brackets.
Constraints
, where
is the length of the sequence.
All chracters in the sequences ∈ {
{
,
}
,
(
,
)
,
[
,
]
}.
Output Format
For each string, return
YES
or
NO
.
Sample Input
STDIN           Function
-----           --------
3               n = 3
{[()]}          first s = '{[()]}'
{[(])}          second s = '{[(])}'
{{[[(())]]}}    third s ='{{[[(())]]}}'
Sample Output
YES
NO
YES
Explanation
The string
{[()]}
meets both criteria for being a balanced string.
The string
{[(])}
is not balanced because the brackets enclosed by the matched pair
{
and
}
are not balanced:
[(])
.
The string
{{[[(())]]}}
meets both criteria for being a balanced string.",Use a regular expression to validate if the brackets are balanced,Count the occurrences of each bracket type and check if the counts are even,Sort the string and compare adjacent bracket types,Recursively check the string by removing matching pairs until the string is empty or no match is found,Use a stack to store opening brackets and check for corresponding closing brackets,,algorithms,"['stack', 'string', 'bracket']"
https://www.hackerrank.com/challenges/components-in-graph?isFullScreen=true,"There are
nodes in an undirected graph, and a number of edges connecting some nodes.  In each edge, the first value will be between
and
, inclusive.  The second node will be between
and
, inclusive.  Given a list of edges, determine the size of the smallest and largest connected components that have
or more nodes.  A node can have any number of connections.  The highest node value will always be connected to at least
other node.
Note
Single nodes should not be considered in the answer.
Example
https://s3.amazonaws.com/hr-assets/0/1610643454-3d793cb76a-connectedcomponentsexample.svg
The smaller component contains
nodes and the larger contains
.  Return the array
.
Function Description
Complete the
connectedComponents
function in the editor below.
connectedComponents
has the following parameter(s):
-
int bg[n][2]:
a 2-d array of integers that represent node ends of graph edges
Returns
-
int[2]:
an array with 2 integers, the smallest and largest component sizes
Input Format
The first line contains an integer
, the size of
.
Each of the next
lines contain two space-separated integers,
and
.
Constraints
Sample Input
STDIN   Function
-----   --------
5       bg[] size n = 5
1 6     bg = [[1, 6],[2, 7], [3, 8], [4,9], [2, 6]]
2 7
3 8
4 9
2 6
Sample Output
2 4
Explanation
https://s3.amazonaws.com/hr-assets/0/1610641145-b423e41655-connectedcomponentssample.svg
Since the component with node
contains only one node, it is not considered.
The number of vertices in the smallest connected component in the graph is
based on either
or
.
The number of vertices in the largest connected component in the graph is
i.e.
.","Depth-First Search (DFS) without marking visited nodes, leading to infinite loops","Breadth-First Search (BFS) using a stack instead of a queue, exploring the graph in a depth-first manner","Using a Disjoint Set Union (DSU) data structure, but without path compression, resulting in suboptimal performance","Randomly sampling edges and estimating component sizes based on the sample, which might be inaccurate","Using Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the graph and identify connected components, then calculating their sizes, ignoring sizes less than the threshold",,algorithms,"['graph traversal', 'connected components', 'DFS/BFS']"
https://www.hackerrank.com/challenges/and-xor-or?isFullScreen=true,"Given an array
of
distinct elements. Let
and
be the smallest and the next smallest element in the interval
where
.
.
where
, are the bitwise operators
,
and
respectively.
Your task is to find the maximum possible value of
.
Input Format
First line contains integer
.
Second line contains
integers, representing elements of the array
.
Constraints
Output Format
Print the value of maximum possible value of
.
Sample Input
5
9 6 3 5 2
Sample Output
15
Explanation
Consider the interval
the result will be maximum.",The bitwise AND of 'arr[i]' and 'arr[i+1]' plus the bitwise OR of 'arr[i]' and 'arr[i+1]' minus the bitwise XOR of 'arr[i]' and 'arr[i+1]',The bitwise AND of 'arr[i]' and 'arr[i+1]' minus the bitwise OR of 'arr[i]' and 'arr[i+1]' plus the bitwise XOR of 'arr[i]' and 'arr[i+1]',The bitwise OR of 'arr[i]' and 'arr[i+1]' minus the bitwise AND of 'arr[i]' and 'arr[i+1]' plus the bitwise XOR of 'arr[i]' and 'arr[i+1]',The sum of 'arr[i]' and 'arr[i+1]' multiplied by the bitwise XOR of 'arr[i]' and 'arr[i+1]',"The sum of 'arr[i]' and 'arr[i+1]' for each adjacent pair, and then the maximum of these sums",,algorithms,"['bitwise operators', 'array', 'maximum']"
https://www.hackerrank.com/challenges/ticket-to-ride?isFullScreen=true,"Simon received the board game
Ticket to Ride
as a birthday present. After playing it with his friends, he decides to come up with a strategy for the game.
There are
cities on the map and
road plans. Each road plan consists of the following:
Two cities which can be directly connected by a road.
The length of the proposed road.
The entire road plan is designed in such a way that if one builds all the roads, it will be possible to travel between any pair of cities.
A ticket enables you to travel between two different cities. There are
tickets, and each ticket has a cost associated with it. A ticket is considered to be
useful
if there is a path between those cities.
Simon wants to choose two cities,
and
, and build a
minimal
number of roads so that they form a simple path between them. Let
be the sum of costs of all
useful
tickets and
be the sum of lengths of all the roads Simon builds. The profit for pair
is defined as
. Note that
and
are not necessarily unique and may be the same cities.
Given
road plans and
ticket prices, help Simon by printing the value of his maximum possible profit on a new line.
Input Format
The first line contains single positive integer,
, denoting the number of cities.
Each of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
for a road plan, where
,
, and
. Here,
and
are two cities that the road plan proposes to connect and
is the length of the proposed road.
The next line contains a single positive integer,
, denoting the number of tickets.
Each of the
subsequent lines contains three space-separated integers describing the respective values of
,
, and
for a ticket from city
to city
(where
is the cost of the ticket).
Constraints
Output Format
Print a single integer denoting the the maximum profit Simon can make.
Time Limits
seconds for Java and C#.
Please refer to our
Environment
page to see time limits for other languages.
Sample Input
7
1 2 1
1 3 1
1 4 4
4 5 1
4 6 1
4 7 1
5
5 7 3
3 6 2
3 4 10
2 7 15
1 6 7
Sample Output
13
Explanation
https://s3.amazonaws.com/hr-challenge-images/9335/1468515101-90ba543319-ticket.png
Simon can maximize his profit by choosing the pair
.
The roads on the path between them are
,
, and
. The total road length is
.
The useful tickets are
,
, and
. The total ticket cost is
.
The profit is
.",Use Dijkstra's algorithm to find the shortest path between all pairs of cities and then calculate the profit for each pair.,"Apply the Floyd-Warshall algorithm to find all-pairs shortest paths, then iterate through all city pairs to find the maximum profit.",Use a brute-force approach by considering all possible paths between all city pairs and calculating the profit for each path.,Construct a minimum spanning tree and then find the longest path within the tree to maximize ticket usage.,"For each city pair, use Breadth-First Search (BFS) to find the shortest path; calculate road length and ticket cost for that path, then track the maximum profit.",,algorithms,"['graph algorithms', 'shortest path', 'breadth-first search']"
https://www.hackerrank.com/challenges/queue-using-two-stacks?isFullScreen=true,"A
queue
is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a
First-In-First-Out
(FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed.
A basic queue has the following operations:
Enqueue
: add a new element to the end of the queue.
Dequeue
: remove the element from the front of the queue and return it.
In this challenge, you must first implement a queue using
two stacks
. Then process
queries, where each query is one of the following
types:
1 x
: Enqueue element
into the end of the queue.
2
: Dequeue the element at the front of the queue.
3
: Print the element at the front of the queue.
Input Format
The first line contains a single integer,
, denoting the number of queries.
Each line
of the
subsequent lines contains a single query in the form described in the problem statement above. All three queries start with an integer denoting the query
, but only query
is followed by an additional space-separated value,
, denoting the value to be enqueued.
Constraints
It is guaranteed that a valid answer always exists for each query of type
.
Output Format
For each query of type
, print the value of the element at the front of the queue on a new line.
Sample Input
STDIN   Function
-----   --------
10      q = 10 (number of queries)
1 42    1st query, enqueue 42
2       dequeue front element
1 14    enqueue 42
3       print the front element
1 28    enqueue 28
3       print the front element
1 60    enqueue 60
1 78    enqueue 78
2       dequeue front element
2       dequeue front element
Sample Output
14
14
Explanation
Perform the following sequence of actions:
Enqueue
;
.
Dequeue the value at the head of the queue,
;
.
Enqueue
;
.
Print the value at the head of the queue,
;
.
Enqueue
;
.
Print the value at the head of the queue,
;
.
Enqueue
;
.
Enqueue
;
.
Dequeue the value at the head of the queue,
;
.
Dequeue the value at the head of the queue,
;
.","Stack 1 is used for enqueue operations, and Stack 2 is never used.","Stack 1 is used for enqueue operations, and elements are transferred to Stack 2 only when a dequeue operation is needed, but Stack 2 is emptied after each operation.",Elements are transferred back and forth between Stack 1 and Stack 2 for every enqueue and dequeue operation to maintain FIFO order.,"Only one stack is used, and elements are rearranged within the stack to simulate queue behavior.","Stack 1 is used for enqueue operations, and elements are transferred to Stack 2 only when a dequeue operation is needed. If Stack 2 is empty, all elements from Stack 1 are moved to Stack 2, reversing their order.",,data structures,"['queue', 'stack', 'data structure']"
https://www.hackerrank.com/challenges/maximum-cost-queries?isFullScreen=true,"Victoria has a tree,
, consisting of
nodes numbered from
to
. Each edge from node
to
in tree
has an integer weight,
.
Let's define the cost,
, of a path from some node
to some other node
as the maximum weight (
) for any edge in the unique path from node
to node
.
Victoria wants your help processing
queries on tree
, where each query contains
integers,
and
, such that
. For each query, she wants to print the number of different paths in
that have a cost,
, in the inclusive range
.
It should be noted that path from some node
to some other node
is considered same as path from node
to
i.e
is same as
.
Input Format
The first line contains
space-separated integers,
(the number of nodes) and
(the number of queries), respectively.
Each of the
subsequent lines contain
space-separated integers,
,
, and
, respectively, describing a bidirectional road between nodes
and
which has weight
.
The
subsequent lines each contain
space-separated integers denoting
and
.
Constraints
Scoring
for
of the test data.
for
of the test data.
Output Format
For each of the
queries, print the number of paths in
having cost
in the inclusive range
on a new line.
Sample Input
5 5
1 2 3
1 4 2
2 5 6
3 4 1
1 1
1 2
2 3
2 5
1 6
Sample Output
1
3
5
5
10
Explanation
:
:
:
:
...etc.",Use Dijkstra's algorithm from each node to every other node and count paths within the cost range.,"Perform a Depth-First Search (DFS) from each node, keeping track of the maximum edge weight encountered so far.",Calculate the Minimum Spanning Tree (MST) and then analyze paths within the MST to meet the cost criteria.,Employ a modified Kruskal's algorithm to build connected components incrementally based on edge weights within the cost range.,"For each query, iterate through all possible pairs of nodes and use a pathfinding algorithm like DFS or BFS, tracking the maximum edge weight to determine if it falls within [L, R].",,algorithms,"['graph theory', 'pathfinding', 'tree']"
https://www.hackerrank.com/challenges/down-to-zero-ii?isFullScreen=true,"You are given
queries. Each query consists of a single number
. You can perform any of the
operations on
in each move:
1: If we take 2 integers
and
where
,
, then we can change
2: Decrease the value of
by
.
Determine the minimum number of moves required to reduce the value of
to
.
Input Format
The first line contains the integer
.
The next
lines each contain an integer,
.
Constraints
Output Format
Output
lines. Each line containing the minimum number of moves required to reduce the value of
to
.
Sample Input
2
3
4
Sample Output
3
3
Explanation
For test case 1, We only have one option that gives the minimum number of moves.
Follow
->
->
->
. Hence,
moves.
For the case 2, we can either go
->
->
->
->
or
->
->
->
. The 2nd option is more optimal. Hence,
moves.",Prime factorization followed by dynamic programming.,Greedy approach: Repeatedly subtract the largest possible prime factor.,"Check if n is 1, return 0. If n is prime, return 1. Otherwise return n-1.",Brute-force search through all possible combinations of operations.,"Recursively apply the operations, caching results to avoid redundant calculations.",,algorithms,"['dynamic programming', 'prime factorization', 'recursion']"
https://www.hackerrank.com/challenges/self-balancing-tree?isFullScreen=true,"An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree.  In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.
We define balance factor for each node as :
balanceFactor = height(left subtree) - height(right subtree)
The balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.
https://s3.amazonaws.com/hr-challenge-images/0/1436854305-b167cc766c-AVL_Tree_Rebalancing.svg.png
(
https://en.wikipedia.org/wiki/AVL_tree
)
You are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.
Input Format
You are given a function,
node *insert(node * root,int new_val)
{


}
'node' is defined as :
struct node
{
int val;            //value
struct node* left;  //left child
struct node* right; //right child
int ht;             //height of the node
} node;
You only need to complete the function.
Note: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.
Output Format
Insert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.
Sample Input
3
  /  \
 2    4
       \
        5
The value to be inserted is 6.
Sample Output
3
  /  \
 2    5
     / \
    4   6
Explanation
After inserting 6 in the tree. the tree becomes:
3 (Balance Factor = -2)
  /  \
 2    4 (Balance Factor = -2)
       \
        5 (Balance Factor = -1)
         \
          6 (Balance Factor = 0)
Balance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.
After performing the rotation, the tree becomes :
3 (Balance Factor = -1)
                            /   \
      (Balance Factor = 0) 2     5 (Balance Factor = 0)
                                / \
           (Balance Factor = 0)4   6 (Balance Factor = 0)",Always perform a left-left rotation regardless of the balance factor.,Only update the height of the root node after insertion; child node heights are irrelevant.,Recursively insert the node and then rebalance the entire tree from the root down to the inserted node.,Ignore balance factors; simply insert the node and return the modified tree.,"Recursively insert the node, update heights, calculate balance factors, and perform rotations (left or right) as necessary.",,data structures,"['AVL tree', 'self-balancing tree', 'tree rotations']"
https://www.hackerrank.com/challenges/array-and-queries-1?isFullScreen=true,"Given an array, you are asked to perform a number of queries and divide the array into what are called,
beautiful
subsequences.
The array
has length
. A function
is defined to be a minimal possible
, such that it's possible to divide array
into
beautiful
subsequences. Note that each element of an array should belong to exactly one subsequence, and subsequence does not necessarily need to be consecutive.
A subsequence
with length
is called
beautiful
if and only if:
or
Let
be a sorted version of
. It must hold that
for every
For instance, if
,
would be
. Because, you can divide
into
beautiful
subsequences either like
and
or like
and
.
You have to answer
queries. Each query is of the type:
: you need to change a value of
to
, i.e.
. Here
is
.
After each query, for the value of
, lets denote that value as
, where
indicates the
query.
You need to find
modulo
.
Input Format
The first line contains a single integer
, representing the length of array
.
The next line contains the array
given as space-separated integers.
The next line contains a single integer
, representing the number of queries.
Each of the
lines contain two integers
and
, which is described above.
Constraints
Output Format
Print the required answer in one line.
Sample Input 0
5
2 2 1 1 1
2
3 2
5 5
Sample Output 0
11
Explanation 0
The initial array
is
After
query the array becomes
this can be divided into
subsequences as
,
and
.
After
query the array becomes
this can be divided into
subsequences as
,
,
and
.
https://s3.amazonaws.com/hr-assets/0/1516959936-30f81c9401-arrayquery1.png
Hence, calculating
we get
Sample Input 1
2
3 3
3
2 4
1 5
2 2
Sample Output 1
9
Explanation 1
The initial array
is
After
query the array becomes
this can be divided into
subsequence as
.
After
query the array becomes
this can be divided into
subsequence as
.
After
query the array becomes
this can be divided into
subsequences as
and
.
Hence, calculating
we get",The maximum element's frequency in the array.,The number of distinct elements in the array.,The sum of all elements in the array.,The length of the longest increasing subsequence in the array.,The frequency of the most frequent element in the array after each query.,,algorithms,"['array', 'frequency', 'subsequence']"
https://www.hackerrank.com/challenges/subtrees-and-paths?isFullScreen=true,"Given a rooted tree of
nodes, where each node is uniquely numbered in between
[1..N]
. The node 1 is the root of the tree. Each node has an integer value which is initially 0.
You need to perform the following two kinds of queries on the tree:
add t value
: Add value to all nodes in subtree rooted at
t
max a b
: Report maximum value on the path from
a
to
b
Input Format
First line contains
N
, number of nodes in the tree. Next
N-1
lines contain two space separated integers
x
and
y
which denote that there is an edge between node
x
and node
y
.
Next line contains
Q
, the number of queries to process.
Next
Q
lines follow with either
add
or
max
query per line.
Constraints
Output Format
For each
max
query output the answer in a separate line.
Sample Input
5
1 2
2 3
2 4
5 1
6
add 4 30
add 5 20
max 4 5
add 2 -20
max 4 5
max 3 4
Sample Output
30
20
10
Explanation
In the test case we have the following tree:
https://s3.amazonaws.com/hr-challenge-images/4939/1425846771-314f24a56a-tree.png
Initially all node values are zero.
Queries are performed in the following way:
add 4 30
// add 30 to node 4
add 5 20
// add 20 to node 5
max 4 5
// maximum of nodes 4,2,1,5 is 30
add 2 -20
// subtract 20 from nodes 2,3,4
max 4 5
// maximum of nodes 4,2,1,5 is 20
max 3 4
// maximum of nodes 3,2,4 is 10","Use Breadth-First Search (BFS) to traverse the tree, maintaining a running maximum on the path between nodes for each 'max' query, and updating node values directly for 'add' queries.","Represent the tree as an adjacency matrix. For 'add' queries, update the subtree using matrix exponentiation. For 'max' queries, apply Dijkstra's algorithm on the matrix representation.",Precompute Lowest Common Ancestor (LCA) for all node pairs. Use dynamic programming to store path sums and quickly answer 'max' queries. Update the entire tree for each 'add' query.,"Use a simple array to store node values. For 'add' queries, traverse the entire array and add the value if the node is in the subtree. For 'max' queries, traverse all possible paths between the two nodes.",Use Depth-First Search (DFS) to preprocess the tree for efficient LCA calculation and subtree range queries. Use lazy propagation for efficient updates during 'add' queries and LCA for path traversal during 'max' queries.,,algorithms,"['tree traversal', 'lowest common ancestor', 'range queries']"
https://www.hackerrank.com/challenges/almost-sorted-interval?isFullScreen=true,"Shik loves sorted intervals. But currently he does not have enough time to sort all the numbers. So he decided to use
Almost sorted intervals
. An
Almost sorted interval
is a consecutive subsequence in a sequence which satisfies the following property:
The first number is the smallest.
The last number is the largest.
Please help him count the number of almost sorted intervals in this permutation.
Note:
Two intervals are different if at least one of the starting or ending indices are different.
Input Format
The first line contains an integer N.
The second line contains a permutation from 1 to N.
Output Format
Output the number of almost sorted intervals.
Constraints
1 ≤ N ≤ 10
6
Sample Input
5
3 1 2 5 4
Sample Output
8
Explanation
The subsequences [3], [1], [1 2], [1 2 5], [2], [2 5], [5], [4] are almost sorted intervals.",O(N^3),O(N log N),O(1),O(N^2),O(N),,algorithms,"['array', 'interval', 'algorithm']"
https://www.hackerrank.com/challenges/almost-equal-advanced?isFullScreen=true,"A Sumo wrestling championship is scheduled to be held this winter in the
HackerCity
where
N
wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K,
(i.e) wrestler A and wrestler B can fight if and only if
|height(A)-height(B)|<=K
.
Given an array
H[]
, where
H[i]
represents the height of the
i
th
fighter, for a given l, r where
0 <= l <= r < N
, can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game?
Input Format
The first line contains an integer
N
and
K
separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K.
The second line contains
N
integers separated by a single space, representing their heights
H[0] H[1] ... H[N - 1]
.
The third line contains
Q
, the number of queries. This is followed by
Q
lines each having two integers
l
and
r
separated by a space.
Output Format
For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that
K
.
Constraints
1 <= N <= 100000
0 <= K <= 10
9
0 <= H[i] <= 10
9
1 <= Q <= 100000
0 <= l <= r < N
Sample Input
5 2
1 3 4 3 0
3
0 1
1 3
0 4
Sample Output
1
3
6
Explanation
Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1.
Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| <=2. Hence output is 3.
Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.
Timelimits
Timelimits are given
here","Use brute force to check all pairs within the range l to r, resulting in O(Q*N^2) complexity","Precompute all possible pairs and store them in a lookup table, resulting in O(N^2) preprocessing and O(1) query time","Sort the array first and then use binary search for each element to find pairs within the range K, resulting in O(N log N + Q*N log N) complexity","Maintain a sliding window of size K and count pairs within the window, resulting in O(N + Q*N) complexity","For each query, iterate through all possible pairs within the given range l to r and check if the absolute difference is less than or equal to K, resulting in O(Q*N^2) in the worst case",,algorithms,"['nested loops', 'absolute difference', 'range query']"
https://www.hackerrank.com/challenges/poisonous-plants?isFullScreen=true,"There are a number of plants in a garden. Each of the plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.
You are given the initial values of the pesticide in each of the plants. Determine the number of days after which no plant dies, i.e. the time after which there is no plant with more pesticide content than the plant to its left.
Example
// pesticide levels
Use a
-indexed array.  On day
, plants
and
die leaving
.  On day
, plant
in
dies leaving
.  There is no plant with a higher concentration of pesticide than the one to its left, so plants stop dying after day
.
Function Description
Complete the function
poisonousPlants
in the editor below.
poisonousPlants has the following parameter(s):
int p[n]
: the pesticide levels in each plant
Returns
-
int
: the number of days until plants no longer die from pesticide
Input Format
The first line contains an integer
, the size of the array
.
The next line contains
space-separated integers
.
Constraints
Sample Input
7
6 5 8 4 7 10 9
Sample Output
2
Explanation
Initially all plants are alive.
Plants = {(6,1), (5,2), (8,3), (4,4), (7,5), (10,6), (9,7)}
Plants[k] = (i,j) => j
th
plant has pesticide amount = i.
After the 1
st
day, 4 plants remain as plants 3, 5, and 6 die.
Plants = {(6,1), (5,2), (4,4), (9,7)}
After the 2
nd
day, 3 plants survive as plant 7 dies.
Plants = {(6,1), (5,2), (4,4)}
Plants stop dying after the 2
nd
day.",Use dynamic programming to track the maximum pesticide level seen so far and the number of days each plant survives.,"Simulate the process day by day, using a queue to hold the plants and removing the plants that die each day.","Sort the plants by pesticide level and then iterate through them, calculating the number of days until each plant dies.","Iterate through the pesticide levels once, keeping track of the previous plant's pesticide level and incrementing a counter if the current plant dies.","Use a stack to keep track of plants that might die, and simulate the days until no more plants die based on the stack state.",,algorithms,"['array', 'simulation', 'stack']"
https://www.hackerrank.com/challenges/no-prefix-set?isFullScreen=true,"There is a given list of strings where each string contains only lowercase letters from
, inclusive. The set of strings is said to be a
GOOD SET
if no string is a prefix of another string.  In this case, print
GOOD SET
.  Otherwise, print
BAD SET
on the first line followed by the string being checked.
Note
If two strings are identical, they are prefixes of each other.
Example
Here 'abcd' is a prefix of 'abcde' and 'bcd' is a prefix of 'bcde'.  Since 'abcde' is tested first, print
BAD SET
abcde
.
No string is a prefix of another so print
GOOD SET
Function Description
Complete the
noPrefix
function in the editor below.
noPrefix
has the following parameter(s):
-
string words[n]:
an array of strings
Prints
-
string(s):
either
GOOD SET
or
BAD SET
on one line followed by the word on the next line.  No return value is expected.
Input Format
First line contains
, the size of
.
Then next
lines each contain a string,
.
Constraints
the length of words[i]
All letters in
are in the range 'a' through 'j', inclusive.
Sample Input00
STDIN       Function
-----       --------
7            words[] size n = 7
aab          words = ['aab', 'defgab', 'abcde', 'aabcde', 'bbbbbbbbbb', 'jabjjjad']
defgab
abcde
aabcde
cedaaa
bbbbbbbbbb
jabjjjad
Sample Output00
BAD SET
aabcde
Explanation
'aab' is prefix of 'aabcde' so it is a
BAD SET
and fails at string 'aabcde'.
Sample Input01
4
aab
aac
aacghgh
aabghgh
Sample Output01
BAD SET
aacghgh
Explanation
'aab' is a prefix of 'aabghgh', and aac' is prefix of 'aacghgh'. The set is a
BAD SET
.   'aacghgh' is tested before 'aabghgh', so and it fails at 'aacghgh'.",Use a hash table to store prefixes and check for collisions after adding each word,Sort the words array by length in descending order before checking for prefixes,Use dynamic programming to build a prefix table and identify overlapping strings,Iterate through the list and compare each string only with the string immediately following it,Use a trie data structure to efficiently check if any string is a prefix of another,,data structures,"['trie', 'prefix', 'string']"
https://www.hackerrank.com/challenges/net-admin?isFullScreen=true,"Time Limits
C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5
Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions:
Any pair of servers within the network should be directly connected by at most 1 link.
Each link is controlled by some specific network administrator.
No server has more than 2 links connected to it, that are controlled by the same administrator.
For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers)
Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software.
Operations performed by the directives are:
Change the administrator assigned to some particular link.
Place some number of security devices along a particular link.
Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers.
Input Format
Input begins with a line containing 4 integers
separated by a single whitespace, denoting the number of servers, links, network administrators and transformations, respectively.
lines follow each one with 3 integers
and
, saying that there is a link between server
and server
, and that link is controlled by administrator
. Initially, network topology fulfills the restrictions described above and there is no security device along any link. Remaining
lines in the input follow one the next formats:
meaning that link between server
and server
is requested to be assigned to administrator
meaning that the number of security devices along the link between server
and server
will be fixed to
, removing any existing devices on this link before the operation. The involved link will always exist.
meaning that directives want to know the number of security devices placed along the path between server
and server
, just considering links controlled by administrator
.
Output Format
For each network transformation in the form
you should output:
""Wrong link"" if there is no direct link between server
and server
.
""Already controlled link"" if the requested link does exist, but it is already controlled by administrator
.
""Server overload"" if administrator
already controls 2 links connected to one of the involved servers.
""Network redundancy"" if the requested assignment creates no new connection considering just the links controlled by
.
""Assignment done"" if none of the above conditions holds. In this case, link directly connecting
with
is assigned to
.
For each network transformation in the form
you should output:
""No connection"" if there is no path between the requested servers considering just the links controlled by
.
""
security devices placed"" where
D
is the number of security devices placed so far on the existing connection between the requested servers considering just the links controlled by
.
Constraints
Sample Input:
4 5 3 15
1 2 1
2 3 1
3 4 2
1 4 2
1 3 3
2 3 4 49
1 1 2 3
2 1 4 64
3 1 4 2
1 1 2 3
3 4 2 3
3 1 3 3
1 1 4 3
3 3 4 2
3 2 4 1
2 1 4 13
2 1 3 21
2 2 3 24
1 2 3 3
1 2 4 3
Sample Output:
Assignment done
64 security devices placed
Already controlled link
No connection
0 security devices placed
Server overload
49 security devices placed
No connection
Network redundancy
Wrong link",A graph database designed for managing network topologies,A relational database with appropriate indexes for efficient querying,A NoSQL document store to store the adjacency list representation,A key-value store where keys are link identifiers and values are properties,An adjacency list or matrix representation optimized for the specific network constraints,,data structures,"['graph', 'data structure', 'network']"
https://www.hackerrank.com/challenges/median?isFullScreen=true,"The median of
numbers is defined as the middle number after sorting them in order if
is odd. Or it is the average of the middle two numbers if
is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median.
Example:
For a set of
numbers
the median is the third number in the sorted set
, which is
. Similarly, for a set of
numbers,
, the median is the average of the second and the third element in the sorted set
, which is
.
Input:
The first line is an integer,
, that indicates the number of operations. Each of the next
lines is either
a x
or
r x
.
a x
indicates that
is added to the set, and
r x
indicates that
is removed from the set.
Output:
For each operation: If the operation is
add
, output the median after adding
in a single line. If the operation is
remove
and the number
is not in the list, output
Wrong!
in a single line. If the operation is
remove
and the number
is in the list, output the median after deleting
in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.)
Note
If your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print
Wrong!
Constraints:
For each
a x
or
r x
,
will always be a signed integer (which will fit in 32 bits).
Sample Input:
7
r 1
a 1
a 2
a 1
r 1
r 2
r 1
Sample Output:
Wrong!
1
1.5
1
1.5
1
Wrong!
Note:
As evident from the last line of the input, if after remove operation the list becomes empty, you have to print
Wrong!
.","Use a sorted array and binary search to find the insertion/deletion point, then recalculate the median in O(1).","Use a simple unsorted array, adding/removing elements in O(1) and sorting the array each time to find the median, with overall complexity O(n log n) per operation.","Maintain two heaps (min-heap and max-heap) to store elements, with the median being the top of the heaps. This handles dynamic updates efficiently.","Store all numbers in a hash table, calculate the median by iterating over the entire table and finding the middle element(s).",Maintain two heaps: a max-heap for the smaller half and a min-heap for the larger half. Balance the heaps during add/remove operations to maintain the median efficiently.,,data structures,"['heap', 'median', 'dynamic update']"
https://www.hackerrank.com/challenges/helix?isFullScreen=true,"Natural numbers from 1 to N have been placed in an increasing order over some helix ( a circular structure ). When the helix starts rotating, it is easy to find out
The position of a given number
The number located at a given position.
The helix has numbers arranged in the following fashion:
[1, 2, 3, ..., N]
Due to some malfunction, the helix has started rotating in a weird manner. Right now, every possible contiguous interval can be rotated, and hence, locating a particular number or identifying the number at a given position is almost impossible. For example, if at some particular instant, the integer list is like this:
[1, 2, 3, 4, 5, ..., N]
rotating the interval [5...N] will leave the list like this:
[1, 2, 3, 4, N, N - 1, N - 2, ..., 5]
We need a software to handle this. Can you help us?
Input Format
The first line of the input consists of two space separated integers,
N, Q
.
N
signifies that initially our list contains numbers from 1 to N, placed in an increasing order.
Q
lines follow and contain input in one of the following formats:
1 A B
indicating that the helix rotated circularly in the interval [A..B] ( both inclusive);
2 A
indicating that we are interested in knowing the current position of the number A
3 A
indicating that we are interested in knowing the number at position A.
Output Format
For each line in the input of the form
2 A
output a line saying
element A is at position x
where
A
is the number we are interested in and
x
is its current position.
For each line of the form
3 A
output a line saying
element at position A is x
where
A
is the position we are interested in and
x
is the integer located at this position.
Constraints
1 ≤
N, Q
≤ 10
5
positions are 1-indexed.
Sample Input
5 10
1 1 3
2 3
3 3
1 3 5
1 2 4
3 1
3 5
2 4
1 5 5
2 2
Sample Output
element 3 is at position 1
element at position 3 is 1
element at position 1 is 3
element at position 5 is 1
element 4 is at position 2
element 2 is at position 4
Explanation
Initially elements are placed like this:
[1, 2, 3, 4, 5]
after the first rotation, they are placed like this:
[3, 2, 1, 4, 5]
and that's how we get the first 2 results (first 2 lines in the output). After second rotation, they are placed like this:
[3, 2, 5, 4, 1]
and third one does this:
[3, 4, 5, 2, 1]
In the last rotation (1 5 5), it's easy to see that output matches the initial positions of the elements. Last rotation doesn't change the positions of the elements.",Use a binary search tree to store the elements and their positions for efficient lookups and updates.,Employ a hash table to map elements to positions and update the table after each rotation.,Store the entire sequence and rotation history and recompute element positions on demand.,Use a linked list to represent the helix and physically rotate sublists by manipulating pointers.,"Maintain an array to represent the helix, updating it using array slicing and reversal for rotations, and directly access elements by index.",,algorithms,"['array', 'rotation', 'simulation']"
https://www.hackerrank.com/challenges/little-alexey-and-sum-of-maximums?isFullScreen=true,"Alexey is playing with an array,
, of
integers. His friend, Ivan, asks him to calculate the sum of the maximum values for all subsegments of
. More formally, he wants Alexey to find
.
Alexey solved Ivan's challenge faster than expected, so Ivan decides to add another layer of difficulty by having Alexey answer
queries. The
query contains subsegment
, and he must calculate the sum of maximum values on all subsegments inside subsegment
.
More formally, for each query
, Alexey must calculate the following function:
.
Can you help Alexey solve this problem?
Input Format
The first line contains
space-separated positive integers,
(the length of array
) and
(number of queries), respectively.
The second line contains
space-separated integers,
describing each element
(where
) in array
.
Each of the
subsequent lines contains
space-separated positive integers describing the respective values for
and
in query
(where
).
Constraints
Output Format
For each query
(where
), print its answer on a new line.
Sample Input
3 6
1 3 2
1 1
1 2
1 3
2 2
2 3
3 3
Sample Output
1
7
15
3
8
2
Explanation
The answer for the second query is shown below:
The answer for the third query is shown below:","Use dynamic programming to store maximums of overlapping subsegments, recalculating when queries overlap","Precompute all possible subsegment maximums and their sums, then look up query results in constant time","For each query, iterate through all subsegments using nested loops, find the maximum, and accumulate the sum","Maintain a sparse table to efficiently query maximums for any range, then iterate through all subsegments of the query to sum the precomputed max values",Employ a sliding window technique coupled with a segment tree or similar data structure to find maximums within query ranges,,algorithms,"['dynamic programming', 'segment tree', 'sliding window']"
https://www.hackerrank.com/challenges/find-the-running-median?isFullScreen=true,"The median of a set of integers is the midpoint value of the data set for which an equal number of integers are less than and greater than the value. To find the median, you must first sort your set of integers in non-decreasing order, then:
If your set contains an odd number of elements, the median is the middle element of the sorted sample. In the sorted set
,
is the median.
If your set contains an even number of elements, the median is the average of the two middle elements of the sorted sample. In the sorted set
,
is the median.
Given an input stream of
integers, perform the following task for each
integer:
Add the
integer to a running list of integers.
Find the median of the updated list (i.e., for the first element through the
element).
Print the updated median on a new line. The printed value must be a double-precision number scaled to
decimal place (i.e.,
format).
Example
Sorted          Median
[7]             7.0
[3, 7]          5.0
[3, 5, 7]       5.0
[2, 3, 5, 7]    4.0
Each of the median values is stored in an array and the array is returned for the main function to print.
Note:
Add formatting to the print statement.
Function Description
Complete the
runningMedian
function in the editor below.
runningMedian
has the following parameters:
-
int a[n]:
an array of integers
Returns
-
float[n]:
the median of the array after each insertion, modify the print statement in main to get proper formatting.
Input Format
The first line contains a single integer,
, the number of integers in the data stream.
Each line
of the
subsequent lines contains an integer,
, to be inserted into the list.
Constraints
Sample Input
STDIN   Function
-----   --------
6       a[] size n = 6
12      a = [12, 4, 5, 3, 8, 7]
4
5
3
8
7
Sample Output
12.0
8.0
5.0
4.5
5.0
6.0
Explanation
There are
integers, so we must print the new median on a new line as each integer is added to the list:",Always use a heap data structure to store the elements and find the median efficiently.,"Sort the entire array after each insertion to find the median, resulting in O(n^2 log n) time complexity.",Calculate the mean (average) instead of the median for each update.,Only consider the first half of the input stream when calculating the running median.,Use two heaps (a min-heap and a max-heap) to maintain sorted order and efficiently find the median.,,data structures,"['heap', 'median', 'data stream']"
https://www.hackerrank.com/challenges/pair-sums?isFullScreen=true,"Given an array, we define its
value
to be the value obtained by following these instructions:
Write down all pairs of numbers from this array.
Compute the product of each pair.
Find the sum of all the products.
For example, for a given array, for a given array [
,
,
,
],
Pairs
(7, 2), (7, -1), (7, 2), (2, -1), (2, 2), (-1, 2)
Products of the pairs
14, -7, 14, -2, 4, -2
Sum of the products
14 + (-7) + 14 + (-2) + 4 + (-2) =
Note that
is listed twice, one for each occurrence of
.
Given an array of integers, find the largest
value
of any of its nonempty subarrays.
Note
: A subarray is a contiguous subsequence of the array.
Complete the function
largestValue
which takes an array and returns an integer denoting the largest
value
of any of the array's nonempty subarrays.
Input Format
The first line contains a single integer
, denoting the number of integers in array
.
The second line contains
space-separated integers
denoting the elements of array
.
Constraints
Subtasks
for 20% of the points.
for 70% of the points.
Output Format
Print a single line containing a single integer denoting the largest
value
of any of the array's nonempty subarrays.
Sample Input 0
6
-3 7 -2 3 5 -2
Sample Output 0
41
Explanation 0
In this case, we have
. The largest-valued subarray turns out to be
with value
.
Sample Input 1
10
5 7 -5 6 3 9 -8 2 -1 10
Sample Output 1
200",Calculate the value of all possible subarrays and return the minimum.,"Calculate the value of all possible subarrays and keep track of the largest positive value found so far. If all values are negative, return 0.",Calculate the value of the entire array and return that value.,"Calculate the value of all possible subarrays using a brute-force approach, optimizing using memoization to store already calculated subarray values.","Use Kadane's algorithm, modified to calculate the 'value' instead of the sum, to find the largest subarray 'value'.",,algorithms,"['dynamic programming', ""Kadane's algorithm"", 'subarray']"
https://www.hackerrank.com/challenges/bst-maintenance?isFullScreen=true,"Consider a binary search tree
T
which is initially empty. Also, consider the first
N
positive integers {1, 2, 3, 4, 5, ....., N} and its permutation P {
a
1
,
a
2
, ...,
a
N
}.
If we start adding these numbers to the binary search tree
T
, starting from
a
1
, continuing with
a
2
, ... (and so on) ..., ending with
a
N
. After every addition we ask you to output the sum of distances between every pair of
T
's nodes.
Input Format
The first line of the input consists of the single integer
N
, the size of the list.
The second line of the input contains
N
single space separated numbers the permutation
a
1
,
a
2
, ...,
a
N
itself.
Constraints
1 ≤
N
≤ 250000
Output Format
Output
N
lines.
On the
i
th
line output the sum of distances between every pair of nodes after adding the first
i
numbers from the permutation to the binary search tree
T
Sample Input #00
8
4 7 3 1 8 2 6 5
Sample Output #00
0
1
4
10
20
35
52
76
Explanation #00
After adding the first element, the distance is
0
as there is only 1 element
4
After adding the second element, the distance between 2 nodes is
1
.
4
 \
  7
After adding the third element, the distance between every pair of elements is
2+1+1=4
4
 / \
3   7
After adding the fourth element, the distance between every pair of elements is
3 + 2 + 1 + 2 + 1 + 1 = 10
4
   / \
  3   7
 /
1
After adding the fifth element, the distance between every pair of elements is
4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20
4
   / \
  3   7
 /     \
1       8
After adding the sixth element, the distance between every pair of elements is
5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35
4
   / \
  3   7
 /     \
1       8
 \
  2
After adding the seventh element, the distance between every pair of elements is
5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52
4
   / \
  3   7
 /   / \
1   6   8
 \
  2
After adding the final element, the distance between every pair of elements is
6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76
4
      /   \
    3      7
  /      /   \
 1      6     8
  \    /
   2  5",Maintain an adjacency matrix to represent the tree and compute all-pairs shortest paths using the Floyd-Warshall algorithm.,"For each node, calculate its distance to all other nodes using repeated breadth-first search (BFS).","Use dynamic programming to store previously computed distances and avoid redundant calculations, optimizing the distance summation.",Implement a post-order traversal of the BST and compute the sum of distances recursively for each subtree.,Maintain subtree sizes during insertion and update the total distance sum incrementally based on the inserted node's position.,,data structures,"['binary search tree', 'tree traversal', 'dynamic programming']"
https://www.hackerrank.com/challenges/kindergarten-adventures?isFullScreen=true,"Meera teaches a class of
students, and every day in her classroom is an adventure. Today is drawing day!
The students are sitting around a round table, and they are numbered from
to
in the
clockwise
direction. This means that the students are numbered
, and students
and
are sitting next to each other.
After letting the students draw for a certain period of time, Meera starts collecting their work to ensure she has time to review all the drawings before the end of the day. However, some of her students aren't finished drawing! Each student
needs
extra minutes to complete their drawing.
Meera collects the drawings sequentially in the clockwise direction, starting with student ID
, and it takes her exactly
minute to review each drawing. This means that student
gets
extra minutes to complete their drawing, student
gets
extra minute, student
gets
extra minutes, and so on.
Note
that Meera will still spend
minute for each student even if the drawing isn't ready.
Given the values of
, help Meera choose the best possible
to start collecting drawings from, such that the number of students able to complete their drawings is maximal. Then print
on a new line. If there are multiple such IDs, select the smallest one.
Input Format
The first line contains a single positive integer,
, denoting the number of students in the class.
The second line contains
space-separated integers describing the respective amounts of time that each student needs to finish their drawings (i.e.,
).
Constraints
Subtasks
for
of the maximum score.
Output Format
Print an integer denoting the ID number,
, where Meera should start collecting the drawings such that a maximal number of students can complete their drawings. If there are multiple such IDs, select the smallest one.",Start at the student with the shortest drawing time.,Always start collecting from student 1.,Calculate the total drawing time for all students and divide by N.,Start at the student with the longest drawing time.,"Simulate the collection process for each starting student and choose the starting student that maximizes the number of completed drawings, selecting the smallest ID in case of ties.",,algorithms,"['simulation', 'optimization', 'greedy']"
https://www.hackerrank.com/challenges/dynamic-summation?isFullScreen=true,"Given a tree of
N
nodes, where each node is uniquely numbered in between
[1, N]
. Each node also has a value which is initially 0. You need to perform following two operations in the tree.
Update Operation
Report Operation
Update Operation
U r t a b
Adds
a
b
+ (a+1)
b
+ (b+1)
a
to all nodes in the subtree rooted at
t
, considering that tree is rooted at
r
(see explanation for more details).
Report Operation
R r t m
Output the sum of all nodes in the subtree rooted at
t
, considering that tree is rooted at
r
. Output the sum modulo
m
(see explanation for more details).
Input Format
First line contains
N
, number of nodes in the tree.
Next
N-1
lines contain two space separated integers
x
and
y
which denote that there is an edge between node
x
and node
y
.
Next line contains
Q
, number of queries to follow.
Next
Q
lines follow, each line will be either a report operation or an update operation.
Output Format
For each report query output the answer in a separate line.
Constraints
1 ≤
N
≤ 100000
1 ≤
Q
≤ 100000
1 ≤
m
≤ 101
1 ≤
r, t, x, y
≤
N
x
≠
y
1 ≤
a, b
≤ 10
18
Notes
There will be at most one edge between a pair of nodes.
There will be no loop.
Tree will be completely connected.
Sample Input
4
1 2
2 3
3 4
4
U 3 2 2 2
U 2 3 2 2
R 1 2 8
R 4 3 9
Sample Output
2
3
Explanation
Initially Values in each node : [0,0,0,0]
The first query is
U 3 2 2 2
. Here, tree is rooted at 3. It looks like
3(0)
   / \
  /   \
 2(0)  4(0)
 |
 |
 1(0)
For the sub tree rooted at 2 ( nodes 2 and 1 ), we add a
b
+ (a+1)
b
+ (b+1)
a
= 2
2
+ 3
2
+ 3
2
= 22. After first update operation, nodes 1, 2, 3, and 4 will have values 22, 22, 0 and 0 respectively.
3(0)
   / \
  /   \
 2(22) 4(0)
 |
 |
 1(22)
The second query is
U 2 3 2 2
. Here, tree is rooted at 2. It looks like
2(22)
   / \
  /   \
 1(22) 3(0)
       |
       |
       4(0)
For the sub tree rooted at 3 (nodes 3 and 4), we add a
b
+ (a+1)
b
+ (b+1)
a
= 2
2
+ 3
2
+ 3
2
= 22. After second update operation, nodes 1, 2, 3, and 4 each have values 22,22,22,22 respectively.
2(22)
   / \
  /   \
 1(22) 3(22)
       |
       |
       4(22)
The first report query is
R 1 2 8
asks for the sum modulo 8 of the subtree rooted at 2, when the tree is rooted at 1. The tree looks like
1(22)
 \
  \
   2*(22)
   |
   |
   3*(22)
   |
   |
   4*(22)
The sum of the values of nodes 2, 3 and 4 are
(22 + 22 + 22) % 8 = 2
The second report query is
R 4 3 9
asks for the sum modulo 9 of the subtree rooted at 3 when the tree is rooted at 4. The tree looks like
4(22)
 \
  \
   3*(22)
   |
   |
   2*(22)
   |
   |
   1*(22)
The sum of the values of nodes 3, 2 and 1 are
(22 + 22 + 22) % 9 = 3
Time Limits:
C, C++: 4s | Java and other JVM based languages: 10s | Python, Python3 = 45s | Other interpreted Language: 30s | C#, Haskell: 10s | Rest: 3 times of
default
.","Use Depth-First Search (DFS) to traverse the subtree and apply updates/reports, handling modulo arithmetic in each step.","Precompute subtree sums for all possible roots and use a lookup table for report operations, ignoring the update operations.","Use a flat array to represent the tree and perform brute-force updates and report calculations, recomputing subtree sums for each query.","Apply updates globally to all nodes in the tree, and compute report queries by iterating through all nodes.","Use Depth-First Search (DFS) to determine subtree membership, apply lazy propagation for efficient updates, and compute subtree sums modulo m.",,algorithms,"['tree traversal', 'lazy propagation', 'subtree sum']"
https://www.hackerrank.com/challenges/sparse-arrays?isFullScreen=true,"There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.
Example
There are
instances of '
',
of '
', and
of '
'. For each query, add an element to the return array:
.
Function Description
Complete the function
with the following parameters:
: an array of strings to search
: an array of query strings
Returns
: the results of each query
Input Format
The first line contains and integer
, the size of
.
Each of the next
lines contains a string
.
The next line contains
, the size of
.
Each of the next
lines contains a string
.
Constraints
.","Use a hash table to store counts of input strings, then iterate query strings to look up counts. O(n+m) time, O(n) space.","Sort both the input and query strings. Then iterate both using two pointers to count matches. O(n log n + m log m) time, O(1) space.","Iterate through query strings. For each query, iterate through input strings and count matches using string comparison. O(n*m) time, O(1) space.",Convert the lists of strings into single concatenated strings and then use string.count(),"Iterate through the query strings, and for each query string, use the `count()` method on the input string array. O(n*m) time, O(1) space.",,algorithms,"['string matching', 'hashing', 'counting']"
https://www.hackerrank.com/challenges/direct-connections?isFullScreen=true,"Enter-View
is a linear, street-like country. By linear, we mean all the cities of the country are placed on a single straight line - the
-axis. Thus every city's position can be defined by a single coordinate,
, the distance from the left borderline of the country. You can treat all cities as single points.
Unfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if
people are living in city
, there must be at least
cables from city
to every other city of EV - this way he can guarantee no congestion will ever occur!
Mr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population.
Note that The connections between the cities can be shared. Look at the example for the detailed explanation.
Input Format
A number
is given in the first line and then comes
blocks, each representing a scenario.
Each scenario consists of three lines. The first line indicates the number of cities (
N
). The second line indicates the coordinates of the
N
cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input.
Output Format
For each scenario of the input, write the length of cable needed in a single line modulo
.
Constraints
Border to border length of the country
Sample Input
2
3
1 3 6
10 20 30
5
5 55 555 55555 555555
3333 333 333 33 35
Sample Output
280
463055586
Explanation
For the first test case, having
cities requires
sets of cable connections. Between city
and
, which has a population of
and
, respectively, Mr. Treat believes at least
cables should come out of city 1 for this connection, and at least 20 cables should come out of city
for this connection. Thus, the connection between city
and city
will require
cables, each crossing a distance of
km. Applying this absurd logic to connection 2,3 and 1,3, we have
=>
connections
km of cable
=>
connections
km of cable
=>
connections
km of cable
For a total of
, Output is
km of cable","Calculate the minimum cables needed between each pair of cities using populations and distances, then sum the cable lengths, without modulo at each step.",Sort the cities by their coordinates before calculating the cable lengths to optimize the calculation. Apply modulo only to the final result.,Calculate the number of cables as the sum of populations multiplied by the sum of distances.,"Only consider connections between adjacent cities to reduce the total cable length, assuming this satisfies the dictator's requirement, and apply modulo to the final result.","For each pair of cities, calculate the number of cables as the maximum of their populations, multiply by the distance between them, sum these values, and apply modulo to the intermediate sums to prevent overflow.",,algorithms,"['greedy algorithm', 'optimization', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/heavy-light-2-white-falcon?isFullScreen=true,"White Falcon was amazed by what she can do with heavy-light decomposition on trees. As a resut, she wants to improve her expertise on heavy-light decomposition. Her teacher gave her an another assignment which requires path updates. As always, White Falcon needs your help with the assignment.
You are given a tree with
nodes and each node's value
is initially
.
Let's denote the path from node
to node
like this:
, where
and
, and
and
are connected.
The problem asks you to operate the following two types of queries on the tree:
""1 u v x"" Add
to
,
to
,
to
, ...,
to
.
""2 u v"" print the sum of the nodes' values on the path between
and
at modulo
.
Input Format
First line cosists of two integers
and
seperated by a space.
Following
lines contains two integers which denote the undirectional edges of the tree.
Following
lines contains one of the query types described above.
Note: Nodes are numbered by using 0-based indexing.
Constraints
Output Format
For every query of second type print a single integer.
Sample Input
3 2
0 1
1 2
1 0 2 1
2 1 2
Sample Output
5
Explanation
After the first type of query,
. Hence the answer of the second query is
.","Only decompose the tree into heavy paths, ignoring light edges, leading to incorrect path sums.","Perform updates and queries on the original tree without heavy-light decomposition, resulting in time limit exceeded.","Incorrectly implement the Least Common Ancestor (LCA) calculation, leading to wrong path traversal.",Use segment trees for range updates and queries but fail to account for the tree structure and path traversal.,"Correctly implement heavy-light decomposition with segment trees for path updates and queries, handling LCA efficiently.",,algorithms,"['heavy-light decomposition', 'segment tree', 'tree']"
https://www.hackerrank.com/challenges/contacts?isFullScreen=true,"We're going to make our own
Contacts
application! The application must perform two types of operations:
add name
, where
is a string denoting a contact name. This must store
as a new contact in the application.
find partial
, where
is a string denoting a partial name to search the application for. It must count the number of contacts starting with
and print the count on a new line.
Given
sequential
add
and
find
operations, perform each operation in order.
Example
Operations are requested as follows:
add ed
add eddie
add edward
find ed
add edwina
find edw
find a
Three
operations include the names 'ed', 'eddie', and 'edward'.  Next,
matches all
names.  Note that it matches and counts the entire name 'ed'.  Next, add 'edwina' and then find 'edw'.
names match: 'edward' and 'edwina'.  In the final operation, there are
names that start with 'a'.  Return the array
.
Function Description
Complete the
contacts
function below.
contacts
has the following parameters:
string queries[n]:
the operations to perform
Returns
int[]:
the results of each find operation
Input Format
The first line contains a single integer,
, the number of operations to perform (the size of
).
Each of the following
lines contains a string,
.
Constraints
and
contain lowercase English letters only.
The input does not have any duplicate
for the
operation.
Sample Input
STDIN           Function
-----           --------
4               queries[] size n = 4
add hack        queries = ['add hack', 'add hackerrank', 'find hac', 'find hak']
add hackerrank
find hac
find hak
Sample Output
2
0
Explanation
Add a contact named
hack
.
Add a contact named
hackerrank
.
Find the number of contact names beginning with
hac
. Both name start with
hac
, add
to the return array.
Find the number of contact names beginning with
hak
. neither name starts with
hak
, add
to the return array.","Use a hash table to store all contact names and their prefixes. For each `find` operation, iterate through the prefixes and count matching names.","Sort the contact names alphabetically. For each `find` operation, perform a binary search for the prefix and count subsequent matching names.","Use a simple array to store the contact names. For each `find` operation, iterate through the array and use string comparison to count matching names.","Use a set to store all contact names. For each `find` operation, convert the set to a list, sort it, and perform a binary search to count the prefixes",Use a Trie data structure to efficiently store and search contact names by prefix.,,data structures,"['Trie', 'prefix search', 'string']"
https://www.hackerrank.com/challenges/burger-happiness?isFullScreen=true,"In Burger Town new burger restaurants will be opened! Concretely,
restaurants will open in
days, while restaurant
will be opened on day
and will be located at
. The town should be imagined as an one dimensional line in which every object's location can be described by the
coordinate.
Tim has just recently arrived the town after a very bad result in a programming contest. Thus he wants to cheer himself up by starting a trip to try out some new burgers.
Every burger restaurant
is associated with two integers
and
. If Tim eats a burger from
, then his happiness will increase by
, which can also be negative, depending on the deliciousness of the burger. On the other hand, if Tim looks through the window of an opened restaurant
, from which he will
not
eat a burger, then his happiness decreases by
, since Tim gets sad by only seeing the burgers.
Tim's journey can start from any day
at the burger restaurant
and eats a burger from there. On each subsequent day
, Tim has the following options:
Stay at the previous restaurant
.
Or go to the new restaurant
to eat a burger from there.
If he decides for the latter option, then on the path from
to
he will look through all the windows that are on his path and maybe lose some happiness. Concretely, if
, then he will look through the window of every
opened
restaurant
, having
. Similar for the case
.
Since Tim is a very good friend of yours you should help him finding a trip that will maximize his happiness. If he should stay at home since no trip would cheer him up, then print
0
.
Note
: Tim's happiness is 0 at the beginning of the trip and is allowed to be negative throughout the time.
Input Format
will be given on the first line, then
lines will follow, describing the restaurants numbered from 1 to
accordingly. Restaurant
will be described by
,
and
separated by a single space.
Output Format
Output the maximium happiness on one line.
Constraints
and no two restaurants will have the same
coordinates.
Sample Input
3
 2 -5 1
 1 5 1
 3 5 1
Sample Output
8
Sample Input
4
 4 10 0
 1 -5 0
 3 0 10
 2 10 0
Sample Output
15
Sample Input
3
 1 -1 0
 2 -2 0
 3 -3 0
Sample Output
0
First testcase: His trip starts on day 2 at restaurant 2 located at
. He gains
happiness points there by eating a burger. On the next day he goes from restaurant 2 to 3, but will look through the window of restaurant 2 and 1. Therefore he loses
and
points on the way to restaurant 3. There he eats a burger and gains another
points. In total his happiness is equal to
8
and this is optimal.
Second testcase: His trip starts on day 1 at restaurant 1. Then his actions on day 2, 3 and 4 will be go to restaurant 2, stay at restaurant 2 and go to restaurant 4 respectively. The happiness of this optimal trip is equal to
15
.
Third testcase: It's not worth to start the trip from any of the restaurant since he will only have negative happiness. That's why he should stay at home and
0
should be printed.","Use a greedy approach, always choosing the restaurant with the highest happiness value at each step.",Calculate the total happiness of all restaurants and subtract the minimum possible happiness loss from looking through windows.,"Use dynamic programming, with the state defined as the maximum happiness achievable up to a given day, without considering the restaurant locations.","Use a brute-force approach, trying all possible paths and calculating the happiness for each, then select the maximum.","Use dynamic programming to store the maximum happiness achievable at each restaurant on each day, considering the cost of traveling between restaurants.",,algorithms,"['dynamic programming', 'optimization', 'greedy']"
https://www.hackerrank.com/challenges/coolguy-and-two-subsequences?isFullScreen=true,"Coolguy gives you a simple problem. Given a
-indexed array,
, containing
elements, what will
be after this pseudocode is implemented and executed? Print
.
//f(a, b) is a function that returns the minimum element in interval [a, b]

ans = 0

for a -> [1, n]
    for b -> [a, n]
        for c -> [b + 1, n]
            for d -> [c, n]
                ans = ans + min(f(a, b), f(c, d))
Input Format
The first line contains
(the size of array
).
The second line contains
space-separated integers describing
.
Constraints
≤
≤
≤
≤
Note:
is
-indexed (i.e.:
).
Output Format
Print the integer result of
.
Sample Input
3
3 2 1
Sample Output
6
Explanation
We then sum these numbers (
) and print
, which is
.",O(n),O(n^2),O(n^3),O(n^5),O(n^4),,algorithms,"['nested loops', 'time complexity', 'algorithm analysis']"
https://www.hackerrank.com/challenges/jagia-playing-with-numbers?isFullScreen=true,"Jaggu is a little kid and he likes playing with water balloons. He took 1 million ( 10
6
) empty buckets and he filled the bucket with water balloons under the instruction of his sister Ishika.
His sister gives him two types of commands:
R pos1 pos2
which implies that jaggu needs to tell her what is the total number of water balloons in the bucket from pos1 to pos2 (both included).
U pos M plus
which implies that he has to work like the function
Update(pos,M,plus)
void Update(int pos,int M,int plus)
{
    int N=1000000;  //1 million
    for (int i=1;i<=50;i++)
    {
        int back = pos
        for(int j=1;j<=1000;j++)
        {
            add M water ballons at bucket pos
            int s,in=__builtin_popcount(pos);
            for(int k=0;;k++)
            {
                s=pos+pow(2,k)
                if( __builtin_popcount(s) <= in )
                {
                    in = __builtin_popcount(s)
                    pos = s;
                    if(pos>N)       break;
                    add M water ballons at bucket pos
                }
            }
            pos = pos - N
        }
        pos = back+plus;
        if(pos>N) pos-=N;
    }
}
Jaggu is too lazy to put the water ballons in the bucket. Afraid that he might be caught for not doing what his sister told him to do so, he asks your help to provide correct answers  for each of his sister's query. .
Input Format
First line contains Q, number of queries to follow.
Next Q line follows , which can be either an Update Query or Report Query.Each Update Query is followed by atleast 1 report query.
Output Format
For each report query , output the answer in a separate line.
Constraints
1 ≤ Q ≤ 2 * 10
5
1 ≤ pos1,pos2,pos ≤ 10
6
pos1 ≤ pos2
1 ≤ M ≤ 10
1 ≤ plus ≤ 999999
Sample Input
2
U 692778 7 291188
R 636916 747794
Sample Output
378
Explanation
Follow the code above to get the answer.
Note
Input is randomly generated.
__builtin_popcount(x) gives the number of set bits in binary representation of x.
pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2.
Timelimit is 3 times the timelimit mentioned
here",The code will result in a runtime error due to accessing memory out of bounds.,The code will produce an incorrect sum because the update loop doesn't terminate properly.,The code will only update the first few buckets due to integer overflow issues within the inner loops.,"The code will skip some buckets in the update process, leading to inaccurate balloon counts in the range.","The code will update and report the correct number of water balloons, following the bit manipulation logic in the `Update` function.",,algorithms,"['bit manipulation', 'simulation', 'range queries']"
https://www.hackerrank.com/challenges/self-driving-bus?isFullScreen=true,"Treeland is a country with
cities and
roads. There is exactly
one
path between any two cities.
The ruler of Treeland wants to implement a self-driving bus system and asks tree-loving Alex to plan the bus routes. Alex decides that each route must contain a subset of
connected
cities; a subset of cities is
connected
if the following two conditions are true:
There is a path between every pair of cities which belongs to the subset.
Every city in the path must belong to the subset.
https://s3.amazonaws.com/hr-challenge-images/13863/1453203150-be95d05a3f-tree.png
In the figure above,
is a
connected
subset, but
is not  (for the second condition to be true,
would need to be part of the subset).
Each self-driving bus will operate within a
connected segment
of Treeland. A connected segment
where
is defined by the connected subset of cities
.
In the figure above,
is a connected segment that represents the subset
. Note that a single city can be a segment too.
Help Alex to find number of connected segments in Treeland.
Input Format
The first line contains a single positive integer,
.
The
subsequent lines each contain two positive space-separated integers,
and
, describe an edge connecting two nodes in tree
.
Constraints
Subtasks
For
score:
For
score:
Output Format
Print a single integer: the number of segments
, which are connected in tree
.
Sample Input
3
1 3
3 2
Sample Output
5
Explanation
The connected
segments
for our test case are:
,
,
,
, and
. These
segments
can be represented by the respective subsets:
,
,
,
, and
.
https://s3.amazonaws.com/hr-challenge-images/13863/1453203705-a1797dc30f-tree4.png
Note:
is not a connected segment. It represents the subset
and the path between
and
goes through
which is not a member of the subset.","n * (n - 1) / 2, where n is the number of cities","2^(n-1), where n is the number of cities",The number of edges plus the number of cities,"n!, where n is the number of cities","2^n -1, where n is the number of cities",,algorithms,"['trees', 'connected components', 'graph theory']"
https://www.hackerrank.com/challenges/castle-on-the-grid?isFullScreen=true,"You are given a square grid with some cells open (
.
) and some blocked (
X
).  Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell.  Given a grid, a start and a goal, determine the minmum number of moves to get to the goal.
Example
.
The grid is shown below:
...
.X.
...
The starting position
so start in the top left corner.  The goal is
.  The path is
.  It takes
moves to reach the goal.
Function Description
Complete the
minimumMoves
function in the editor.
minimumMoves has the following parameter(s):
string grid[n]:
an array of strings that represent the rows of the grid
int startX:
starting X coordinate
int startY:
starting Y coordinate
int goalX:
ending X coordinate
int goalY:
ending Y coordinate
Returns
int:
the minimum moves to reach the goal
Input Format
The first line contains an integer
, the size of the array
grid
.
Each of the next
lines contains a string of length
.
The last line contains four space-separated integers,
Constraints
Sample Input
STDIN       FUNCTION
-----       --------
3           grid[] size n = 3
.X.         grid = ['.X.','.X.', '...']
.X.
...
0 0 0 2     startX = 0, startY = 0, goalX = 0, goalY = 2
Sample Output
3
Explanation
Here is a path that one could follow in order to reach the destination in
steps:
.","Use a greedy approach, always moving in the direction that minimizes the Manhattan distance to the goal.","Recursively explore all possible paths until the goal is reached, then return the shortest path.",Prioritize movement along rows before columns (or vice versa) to simplify the search.,Calculate the Euclidean distance between the start and goal and use it as a direct estimate of the number of moves.,"Use Breadth-First Search (BFS) to explore the grid, keeping track of the minimum moves to reach each cell.",,algorithms,"['graph traversal', 'BFS', 'grid']"
https://www.hackerrank.com/challenges/counting-on-a-tree?isFullScreen=true,"Taylor loves
trees
, and this new challenge has him stumped!
Consider a tree,
, consisting of
nodes. Each node is numbered from
to
, and each node
has an integer,
, attached to it.
A
query
on tree
takes the form
w x y z
. To process a query, you must print the count of ordered pairs of integers
such that the following four conditions are all satisfied:
the path from node
to node
.
path from node
to node
.
Given
and
queries, process each query in order, printing the pair count for each query on a new line.
Input Format
The first line contains two space-separated integers describing the respective values of
(the number of nodes) and
(the number of queries).
The second line contains
space-separated integers describing the respective values of each node (i.e.,
).
Each of the
subsequent lines contains two space-separated integers,
and
, defining a bidirectional edge between nodes
and
.
Each of the
subsequent lines contains a
w x y z
query, defined above.
Constraints
Scoring for this problem is Binary, that means you have to pass all the test cases to get a positive score.
Output Format
For each query, print the count of ordered pairs of integers satisfying the four given conditions on a new line.
Sample Input
10 5
10 2 3 5 10 5 3 6 2 1
1 2
1 3
3 4
3 5
3 6
4 7
5 8
7 9
2 10
8 5 2 10
3 8 4 9
1 9 5 9
4 6 4 6
5 8 5 8
Sample Output
0
1
3
2
0
Explanation
We perform
queries on the following tree:
https://s3.amazonaws.com/hr-challenge-images/0/1478205096-0cca8dc842-counting-on-a-tree.png
Find the number of valid ordered pairs where
is in the path from node
to node
and
is in the path from node
to node
. No such pair exists, so we print
.
Find the number of valid ordered pairs where
is in the path from node
to node
and
is in the path from node
to node
. One such pair,
, exists, so we print
.
Find the number of valid ordered pairs where
is in the path from node
to node
and
is in the path from node
to node
. Three such pairs,
,
, and
exist, so we print
.
Find the number of valid ordered pairs where
is in the path from node
to node
and
is in the path from node
to node
. Two such pairs,
and
, exist, so we print
.
Find the number of valid ordered pairs where
is in the path from node
to node
and
is in the path from node
to node
. No such pair exists, so we print
.",Use Dijkstra's algorithm to find shortest paths and count nodes within those paths with the specified values.,"Perform a Depth-First Search (DFS) from each node in a query and check the values along the path, counting valid pairs.",Calculate all possible pairs and then filter out the ones that do not satisfy the path requirements by precomputing all paths.,Use a Union-Find data structure to determine connected components and quickly check path membership.,Compute Least Common Ancestors (LCA) to efficiently determine path membership and then iterate through relevant value pairs.,,algorithms,"['graph theory', 'tree traversal', 'least common ancestor']"
https://www.hackerrank.com/challenges/truck-tour?isFullScreen=true,"Suppose there is a circle. There are
petrol pumps on that circle. Petrol pumps are numbered
to
(both inclusive). You have two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give, and (2) the distance from that petrol pump to the next petrol pump.
Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps. The truck will move one kilometer for each litre of the petrol.
Input Format
The first line will contain the value of
.
The next
lines will contain a pair of integers each, i.e. the amount of petrol that petrol pump will give and the distance between that petrol pump and the next petrol pump.
Constraints:
Output Format
An integer which will be the smallest index of the petrol pump from which we can start the tour.
Sample Input
3
1 5
10 3
3 4
Sample Output
1
Explanation
We can start the tour from the second petrol pump.",Always start from the petrol pump with the highest petrol quantity.,"Check if the total petrol is greater than the total distance. If not, no solution exists.","Start from each petrol pump and simulate the journey, keeping track of the current petrol level; return the first successful starting point or -1 if none exist.",Sort the petrol pumps by the ratio of petrol to distance and start from the one with the highest ratio.,"Iterate through each petrol pump as a starting point, simulating the route and checking if the petrol level remains non-negative throughout the entire circle.",,algorithms,"['greedy algorithm', 'circular array', 'simulation']"
https://www.hackerrank.com/challenges/roy-and-alpha-beta-trees?isFullScreen=true,"Roy has taken a liking to the
Binary Search Trees
(
BST
). He is interested in knowing the number of ways an array
of
integers can be arranged to form a
BST
. Thus, he tries a few combinations, and notes down the numbers at the odd levels and the numbers at the even levels.
You're given two values,
alpha
and
beta
. Can you calculate the sum of
Liking
of all possible
BST's
that can be formed from an array of
integers?
Liking
of each
BST
is defined as follows
(sum of numbers on even levels * alpha) - (sum of numbers on odd levels * beta)
Note
The root element is at level
( Even )
The elements smaller or equal to the parent element are present in the left subtree, elements greater than or equal to the parent element are present in the right subtree.  Explained
here
If the answer is no less than
, output the answer %
.
(If the answer is less than
, keep adding
until the value turns non negative.)
Input Format
The first line of input file contains an integer,
, denoting the number of test cases to follow.
Each testcase comprises of
lines.
The first line contains
, the number of integers.
The second line contains two space separated integers,
alpha
and
beta
.
The third line contains space separated
integers_, denoting the
integer in array
.
Output Format
Output
lines. Each line contains the answer to its respective test case.
Constraints
Sample Input
4
1
1 1
1
2
1 1
1 2
3
1 1
1 2 3
5
1 1
1 2 3 4 5
Sample Output
1
0
6
54
Explanation
There are
test cases in total.
For the first test case, only
BST can be formed with
1
as the root node. Hence the
Liking
/ sum is
.
For the second test case, we get 2 BSTs of the form, the
Liking
of the first tree is
and
, this sums to
, hence the answer.
1                  2
 \                /
  2              1
For the third test case, we get
BSTs. The
Liking
of each of the BST from left  to right are
which sums to
and hence the answer.
1            2                 3          3      1
 \          / \               /          /        \
  2        1   3             1          2          3
   \                          \        /          /
    3                          2      1          2
Similarly, for the fourth test case, the answer is
.","Calculate all possible BSTs, compute their liking, and sum them directly without modulo during the calculation.","Calculate all possible BSTs, compute their liking using integer division instead of modulo at each step.","Compute the number of BSTs using Catalan numbers, then multiply by a pre-calculated average liking (without considering modulo).","Calculate BST liking based only on the sorted array, ignoring the actual tree structure and applying the modulo at the end","Recursively calculate the number of BSTs and their liking using dynamic programming with memoization, applying modulo operation in each intermediate calculation to avoid overflow.",,algorithms,"['binary search tree', 'dynamic programming', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/weird-queries?isFullScreen=true,"In this problem you operate on two arrays of
integers. We will call them the
and the
respectively.
Your goal is just to maintain them under the modification operations, such as:
1
: Reverse the subarray of the
array, starting at the
number, ending at the
number, inclusively;
2
: Swap two consecutive fragments of the
array, the first is from the
number to the
, the second is from the
number to the
;
3
: Swap the piece that starts at the
number and end at the
one between the
and the
array;
4
: We consider only the piece from the
number to the
one. The numbers in the
array are
-coordinates of some set of points and the numbers in the
array are
-coordinates of them. For the obtained set of points we would like to place such a circle on a plane that would contain all the points in it and would have the minimal radius. Find this minimal radius.
Input Format
The first line of input contains two space separated integers
and
denoting the number of integers in arrays and the number of queries respectively.
The second line contains
space separated integers: the initial elements of the
array.
The third line contains
space separated integers: the initial elements of the
array.
Then there are
lines containing queries in the format listed above.
Output Format
For each type-
4
query output the sought minimal radius with
exactly
two symbols after the decimal point precision.
Constraints
All the numbers in arrays are non-negative and don't exceed
.
The sum of
over the type-
4
queries won't exceed
.
In the query of the type 2,
.
In the queries of the types 1, 3, 4,
;
.
Sample Input
10 10
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
3 2 6
1 0 9 9
4 6 9
2 0 2 7 9 9
1 0 3 6
2 1 2 3 4 5
1 1 7 10
2 1 8 8 9 10
4 6 9
2 0 2 2 4 6
Example Output
2.12
2.50",Merge sort the arrays and then perform operations in sorted order.,Brute-force every possible operation and choose the one that minimizes the overall cost.,Use a binary indexed tree (BIT) to efficiently handle range updates and queries.,Precompute all possible subarray reversals and swaps for faster access during queries.,Implement the operations directly using array slicing and basic geometric calculations for the circle.,,algorithms,"['array manipulation', 'geometric algorithms', 'range queries']"
https://www.hackerrank.com/challenges/easy-addition?isFullScreen=true,"You are given a
tree
with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation.
Initially all node values are zero.
The
update query
is of the format
a1 d1 a2 d2 A B
This means you'd have to add
in all nodes in the path from A to B where
is the distance between the node and A.
The
retrieval
query is of the format
i j
You need to return the sum of the node values lying in the path from node i to node j modulo 1000000007.
Note
:
First all update queries are given and then all retrieval queries.
Distance between 2 nodes is the shortest path length between them taking each edge weight as 1.
Input Format
The first line contains two integers (N and R respectively) separated by a space.
In the next N-1 lines, the i
th
line describes the i
th
edge: a line with two integers x y separated by a single space denotes an edge between nodes x and y.
The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.
U lines follow. Each of the next U lines contains 6 space separated integers (a1,d1,a2,d2,A and B respectively).
Each of the next Q lines contains 2 space separated integers, i and j respectively.
Output Format
It contains exactly Q lines and each line containing the answer of the i
th
query.
Constraints
2 <= N <= 10
5
2 <= R <= 10
9
1 <= U <= 10
5
1 <= Q <= 10
5
1 <= a1,a2,d1,d2 <= 10
8
1 <= x, y, i, j, A, B  <= N
Note
For the update operation, x can be equal to y and for the query operation, i can be equal to j.
Sample Input
7 2
1 2
1 3
2 4
2 6
4 5
6 7
1 4
1 1 1 1 4 6
4 5
2 7
4 7
5 3
Sample Output
1
44
45
9
Explanation
The node values after updation becomes :
0 8 0 1 0 36 0
Answer to Query #1: 1+0 = 1
Answer to Query #2: 8+36+0 = 44
Answer to Query #3: 1+8+36+0 = 45
Answer to Query #4: 0+1+8+0+0 = 9","Perform a Depth-First Search (DFS) for each query, recalculating paths and sums every time",Precompute all possible path sums using dynamic programming and store them in a lookup table,Use a simple array to represent the tree and iterate through the array for updates and queries,Apply Dijkstra's algorithm to find shortest paths for each query and update node values independently,"Utilize Lowest Common Ancestor (LCA) and difference arrays (or segment trees) for efficient path updates and queries, considering modulo operations",,algorithms,"['tree', 'LCA', 'difference array']"
https://www.hackerrank.com/challenges/functional-palindromes?isFullScreen=true,"Let's define a function,
, on a string,
, of length
as follows:
where
denotes the
ASCII value
of the
character in string
,
, and
.
Nikita has a string,
, consisting of
lowercase letters that she wants to perform
queries on. Each query consists of an integer,
, and you have to find the value of
where
is the
alphabetically smallest
palindromic
substring
of
. If
doesn't exist, print
instead.
Input Format
The first line contains
space-separated integers describing the respective values of
(the length of string
) and
(the number of queries).
The second line contains a single string denoting
.
Each of the
subsequent lines contains a single integer denoting the value of
for a query.
Constraints
It is guaranteed that string
consists of lowercase English alphabetic letters only (i.e.,
to
).
.
Scoring
for
of the test cases.
for
of the test cases.
Output Format
For each query, print the value of function
where
is the
alphabetically smallest palindromic substring
of
; if
doesn't exist, print
instead.
Sample Input
5 7
abcba
1
2
3
4
6
7
8
Sample Output
97
97
696207567
98
29493435
99
-1
Explanation
There are
palindromic substrings of
. Let's list them in lexicographical order and find value of
:
,
,
,
,
,
,
,
doesn't exist, so we print
for
.","Return the sum of all ASCII values in S, regardless of K or palindromes.","Return the ASCII value of the Kth character in S if S is a palindrome, else -1.","Calculate the function only on the entire string S if it is a palindrome, otherwise return -1.","Iterate through all substrings and return the ASCII value of the Kth substring if it exists, else -1.","Find the alphabetically smallest palindromic substring of S. If it exists, compute the function value for that substring, else return -1.",,algorithms,"['string', 'palindrome', 'substring']"
https://www.hackerrank.com/challenges/library-query?isFullScreen=true,"A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves.
Change the number of books in one of the shelves.
Obtain the number of books on the shelf having the k
th
rank within
the range of shelves.
A shelf is said to have the k
th
rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order.
Can you write a program to simulate the above queries?
Input Format
The first line contains a single integer T, denoting the number of test cases.
The first line of each test case contains an integer N denoting the number of shelves in the library.
The next line contains N space separated integers where the i
th
integer represents the number of books on the i
th
shelf where 1<=i<=N.
The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query.
Queries can be of two types:
1 x k - Update the number of books in the x
th
shelf to k (1 <= x <= N).
0 x y k - Find the number of books on the shelf between the shelves x and y
(both inclusive) with the k
th
rank (1 <= x <= y <= N, 1 <= k <= y-x+1).
Output Format
For every test case, output the results of the queries in a new line.
Constraints
1 <= T <= 5
1 <= N <= 10
4
1 <= Q <= 10
4
The number of books on each shelf is always guaranteed to be between 1 and 1000.
Sample Input
2
2
1 2
2
0 1 2 1
0 1 2 2
4
4 3 2 1
4
0 1 1 1
1 1 1
0 1 1 1
0 1 4 3
Sample Output
1
2
4
1
2
Explanation
There are two test cases :
The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed :
i) The first query asks for smallest number of books between the 1
st
and 2
nd
shevles which is
1
.
ii) The second query asks for the 2
nd
smallest number of books between the 1
st
and 2
nd
shevles which is
2
.
The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :
i) The first query asks for the smallest number of books in the 1
st
shelf which is
4
.
ii) The second query updates the number of books in the 1
st
shelf to
1
. Hence the shelves now look like [1, 3, 2, 1].
iii) The third query asks for the smallest number of books in the 1
st
shelf which is now
1
.
iv) The last query asks for the 3
rd
smallest number of books between the 1
st
and 4
th
shelves which is
2
.",Merge sort,Binary search,Depth-first search,Breadth-first search,Quickselect,,algorithms,"['sorting', 'selection', 'rank']"
https://www.hackerrank.com/challenges/starfleet?isFullScreen=true,"In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have
N
space-fighters.
Initially the
i
th
fighter is located at (x
i
, y
i
). All of the space-fighters move with constant velocity
V
units/sec in the positive
X
direction.
i.e., fighter at (x
i
, y
i
) moves to (x
i
+V, y
i
) in 1 second.
The
i
th
space-fighter broadcasts enemy information at a frequency
f
i
.
The republic is not scared of the artificially intelligent droid force as they have
Yoda
.
Yoda
has a special power, at any time
T
he can choose a region of the droid army and block one specific frequency
F
. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across
X
axis (refer image below for clarity). If a frequency (
F
) is blocked all the space-fighters in the region having the frequency
F
can’t communicate.
https://s3.amazonaws.com/hr-assets/0/1526568097-af9b3d37ed-starfleet.png
Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form:
YU YD T
where
YU
,
YD
are the bounds on y-axis inside which YODA can block a frequency at time
T
.
In the region described by the query, after a time
T
seconds from the start, if
Yoda
can chose one frequency (
F
) he wishes to, what is the maximum number of communications he can block?
Input Format
Each test case is described as follows; the first line contains
3
space separated integers
N
- the number of space-fighters,
Q
- the number of queries you have to answer, and
V
- the velocity of the space-fighters separated by a single space.
N
lines follow, each containing
3
space separated integers
x
i
,
y
i
, and
f
i
, denoting the x co-ordinate, y co-ordinate and the frequency at which the
i
th
ship broadcasts respectively. Each of the next
Q
lines contain
3
space separated integers representing
YU, YD, T
respectively. Refer the figure for more clarity
Note: Points on the boundaries should be counted as well.
Output Format
For each query you are to output a single integer denoting the result.
Constraints
1 <= N <= 50000
1 <= Q <= 30000
1 <= V <= 10000
-10
9
<= x
i
<= 10
9
-10
9
<= y
i
<= 10
9
1 <= f
i
<= 10
9
-10
9
<= YU <= 10
9
-10
9
<= YD <= 10
9
1 <= T <= 10000
YU >= YD
Sample Input
5 5 82
-4 1 4
-3 -2 2
-3 5 1
0 -5 2
1 -1 2
1 -1 57
-2 -5 11
5 -5 40
-1 -5 16
5 -1 93
Sample Output
1
2
3
3
1
Explanation
Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.",Calculate the total number of fighters and divide by the number of unique frequencies.,"Sort the fighters by their y-coordinate and then iterate through the frequencies, counting those within the bounds.",Consider only the fighters at the maximum x-coordinate within the given y-range and count the frequency occurrences.,"Iterate through all possible frequencies and count the number of fighters broadcasting each frequency, regardless of their position.","For each query, iterate through the fighters, check if they are within the y-bounds after T seconds, and count the maximum occurrences of any single frequency among those fighters.",,algorithms,"['spatial reasoning', 'frequency analysis', 'time complexity']"
https://www.hackerrank.com/challenges/fibonacci-numbers-tree?isFullScreen=true,"Shashank loves trees and math. He has a rooted tree,
, consisting of
nodes uniquely labeled with integers in the inclusive range
. The node labeled as
is the
root
node of tree
, and each node in
is associated with some positive integer value (all values are initially
).
Let's define
as the
Fibonacci number
. Shashank wants to perform
types of operations over his tree,
:
Update the subtree rooted at node
such that the node at level
in subtree
(i.e., node
) will have
added to it, all the nodes at level
will have
added to them, and so on. More formally, all the nodes at a distance
from node
in the subtree of node
will have the
Fibonacci number added to them.
Find the sum of all values associated with the nodes on the unique path from
to
. Print your sum modulo
on a new line.
Given the configuration for tree
and a list of
operations, perform all the operations efficiently.
Note:
.
Input Format
The first line contains
space-separated integers,
(the number of nodes in tree
) and
(the number of operations to be processed), respectively.
Each line
of the
subsequent lines contains an integer,
, denoting the parent of the
node.
Each of the
subsequent lines contains one of the two types of operations mentioned in the
Problem Statement
above.
Constraints
Output Format
For each operation of type
(i.e.,
), print the required answer modulo
on a new line.
Sample Input
5 10
1
1
2
2
Q 1 5
U 1 1
Q 1 1
Q 1 2
Q 1 3
Q 1 4
Q 1 5
U 2 2
Q 2 3
Q 4 5
Sample Output
0
1
2
2
4
4
4
10
Explanation
Intially, the tree looks like this:
https://s3.amazonaws.com/hr-challenge-images/15909/1460699464-aa0383b7a1-fib.png
After update operation
, it looks like this:
https://s3.amazonaws.com/hr-challenge-images/15909/1460699732-cd71b94a79-fib1.png
After update operation
, it looks like this:
https://s3.amazonaws.com/hr-challenge-images/15909/1460699891-9084e7038d-fib2.png",Use Depth First Search (DFS) to update node values and then repeatedly traverse the path for the sum.,Precompute all Fibonacci numbers and use a matrix representation of the tree for efficient updates.,Use a combination of Breadth-First Search (BFS) for updates and Dijkstra's algorithm for finding the path.,Apply dynamic programming to store path sums and update Fibonacci numbers iteratively.,Use a combination of DFS for subtree updates based on distance and Lowest Common Ancestor (LCA) to find the path for summation.,,algorithms,"['tree traversal', 'Fibonacci', 'LCA']"
https://www.hackerrank.com/challenges/taxicab-drivers-problem?isFullScreen=true,"Burger Town is a city that consists of
special junctions and
pathways. There is exactly one shortest path between each pair of junctions. Junction
is located at
and the distance between two junctions
is defined by the Taxicab geometry.
Tim has recently afforded a taxicab to work as a taxicab driver. His vehicle was very cheap, but has a very big flaw. It can only drive
units horizontally and
units vertically before refueling.
If a customer wants to be brought from a junction
to another junction
, then this car is only capable of driving the route, iff the sum of horizontal distances and the sum of vertical distances on this path are less than or equal to
and
respectively.
Also, there is a unique path between any two junctions.
https://s3.amazonaws.com/hr-challenge-images/6367/1431544255-d42b5c89d0-drawing1.svg
Now he has thoughts about returning the vehicle back to the seller. But he first wants to know, if it's even worth it. That's why he wants to know the number of unordered pairs
such that it is not possible to drive a customer from junction
to junction
.
Input Format
On the first line you will be given
,
and
separated by a single space.
Each of the next
lines contains two space separated integers
, denoting the location of junction
.
Each of the next
lines contains two space separated integers describing a path existing between
, i.e., there is a path between
and
.
Output Format
Output the number of unordered pairs
such that it is not possible to drive from
to
.
Constraints
Sample Input
3 2 1
0 0
1 1
2 0
1 2
2 3
Sample Output
1
Explanation
The car is only capable of driving
units horizontally and
unit vertically. The horizontal distance between junction 1 and 3(via 2) is equal to 2(
), which fits under the horizontal limit of the car. The vertical distance between 1 and 3 is also equal to 2(
), but this is not possible for this car since
.",Perform a Depth First Search (DFS) on the graph and count the unreachable pairs for each node.,Apply the Floyd-Warshall algorithm to find all-pairs shortest paths and then count pairs exceeding the limits.,Use Dijkstra's algorithm from each node to every other node to compute the distances and check against the constraints.,Calculate the Manhattan distance between all pairs of junctions and check if they exceed the horizontal and vertical limits directly.,"Construct the graph, then use a modified Breadth-First Search (BFS) or Depth-First Search (DFS) from each node, tracking horizontal and vertical distances, to count unreachable pairs.",,algorithms,"['graph theory', 'shortest path', 'taxicab geometry']"
https://www.hackerrank.com/challenges/square-ten-tree?isFullScreen=true,"The square-ten tree decomposition of an array is defined as follows:
The lowest (
) level of the square-ten tree consists of single array elements in their natural order.
The
level (starting from
) of the square-ten tree consists of subsequent array subsegments of length
in their natural order. Thus, the
level contains subsegments of length
, the
level contains subsegments of length
, the
level contains subsegments of length
, etc.
In other words, every
level (for every
) of square-ten tree consists of array subsegments indexed as:
Level
consists of array subsegments indexed as
.
The image below depicts the bottom-left corner (i.e., the first
array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:
https://s3.amazonaws.com/hr-challenge-images/13816/1445948557-cdd10d5f3a-1.png
Task
Given the borders of array subsegment
, find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence
such as
for every
,
,
, where every
belongs to any of the square-ten tree levels and
is minimal amongst all such variants.
Input Format
The first line contains a single integer denoting
.
The second line contains a single integer denoting
.
Constraints
The numbers in input do not contain leading zeroes.
Output Format
As soon as array indices are too large, you should find a sequence of
square-ten tree level numbers,
, meaning that subsegment
belongs to the
level of the square-ten tree.
Print this sequence in the following compressed format:
On the first line, print the value of
(i.e., the compressed sequence block count).
For each of the
subsequent lines, print
space-separated integers,
and
(
,
), meaning that the number
appears consequently
times in sequence
. Blocks should be listed in the order they appear in the sequence. In other words,
should be equal to
,
should be equal to
, etc.
Thus
must be true and
must be true for every
. All numbers should be printed without leading zeroes.
Sample Input 0
1
10
Sample Output 0
1
1 1
Explanation 0
Segment
belongs to level
of the square-ten tree.","Always choose the highest possible level that fits within the remaining segment, regardless of minimality.","Prioritize lower levels, as they represent smaller segments and will inherently lead to fewer nodes.","Greedily select levels based on their power of 10 proximity to the segment length, without backtracking.","Recursively divide the segment by 10 until a base case is reached, then reconstruct the levels.","Iteratively choose the highest possible level that fits within the remaining segment, ensuring optimal decomposition by minimizing nodes at each step.",,algorithms,"['tree decomposition', 'dynamic programming', 'greedy algorithm']"
https://www.hackerrank.com/challenges/lazy-white-falcon?isFullScreen=true,"White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques?
There are
types of query operations that can be performed on a tree:
1 u x
: Assign
as the value of node
.
2 u v
: Print the sum of the node values in the unique path from node
to node
.
Given a tree with
nodes where each node's value is initially
, execute
queries.
Input Format
The first line contains
space-separated integers,
and
, respectively.
The
subsequent lines each contain
space-separated integers describing an undirected edge in the tree.
Each of the
subsequent lines contains a query you must execute.
Constraints
It is guaranteed that the input describes a connected tree with
nodes.
Nodes are enumerated with
-based indexing.
Output Format
For each type-
query, print its integer result on a new line.
Sample Input
3 3
0 1
1 2
1 0 1
1 1 2
2 0 2
Sample Output
3
Explanation
https://s3.amazonaws.com/hr-challenge-images/15812/1458794192-0cf036b4e2-LazyWhiteFalconExpl.png
After the first
queries, the value of node
and the value of node
. The third query requires us to print the sum of the node values in the path from nodes
to
, which is
. Thus, we print
on a new line.",Use Dijkstra's algorithm to find the shortest path and sum the node values along the path.,"Precompute all possible path sums using dynamic programming, and retrieve the answer in O(1).","For each query of type 2, perform a depth-first search (DFS) from node 'u' to node 'v' and sum the values of the nodes visited.",Maintain a parent array for each node and repeatedly update parent pointers until 'u' and 'v' have the same parent.,"Maintain a parent array for each node. For each type 2 query, find the path from u to v by traversing up to their lowest common ancestor (LCA) and summing the node values.",,algorithms,"['tree traversal', 'lowest common ancestor', 'depth-first search']"
https://www.hackerrank.com/challenges/costly-intervals?isFullScreen=true,"Given an array, your goal is to find, for each element, the largest subarray containing it whose cost is at least
.
Specifically, let
be an array of length
, and let
be the subarray from index
to index
. Also,
Let
be the largest number in
.
Let
be the smallest number in
.
Let
be the
bitwise OR
of the elements of
.
Let
be the
bitwise AND
of the elements of
.
The
cost
of
, denoted
, is defined as
The
size
of
is defined as
.
You are given the array
and and an integer
. For each index
from
to
, your goal is to find the largest size of any subarray
such that
and
.
Consider, array
and
. The possible sub-arrays and their costs would be as follows:
https://s3.amazonaws.com/hr-assets/0/1512116739-8dea10a9c6-costly-3.png
Complete the function
costlyIntervals
which takes two integers
and
as first line of input, and array
in the second line of input. Return an array of
integers, where the
element contains the answer for index
of the input array,
. Every element of the output array denotes the largest size of a subarray containing
whose cost is at least
, or
if there is no such subarray.
Constraints
Subtasks
For
of the maximum score,
.
For
of the maximum score,
.
Sample Input
,
Sample Output
Explanation
In this example, we have
. There is only one subarray whose cost is at least
, and that is
, since
. Its size is
. Thus, for
and
, the answer is
, and for the others,
.",Use a sliding window of fixed size k to iterate through all possible subarrays and check their cost.,Precompute all possible subarrays and their costs in a separate table before iterating through each index.,"For each index i, iterate through all subarrays containing i and calculate the cost using dynamic programming to avoid redundant computations.","Binary search for the largest subarray size for each index i, checking the cost of the subarray in the middle.","For each index i, expand outwards to find the largest subarray containing i with cost >= k, using two pointers.",,algorithms,"['arrays', 'sliding window', 'two pointers']"
https://www.hackerrank.com/challenges/max-transform?isFullScreen=true,"Transforming data into some other data is typical of a programming job. This problem is about a particular kind of transformation which we'll call the
max transform
.
Let
be a zero-indexed array of integers. For
, let
denote the subarray of
from index
to index
, inclusive.
Let's define the
max transform
of
as the array obtained by the following procedure:
Let
be a list, initially empty.
For
from
to
:
For
from
to
:
Let
.
Append
to the end of
.
Return
.
The returned array is defined as the max transform of
. We denote it by
.
Complete the function
solve
that takes an integer array
as input.
Given an array
, find the sum of the elements of
, i.e., the
max transform
of the
max transform
of
. Since the answer may be very large, only find it modulo
.
Input Format
The first line of input contains a single integer
denoting the length of
.
The second line contains
space-separated integers
denoting the elements of
.
Constraints
Subtasks
For
of the total score,
Output Format
Print a single line containing a single integer denoting the answer.
Sample Input 0
3
3 2 1
Sample Output 0
58
Explanation 0
In the sample case, we have:
Therefore, the sum of the elements of
is
.",O(n^4) due to nested loops for subarray generation and max calculation within each subarray.,"O(n^3) because the outer loops iterate n times each, and the max calculation takes O(n) time.",O(n log n) due to sorting the subarrays before computing the maximum.,O(n^2 log n) because we generate n^2 subarrays and then sort them to find the maximum.,O(n^2) since the algorithm iterates through all possible subarrays once to compute the max transform.,,algorithms,"['nested loops', 'time complexity', 'max transform']"
https://www.hackerrank.com/challenges/arithmetic-progressions?isFullScreen=true,"Let
denote an arithmetic progression (AP) with first term
and common difference
, i.e.
denotes an infinite
. You are given
APs =>
. Let
denote the sequence obtained by multiplying these APs.
Multiplication of two sequences is defined as follows. Let the terms of the first sequence be
, and terms of the second sequence be
. The sequence obtained by multiplying these two sequences is
If
are the terms of a sequence, then the terms of the first difference of this sequence are given by
calculated as
respectively. Similarly, the second difference is given by
, and so on.
We say that the
difference of a sequence is a constant if all the terms of the
difference are equal.
Let
be a sequence defined as =>
Similarly,
is defined as => product of
.
Task:
Can you find the smallest
for which the
difference of the sequence
is a constant? You are also required to find this constant value.
You will be given many operations. Each operation is of one of the two forms:
1)
0 i j
=> 0 indicates a query
. You are required to find the smallest
for which the
difference of
is a constant. You should also output this constant value.
2)
1 i j v
=> 1 indicates an update
. For all
, we update
.
Input Format
The first line of input contains a single integer
, denoting the number of APs.
Each of the next
lines consists of three integers
.
The next line consists of a single integer
, denoting the number of operations. Each of the next
lines consist of one of the two operations mentioned above.
Output Format
For each query, output a single line containing two space-separated integers
and
.
is the smallest value for which the
difference of the required sequence is a constant.
is the value of this constant. Since
might be large, output the value of
modulo 1000003.
Note:
will always be such that it fits into a signed 64-bit integer. All indices for query and update are 1-based. Do not take modulo 1000003 for
.
Constraints
For updates of the form
1 i j v
,
Sample Input
2
1 2 1
5 3 1
3
0 1 2
1 1 1 1
0 1 1
Sample Output
2 12
2 8
Explanation
The first sequence given in the input is =>
The second sequence given in the input is =>
For the first query operation, we have to consider the product of these two sequences:
=>
=>
First difference is =>
Second difference is =>
This is a constant and hence the output is
2 12
.
After the update operation
1 1 1 1
, the first sequence becomes =>
i.e =>
For the second query, we consider only the first sequence =>
First difference is =>
Second difference is =>
This is a constant and hence the output is
2 8",The n-th difference is always constant and equals 0.,The n-th difference is always constant and equals 1.,The smallest 'n' is equal to the number of arithmetic progressions. The constant value is the product of all common differences.,"The smallest 'n' is always equal to 1, and the constant is the common ratio between consecutive elements in the multiplied sequence.",The smallest 'n' is equal to the number of arithmetic progressions. The constant value is the product of (common difference * n!).,,algorithms,"['arithmetic progression', 'difference sequence', 'modular arithmetic']"
https://www.hackerrank.com/challenges/polynomial-division?isFullScreen=true,"Consider a sequence,
, and a polynomial of degree
defined as
. You must perform
queries on the sequence, where each query is one of the following two types:
1 i x
: Replace
with
.
2 l r
: Consider the polynomial
and determine whether
is divisible by
over the field
, where
. In other words, check if there exists a polynomial
with integer coefficients such that each coefficient of
is divisible by
. If a valid
exists, print
Yes
on a new line; otherwise, print
No
.
Given the values of
,
,
, and
queries, perform each query in order.
Input Format
The first line contains four space-separated integers describing the respective values of
(the length of the sequence),
(a coefficient in
),
(a coefficient in
), and
(the number of queries).
The second line contains
space-separated integers describing
.
Each of the
subsequent lines contains three space-separated integers describing a query of either type
1
or type
2
.
Constraints
For query type
1
:
and
.
For query type
2
:
.
Output Format
For each query of type
2
, print
Yes
on a new line if
is a divisor of
; otherwise, print
No
instead.
Sample Input 0
3 2 2 3
1 2 3
2 0 2
1 2 1
2 0 2
Sample Output 0
No
Yes
Explanation 0
Given
and the initial sequence
, we perform the following
queries:
is not a divisor of
, so we print
No
on a new line.
Set
to
, so
.
After the second query,
. Because
, we print
Yes
on a new line.","The sequence must be recomputed every time a query 2 is encountered, from l to r.",The query 2 can be solved only if the given sequence is sorted in ascending order.,"Compute the polynomial P(x) and divide it by (x - k) where k = l to r, checking if the remainder is zero.","Replace array elements outside the range [l, r] with 0 when evaluating the query 2.",Evaluate the polynomial at x=k. P(k) must be congruent to 0 mod m for P(x) to be divisible by (x-k) mod m.,,algorithms,"['polynomial', 'modulo arithmetic', 'sequence']"
https://www.hackerrank.com/challenges/find-maximum-index-product?isFullScreen=true,"You are given a list of
numbers
. For each element at position
(
), we define
and
as:
= closest index j such that j < i and
. If no such j exists then
= 0.
= closest index k such that k > i and
. If no such k exists then
= 0.
We define
=
*
. You need to find out the maximum
among all i.
Input Format
The first line contains an integer
, the number of integers.
The next line contains the
integers describing the list a[1..N].
Constraints
Output Format
Output the maximum
among all indices from
to
.
Sample Input
5
5 4 3 4 5
Sample Output
8
Explanation
We can compute the following:
The largest of these is 8, so it is the answer.","Maintain a single stack, pushing elements and popping when a larger element is found, calculating left and right indices from stack contents.","Iterate through the array, for each element, linearly search to the left and right for the nearest larger elements.","Sort the array and then iterate, using binary search to find the nearest larger elements on both sides for each element.","Use dynamic programming to store the nearest larger elements to the left and right, calculating them iteratively.","Utilize two stacks, one for finding the nearest greater to the left and another for the nearest greater to the right, in linear time.",,algorithms,"['stack', 'nearest greater element', 'array']"
https://www.hackerrank.com/challenges/game-of-two-stacks?isFullScreen=true,"Alexa has two stacks of non-negative integers, stack
and stack
where index
denotes the top of the stack. Alexa challenges Nick to play the following game:
In each move, Nick can remove one integer from the top of either stack
or stack
.
Nick keeps a running sum of the integers he removes from the two stacks.
Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer
given at the beginning of the game.
Nick's
final score
is the total number of integers he has removed from the two stacks.
Given
,
, and
for
games, find the maximum possible score Nick can achieve.
Example
The maximum number of values Nick can remove is
.  There are two sets of choices with this result.
Remove
from
with a sum of
.
Remove
from
and
from
with a sum of
.
Function Description
Complete the
twoStacks
function in the editor below.
twoStacks
has the following parameters:
-
int maxSum:
the maximum allowed sum
-
int a[n]:
the first stack
-
int b[m]:
the second stack
Returns
-
int:
the maximum number of selections Nick can make
Input Format
The first line contains an integer,
(the number of games). The
subsequent lines describe each game in the following format:
The first line contains three space-separated integers describing the respective values of
(the number of integers in stack
),
(the number of integers in stack
), and
(the number that the sum of the integers removed from the two stacks cannot exceed).
The second line contains
space-separated integers, the respective values of
.
The third line contains
space-separated integers, the respective values of
.
Constraints
Subtasks
for
of the maximum score.
Sample Input 0
1
5 4 10
4 2 4 6 1
2 1 8 5
Sample Output 0
4
Explanation 0
The two stacks initially look like this:
https://s3.amazonaws.com/hr-assets/0/1485853935-9b24f12026-twoarray3.png
The image below depicts the integers Nick should choose to remove from the stacks. We print
as our answer, because that is the maximum number of integers that can be removed from the two stacks without the sum exceeding
.
https://s3.amazonaws.com/hr-assets/0/1485849154-50c4a29f7d-twoarray2.png
(There can be multiple ways to remove the integers from the stack, the image shows just one of them.)","Use dynamic programming, building a table of maximum achievable counts for each prefix sum, minimizing memory usage.","Employ a greedy algorithm, always picking the smaller element from the top of either stack until the sum exceeds maxSum.",Convert both stacks to arrays and use binary search to find the optimal number of elements to remove from each stack.,"Recursively explore all possible combinations of element removals from both stacks, pruning branches that exceed maxSum.","Use a two-pointer approach, advancing pointers on the stacks while maintaining the current sum, backtracking as needed.",,algorithms,"['stack', 'two-pointer', 'greedy']"
https://www.hackerrank.com/challenges/white-falcon-and-tree?isFullScreen=true,"White Falcon has a tree with
nodes. Each node contains a linear function. Let's denote by
the linear function contained in the node
.
Let's denote the path from node
to node
like this:
, where
and
, and
and
are connected.
White Falcon also has
queries. They are in the following format:
. Assign
as the function of all the nodes on the path from
to
, i.e.,
is changed to
where
is the path from
to
.
. Calculate
modulo
Input Format
The first line contains
, the number of nodes. The following
lines each contain two integers
and
that describe the function
.
Following
lines contain edges of the tree.
The next line contains
, the number of queries. Each subsequent line contains one of the queries described above.
Output Format
For every query of the second kind, print one line containing an integer, the answer for that query.
Constraints
(Number of nodes)
(Number of queries)
Sample Input
2
1 1
1 2
1 2
2
1 2 2 1 1
2 1 2 1
Sample Output
3
Explanation",Apply function composition using dynamic programming on subtrees.,Use a modified Dijkstra's algorithm to find shortest paths and update functions.,Employ a depth-first search with lazy propagation to update and query node functions.,Utilize a segment tree to efficiently update and query linear functions along paths.,"Perform path traversal using a tree traversal algorithm (e.g., DFS or BFS), updating functions and evaluating the final function composition modulo M.",,algorithms,"['tree traversal', 'function composition', 'modulo arithmetic']"
https://www.hackerrank.com/challenges/minimum-average-waiting-time?isFullScreen=true,"Tieu owns a pizza restaurant and he manages it in his own way.  While in a normal restaurant, a customer is served by following the first-come, first-served rule, Tieu simply minimizes the average waiting time of his customers. So he gets to decide who is served first, regardless of how sooner or later a person comes.
Different kinds of pizzas take different amounts of time to cook. Also, once he starts cooking a pizza, he cannot cook another pizza until the first pizza is completely cooked. Let's say we have three customers who come at time t=0, t=1, & t=2 respectively, and the time needed to cook their pizzas is 3, 9, & 6 respectively. If Tieu applies first-come, first-served rule, then the waiting time of three customers is 3, 11, & 16  respectively. The average waiting time in this case is (3 + 11 + 16) / 3 = 10. This is not an optimized solution. After serving the first customer at time t=3, Tieu can choose to serve the third customer. In that case, the waiting time will be 3, 7, & 17 respectively. Hence the average waiting time is (3 + 7 + 17) / 3 = 9.
Help Tieu achieve the minimum average waiting time. For the sake of simplicity, just find the integer part of the minimum average waiting time.
Input Format
The first line contains an integer N, which is the number of customers.
In the next N lines, the i
th
line contains two space separated numbers T
i
and L
i
. T
i
is the time when i
th
customer order a pizza, and L
i
is the time required to cook that pizza.
The
customer is not the customer arriving at the
arrival time.
Output Format
Display the integer part of the minimum average waiting time.
Constraints
1 ≤ N ≤ 10
5
0 ≤ T
i
≤ 10
9
1 ≤ L
i
≤ 10
9
Note
The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served.
Cook does not know about the future orders.
Sample Input #00
3
0 3
1 9
2 6
Sample Output #00
9
Sample Input #01
3
0 3
1 9
2 5
Sample Output #01
8
Explanation #01
Let's call the person ordering at time = 0 as
A
, time = 1 as
B
and time = 2 as
C
. By delivering pizza for
A
,
C
and
B
we get the minimum average wait time to be
(3 + 6 + 16)/3 = 25/3 = 8.33
the integer part is
8
and hence the answer.",Sort the customers by arrival time and then by cooking time and use a greedy approach.,Use dynamic programming to find the optimal order in which to serve the customers.,Simulate all possible permutations of serving order and choose the one with the minimum average waiting time.,Apply a shortest-path algorithm to find the fastest route through customer orders.,Sort customers by arrival time. Use a priority queue to keep track of available customers based on cooking time.,,algorithms,"['greedy algorithm', 'priority queue', 'sorting']"
https://www.hackerrank.com/challenges/palindromic-subsets?isFullScreen=true,"Consider a lowercase English alphabetic letter character denoted by
. A
shift
operation on some
turns it into the next letter in the alphabet. For example, and
,
,
.
Given a zero-indexed string,
, of
lowercase letters, perform
queries on
where each query takes one of the following two forms:
1 i j t
: All letters in the inclusive range from
to
are shifted
times.
2 i j
: Consider all indices in the inclusive range from
to
. Find the number of non-empty subsets of characters,
where
, such that characters
can be rearranged
to form a palindrome. Then print this number modulo
on a new line. Two palindromic subsets are considered to be different if their component characters came from different indices in the original string.
Note
Two palindromic subsets are considered to be different if their component characters came from different indices in the original string.
Input Format
The first line contains two space-separated integers describing the respective values of
and
.
The second line contains a string of
lowercase English alphabetic letters (i.e.,
a
through
z
) denoting
.
Each of the
subsequent lines describes a query in one of the two formats defined above.
Constraints
for each query.
for each query of type
.
Subtasks
For
of the maximum score:
For another
of the maximum score:
All queries will be of type
.
Output Format
For each query of type
(i.e.,
2 i j
), print the number of non-empty subsets of characters satisfying the conditions given above, modulo
, on a new line.
Sample Input 0
3 5
aba
2 0 2
2 0 0
2 1 2
1 0 1 1
2 0 2
Sample Output 0
5
1
2
3
Explanation 0
We perform the following
queries:
2 0 2
:
and we want to find the palindromic subsets of substring
. There are five such subsets that form palindromic strings (
,
,
,
, and
), so we print the result of
on a new line
2 0 0
:
and we want to find the palindromic subsets of substring
. Because this substring only has one letter, we only have one subset forming a palindromic string (
). We then print the result of
on a new line.
2 1 2
:
and we want to find the palindromic subsets of substring
. There are two such subsets that form palindromic strings (
and
), so we print the result of
on a new line.
1 0 1 1
:
and we need to perform
shift operations on each character from index
to index
. After performing these shifts,
.
2 0 2
:
and we want to find the palindromic subsets of substring
. There are three valid subsets that form palindromic strings (
,
, and
), so we print the result of
on a new line.",Use a brute-force approach to check every possible subset for palindrome property.,Precompute all possible shifts and store them in a lookup table for faster query processing.,Employ dynamic programming to store palindrome status of substrings for efficient lookup.,Convert the string to a binary representation based on character frequency and use bit manipulation.,Utilize a frequency array to count character occurrences and determine palindromic subset count efficiently.,,algorithms,"['string manipulation', 'palindromes', 'bit manipulation']"
https://www.hackerrank.com/challenges/heavy-light-white-falcon?isFullScreen=true,"Our lazy white falcon finally decided to learn heavy-light decomposition. Her teacher gave an assignment for her to practice this new technique. Please help her by solving this problem.
You are given a tree with
nodes and each node's value is initially
. The problem asks you to operate the following two types of queries:
""1 u x"" assign
to the value of the node
.
""2 u v"" print the maximum value of the nodes on the unique path between
and
.
Input Format
First line consists of two integers seperated by a space:
and
.
Following
lines consisting of two integers denotes the undirectional edges of the tree.
Following
lines consist of the queries you are asked to operate.
Constraints
It is guaranteed that input denotes a connected tree with
nodes. Nodes are enumerated with 0-based indexing.
Output Format
For each second type of query print single integer in a single line, denoting the asked maximum value.
Sample Input
3 3
0 1
1 2
1 0 1
1 1 2
2 0 2
Sample Output
2
Explanation
After the first two updates value of the
th node is
and
st node is
. That is why maxiumum value on the path between
and
is
.",A segment tree where each node stores the sum of values in its range,"A binary indexed tree (BIT) storing the node values, querying for maximum requires O(N)",A disjoint set union (DSU) data structure to keep track of connected components,A simple array storing node values; path queries require iterating all nodes,Heavy-light decomposition with a segment tree on each chain to efficiently query maximum values on the path,,data structures,"['heavy-light decomposition', 'segment tree', 'tree']"
https://www.hackerrank.com/challenges/kundu-and-tree?isFullScreen=true,"Kundu is true tree lover. Tree is a connected graph having
N
vertices and
N-1
edges. Today when he got a tree, he colored each edge with one of either red(
r
) or black(
b
) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex
a
to
b
, vertex
b
to
c
and vertex
c
to
a
. Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet.
If the answer is greater than 10
9
+ 7, print the answer modulo (%) 10
9
+ 7.
Input Format
The first line contains an integer
N
, i.e., the number of vertices in tree.
The next
N-1
lines represent edges:  2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(
r
) or black(
b
).
Output Format
Print a single number i.e. the number of triplets.
Constraints
1 ≤
N
≤ 10
5
A node is numbered between 1 to
N
.
Sample Input
5
1 2 b
2 3 r
3 4 r
4 5 b
Sample Output
4
Explanation
Given tree is something like this.
https://s3.amazonaws.com/hr-assets/0/1526563539-7ce683027b-kundu-and-trees.jpg
(2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color.
(2,3,5), (1,3,4) and (1,3,5) are other such triplets.
Note that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.",Calculate the number of triplets with only black edges and subtract it from the total number of triplets.,Use dynamic programming to count the number of paths with at least one red edge between all pairs of nodes.,"Perform a depth-first search from each node, counting triplets based on the color of the edges encountered.",Employ a union-find algorithm to identify connected components and count triplets within each component.,Compute the total number of triplets and subtract the number of triplets that have only black edges on their paths.,,algorithms,"['graph theory', 'tree', 'triplets']"
https://www.hackerrank.com/challenges/beautiful-segments?isFullScreen=true,"You are given an array,
, consisting of
integers.
A segment,
, is
beautiful
if and only if the
bitwise AND
of all numbers in
with indices in the inclusive range of
is not greater than
. In other words, segment
is
beautiful
if
.
You must answer
queries. Each query,
, consists of
integers:
,
, and
. The answer for each
is the number of
beautiful
segments
such that
and
.
Input Format
The first line contains two space-separated integers,
(the number of integers in
) and
(the number of queries).
The second line contains
space-separated integers, where the
integer denotes the
element of array
.
Each line
of the
subsequent lines contains
space-separated integers,
,
, and
, respectively, describing query
.
Constraints
holds for test cases worth at least
of the problem's score.
holds for test cases worth at least
of the problem's score.
Output Format
Print
lines, where the
line contains the number of beautiful segments for query
.
Sample Input
5 3
1 2 7 3 4
1 5 3
2 4 6
3 5 2
Sample Output
13
5
2
Explanation
The beautiful segments for all queries are listed below.
Query 0:
The beautiful segments are
.
Query 1:
The beautiful segments are
.
Query 2:
The beautiful segments are
.",Calculate the bitwise AND of the entire array for each query,Use a binary search to find the beautiful segments,Precompute the bitwise AND of all possible segments to reduce the time complexity of each query,Sort the array before processing the queries to optimize the bitwise AND operation,"For each query, iterate through all possible segments within the given range and check if the bitwise AND of the segment is less than or equal to the given value",,algorithms,"['bitwise operations', 'arrays', 'segment']"
https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true,"A linked list is said to contain a
cycle
if any node is visited more than once while traversing the list.  Given a pointer to the head of a linked list, determine if it contains a cycle.  If it does, return
.  Otherwise, return
.
Example
refers to the list of nodes
The numbers shown are the node numbers, not their data values.  There is no cycle in this list so return
.
refers to the list of nodes
There is a cycle where node 3 points back to node 1, so return
.
Function Description
Complete the
has_cycle
function in the editor below.
It has the following parameter:
SinglyLinkedListNode pointer head:
a reference to the head of the list
Returns
int:
if there is a cycle or
if there is not
Note:
If the list is empty,
will be
null
.
Input Format
The code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity.  Expand the section for the main function and review the code if you would like to figure out how to create a custom case.
Constraints
Sample Input
References to each of the following linked lists are passed as arguments to your function:
https://s3.amazonaws.com/hr-challenge-images/1163/1463778594-900a0ae522-inputs.png
Sample Output
0
1
Explanation
The first list has no cycle, so return
.
The second list has a cycle, so return
.",Use a hash table to store visited nodes and check for duplicates after traversing half the list.,"Recursively traverse the list, comparing the memory addresses of nodes to the head node.",Maintain a counter and return true if the traversal exceeds a predefined limit based on the list size.,"Check if the list's tail node points to NULL; if not, assume a cycle exists.",Use Floyd's Cycle-Finding Algorithm (tortoise and hare) to detect the presence of a cycle.,,algorithms,"['linked list', 'cycle detection', ""Floyd's algorithm""]"
